**第三部分    数据结构**

**介绍**

集合对于计算机科学和数学同样重要。而数学集合是不变的，算法操作的集合可以随时间增长、缩小或以其他方式改变。我们称这样的集合为**动态集合**。接下来的四章介绍了一些表示有限动态集合和在计算机上操作它们的基本技术。

算法可能需要在集合上执行多种类型的操作。例如，许多算法只需要能够将元素插入、从集合中删除元素和测试成员资格。我们将支持这些操作的动态集合称为**字典**。其他算法需要更复杂的操作。例如，最小优先队列，第六章在堆数据结构的背景下介绍了它们，支持将元素插入和从集合中提取最小元素的操作。实现动态集合的最佳方法取决于您需要支持的操作。

**动态集合的元素**

在动态集合的典型实现中，每个元素由一个对象表示，给定对象的指针可以检查和操作其属性。某些类型的动态集合假设对象的属性之一是一个标识性的`键`。如果键都不同，我们可以将动态集合看作是一组键值。对象可能包含`附加数据`，这些数据包含在其他对象属性中，但在集合实现中未被使用。它还可能具有被集合操作操作的属性。这些属性可能包含数据或指向集合中其他对象的指针。

一些动态集合假设键来自一个全序集合，比如实数或按照字母顺序排列的所有单词集合。全序允许我们定义集合的最小元素，例如，或者谈论集合中大于给定元素的下一个元素。

**动态集合`上的`操作**

动态集合上的操作可以分为两类：`查询`，简单返回关于集合的信息，和`修改操作`，改变集合。以下是一些典型操作的列表。任何具体的应用通常只需要实现其中的几个。

`SEARCH(S, k)`

一个查询，给定一个集合`S`和一个键值`k`，返回一个指针`x`，指向`S`中的一个元素，使得`x.key = k`，如果没有这样的元素属于`S`，则返回 NIL。

`INSERT(S, x)`  

一个修改操作，将由`x`指向的元素添加到集合`S`中。我们通常假设元素`x`中集合实现所需的任何属性已经被初始化。

`DELETE(S, x)`

一个修改操作，给定一个指向集合`S`中元素的指针`x`，从`S`中移除`x`。（注意，此操作接受一个指向元素`x`的指针，而不是一个键值。）

MINIMUM(`S`) 和 MAXIMUM(`S`)

在一个全序集合`S`上的查询，返回具有最小键（对于 MINIMUM）或最大键（对于 MAXIMUM）的`S`中元素的指针。

`SUCCESSOR(S, x)`

一个查询，给定一个元素`x`，其键来自一个全序集合`S`，返回`S`中比`x`大的下一个元素的指针，如果`x`是最大元素，则返回 NIL。

`PREDECESSOR(S, x)`

一个查询，给定一个元素`x`，其键来自一个全序集合`S`，返回`S`中比`x`小的下一个元素的指针，如果`x`是最小元素，则返回 NIL。

在某些情况下，我们可以扩展 `SUCCESSOR` 和 `PREDECESSOR` 查询，使其适用于具有非不同键的集合。对于`n`个键的集合，通常假设调用 `MINIMUM`，然后调用`n - 1` 次 `SUCCESSOR` 会按排序顺序枚举集合中的元素。

我们通常根据集合的大小来衡量执行集合操作所需的时间。例如，第十三章描述了一种数据结构，可以在大小为`n`的集合上以`O(lg n)`的时间支持上述任何操作。

当然，您始终可以选择用数组实现动态集合。这样做的优点是动态集合操作的算法很简单。然而，缺点是许多这些操作在最坏情况下的运行时间为 `Θ(n)`。如果数组未排序，INSERT 和 DELETE 可以在Θ(1)时间内完成，但其余操作需要 `Θ(n)`时间。如果相反，数组保持排序顺序，那么 MINIMUM、MAXIMUM、SUCCESSOR 和 PREDECESSOR 需要Θ(1)时间；如果用二分查找实现 SEARCH，则需要`O(lg n)`时间；但在最坏情况下，INSERT 和 DELETE 需要 `Θ(n)`时间。本部分研究的数据结构改进了许多动态集合操作的数组实现。

`第三部分概述`

第十章–第十三章描述了几种我们可以用来实现动态集合的数据结构。我们稍后将使用许多这些数据结构来构建各种问题的高效算法。我们在第六章中已经看到另一个重要的数据结构——堆。

第十章介绍了使用简单数据结构（如数组、矩阵、栈、队列、链表和根树）的基本要点。如果您已经学过入门级编程课程，那么这些内容应该对您来说很熟悉。

第十一章介绍了哈希表，这是一种广泛使用的数据结构，支持字典操作 `INSERT`、`DELETE` 和 `SEARCH`。在最坏情况下，哈希表执行 `SEARCH` 操作需要Θ(n)的时间，但哈希表操作的期望时间为`O(1)`。我们依靠概率来分析哈希表操作，但即使没有概率，您也可以理解这些操作是如何工作的。

二叉搜索树，被涵盖在第十二章中，支持上述所有动态集合操作。在拥有`n`个元素的树上，每个操作在最坏情况下需要 `Θ(n)`的时间。二叉搜索树是许多其他数据结构的基础。

第十三章介绍了红黑树，这是二叉搜索树的一种变体。与普通二叉搜索树不同，红黑树保证性能良好：在最坏情况下，操作需要`O(lg n)`的时间。红黑树是一种平衡搜索树。第五部分的第十八章介绍了另一种平衡搜索树，称为 B 树。虽然红黑树的机制有些复杂，但您可以从本章中大部分属性中了解到它们，而无需详细研究机制。然而，您可能会发现逐步阅读代码是有益的。
