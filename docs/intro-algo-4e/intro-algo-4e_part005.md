***第五部分    高级数据结构***

**介绍**

本部分重新研究支持动态集操作的数据结构，但比第三部分更高级。例如，其中的一章广泛使用了来自第十六章的摊销分析技术。

第十七章展示了如何增强红黑树——在每个节点中添加额外信息——以支持动态集操作，除了第十二章和第十三章中涵盖的操作外。第一个示例增强红黑树以动态维护一组键的顺序统计信息。另一个示例以不同的方式增强它们以维护实数间隔。第十七章包括一个定理，给出了红黑树何时可以增强的充分条件，同时保持插入和删除的`O`(lg *n*)运行时间。  

第十八章介绍了 B 树，这是专门设计用于存储在磁盘上的平衡搜索树。由于磁盘的操作速度远远慢于随机访问内存，B 树的性能不仅取决于动态集操作消耗的计算时间，还取决于它们执行的磁盘访问次数。对于每个 B 树操作，磁盘访问次数随着 B 树的高度增加而增加，但 B 树操作保持高度较低。

第十九章研究了不相交集的数据结构。从一个包含`n`个元素的宇宙开始，每个元素最初都在自己的单例集中，UNION 操作将两个集合合并。在任何时候，`n`个元素被划分为不相交集合，即使对 UNION 操作的调用动态地改变了集合的成员。查询 FIND-SET 标识了当前包含给定元素的唯一集合。将每个集合表示为简单的根树会产生出人意料的快速操作：一系列`m`个操作在`O(mα(n))`时间内运行，其中`α(n)`是一个增长非常缓慢的函数—在任何可想象的应用中，`α(n)`最多为 4。证明这个时间界的摊销分析和数据结构一样简单。

本部分涵盖的主题绝不是“高级”数据结构的唯一示例，其他高级数据结构包括以下内容：

+   **`斐波那契堆`** [156] 实现了可合并堆（参见第 268 页的问题 10-2），INSERT、MINIMUM 和 UNION 操作仅需`O(1)`的实际和摊销时间，而 EXTRACT-MIN 和 DELETE 操作需要`O(lg n)`的摊销时间。然而，这些数据结构最重要的优势是 DECREASE-KEY 仅需`O(1)`的摊销时间。**`严格斐波那契堆`** [73]，稍后开发的，使所有这些时间界都成为实际时间界。由于 DECREASE-KEY 操作只需恒定的摊销时间，（严格）斐波那契堆构成迄今为止某些渐进最快图问题算法的关键组成部分。

+   ***动态树*** `[415, 429]` 维护一个不相交根树的森林。每棵树中的每条边都有一个实值成本。动态树支持查询以找到父节点、根节点、边成本，以及从节点到根的简单路径上的最小边成本。树可以通过切断边、更新从节点到根的所有边成本、将一个根链接到另一棵树、以及使一个节点成为其所在树的根来进行操作。一个动态树的实现为每个操作提供了`O(lg n)`的摊销时间界，而一个更复杂的实现则提供了`O(lg n)`的最坏情况时间界。动态树在一些渐进最快的网络流算法中使用。

+   ***伸展树*** `[418, 429]` 是一种二叉搜索树，标准搜索树操作在`O(lg n)`的摊销时间内运行。伸展树的一个应用简化了动态树。

+   ***持久化*** 数据结构允许对数据结构的过去版本进行查询，有时也可以进行更新。例如，链接数据结构可以在只有很小的时间和空间成本的情况下持久化[126]。问题 `13-1` 给出了一个持久化动态集的简单示例。

+   几种数据结构允许更快地实现字典操作（插入、删除和搜索）对于一组受限制的键。通过利用这些限制，它们能够实现比基于比较的数据结构更好的最坏情况渐近运行时间。如果键是从集合{0, 1, 2, … , *u* − 1}中抽取的唯一整数，其中*u*是 2 的确切幂，则一种递归数据结构称为`van Emde Boas 树` [440, 441] 支持每个操作搜索、插入、删除、最小值、最大值、后继和前驱在`O(lg lg u)`时间内。`融合树` [157] 是第一种允许在宇宙受限于整数时更快地实现字典操作的数据结构，将这些操作实现在`O(lg n/lg lg n)`时间内。几种后续的数据结构，包括`指数搜索树` [17]，也改进了一些或所有字典操作的界限，并在本书的章节注释中提到。  

+   ***动态图数据结构*** 支持各种查询，同时允许图的结构通过插入或删除顶点或边的操作而改变。它们支持的查询示例包括顶点连通性`[214]`，边连通性，最小生成树`[213]`，双连通性和传递闭包`[212]`。

本书中的章节注释提到了其他数据结构。
