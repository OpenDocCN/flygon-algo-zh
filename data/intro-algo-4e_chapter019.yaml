- en: '[**19        Data Structures for Disjoint Sets**](toc.xhtml#chap-19)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[**19        不相交集数据结构**](toc.xhtml#chap-19)'
- en: 'Some applications involve grouping *n* distinct elements into a collection
    of disjoint sets—sets with no elements in common. These applications often need
    to perform two operations in particular: finding the unique set that contains
    a given element and uniting two sets. This chapter explores methods for maintaining
    a data structure that supports these operations.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一些应用涉及将*n*个不同元素分组到一组不相交的集合中，即没有共同元素的集合。这些应用通常需要执行两个特定操作：找到包含给定元素的唯一集合和合并两个集合。本章探讨了维护支持这些操作的数据结构的方法。
- en: '[Section 19.1](chapter019.xhtml#Sec_19.1) describes the operations supported
    by a disjoint-set data structure and presents a simple application. [Section 19.2](chapter019.xhtml#Sec_19.2)
    looks at a simple linked-list implementation for disjoint sets. [Section 19.3](chapter019.xhtml#Sec_19.3)
    presents a more efficient representation using rooted trees. The running time
    using the tree representation is theoretically superlinear, but for all practical
    purposes it is linear. [Section 19.4](chapter019.xhtml#Sec_19.4) defines and discusses
    a very quickly growing function and its very slowly growing inverse, which appears
    in the running time of operations on the tree-based implementation, and then,
    by a complex amortized analysis, proves an upper bound on the running time that
    is just barely superlinear.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第19.1节](chapter019.xhtml#Sec_19.1)描述了不相交集数据结构支持的操作，并提供了一个简单的应用。[第19.2节](chapter019.xhtml#Sec_19.2)介绍了不相交集的简单链表实现。[第19.3节](chapter019.xhtml#Sec_19.3)介绍了使用根树的更有效表示。使用树表示的运行时间在理论上是超线性的，但在所有实际目的上都是线性的。[第19.4节](chapter019.xhtml#Sec_19.4)定义和讨论了一个增长非常快的��数及其增长非常慢的反函数，它们出现在基于树的实现的运行时间中，然后通过复杂的摊销分析证明了运行时间的上界，刚好是超线性的。'
- en: '[**19.1    Disjoint-set operations**](toc.xhtml#Rh1-111)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[**19.1    不相交集操作**](toc.xhtml#Rh1-111)'
- en: A ***disjoint-set data structure*** maintains a collection S = {*S*[1], *S*[2],
    … , *S[k]*} of disjoint dynamic sets. To identify each set, choose a ***representative***,
    which is some member of the set. In some applications, it doesn’t matter which
    member is used as the representative; it matters only that if you ask for the
    representative of a dynamic set twice without modifying the set between the requests,
    you get the same answer both times. Other applications may require a prespecified
    rule for choosing the representative, such as choosing the smallest member in
    the set (for a set whose elements can be ordered).
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一个***不相交集数据结构***维护一组不相交的动态集合S = {*S*[1], *S*[2], … , *S[k]*}。为了标识每个集合，选择一个***代表***，即集合的某个成员。在某些应用中，使用哪个成员作为代表并不重要；重要的是，如果在两次请求之间没有修改集合地询问动态集合的代表，那么两次都会得到相同的答案。其他应用可能需要一个预先规定的规则来选择代表，比如选择集合中最小的成员（对于元素可以排序的集合）。
- en: 'As in the other dynamic-set implementations we have studied, each element of
    a set is represented by an object. Letting *x* denote an object, we’ll see how
    to support the following operations:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们研究过的其他动态集实现一样，集合的每个元素都由一个对象表示。让*x*表示一个对象，我们将看到如何支持以下操作：
- en: MAKE-SET(*x*), where *x* does not already belong to some other set, creates
    a new set whose only member (and thus representative) is *x*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: MAKE-SET(*x*)，其中*x*尚未属于其他集合，创建一个只有*x*作为成员（因此也是代表）的新集合。
- en: UNION(*x*, *y*) unites two disjoint, dynamic sets that contain *x* and *y*,
    say *S[x]* and *S[y]*, into a new set that is the union of these two sets. The
    representative of the resulting set is any member of *S[x]* ∪ *S[y]*, although
    many implementations of UNION specifically choose the representative of either
    *S[x]* or *S[y]* as the new representative. Since the sets in the collection must
    at all times be disjoint, the UNION operation destroys sets *S[x]* and *S[y]*,
    removing them from the collection S. In practice, implementations often absorb
    the elements of one of the sets into the other set.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: UNION(*x*, *y*)将包含*x*和*y*的两个不相交动态集合，即*S[x]*和*S[y]*，合并成一个新集合，该集合是这两个集合的并集。结果集的代表是*S[x]*
    ∪ *S[y]*中的任何成员，尽管许多UNION的实现特别选择*S[x]*或*S[y]*的代表作为新代表。由于集合在任何时候必须是不相交的，UNION操作会销毁集合*S[x]*和*S[y]*，将它们从集合S中移除。在实践中，实现通常会将一个集合的元素吸收到另一个集合中。
- en: FIND-SET(*x*) returns a pointer to the representative of the unique set containing
    *x*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: FIND-SET(*x*)返回指向包含*x*的唯一集合的代表的指针。
- en: 'Throughout this chapter, we’ll analyze the running times of disjoint-set data
    structures in terms of two parameters: *n*, the number of MAKE-SET operations,
    and *m*, the total number of MAKE-SET, UNION, and FIND-SET operations. Because
    the total number of operations *m* includes the *n* MAKE-SET operations, *m* ≥
    *n*. The first *n* operations are always MAKE-SET operations, so that after the
    first *n* operations, the collection consists of *n* singleton sets. Since the
    sets are disjoint at all times, each UNION operation reduces the number of sets
    by 1\. After *n* − 1 UNION operations, therefore, only one set remains, and so
    at most *n* − 1 UNION operations can occur.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将分析不相交集数据结构的运行时间，以两个参数*n*和*m*为基础，其中*n*是MAKE-SET操作的数量，*m*是MAKE-SET、UNION和FIND-SET操作的总数。因为总操作数*m*包括*n*个MAKE-SET操作，所以*m*
    ≥ *n*。前*n*个操作总是MAKE-SET操作，因此在前*n*个操作之后，集合由*n*个单例集合组成。由于集合始终是不相交的，每个UNION操作都会将集合数量减少1。因此，在*n*
    − 1个UNION操作之后，只剩下一个集合，因此最多可以发生*n* − 1个UNION操作。
- en: '**An application of disjoint-set data structures**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**不相交集数据结构的应用**'
- en: One of the many applications of disjoint-set data structures arises in determining
    the connected components of an undirected graph (see [Section B.4](appendix002.xhtml#Sec_B.4)).
    [Figure 19.1(a)](chapter019.xhtml#Fig_19-1), for example, shows a graph with four
    connected components.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 不相交集数据结构的许多应用之一是确定无向图的连通分量（参见[附录B.4节](appendix002.xhtml#Sec_B.4)）。例如，[图19.1(a)](chapter019.xhtml#Fig_19-1)展示了一个具有四个连通分量的图。
- en: The procedure CONNECTED-COMPONENTS on the following page uses the disjoint-set
    operations to compute the connected components of a graph. Once the CONNECTED-COMPONENTS
    procedure has preprocessed the graph, the procedure SAME-COMPONENT answers queries
    about whether two vertices belong to the same connected component. In pseudocode,
    we denote the set of vertices of a graph *G* by *G*.*V* and the set of edges by
    *G*.*E*.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 过程 CONNECTED-COMPONENTS 在下一页上使用不相交集合操作来计算图的连通分量。一旦 CONNECTED-COMPONENTS 过程对图进行了预处理，SAME-COMPONENT
    过程就可以回答关于两个顶点是否属于同一连通分量的查询。在伪代码中，我们用 *G* 表示图的顶点集，用 *G*.*E* 表示边集。
- en: The procedure CONNECTED-COMPONENTS initially places each vertex *v* in its own
    set. Then, for each edge (*u*, *v*), it unites the sets containing *u* and *v*.
    By Exercise 19.1-2, after all the edges are processed, two vertices belong to
    the same connected component if and only if the objects corresponding to the vertices
    belong to the same set. Thus CONNECTED-COMPONENTS computes sets in such a way
    that the procedure SAME-COMPONENT can determine whether two vertices are in the
    same connected component. [Figure 19.1(b)](chapter019.xhtml#Fig_19-1) illustrates
    how CONNECTED-COMPONENTS computes the disjoint sets.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 过程 CONNECTED-COMPONENTS 最初将每个顶点 *v* 放入自己的集合中。然后，对于每条边 (*u*, *v*), 它将包含 *u* 和
    *v* 的集合合并。根据练习 19.1-2，处理完所有边后，两个顶点属于同一连通分量当且仅当对应于顶点的对象属于同一集合。因此，CONNECTED-COMPONENTS
    以这种方式计算集合，使得 SAME-COMPONENT 过程可以确定两个顶点是否属于同一连通分量。[图 19.1(b)](chapter019.xhtml#Fig_19-1)
    说明了 CONNECTED-COMPONENTS 如何计算不相交集合。
- en: '![art](images/Art_P557.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P557.jpg)'
- en: '**Figure 19.1 (a)** A graph with four connected components: {*a*, *b*, *c*,
    *d*}, {*e*, *f*, *g*}, {*h*, *i*}, and {*j* }. **(b)** The collection of disjoint
    sets after processing each edge.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 19.1 (a)** 一个具有四个连通分量的图：{*a*, *b*, *c*, *d*}, {*e*, *f*, *g*}, {*h*, *i*},
    和 {*j* }。**(b)** 处理每条边后的不相交集合的集合。'
- en: CONNECTED-COMPONENTS(*G*)
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: CONNECTED-COMPONENTS(*G*)
- en: '| 1 | **for** each vertex *v* ∈ *G*.*V* |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **对于**图 *G*.*V* 中的每个顶点 *v* |'
- en: '| 2 | MAKE-SET(*v*) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 2 | MAKE-SET(*v*) |'
- en: '| 3 | **for** each edge (*u*, *v*) ∈ *G*.*E* |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **对于**图 *G*.*E* 中的每条边 (*u*, *v*) |'
- en: '| 4 | **if** FIND-SET(*u*) ≠ FIND-SET(*v*) |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **如果** FIND-SET(*u*) ≠ FIND-SET(*v*) |'
- en: '| 5 | UNION(*u*, *v*) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 5 | UNION(*u*, *v*) |'
- en: '| SAME-COMPONENT(*u*, *v*) |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| SAME-COMPONENT(*u*, *v*) |'
- en: '| 1 | **if** FIND-SET(*u*) == FIND-SET(*v*) |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **如果** FIND-SET(*u*) == FIND-SET(*v*) |'
- en: '| 2 | **return** TRUE |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **返回** TRUE |'
- en: '| 3 | **else return**FALSE |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **否则返回**FALSE |'
- en: In an actual implementation of this connected-components algorithm, the representations
    of the graph and the disjoint-set data structure would need to reference each
    other. That is, an object representing a vertex would contain a pointer to the
    corresponding disjoint-set object, and vice versa. Since these programming details
    depend on the implementation language, we do not address them further here.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个连通分量算法的实际实现中，图的表示和不相交集合数据结构需要相互引用。也就是说，表示顶点的对象应包含指向相应不相交集合对象的指针，反之亦然。由于这些编程细节取决于实现语言，我们在这里不再详细讨论。
- en: When the edges of the graph are static—not changing over time—depth-first search
    can compute the connected components faster (see Exercise 20.3-12 on page 572).
    Sometimes, however, the edges are added dynamically, with the connected components
    updated as each edge is added. In this case, the implementation given here can
    be more efficient than running a new depth-first search for each new edge.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当图的边是静态的——不随时间变化时——深度优先搜索可以更快地计算连通分量（参见第572页上的练习20.3-12）。然而，有时边是动态添加的，随着每条边的添加，连通分量会更新。在这种情况下，这里给出的实现可能比为每条新边运行新的深度优先搜索更有效。
- en: '**Exercises**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***19.1-1***'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.1-1***'
- en: The CONNECTED-COMPONENTS procedure is run on the undirected graph *G* = (*V*,
    *E*), where *V* = {*a*, *b*, *c*, *d*, *e*, *f*, *g*, *h*, *i*, *j*, *k*}, and
    the edges of *E* are processed in the order (*d*, *i*), (*f*, *k*), (*g*, *i*),
    (*b*, *g*), (*a*, *h*), (*i*, *j*), (*d*, *k*), (*b*, *j*), (*d*, *f*), (*g*,
    *j*), (*a*, *e*). List the vertices in each connected component after each iteration
    of lines 3–5.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: CONNECTED-COMPONENTS 过程在无向图 *G* = (*V*, *E*) 上运行，其中 *V* = {*a*, *b*, *c*, *d*,
    *e*, *f*, *g*, *h*, *i*, *j*, *k*}，边 *E* 按顺序 (*d*, *i*), (*f*, *k*), (*g*, *i*),
    (*b*, *g*), (*a*, *h*), (*i*, *j*), (*d*, *k*), (*b*, *j*), (*d*, *f*), (*g*,
    *j*), (*a*, *e*) 处理。在每次执行第 3-5 行后，列出每个连通分量中的顶点。
- en: '***19.1-2***'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.1-2***'
- en: Show that after all edges are processed by CONNECTED-COMPONENTS, two vertices
    belong to the same connected component if and only if they belong to the same
    set.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 证明经过 CONNECTED-COMPONENTS 处理所有边后，两个顶点属于同一连通分量当且仅当它们属于同一集合。
- en: '***19.1-3***'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.1-3***'
- en: During the execution of CONNECTED-COMPONENTS on an undirected graph *G* = (*V*,
    *E*) with *k* connected components, how many times is FIND-SET called? How many
    times is UNION called? Express your answers in terms of |*V* |, |*E*|, and *k*.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在无向图 *G* = (*V*, *E*) 上运行 CONNECTED-COMPONENTS 过程时，有 *k* 个连通分量，FIND-SET 被调用多少次？UNION
    被调用多少次？用 |*V* |, |*E*|, 和 *k* 表示你的答案。
- en: '[**19.2    Linked-list representation of disjoint sets**](toc.xhtml#Rh1-112)'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '[**19.2    不相交集合的链表表示**](toc.xhtml#Rh1-112)'
- en: '[Figure 19.2(a)](chapter019.xhtml#Fig_19-2) shows a simple way to implement
    a disjoint-set data structure: each set is represented by its own linked list.
    The object for each set has attributes *head*, pointing to the first object in
    the list, and *tail*, pointing to the last object. Each object in the list contains
    a set member, a pointer to the next object in the list, and a pointer back to
    the set object. Within each linked list, the objects may appear in any order.
    The representative is the set member in the first object in the list.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 19.2(a)](chapter019.xhtml#Fig_19-2) 展示了一种实现不相交集合数据结构的简单方法：每个集合由其自己的链表表示。每个集合的对象具有属性
    *head*，指向列表中的第一个对象，*tail*，指向列表中的最后一个对象。列表中的每个对象包含一个集合成员，指向列表中的下一个对象的指针，以及指回集合对象的指针。在每个链表中，对象可以以任何顺序出现。代表是列表中第一个对象中的集合成员。'
- en: With this linked-list representation, both MAKE-SET and FIND-SET require only
    *O*(1) time. To carry out MAKE-SET(*x*), create a new linked list whose only object
    is *x*. For FIND-SET(*x*), just follow the pointer from *x* back to its set object
    and then return the member in the object that *head* points to. For example, in
    [Figure 19.2(a)](chapter019.xhtml#Fig_19-2), the call FIND-SET(*g*) returns *f*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种链表表示，MAKE-SET和FIND-SET只需要*O*(1)的时间。执行MAKE-SET(*x*)，创建一个只包含*x*的新链表。对于FIND-SET(*x*)，只需从*x*返回到其集合对象的指针，然后返回指向*head*的对象中的成员。例如，在[19.2(a)图](chapter019.xhtml#Fig_19-2)中，调用FIND-SET(*g*)返回*f*。
- en: '![art](images/Art_P558.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P558.jpg)'
- en: '**Figure 19.2 (a)** Linked-list representations of two sets. Set *S*[1] contains
    members *d*, *f*, and *g*, with representative *f*, and set *S*[2] contains members
    *b*, *c*, *e*, and *h*, with representative *c*. Each object in the list contains
    a set member, a pointer to the next object in the list, and a pointer back to
    the set object. Each set object has pointers *head* and *tail* to the first and
    last objects, respectively. **(b)** The result of UNION(*g*, *e*), which appends
    the linked list containing *e* to the linked list containing *g*. The representative
    of the resulting set is *f*. The set object for *e*’s list, *S*[2], is destroyed.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**图19.2 (a)** 两个集合的链表表示。集合*S*[1]包含成员*d*、*f*和*g*，代表是*f*，集合*S*[2]包含成员*b*、*c*、*e*和*h*，代表是*c*。列表中的每个对象包含一个集合成员、指向列表中下一个对象的指针以及指向集合对象的指针。每个集合对象都有指向第一个和最后一个对象的指针*head*和*tail*。**(b)**
    UNION(*g*, *e*)的结果，将包含*e*的链表附加到包含*g*的链表。结果集的代表是*f*。*e*的列表的集合对象*S*[2]被销毁。'
- en: '**A simple implementation of union**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**联合的简单实现**'
- en: 'The simplest implementation of the UNION operation using the linked-list set
    representation takes significantly more time than MAKE-SET or FIND-SET. As [Figure
    19.2(b)](chapter019.xhtml#Fig_19-2) shows, the operation UNION(*x*, *y*) appends
    *y*’s list onto the end of *x*’s list. The representative of *x*’s list becomes
    the representative of the resulting set. To quickly find where to append *y*’s
    list, use the *tail* pointer for *x*’s list. Because all members of *y*’s list
    join *x*’s list, the UNION operation destroys the set object for *y*’s list. The
    UNION operation is where this implementation pays the price for FIND-SET taking
    constant time: UNION must also update the pointer to the set object for each object
    originally on *y*’s list, which takes time linear in the length of *y*’s list.
    In [Figure 19.2](chapter019.xhtml#Fig_19-2), for example, the operation UNION(*g*,
    *e*) causes pointers to be updated in the objects for *b*, *c*, *e*, and *h*.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 使用链表集合表示的UNION操作的最简单实现所需的时间明显比MAKE-SET或FIND-SET多。如[19.2(b)图](chapter019.xhtml#Fig_19-2)所示，UNION(*x*,
    *y*)操作将*y*的列表附加到*x*的列表末尾。*x*的列表的代表成为结果集的代表。为了快速找到要附加*y*的列表的位置，使用*x*的列表的*tail*指针。因为*y*的列表的所有成员都加入*x*的列表，UNION操作会销毁*y*的列表的集合对象。UNION操作是这种实现付出代价的地方，因为FIND-SET花费恒定时间：UNION还必须更新原始在*y*的列表上的每个对象的集合对象指针，这需要与*y*的列表长度成正比的时间。例如，在[19.2图](chapter019.xhtml#Fig_19-2)中，操作UNION(*g*,
    *e*)导致*b*、*c*、*e*和*h*的对象中的指针被更新。
- en: 'In fact, we can construct a sequence of *m* operations on *n* objects that
    requires Θ(*n*²) time. Starting with objects *x*[1], *x*[2], … , *x[n]*, execute
    the sequence of *n* MAKE-SET operations followed by *n* − 1 UNION operations shown
    in [Figure 19.3](chapter019.xhtml#Fig_19-3), so that *m* = 2*n*−1\. The *n* MAKE-SET
    operations take Θ(*n*) time. Because the *i*th UNION operation updates *i* objects,
    the total number of objects updated by all *n*−1 UNION operations forms an arithmetic
    series:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以对*n*个对象进行一系列*m*个操作，需要Θ(*n*²)的时间。从对象*x*[1]，*x*[2]，…，*x[n]*开始，执行[n.3图](chapter019.xhtml#Fig_19-3)中显示的*n*个MAKE-SET操作，然后是*n*−1个UNION操作，使得*m*
    = 2*n*−1。这*n*个MAKE-SET操作需要Θ(*n*)的时间。因为第*i*个UNION操作更新*i*个对象，所有*n*−1个UNION操作更新的对象总数形成一个等差数列：
- en: '![art](images/Art_P559.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P559.jpg)'
- en: '**Figure 19.3** A sequence of 2*n* − 1 operations on *n* objects that takes
    Θ(*n*²) time, or Θ(*n*) time per operation on average, using the linked-list set
    representation and the simple implementation of UNION.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '**图19.3** 对*n*个对象进行的一系列2*n*−1个操作，使用链表集合表示和UNION的简单实现，需要Θ(*n*²)的时间，或者平均每个操作需要Θ(*n*)的时间。'
- en: '![art](images/Art_P560.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P560.jpg)'
- en: The total number of operations is 2*n*−1, and so each operation on average requires
    Θ(*n*) time. That is, the amortized time of an operation is Θ(*n*).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 总操作数为2*n*−1，因此每个操作平均需要Θ(*n*)的时间。也就是说，操作的摊销时间是Θ(*n*)。
- en: '**A weighted-union heuristic**'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '**加权联合启发式**'
- en: In the worst case, the above implementation of UNION requires an average of
    Θ(*n*) time per call, because it might be appending a longer list onto a shorter
    list, and the procedure must update the pointer to the set object for each member
    of the longer list. Suppose instead that each list also includes the length of
    the list (which can be maintained straightforwardly with constant overhead) and
    that the UNION procedure always appends the shorter list onto the longer, breaking
    ties arbitrarily. With this simple ***weighted-union heuristic***, a single UNION
    operation can still take Ω(*n*) time if both sets have Ω(*n*) members. As the
    following theorem shows, however, a sequence of *m* MAKE-SET, UNION, and FIND-SET
    operations, *n* of which are MAKE-SET operations, takes *O*(*m* + *n* lg *n*)
    time.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在最坏情况下，上述UNION的实现每次调用平均需要Θ(*n*)的时间，因为可能会将较长的列表附加到较短的列表上，而过程必须更新较长列表的每个成员的集合对象指针。相反，假设每个列表还包括列表的长度（可以通过常量开销简单地维护），并且UNION过程总是将较短的列表附加到较长的列表上，随机打破平局。使用这种简单的***加权联合启发式***，如果两个集合都有Ω(*n*)个成员，则单个UNION操作仍可能需要Ω(*n*)的时间。然而，如下定理所示，一系列*m*个MAKE-SET、UNION和FIND-SET操作，其中*n*个是MAKE-SET操作，需要*O*(*m*
    + *n* lg *n*)的时间。
- en: '***Theorem 19.1***'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理19.1***'
- en: Using the linked-list representation of disjoint sets and the weighted-union
    heuristic, a sequence of *m* MAKE-SET, UNION, and FIND-SET operations, *n* of
    which are MAKE-SET operations, takes *O*(*m* + *n* lg *n*) time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 使用不相交集合的链表表示和加权并启发式方法，包含*m*个MAKE-SET、UNION和FIND-SET操作的序列，其中*n*个是MAKE-SET操作，需要*O*(*m*
    + *n* lg *n*)的时间。
- en: '***Proof***   Because each UNION operation unites two disjoint sets, at most
    *n* − 1 UNION operations occur over all. We now bound the total time taken by
    these UNION operations. We start by determining, for each object, an upper bound
    on the number of times the object’s pointer back to its set object is updated.
    Consider a particular object *x*. Each time *x*’s pointer is updated, *x* must
    have started in the smaller set. The first time *x*’s pointer is updated, therefore,
    the resulting set must have at least 2 members. Similarly, the next time *x*’s
    pointer is updated, the resulting set must have had at least 4 members. Continuing
    on, for any *k* ≤ *n*, after *x*’s pointer has been updated ⌈lg *k*⌉ times, the
    resulting set must have at least *k* members. Since the largest set has at most
    *n* members, each object’s pointer is updated at most ⌈lg *n*⌉ times over all
    the UNION operations. Thus the total time spent updating object pointers over
    all UNION operations is *O*(*n* lg *n*). We must also account for updating the
    *tail* pointers and the list lengths, which take only Θ(1) time per UNION operation.
    The total time spent in all UNION operations is thus *O*(*n* lg *n*).'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***  因为每个UNION操作将两个不相交的集合合并，所有操作中最多发生*n* − 1次UNION操作。我们现在限制这些UNION操作所花费的总时间。我们首先确定每个对象的指针回到其集合对象的更新次数的上限。考虑一个特定的对象*x*。每次更新*x*的指针时，*x*必须起始于较小的集合。因此，第一次更新*x*的指针时，结果集合必须至少有2个成员。类似地，下一次更新*x*的指针时，结果集合必须至少有4个成员。继续下去，对于任何*k*
    ≤ *n*，在*x*的指针被更新⌈lg *k*⌉次后，结果集合必须至少有*k*个成员。由于最大的集合最多有*n*个成员，每个对象的指针在所有UNION操作中最多更新⌈lg
    *n*⌉次。因此，在所有UNION操作中花费在更新对象指针上的总时间为*O*(*n* lg *n*)。我们还必须考虑更新*tail*指针和列表长度，每个UNION操作仅需要Θ(1)的时间。因此，所有UNION操作中花费的总时间为*O*(*n*
    lg *n*)。'
- en: The time for the entire sequence of *m* operations follows. Each MAKE-SET and
    FIND-SET operation takes *O*(1) time, and there are *O*(*m*) of them. The total
    time for the entire sequence is thus *O*(*m* + *n* lg *n*).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 整个*m*个操作序列的时间如下。每个MAKE-SET和FIND-SET操作都需要*O*(1)的时间，共有*O*(*m*)个。因此，整个序列的总时间为*O*(*m*
    + *n* lg *n*)。
- en: ▪
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Exercises**'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***19.2-1***'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.2-1***'
- en: Write pseudocode for MAKE-SET, FIND-SET, and UNION using the linked-list representation
    and the weighted-union heuristic. Make sure to specify the attributes that you
    assume for set objects and list objects.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用链表表示和加权并启发式方法编写MAKE-SET、FIND-SET和UNION的伪代码。确保指定你假设的集合对象和列表对象的属性。
- en: '***19.2-2***'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.2-2***'
- en: Show the data structure that results and the answers returned by the FIND-SET
    operations in the following program. Use the linked-list representation with the
    weighted-union heuristic. Assume that if the sets containing *x[i]* and *x[j]*
    have the same size, then the operation UNION(*x[i]*, *x[j]*) appends *x[j]*’s
    list onto *x[i]*’s list.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 展示由以下程序中的FIND-SET操作返回的数据结构和答案。使用带有加权并启发式方法的链表表示。假设如果包含*x[i]*和*x[j]*的集合大小相同，则操作UNION(*x[i]*,
    *x[j]*)将*x[j]*的列表附加到*x[i]*的列表上。
- en: '|   1 | **for** *i* = 1 **to** 16 |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '|   1 | **for** *i* = 1 **to** 16 |'
- en: '|   2 | MAKE-SET(*x[i]*) |'
  id: totrans-60
  prefs: []
  type: TYPE_TB
  zh: '|   2 | MAKE-SET(*x[i]*) |'
- en: '|   3 | **for** *i* = 1 **to** 15 **by** 2 |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '|   3 | **for** *i* = 1 **to** 15 **by** 2 |'
- en: '|   4 | UNION(*x[i]*, *x*[*i*+1]) |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '|   4 | UNION(*x[i]*, *x*[*i*+1]) |'
- en: '|   5 | **for** *i* = 1 **to** 13 **by** 4 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '|   5 | **for** *i* = 1 **to** 13 **by** 4 |'
- en: '|   6 | UNION(*x[i]*, *x*[*i*+2]) |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|   6 | UNION(*x[i]*, *x*[*i*+2]) |'
- en: '|   7 | UNION(*x*[1], *x*[5]) |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '|   7 | UNION(*x*[1], *x*[5]) |'
- en: '|   8 | UNION(*x*[11], *x*[13]) |'
  id: totrans-66
  prefs: []
  type: TYPE_TB
  zh: '|   8 | UNION(*x*[11], *x*[13]) |'
- en: '|   9 | UNION(*x*[1], *x*[10]) |'
  id: totrans-67
  prefs: []
  type: TYPE_TB
  zh: '|   9 | UNION(*x*[1], *x*[10]) |'
- en: '| 10 | FIND-SET(*x*[2]) |'
  id: totrans-68
  prefs: []
  type: TYPE_TB
  zh: '| 10 | FIND-SET(*x*[2]) |'
- en: '| 11 | FIND-SET(*x*[9]) |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 11 | FIND-SET(*x*[9]) |'
- en: '***19.2-3***'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.2-3***'
- en: Adapt the aggregate proof of Theorem 19.1 to obtain amortized time bounds of
    *O*(1) for MAKE-SET and FIND-SET and *O*(lg *n*) for UNION using the linked-list
    representation and the weighted-union heuristic.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将定理19.1的总体证明改编为使用链表表示和加权并启发式方法获得MAKE-SET和FIND-SET的*O*(1)摊销时间界限，以及UNION的*O*(lg
    *n*)摊销时间界限。
- en: '***19.2-4***'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.2-4***'
- en: Give a tight asymptotic bound on the running time of the sequence of operations
    in [Figure 19.3](chapter019.xhtml#Fig_19-3) assuming the linked-list representation
    and the weighted-union heuristic.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 给出在[图19.3](chapter019.xhtml#Fig_19-3)中操作序列的运行时间的紧密渐近界限，假设使用链表表示和加权并启发式方法。
- en: '***19.2-5***'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.2-5***'
- en: 'Professor Gompers suspects that it might be possible to keep just one pointer
    in each set object, rather than two (*head* and *tail*), while keeping the number
    of pointers in each list element at two. Show that the professor’s suspicion is
    well founded by describing how to represent each set by a linked list such that
    each operation has the same running time as the operations described in this section.
    Describe also how the operations work. Your scheme should allow for the weighted-union
    heuristic, with the same effect as described in this section. (*Hint*: Use the
    tail of a linked list as its set’s representative.)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 教授戈姆珀斯怀疑可能只需在每个集合对象中保留一个指针，而不是两个（*head* 和 *tail*），同时保持每个列表元素中指针的数量为两个。通过描述如何用链表表示每个集合来证明教授的怀疑是正确的，使得每个操作的运行时间与本节描述的操作相同。还要描述操作的工作原理。你的方案应允许使用加权并启发式方法，效果与本节描述的相同。(*提示*：使用链表的尾部作为其集合的代表。)
- en: '***19.2-6***'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.2-6***'
- en: 'Suggest a simple change to the UNION procedure for the linked-list representation
    that removes the need to keep the *tail* pointer to the last object in each list.
    Regardless of whether the weighted-union heuristic is used, your change should
    not change the asymptotic running time of the UNION procedure. (*Hint*: Rather
    than appending one list to another, splice them together.)'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 建议对链表表示的UNION过程进行简单更改，以消除保留每个列表中最后一个对象的*tail*指针的需要。无论是否使用加权合并启发式，您的更改都不应改变UNION过程的渐进运行时间。(*提示*：不要将一个列表附加到另一个列表，而是将它们拼接在一起。)
- en: '[**19.3    Disjoint-set forests**](toc.xhtml#Rh1-113)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '[**19.3    不相交集合森林**](toc.xhtml#Rh1-113)'
- en: A faster implementation of disjoint sets represents sets by rooted trees, with
    each node containing one member and each tree representing one set. In a ***disjoint-set
    forest***, illustrated in [Figure 19.4(a)](chapter019.xhtml#Fig_19-4), each member
    points only to its parent. The root of each tree contains the representative and
    is its own parent. As we’ll see, although the straightforward algorithms that
    use this representation are no faster than ones that use the linked-list representation,
    two heuristics—“union by rank” and “path compression”—yield an asymptotically
    optimal disjoint-set data structure.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 更快的不相交集合实现通过根树表示集合，每个节点包含一个成员，每棵树表示一个集合。在***不相交集合森林***中，如[图19.4(a)](chapter019.xhtml#Fig_19-4)所示，每个成员只指向其父节点。每棵树的根包含代表并且是自己的父节点。正如我们将看到的，尽管使用这种表示的直接算法并不比使用链表表示的算法更快，但两个启发式——“按秩合并”和“路径压缩”——产生了一个渐进最优的不相交集合数据结构。
- en: The three disjoint-set operations have simple implementations. A MAKE-SET operation
    simply creates a tree with just one node. A FIND-SET operation follows parent
    pointers until it reaches the root of the tree. The nodes visited on this simple
    path toward the root constitute the ***find path***. A UNION operation, shown
    in [Figure 19.4(b)](chapter019.xhtml#Fig_19-4), simply causes the root of one
    tree to point to the root of the other.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 三个不相交集合操作有简单的实现。MAKE-SET操作简单地创建一个只有一个节点的树。FIND-SET操作沿着父指针向树根移动，直到达到树根。在这条通向根的简单路径上访问的节点构成***查找路径***。UNION操作，如[图19.4(b)](chapter019.xhtml#Fig_19-4)所示，只是使一棵树的根指向另一棵树的根。
- en: '![art](images/Art_P561.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P561.jpg)'
- en: '**Figure 19.4** A disjoint-set forest. **(a)** Trees representing the two sets
    of [Figure 19.2](chapter019.xhtml#Fig_19-2). The tree on the left represents the
    set {*b*, *c*, *e*, *h*}, with *c* as the representative, and the tree on the
    right represents the set {*d*, *f*, *g*}, with *f* as the representative. **(b)**
    The result of UNION (*e*, *g*).'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**图19.4** 不相交集合森林。**(a)** 代表[图19.2](chapter019.xhtml#Fig_19-2)中两个集合的树。左侧的树代表集合{*b*,
    *c*, *e*, *h*}，其中*c*是代表，右侧的树代表集合{*d*, *f*, *g*}，其中*f*是代表。**(b)** UNION (*e*, *g*)的结果。'
- en: '**Heuristics to improve the running time**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**改进运行时间的启发式**'
- en: So far, disjoint-set forests have not improved on the linked-list implementation.
    A sequence of *n* − 1 UNION operations could create a tree that is just a linear
    chain of *n* nodes. By using two heuristics, however, we can achieve a running
    time that is almost linear in the total number *m* of operations.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，不相交集合森林并没有改进链表实现。一系列*n* − 1个UNION操作可能创建一个只是*n*个节点的线性链的树。然而，通过使用两个启发式，我们可以实现一个几乎与操作总数*m*几乎线性的运行时间。
- en: The first heuristic, ***union by rank***, is similar to the weighted-union heuristic
    we used with the linked-list representation. The common-sense approach is to make
    the root of the tree with fewer nodes point to the root of the tree with more
    nodes. Rather than explicitly keeping track of the size of the subtree rooted
    at each node, however, we’ll adopt an approach that eases the analysis. For each
    node, maintain a ***rank***, which is an upper bound on the height of the node.
    Union by rank makes the root with smaller rank point to the root with larger rank
    during a UNION operation.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个启发式，***按秩合并***，类似于我们在链表表示中使用的加权合并启发式。常识的方法是使节点较少的树的根指向节点较多的树的根。然而，与明确跟踪每个节点根的子树大小不同，我们将采用一种简化分析的方法。对于每个节点，维护一个***秩***，它是节点高度的一个上界。在UNION操作期间，按秩合并使秩较小的根指向秩较大的根。
- en: The second heuristic, ***path compression***, is also quite simple and highly
    effective. As shown in [Figure 19.5](chapter019.xhtml#Fig_19-5), FIND-SET operations
    use it to make each node on the find path point directly to the root. Path compression
    does not change any ranks.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个启发式，***路径压缩***，也非常简单且高效。如[图19.5](chapter019.xhtml#Fig_19-5)所示，FIND-SET操作使用它使沿查找路径的每个节点直接指向根。路径压缩不会改变任何秩。
- en: '**Pseudocode for disjoint-set forests**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**不相交集合森林的伪代码**'
- en: The union-by-rank heuristic requires its implementation to keep track of ranks.
    With each node *x*, maintain the integer value *x*.*rank*, which is an upper bound
    on the height of *x* (the number of edges in the longest simple path from a descendant
    leaf to *x*). When MAKE-SET creates a singleton set, the single node in the corresponding
    tree has an initial rank of 0\. Each FIND-SET operation leaves all ranks unchanged.
    The UNION operation has two cases, depending on whether the roots of the trees
    have equal rank. If the roots have unequal ranks, make the root with higher rank
    the parent of the root with lower rank, but don’t change the ranks themselves.
    If the roots have equal ranks, arbitrarily choose one of the roots as the parent
    and increment its rank.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 按秩合并启发式要求其实现跟踪秩。对于每个节点*x*，维护整数值*x*.*rank*，它是*x*的高度的一个上界（从后代叶子到*x*的最长简单路径中的边数）。当MAKE-SET创建一个单例集时，对应树中的单个节点具有初始秩为0。每个FIND-SET操作都不会改变所有秩。UNION操作有两种情况，取决于树的根是否具有相等的秩。如果根的秩不相等，则使具有更高秩的根成为具有较低秩的根的父节点，但不更改秩本身。如果根的秩相等，则任意选择一个根作为父节点并增加其秩。
- en: '![art](images/Art_P562.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P562.jpg)'
- en: '**Figure 19.5** Path compression during the operation FIND-SET. Arrows and
    self-loops at roots are omitted. **(a)** A tree representing a set prior to executing
    FIND-SET(*a*). Triangles represent subtrees whose roots are the nodes shown. Each
    node has a pointer to its parent. **(b)** The same set after executing FIND-SET(*a*).
    Each node on the find path now points directly to the root.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 19.5** 在执行 FIND-SET 操作期间的路径压缩。省略了根节点的箭头和自环。**(a)** 表示在执行 FIND-SET(*a*)之前表示集合的树。三角形代表根节点为所示节点的子树。每个节点都有指向其父节点的指针。**(b)**
    在执行 FIND-SET(*a*)之后的同一集合。沿着查找路径的每个节点现在直接指向根节点。'
- en: Let’s put this method into pseudocode, appearing on the next page. The parent
    of node *x* is denoted by *x*.*p*. The LINK procedure, a subroutine called by
    UNION, takes pointers to two roots as inputs. The FIND-SET procedure with path
    compression, implemented recursively, turns out to be quite simple.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将这种方法放入伪代码中，出现在下一页上。节点*x*的父节点用*x*.*p*表示。LINK过程是UNION调用的子例程，接受两个根节点的指针作为输入。使用路径压缩实现的递归FIND-SET过程实际上非常简单。
- en: 'The FIND-SET procedure is a ***two-pass method***: as it recurses, it makes
    one pass up the find path to find the root, and as the recursion unwinds, it makes
    a second pass back down the find path to update each node to point directly to
    the root. Each call of FIND-SET(*x*) returns *x*.*p* in line 3\. If *x* is the
    root, then FIND-SET skips line 2 and just returns *x*.*p*, which is *x*. In this
    case the recursion bottoms out. Otherwise, line 2 executes, and the recursive
    call with parameter *x*.*p* returns a pointer to the root. Line 2 updates node
    *x* to point directly to the root, and line 3 returns this pointer.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: FIND-SET过程是一个***两遍方法***：当递归时，它沿着查找路径向上进行一次查找以找到根节点，当递归解开时，它沿着查找路径向下进行第二次查找以更新每个节点直接指向根节点。FIND-SET(*x*)的每次调用在第3行返回*x*.*p*。如果*x*是根节点，则FIND-SET跳过第2行并直接返回*x*.*p*，即*x*。在这种情况下，递归到底。否则，第2行执行，带有*x*.*p*参数的递归调用返回指向根节点的指针。第2行更新节点*x*直接指向根节点，第3行返回此指针。
- en: MAKE-SET(*x*)
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: MAKE-SET(*x*)
- en: '| 1 | *x*.*p* = *x* |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *x*.*p* = *x* |'
- en: '| 2 | *x*.*rank* = 0 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *x*.*rank* = 0 |'
- en: UNION(*x*, *y*)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: UNION(*x*, *y*)
- en: '| 1 | LINK(FIND-SET(*x*), FIND-SET(*y*)) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 1 | LINK(FIND-SET(*x*), FIND-SET(*y*)) |'
- en: LINK(*x*, *y*)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: LINK(*x*, *y*)
- en: '| 1 | **if** *x*.*rank > y*.*rank* |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **if** *x*.*rank > y*.*rank* |'
- en: '| 2 | *y*.*p* = *x* |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *y*.*p* = *x* |'
- en: '| 3 | **else** *x*.*p* = *y* |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **else** *x*.*p* = *y* |'
- en: '| 4 | **if** *x*.*rank* == *y*.*rank* |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **if** *x*.*rank* == *y*.*rank* |'
- en: '| 5 | *y*.*rank* = *y*.*rank* + 1 |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 5 | *y*.*rank* = *y*.*rank* + 1 |'
- en: FIND-SET(*x*)
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: FIND-SET(*x*)
- en: '| 1 | **if** *x* ≠ *x*.*p* | **//** not the root? |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **if** *x* ≠ *x*.*p* | **//** 不是根节点？ |'
- en: '| 2 | *x*.*p* = FIND-SET(*x*.*p*) | **//** the root becomes the parent |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *x*.*p* = FIND-SET(*x*.*p*) | **//** 根节点成为父节点 |'
- en: '| 3 | **return** *x*.*p* | **//** return the root |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **return** *x*.*p* | **//** 返回根节点 |'
- en: '**Effect of the heuristics on the running time**'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '**启发式对运行时间的影响**'
- en: Separately, either union by rank or path compression improves the running time
    of the operations on disjoint-set forests, and combining the two heuristics yields
    an even greater improvement. Alone, union by rank yields a running time of *O*(*m*
    lg *n*) for a sequence of *m* operations, *n* of which are MAKE-SET (see Exercise
    19.4-4), and this bound is tight (see Exercise 19.3-3). Although we won’t prove
    it here, for a sequence of *n* MAKE-SET operations (and hence at most *n* − 1
    UNION operations) and *f* FIND-SET operations, the worst-case running time using
    only the path-compression heuristic is Θ(*n* + *f* · (1 + log[2+*f*/*n*]*n*)).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 单独使用按秩合并或路径压缩都可以改善不相交集森林上的操作运行时间，而将这两种启发式方法结合起来会带来更大的改进。单独使用按秩合并，对于一系列*m*个操作，其中*n*个是MAKE-SET操作（参见练习19.4-4），其运行时间为*O*(*m*
    lg *n*)，这个界限是紧的（参见练习19.3-3）。虽然我们在这里不会证明，但对于*n*个MAKE-SET操作序列（因此最多*n*−1个UNION操作）和*f*个FIND-SET操作，��使用路径压缩启发式方法的最坏情况运行时间是Θ(*n*
    + *f* · (1 + log[2+*f*/*n*]*n*)。
- en: Combining union by rank and path compression gives a worst-case running time
    of *O*(*m α*(*n*)), where *α*(*n*) is a *very* slowly growing function, defined
    in [Section 19.4](chapter019.xhtml#Sec_19.4). In any conceivable application of
    a disjoint-set data structure, *α*(*n*) ≤ 4, and thus, its running time is as
    good as linear in *m* for all practical purposes. Mathematically speaking, however,
    it is superlinear. [Section 19.4](chapter019.xhtml#Sec_19.4) proves this *O*(*mα*(*n*))
    upper bound.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 将按秩合并和路径压缩结合起来，得到最坏情况下的运行时间为*O*(*m α*(*n*))，其中*α*(*n*)是一个增长非常缓慢的函数，在[第19.4节](chapter019.xhtml#Sec_19.4)中定义。在任何可能的不相交集数据结构应用中，*α*(*n*)
    ≤ 4，因此，对于所有实际目的而言，其运行时间与*m*线性一样好。但从数学上讲，它是超线性的。[第19.4节](chapter019.xhtml#Sec_19.4)证明了这个*O*(*mα*(*n*))的上界。
- en: '**Exercises**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***19.3-1***'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.3-1***'
- en: Redo Exercise 19.2-2 using a disjoint-set forest with union by rank and path
    compression. Show the resulting forest with each node including its *x[i]* and
    rank.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 使用按秩合并和路径压缩的不相交集森林重新做练习19.2-2。展示每个节点的*x[i]*和秩的结果森林。
- en: '***19.3-2***'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.3-2***'
- en: Write a nonrecursive version of FIND-SET with path compression.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个具有路径压缩的FIND-SET的非递归版本。
- en: '***19.3-3***'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.3-3***'
- en: Give a sequence of *m* MAKE-SET, UNION, and FIND-SET operations, *n* of which
    are MAKE-SET operations, that takes Ω(*m* lg *n*) time when using only union by
    rank and not path compression.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个包含*m*个MAKE-SET、UNION和FIND-SET操作序列，其中*n*个是MAKE-SET操作，当仅使用按秩合并而不使用路径压缩时，需要Ω(*m*
    lg *n*)时间。
- en: '***19.3-4***'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.3-4***'
- en: Consider the operation PRINT-SET(*x*), which is given a node *x* and prints
    all the members of *x*’s set, in any order. Show how to add just a single attribute
    to each node in a disjoint-set forest so that PRINT-SET(*x*) takes time linear
    in the number of members of *x*’s set and the asymptotic running times of the
    other operations are unchanged. Assume that you can print each member of the set
    in *O*(1) time.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑操作 PRINT-SET(*x*)，给定一个节点*x*并按任意顺序打印*x*集合的所有成员。展示如何向不相交集森林中的每个节点添加一个属性，以便PRINT-SET(*x*)的时间与*x*集合的成员数量线性，而其他操作的渐近运行时间保持不变。假设您可以在*O*(1)时间内打印集合的每个成员。
- en: ★ ***19.3-5***
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***19.3-5***
- en: Show that any sequence of *m* MAKE-SET, FIND-SET, and LINK operations, where
    all the LINK operations appear before any of the FIND-SET operations, takes only
    *O*(*m*) time when using both path compression and union by rank. You may assume
    that the arguments to LINK are roots within the disjoint-set forest. What happens
    in the same situation when using only path compression and not union by rank?
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 证明任何一系列的*m*个MAKE-SET、FIND-SET和LINK操作，其中所有的LINK操作出现在任何FIND-SET操作之前，当使用路径压缩和秩并查集时，仅需要*O*(*m*)的时间。您可以假设LINK的参数是不相交集合森林中的根。当仅使用路径压缩而不使用秩并查集时，在相同情况下会发生什么？
- en: '[★ **19.4 Analysis of union by rank with path compression**](toc.xhtml#Rh1-114)'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[★ **19.4 带路径压缩的秩的并查集分析**](toc.xhtml#Rh1-114)'
- en: As noted in [Section 19.3](chapter019.xhtml#Sec_19.3), the combined union-by-rank
    and path-compression heuristic runs in *O*(*m α*(*n*)) time for *m* disjoint-set
    operations on *n* elements. In this section, we’ll explore the function *α* to
    see just how slowly it grows. Then we’ll analyze the running time using the potential
    method of amortized analysis.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第19.3节](chapter019.xhtml#Sec_19.3)中所指出的，联合使用秩和路径压缩启发式方法在*n*个元素上进行*m*个不相交集合操作的时间复杂度为*O*(*m
    α*(*n*))。在本节中，我们将探讨函数*α*的增长速度。然后，我们将使用摊销分析的潜在方法分析运行时间。
- en: '**A very quickly growing function and its very slowly growing inverse**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个增长非常快的函数及其增长非常缓慢的逆函数**'
- en: For integers *j*, *k* ≥ 0, we define the function *A[k]*(*j*) as
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 对于整数*j*，*k* ≥ 0，我们定义函数*A[k]*(*j*)为
- en: '![art](images/Art_P563.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P563.jpg)'
- en: where the expression ![art](images/Art_P564.jpg) uses the functional-iteration
    notation defined in equation (3.30) on page 68\. Specifically, equation (3.30)
    gives ![art](images/Art_P565.jpg) and ![art](images/Art_P566.jpg) for *i* ≥ 1\.
    We call the parameter *k* the ***level*** of the function *A*.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 式中的表达式 ![art](images/Art_P564.jpg) 使用了第68页方程（3.30）中定义的函数迭代符号。具体来说，方程（3.30）给出了
    *i* ≥ 1 时的 ![art](images/Art_P565.jpg) 和 ![art](images/Art_P566.jpg)。我们将参数*k*称为函数*A*的***级别***。
- en: The function *A[k]*(*j*) strictly increases with both *j* and *k*. To see just
    how quickly this function grows, we first obtain closed-form expressions for *A*[1](*j*)
    and *A*[2](*j*).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 函数*A[k]*(*j*)随着*j*和*k*严格增加。为了了解这个函数增长的速度，我们首先得到了* A*[1](*j*) 和 *A*[2](*j*) 的闭合形式表达式。
- en: '***Lemma 19.2***'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 19.2***'
- en: For any integer *j* ≥ 1, we have *A*[1](*j*) = 2*j* + 1.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何整数*j* ≥ 1，我们有 *A*[1](*j*) = 2*j* + 1。
- en: '***Proof***   We first use induction on *i* to show that ![art](images/Art_P567.jpg).
    For the base case, ![art](images/Art_P568.jpg). For the inductive step, assume
    that ![art](images/Art_P569.jpg). Then ![art](images/Art_P570.jpg). Finally, we
    note that ![art](images/Art_P571.jpg).'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   我们首先对*i*使用归纳法证明 ![art](images/Art_P567.jpg)。对于基本情况，我们有 ![art](images/Art_P568.jpg)。对于归纳步骤，假设
    ![art](images/Art_P569.jpg)。那么 ![art](images/Art_P570.jpg)。最后，我们注意到 ![art](images/Art_P571.jpg)。'
- en: ▪
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Lemma 19.3***'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 19.3***'
- en: For any integer *j* ≥ 1, we have *A*[2] (*j*) = 2^(*j*+1)(*j* + 1) − 1.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何整数*j* ≥ 1，我们有 *A*[2] (*j*) = 2^(*j*+1)(*j* + 1) − 1。
- en: '***Proof***   We first use induction on *i* to show that ![art](images/Art_P572.jpg).
    For the base case, we have ![art](images/Art_P573.jpg). For the inductive step,
    assume that ![art](images/Art_P574.jpg). Then ![art](images/Art_P575.jpg). Finally,
    we note that ![art](images/Art_P576.jpg).'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   我们首先对*i*使用归纳法证明 ![art](images/Art_P572.jpg)。对于基本情况，我们有 ![art](images/Art_P573.jpg)。对于归纳步骤，假设
    ![art](images/Art_P574.jpg)。那么 ![art](images/Art_P575.jpg)。最后，我们注意到 ![art](images/Art_P576.jpg)。'
- en: Now we can see how quickly *A[k]*(*j*) grows by simply examining *A[k]*(1) for
    levels *k* = 0, 1, 2, 3, 4\. From the definition of *A*[0](*j*) and the above
    lemmas, we have *A*[0](1) = 1 + 1 = 2, *A*[1](1) = 2 *·* 1 + 1 = 3, and *A*[2](1)
    = 2^(1+1) · (1 + 1) − 1 = 7\. We also have
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过简单地检查* A[k]*(*j*) 在级别*k* = 0, 1, 2, 3, 4时的值来看出它增长的速度。根据*A*[0](*j*)的定义和上述引理，我们有
    *A*[0](1) = 1 + 1 = 2, *A*[1](1) = 2 *·* 1 + 1 = 3, 和 *A*[2](1) = 2^(1+1) · (1
    + 1) − 1 = 7。我们还有
- en: '| *A*[3](1) | = | ![art](images/Art_P577.jpg) |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| *A*[3](1) | = | ![art](images/Art_P577.jpg) |'
- en: '|  | = | *A*[2](*A*[2](1)) |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *A*[2](*A*[2](1)) |'
- en: '|  | = | *A*[2](7) |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *A*[2](7) |'
- en: '|  | = | 2⁸ · 8 − 1 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 2⁸ · 8 − 1 |'
- en: '|  | = | 2^(11) − 1 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 2^(11) − 1 |'
- en: '|  | = | 2047 |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 2047 |'
- en: and
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '| *A*[4](1) | = | ![art](images/Art_P578.jpg) |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| *A*[4](1) | = | ![art](images/Art_P578.jpg) |'
- en: '|  | = | *A*[3](*A*[3](1)) |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *A*[3](*A*[3](1)) |'
- en: '|  | = | *A*[3](2047) |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *A*[3](2047) |'
- en: '|  | = | ![art](images/Art_P579.jpg) |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '|  | = | ![art](images/Art_P579.jpg) |'
- en: '|  | ≫ | *A*[2](2047) |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '|  | ≫ | *A*[2](2047) |'
- en: '|  | = | 2^(2048) · 2048 − 1 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 2^(2048) · 2048 − 1 |'
- en: '|  | = | 2^(2059) − 1 |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 2^(2059) − 1 |'
- en: '|  | > | 2^(2056) |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|  | > | 2^(2056) |'
- en: '|  | = | (2⁴)^(514) |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|  | = | (2⁴)^(514) |'
- en: '|  | = | 16^(514) |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 16^(514) |'
- en: '|  | ≫ | 10^(80), |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|  | ≫ | 10^(80), |'
- en: which is the estimated number of atoms in the observable universe. (The symbol
    “≫” denotes the “much-greater-than” relation.)
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这是可观测宇宙中估计的原子数量。（符号“≫”表示“远大于”关系。）
- en: We define the inverse of the function *A[k]*(*n*), for integer *n* ≥ 0, by
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义整数*n* ≥ 0时函数*A[k]*(*n*)的逆函数为
- en: '![art](images/Art_P580.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P580.jpg)'
- en: In words, *α*(*n*) is the lowest level *k* for which *A[k]*(1) is at least *n*.
    From the above values of *A[k]*(1), we see that
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*α*(*n*) 是*A[k]*(1) 至少为*n*的最低级别*k*。从上述值*A[k]*(1) 可以看出
- en: '![art](images/Art_P581.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P581.jpg)'
- en: It is only for values of *n* so large that the term “astronomical” understates
    them (greater than *A*[4](1), a huge number) that *α*(*n*) > 4, and so *α*(*n*)
    ≤ 4 for all practical purposes.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当*n*的值非常大，以至于术语“天文数字”都无法描述它们（大于*A*[4](1)，一个巨大的数字）时，*α*(*n*) > 4，因此对于所有实际目的，*α*(*n*)
    ≤ 4。
- en: '**Properties of ranks**'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**秩的性质**'
- en: In the remainder of this section, we prove an *O*(*mα*(*n*)) bound on the running
    time of the disjoint-set operations with union by rank and path compression. In
    order to prove this bound, we first prove some simple properties of ranks.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节的其余部分，我们证明了使用秩和路径压缩的不相交集合操作的运行时间具有*O*(*mα*(*n*))的上界。为了证明这个上界，我们首先证明了秩的一些简单性质。
- en: '***Lemma 19.4***'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 19.4***'
- en: For all nodes *x*, we have *x*.*rank* ≤ *x*.*p*.*rank*, with strict inequality
    if *x* ≠ *x*.*p* (*x* is not a root). The value of *x*.*rank* is initially 0,
    increases through time until *x* ≠ *x*.*p*, and from then on, *x*.*rank* does
    not change. The value of *x*.*p*.*rank* monotonically increases over time.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有节点* x *，我们有* x *.*rank* ≤ * x *.*p *.*rank*，如果* x * ≠ * x *.*p *（* x *不是根节点），则严格不等式成立。*
    x *.*rank*的值最初为0，随着时间的推移逐渐增加，直到* x * ≠ * x *.*p *，从那时起，* x *.*rank*不再改变。* x *.*p
    *.*rank*的值随时间单调增加。
- en: '***Proof***   The proof is a straightforward induction on the number of operations,
    using the implementations of MAKE-SET, UNION, and FIND-SET that appear on page
    530, and is left as Exercise 19.4-1.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 证明是对操作次数进行简单的归纳，使用出现在第530页上的MAKE-SET，UNION和FIND-SET的实现，并留作练习19.4-1。'
- en: ▪
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Corollary 19.5***'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论19.5***'
- en: On the simple path from any node going up toward a root, node ranks strictly
    increase.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从任何向根节点上升的简单路径上，节点的秩严格增加。
- en: ▪
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Lemma 19.6***'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理19.6***'
- en: Every node has rank at most *n* − 1.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 每个节点的秩最多为* n * − 1。
- en: '***Proof***   Each node’s rank starts at 0, and it increases only upon LINK
    operations. Because there are at most *n* − 1 UNION operations, there are also
    at most *n* − 1 LINK operations. Because each LINK operation either leaves all
    ranks alone or increases some node’s rank by 1, all ranks are at most *n* − 1.'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 每个节点的秩从0开始，仅在LINK操作时增加。因为最多有* n * − 1个UNION操作，所以也最多有* n * − 1个LINK操作。因为每个LINK操作要么保持所有秩不变，要么将某个节点的秩增加1，所以所有秩最多为*
    n * − 1。'
- en: ▪
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Lemma 19.6 provides a weak bound on ranks. In fact, every node has rank at most
    ⌊lg *n*⌋ (see Exercise 19.4-2). The looser bound of Lemma 19.6 suffices for our
    purposes, however.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 引理19.6提供了对秩的弱界限。实际上，每个节点的秩最多为⌊lg * n *⌋（参见练习19.4-2）。然而，引理19.6的较松界限对我们的目的足够了。
- en: '**Proving the time bound**'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '**证明时间界**'
- en: In order to prove the *O*(*mα*(*n*)) time bound, we’ll use the potential method
    of amortized analysis from [Section 16.3](chapter016.xhtml#Sec_16.3). In performing
    the amortized analysis, it will be convenient to assume that we invoke the LINK
    operation rather than the UNION operation. That is, since the parameters of the
    LINK procedure are pointers to two roots, we act as though we perform the appropriate
    FIND-SET operations separately. The following lemma shows that even if we count
    the extra FIND-SET operations induced by UNION calls, the asymptotic running time
    remains unchanged.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明* O *（* mα *（* n *））时间界，我们将使用摊还分析的潜在方法，从[第16.3节](chapter016.xhtml#Sec_16.3)中。在进行摊还分析时，假设我们调用LINK操作而不是UNION操作将很方便。也就是说，由于LINK过程的参数是指向两个根节点的指针，我们假设分别执行适当的FIND-SET操作。以下引理表明，即使计算由UNION调用引起的额外FIND-SET操作，渐近运行时间也保持不变。
- en: '***Lemma 19.7***'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理19.7***'
- en: Suppose that we convert a sequence *S*′ of *m*′ MAKE-SET, UNION, and FIND-SET
    operations into a sequence *S* of *m* MAKE-SET, LINK, and FIND-SET operations
    by turning each UNION into two FIND-SET operations followed by one LINK. Then,
    if sequence *S* runs in *O*(*mα*(*n*)) time, sequence *S*′ runs in *O*(*m*′ *α*(*n*))
    time.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们通过将* m *′个MAKE-SET，UNION和FIND-SET操作的序列*S*′转换为* m *个MAKE-SET，LINK和FIND-SET操作的序列*S*，将每个UNION转换为两个FIND-SET操作，然后是一个LINK操作。那么，如果序列*S*运行在*
    O *（* mα *（* n *））时间内，序列*S*′运行在* O *（* m *′ * α *（* n *））时间内。
- en: '***Proof***   Since each UNION operation in sequence *S*′ is converted into
    three operations in *S*, we have *m*′ ≤ *m* ≤ 3*m*′, so that *m* = Θ(*m*′), Thus,
    an *O*(*m α*(*n*)) time bound for the converted sequence *S* implies an *O*(*m*′
    *α*(*n*)) time bound for the original sequence *S*′.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 由于序列*S*′中的每个UNION操作在*S*中转换为三个操作，所以我们有* m *′ ≤ * m * ≤ 3* m *′，因此*
    m * = Θ（* m *′），因此，对于转换后的序列*S*的* O *（* m α *（* n *））时间界意味着原始序列*S*′的* O *（* m *′
    * α *（* n *））时间界。'
- en: ▪
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: From now on, we assume that the initial sequence of *m*′ MAKE-SET, UNION, and
    FIND-SET operations has been converted to a sequence of *m* MAKE-SET, LINK, and
    FIND-SET operations. We now prove an *O*(*m α*(*n*)) time bound for the converted
    sequence and appeal to Lemma 19.7 to prove the *O*(*m*′ *α*(*n*)) running time
    of the original sequence of *m*′ operations.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们假设* m *′个MAKE-SET，UNION和FIND-SET操作的初始序列已经转换为* m *个MAKE-SET，LINK和FIND-SET操作的序列。我们现在证明转换后的序列具有*
    O *（* m α *（* n *））时间界，并引用引理19.7证明原始* m *′操作序列的* O *（* m *′ * α *（* n *））运行时间。
- en: '**Potential function**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**潜在函数**'
- en: 'The potential function we use assigns a potential *ϕ*[*q*](*x*) to each node
    *x* in the disjoint-set forest after *q* operations. For the potential Φ*[q]*
    of the entire forest after *q* operations, sum the individual node potentials:
    ![art](images/Art_P582.jpg). Because the forest is empty before the first operation,
    the sum is taken over an empty set, and so Φ[0] = 0\. No potential Φ*[q]* is ever
    negative.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用的潜在函数为每个节点* x *在经过*q*次操作后的不相交集合森林中分配一个潜在值*ϕ*[* q *]（* x *）。对于经过*q*次操作后整个森林的潜在值Φ*[q]*，将各个节点的潜在值求和：![艺术](images/Art_P582.jpg)。因为在第一次操作之前森林是空的，所以总和是在一个空集合上进行的，因此Φ[0]
    = 0。没有潜在值Φ*[q]*是负的。
- en: The value of *ϕ[q]*(*x*) depends on whether *x* is a tree root after the *q*th
    operation. If it is, or if *x*.*rank* = 0, then *ϕ[q]*(*x*) = *α*(*n*) · *x*.*rank*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '*ϕ[q]*（* x *）的值取决于第*q*次操作后* x *是否为树根。如果是，或者* x *.*rank* = 0，则*ϕ[q]*（* x *）=
    *α*（* n *）·* x *.*rank*。'
- en: Now suppose that after the *q*th operation, *x* is not a root and that *x*.*rank*
    ≥ 1\. We need to define two auxiliary functions on *x* before we can define *ϕ[q]*(*x*).
    First we define
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设在第*q*次操作之后，* x *不是根节点且* x *.*rank* ≥ 1。我们需要在定义*ϕ[q]*（* x *）之前为* x *定义两个辅助函数。首先我们定义
- en: '![art](images/Art_P583.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P583.jpg)'
- en: That is, level(*x*) is the greatest level *k* for which *A[k]*, applied to *x*’s
    rank, is no greater than *x*’s parent’s rank.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，level（* x *）是最大的级别*k*，对于该级别，* A [k]*应用于* x *的秩，不大于* x *的父节点的秩。
- en: We claim that
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声称
- en: '![art](images/Art_P584.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P584.jpg)'
- en: which we see as follows. We have
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如下所示。我们有
- en: '| *x*.*p*.*rank* | ≥ | *x*.*rank* + 1 | (by Lemma 19.4 because *x* is not a
    root) |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| *x*.*p*.*rank* | ≥ | *x*.*rank* + 1 |（根据引理19.4，因为*x*不是根节点）'
- en: '|  | = | *A*[0](*x*.*rank*) | (by the definition (19.1) of *A*[0](*j*)), |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *A*[0]（* x *.*rank*） |（根据*A*[0]（* j *）的定义（19.1）），'
- en: which implies that level(*x*) ≥ 0, and
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着level(*x*) ≥ 0，并且
- en: '| *A*[*α*(*n*)](*x*.*rank*) | ≥ | *A*[*α*(*n*)](1) | (because *A[k]*(*j*) is
    strictly increasing) |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| *A*[*α*(*n*)](*x*.*rank*) | ≥ | *A*[*α*(*n*)](1) |（因为*A[k]*(*j*)是严格增加的）|'
- en: '|  | ≥ | *n* | (by the definition (19.2) of *α*(*n*)) |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|  | ≥ | *n* |（根据*α*(*n*)的定义(19.2)），|'
- en: '|  | > | *x*.*p*.*rank* | (by Lemma 19.6), |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '|  | > | *x*.*p*.*rank* | (根据引理 19.6)，|'
- en: which implies that level(*x*) < *α*(*n*).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着级别(*x*) < *α*(*n*)。
- en: For a given nonroot node *x*, the value of level(*x*) monotonically increases
    over time. Why? Because *x* is not a root, its rank does not change. The rank
    of *x*.*p* monotonically increases over time, since if *x*.*p* is not a root then
    its rank does not change, and if *x*.*p* is a root then its rank can never decrease.
    Thus, the difference between *x*.*rank* and *x*.*p*.*rank* monotonically increases
    over time. Therefore, the value of *k* needed for *A[k]*(*x*.*rank*) to overtake
    *x*.*p*.*rank* monotonically increases over time as well.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的非根节点*x*，level(*x*)的值随时间单调递增。为什么？因为*x*不是根节点，其等级不会改变。*x*.*p*的等级随时间单调递增，因为如果*x*.*p*不是根节点，则其等级不会改变，如果*x*.*p*是根节点，则其等级永远不会减少。因此，*x*.*rank*和*x*.*p*.*rank*之间的差异随时间单调递增。因此，为了使*A[k]*(*x*.*rank*)超过*x*.*p*.*rank*所需的*k*值也会随时间单调递增。
- en: 'The second auxiliary function applies when *x*.*rank* ≥ 1: iter(*x*) = max'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个辅助函数适用于*x*.*rank* ≥ 1：iter(*x*) = max
- en: '![art](images/Art_P585.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P585.jpg)'
- en: That is, iter(*x*) is the largest number of times we can iteratively apply *A*[level(*x*)],
    applied initially to *x*’s rank, before exceeding *x*’s parent’s rank.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，iter(*x*)是我们可以在超过*x*的父节点的等级之前，最多可以迭代应用*A*[level(*x*)]的次数。
- en: We claim that when *x*.*rank* ≥ 1, we have
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声称当*x*.*rank* ≥ 1时，我们有
- en: '![art](images/Art_P586.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P586.jpg)'
- en: which we see as follows. We have
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样看。我们有
- en: '| *x*.*p*.*rank* | ≥ | *A*[level(*x*)](*x*.*rank*) | (by the definition (19.3)
    of level(*x*)) |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| *x*.*p*.*rank* | ≥ | *A*[level(*x*)](*x*.*rank*) |（根据level(*x*)的定义(19.3)）|'
- en: '|  | = | ![art](images/Art_P587.jpg) | (by the definition (3.30) of functional
    iteration), |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '|  | = | ![art](images/Art_P587.jpg) |（根据函数迭代的定义(3.30)），|'
- en: which implies that iter(*x*) ≥ 1\. We also have
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着iter(*x*) ≥ 1。我们还有
- en: '| ![art](images/Art_P588.jpg) | = | *A*[level(*x*)+1](*x*.*rank*) | (by the
    definition (19.1) of *A[k]*(*j*)) |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| ![art](images/Art_P588.jpg) | = | *A*[level(*x*)+1](*x*.*rank*)（根据*A[k]*(*j*)的定义(19.1)）|'
- en: '|  | > | *x*.*p*.*rank* | (by the definition (19.3) of level(*x*)), |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '|  | > | *x*.*p*.*rank* |（根据level(*x*)的定义(19.3)），|'
- en: which implies that iter(*x*) ≤ *x*.*rank*. Note that because *x*.*p*.*rank*
    monotonically increases over time, in order for iter(*x*) to decrease, level(*x*)
    must increase. As long as level(*x*) remains unchanged, iter(*x*) must either
    increase or remain unchanged.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着iter(*x*) ≤ *x*.*rank*。请注意，因为*x*.*p*.*rank*随时间单调递增，为了使iter(*x*)减少，level(*x*)必须增加。只要level(*x*)保持不变，iter(*x*)要么增加要么保持不变。
- en: 'With these auxiliary functions in place, we are ready to define the potential
    of node *x* after *q* operations:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些辅助函数，我们就可以定义节点*x*在*q*次操作后的潜力：
- en: '![art](images/Art_P589.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P589.jpg)'
- en: We next investigate some useful properties of node potentials.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来研究节点潜力的一些有用性质。
- en: '***Lemma 19.8***'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 19.8***'
- en: For every node *x*, and for all operation counts *q*, we have
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个节点*x*，以及所有操作次数*q*，我们有
- en: 0 ≤ *ϕ[q]*(*x*) ≤ *α*(*n*) · *x*.*rank*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 0 ≤ *ϕ[q]*(*x*) ≤ *α*(*n*) · *x*.*rank*。
- en: '***Proof***   If *x* is a root or *x*.*rank* = 0, then *ϕ[q]*(*x*) = *α*(*n*)
    · *x*.*rank* by definition. Now suppose that *x* is not a root and that *x*.*rank*
    ≥ 1\. We can obtain a lower bound on *ϕ[q]*(*x*) by maximizing level(*x*) and
    iter(*x*). The bounds (19.4) and (19.6) give *α*(*n*) − level(*x*) ≥ 1 and iter(*x*)
    ≤ *x*.*rank*. Thus, we have'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 如果*x*是根节点或*x*.*rank* = 0，则根据定义，*ϕ[q]*(*x*) = *α*(*n*) · *x*.*rank*。现在假设*x*不是根节点且*x*.*rank*
    ≥ 1。我们可以通过最大化level(*x*)和iter(*x*)来获得*ϕ[q]*(*x*)的下界。不等式(19.4)和(19.6)给出了*α*(*n*)
    − level(*x*) ≥ 1和iter(*x*) ≤ *x*.*rank*。因此，我们有'
- en: '| *ϕ[q]*(*x*) | = | (*α*(*n*) − level(*x*)) · *x*.*rank* − iter(*x*) |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '| *ϕ[q]*(*x*) | = | (*α*(*n*) − level(*x*)) · *x*.*rank* − iter(*x*) |'
- en: '|  | ≥ | *x*.*rank* − *x*.*rank* |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|  | ≥ | *x*.*rank* − *x*.*rank* |'
- en: '|  | = | 0. |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 0。|'
- en: Similarly, minimizing level(*x*) and iter(*x*) provides an upper bound on *ϕ[q]*(*x*).
    By the bound (19.4), level(*x*) ≥ 0, and by the bound (19.6), iter(*x*) ≥ 1\.
    Thus, we have
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，最小化level(*x*)和iter(*x*)提供了*ϕ[q]*(*x*)的上界。根据不等式(19.4)，level(*x*) ≥ 0，根据不等式(19.6)，iter(*x*)
    ≥ 1。因此，我们有
- en: '| *ϕ[q]*(*x*) | ≤ | (*α*(*n*) − 0) · *x*.*rank* − 1 |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| *ϕ[q]*(*x*) | ≤ | (*α*(*n*) − 0) · *x*.*rank* − 1 |'
- en: '|  | = | *α*(*n*) · *x*.*rank* − 1 |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *α*(*n*) · *x*.*rank* − 1 |'
- en: '|  | < | *α*(*n*) · *x*.*rank*. |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|  | < | *α*(*n*) · *x*.*rank*。|'
- en: ▪
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Corollary 19.9***'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论 19.9***'
- en: If node *x* is not a root and *x*.*rank >* 0, then *ϕ[q]*(*x*) < *α*(*n*) ·
    *x*.*rank*.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点*x*不是根节点且*x*.*rank >* 0，则*ϕ[q]*(*x*) < *α*(*n*) · *x*.*rank*。
- en: '**Potential changes and amortized costs of operations**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**潜力变化和操作的摊销成本**'
- en: We are now ready to examine how the disjoint-set operations affect node potentials.
    Once we understand how each operation can change the potential, we can determine
    the amortized costs.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备研究不相交集操作如何影响节点���力。一旦我们了解每个操作如何改变潜力，我们就可以确定摊销成本。
- en: '***Lemma 19.10***'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 19.10***'
- en: Let *x* be a node that is not a root, and suppose that the *q*th operation is
    either a LINK or a FIND-SET. Then after the *q*th operation, *ϕ[q]*(*x*) ≤ *ϕ*[*q*−1](*x*).
    Moreover, if *x*.*rank* ≥ 1 and either level(*x*) or iter(*x*) changes due to
    the *q*th operation, then *ϕ[q]*(*x*) ≤ *ϕ*[*q*−1](*x*) − 1\. That is, *x*’s potential
    cannot increase, and if it has positive rank and either level(*x*) or iter(*x*)
    changes, then *x*’s potential drops by at least 1.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 假设*x*是一个非根节点，并且假设*q*次操作是LINK或FIND-SET。那么在*q*次操作后，*ϕ[q]*(*x*) ≤ *ϕ*[*q*−1](*x*)。此外，如果*x*.*rank*
    ≥ 1并且由于*q*次操作而level(*x*)或iter(*x*)发生变化，则*ϕ[q]*(*x*) ≤ *ϕ*[*q*−1](*x*) − 1。也就是说，*x*的潜力不会增加，如果它具有正等级并且level(*x*)或iter(*x*)发生变化，则*x*的潜力至少下降1。
- en: '***Proof***   Because *x* is not a root, the *q*th operation does not change
    *x*.*rank*, and because *n* does not change after the initial *n* MAKE-SET operations,
    *α*(*n*) remains unchanged as well. Hence, these components of the formula for
    *x*’s potential remain the same after the *q*th operation. If *x*.*rank* = 0,
    then *ϕ*[*q*](*x*) = *ϕ*[*q*−1](*x*) = 0.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 因为*x*不是根节点，第*q*次操作不会改变*x*.*rank*，并且在初始的*n*个MAKE-SET操作之后，*n*不会改变，*α*(*n*)也不会改变。因此，在第*q*次操作之后，*x*的潜力公式中这些部分保持不变。如果*x*.*rank*
    = 0，则*ϕ*[*q*](*x*) = *ϕ*[*q*−1](*x*) = 0。'
- en: Now assume that *x*.*rank* ≥ 1\. Recall that level(*x*) monotonically increases
    over time. If the *q*th operation leaves level(*x*) unchanged, then iter(*x*)
    either increases or remains unchanged. If both level(*x*) and iter(*x*) are unchanged,
    then *ϕ*[*q*](*x*) = *ϕ*[*q*−1](*x*). If level(*x*) is unchanged and iter(*x*)
    increases, then it increases by at least 1, and so *ϕ*[*q*](*x*) ≤ *ϕ*[*q*−1](*x*)
    − 1.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设*x*.*rank* ≥ 1。回想一下，level(*x*)随时间单调递增。如果第*q*次操作使level(*x*)保持不变，则iter(*x*)要么增加要么保持不变。如果level(*x*)和iter(*x*)都保持不变，则*ϕ*[*q*](*x*)
    = *ϕ*[*q*−1](*x*)。��果level(*x*)保持不变且iter(*x*)增加，则增加至少1，因此*ϕ*[*q*](*x*) ≤ *ϕ*[*q*−1](*x*)
    − 1。
- en: Finally, if the *q*th operation increases level(*x*), it increases by at least
    1, so that the value of the term (*α*(*n*) − level(*x*)) · *x*.*rank* drops by
    at least *x*.*rank*. Because level(*x*) increased, the value of iter(*x*) might
    drop, but according to the bound (19.6), the drop is by at most *x*.*rank* − 1\.
    Thus, the increase in potential due to the change in iter(*x*) is less than the
    decrease in potential due to the change in level(*x*), yielding *ϕ*[*q*](*x*)
    ≤ *ϕ*[*q*−1](*x*) − 1.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如果第*q*次操作增加了级别(*x*)，那么至少增加1，因此术语(*α*(*n*) − level(*x*)) · *x*.*rank*的值至少下降*x*.*rank*。由于级别(*x*)增加了，iter(*x*)的值可能会下降，但根据不等式(19.6)，下降最多为*x*.*rank*
    − 1。因此，由于iter(*x*)的变化而导致的潜力增加小于由于级别(*x*)的变化而导致的潜力减少，得到*ϕ*[*q*](*x*) ≤ *ϕ*[*q*−1](*x*)
    − 1。
- en: ▪
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Our final three lemmas show that the amortized cost of each MAKE-SET, LINK,
    and FIND-SET operation is *O*(*α*(*n*)). Recall from equation (16.2) on page 456
    that the amortized cost of each operation is its actual cost plus the change in
    potential due to the operation.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后的三个引理表明每个MAKE-SET、LINK和FIND-SET操作的摊销成本为*O*(*α*(*n*)). 请回顾第456页上方程(16.2)中的内容，即每个操作的摊销成本等于其实际成本加上由操作引起的潜力变化。
- en: '***Lemma 19.11***'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 19.11***'
- en: The amortized cost of each MAKE-SET operation is *O*(1).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 每个MAKE-SET操作的摊销成本为*O*(1)。
- en: '***Proof***   Suppose that the *q*th operation is MAKE-SET(*x*). This operation
    creates node *x* with rank 0, so that *ϕ*[*q*](*x*) = 0\. No other ranks or potentials
    change, and so Φ*[q]* = Φ[*q*−1]. Noting that the actual cost of the MAKE-SET
    operation is *O*(1) completes the proof.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 假设第*q*次操作是MAKE-SET(*x*)。此操作创建具有等级0的节点*x*，因此*ϕ*[*q*](*x*) = 0。没有其他等级或潜力发生变化，因此Φ*[q]*
    = Φ[*q*−1]。注意MAKE-SET操作的实际成本��*O*(1)完成了证明。'
- en: ▪
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Lemma 19.12***'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 19.12***'
- en: The amortized cost of each LINK operation is *O*(*α*(*n*)).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 每个LINK操作的摊销成本为*O*(*α*(*n*)).
- en: '***Proof***   Suppose that the *q*th operation is LINK(*x*, *y*). The actual
    cost of the LINK operation is *O*(1). Without loss of generality, suppose that
    the LINK makes *y* the parent of *x*.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 假设第*q*次操作是LINK(*x*, *y*)。LINK操作的实际成本为*O*(1)。不失一般性地，假设LINK使*y*成为*x*的父节点。'
- en: 'To determine the change in potential due to the LINK, note that the only nodes
    whose potentials may change are *x*, *y*, and the children of *y* just prior to
    the operation. We’ll show that the only node whose potential can increase due
    to the LINK is *y*, and that its increase is at most *α*(*n*):'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定LINK导致的潜力变化，请注意，唯一可能发生潜力变化的节点是*x*、*y*和操作之前*y*的子节点。我们将展示，唯一可能由LINK导致潜力增加的节点是*y*，而且它的增加最多为*α*(*n*)：
- en: By Lemma 19.10, any node that is *y*’s child just before the LINK cannot have
    its potential increase due to the LINK.
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据引理19.10，LINK之前是*y*的子节点的任何节点都不会因LINK而潜力增加。
- en: From the definition (19.7) of *ϕ*[*q*](*x*), note that, since *x* was a root
    just before the *q*th operation, *ϕ*[*q*−1](*x*) = *α*(*n*) · *x*.*rank* at that
    time. If *x*.*rank* = 0, then *ϕ*[*q*](*x*) = *ϕ*[*q*−1](*x*) = 0\. Otherwise,
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 根据*ϕ*[*q*](*x*)的定义(19.7)，请注意，由于*x*在第*q*次操作之前是一个根节点，那时*ϕ*[*q*−1](*x*) = *α*(*n*)
    · *x*.*rank*。如果*x*.*rank* = 0，则*ϕ*[*q*](*x*) = *ϕ*[*q*−1](*x*) = 0。否则，
- en: '| *ϕ*[*q*](*x*) | < | *α*(*n*) · *x*.*rank* | (by Corollary 19.9) |'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| *ϕ*[*q*](*x*) | < | *α*(*n*) · *x*.*rank* | (根据推论19.9) |'
- en: '|  | = | *ϕ*[*q*−1](*x*), |  |'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | *ϕ*[*q*−1](*x*), |  |'
- en: and so *x*’s potential decreases.
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此*x*的潜力减少。
- en: Because *y* is a root prior to the LINK, *ϕ*[*q*−1](*y*) = *α*(*n*) · *y*.*rank*.
    After the LINK operation, *y* remains a root, so that *y*’s potential still equals
    *α*(*n*) times its rank after the operation. The LINK operation either leaves
    *y*’s rank alone or increases *y*’s rank by 1\. Therefore, either *ϕ*[*q*](*y*)
    = *ϕ*[*q*−1](*y*) or *ϕ*[*q*](*y*) = *ϕ*[*q*−1](*y*) + *α*(*n*).
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 因为LINK之前*y*是根节点，所以LINK操作之后，*y*仍然是根节点，因此*y*的潜力仍然等于操作后的等级乘以*α*(*n*)。LINK操作要么保持*y*的等级不变，要么将*y*的等级增加1。因此，要么*ϕ*[*q*](*y*)
    = *ϕ*[*q*−1](*y*)，要么*ϕ*[*q*](*y*) = *ϕ*[*q*−1](*y*) + *α*(*n*)。
- en: The increase in potential due to the LINK operation, therefore, is at most *α*(*n*).
    The amortized cost of the LINK operation is *O*(1) + *α*(*n*) = *O*(*α*(*n*)).
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，由于LINK操作而导致的潜力增加最多为*α*(*n*)。LINK操作的摊销成本为*O*(1) + *α*(*n*) = *O*(*α*(*n*)).
- en: ▪
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Lemma 19.13***'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 19.13***'
- en: The amortized cost of each FIND-SET operation is *O*(*α*(*n*)).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 每个FIND-SET操作的摊销成本为*O*(*α*(*n*)).
- en: '***Proof***   Suppose that the *q*th operation is a FIND-SET and that the find
    path contains *s* nodes. The actual cost of the FIND-SET operation is *O*(*s*).
    We will show that no node’s potential increases due to the FIND-SET and that at
    least max {0, *s* − (*α*(*n*) + 2)} nodes on the find path have their potential
    decrease by at least 1.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 假设第*q*次操作是FIND-SET，并且查找路径包含*s*个节点。FIND-SET操作的实际成本为*O*(*s*)。我们将展示，没有节点的潜力会因FIND-SET而增加，并且至少有max
    {0, *s* − (*α*(*n*) + 2)}个节点在查找路径上的潜力至少减少1。'
- en: We first show that no node’s potential increases. Lemma 19.10 takes care of
    all nodes other than the root. If *x* is the root, then its potential is *α*(*n*)
    · *x*.*rank*, which does not change due to the FIND-SET operation.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先展示没有节点的潜力会增加。引理19.10照顾了除根节点以外的所有节点。如果*x*是根节点，则其潜力为*α*(*n*) · *x*.*rank*，由于FIND-SET操作不会改变，因此不会改变。
- en: Now we show that at least max {0, *s* − (*α*(*n*) + 2)} nodes have their potential
    decrease by at least 1\. Let *x* be a node on the find path such that *x*.*rank
    >* 0 and *x* is followed somewhere on the find path by another node *y* that is
    not a root, where level(*y*) = level(*x*) just before the FIND-SET operation.
    (Node *y* need not *immediately* follow *x* on the find path.) All but at most
    *α*(*n*) + 2 nodes on the find path satisfy these constraints on *x*. Those that
    do not satisfy them are the first node on the find path (if it has rank 0), the
    last node on the path (i.e., the root), and the last node *w* on the path for
    which level(*w*) = *k*, for each *k* = 0, 1, 2, … , *α*(*n*)−1.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们展示至少max {0, *s* − (*α*(*n*) + 2)}个节点的潜力至少减少1。让*x*是查找路径上的一个节点，使得*x*.*rank
    >* 0，并且在FIND-SET操作之前，跟随在查找路径上的另一个非根节点*y*，其中level(*y*) = level(*x*)。 (节点*y*不一定*立即*跟在*x*后面的查找路径上。)
    查找路径上除了最多*α*(*n*) + 2个节点满足*x*的这些约束条件之外，其他节点都满足这些约束条件。不满足这些条件的节点是查找路径上的第一个节点(如果它的等级为0)，路径的最后一个节点(即根节点)，以及路径上的最后一个节点*w*，其中level(*w*)
    = *k*，对于每个*k* = 0, 1, 2, … , *α*(*n*)−1。
- en: Consider such a node *x*. It has positive rank and is followed somewhere on
    the find path by nonroot node *y* such that level(*y*) = level(*x*) before the
    path compression occurs. We claim that the path compression decreases *x*’s potential
    by at least 1\. To prove this claim, let *k* = level(*x*) = level(*y*) and *i*
    = iter(*x*) before the path compression occurs. Just prior to the path compression
    caused by the FIND-SET, we have
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这样一个节点*x*。它具有正等级，并且在路径压缩发生之前的查找路径上的某个位置后跟非根节点*y*，使得level(*y*) = level(*x*)。我们声称路径压缩至少会使*x*的潜力减少1。为了证明这一点，让*k*
    = level(*x*) = level(*y*)，*i* = 路径压缩发生之前的iter(*x*)。就在由FIND-SET引起的路径压缩之前，我们有
- en: '| *x*.*p*.*rank* | ≥ | ![art](images/Art_P590.jpg) | (by the definition (19.5)
    of iter(*x*)), |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| *x*.*p*.*rank* | ≥ | ![艺术](images/Art_P590.jpg) | (根据iter(*x*)的定义(19.5))
    |'
- en: '| *y*.*p*.*rank* | ≥ | *A[k]*(*y*.*rank*) | (by the definition (19.3) of level(*y*)),
    |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| *y*.*p*.*rank* | ≥ | *A[k]*(*y*.*rank*) | (根据level(*y*)的定义(19.3)) |'
- en: '| *y*.*rank* | ≥ | *x*.*p*.*rank* | (by Corollary 19.5 and because *y* follows
    *x* on the find path). |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| *y*.*rank* | ≥ | *x*.*p*.*rank* | (根据推论19.5和因为*y*在查找路径上跟随*x*)。 |'
- en: Putting these inequalities together gives
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些不等式放在一起得到
- en: '| *y*.*p*.*rank* | ≥ | *A[k]*(*y*.*rank*) |  |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| *y*.*p*.*rank* | ≥ | *A[k]*(*y*.*rank*) |  |'
- en: '|  | ≥ | *A[k]*(*x*.*p*.*rank*) | (because *A[k]*(*j*) is strictly increasing)
    |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '|  | ≥ | *A[k]*(*x*.*p*.*rank*) | (因为*A[k]*(*j*)是严格递增的) |'
- en: '|  | ≥ | ![art](images/Art_P591.jpg) |  |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '|  | ≥ | ![艺术](images/Art_P591.jpg) |  |'
- en: '|  | = | ![art](images/Art_P592.jpg) | (by the definition (3.30) of functional
    iteration). |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '|  | = | ![艺术](images/Art_P592.jpg) | (根据函数迭代的定义(3.30))。 |'
- en: Because path compression makes *x* and *y* have the same parent, after path
    compression we have *x*.*p*.*rank* = *y*.*p*.*rank*. The parent of *y* might change
    due to the path compression, but if it does, the rank of *y*’s new parent compared
    with the rank of *y*’s parent before path compression is either the same or greater.
    Since *x*.*rank* does not change, ![art](images/Art_P593.jpg) after path compression.
    By the definition (19.5) of the iter function, the value of iter(*x*) increases
    from *i* to at least *i* + 1\. By Lemma 19.10, *ϕ*[*q*](*x*) ≤ *ϕ*[*q*−1](*x*)
    − 1, so that *x*’s potential decreases by at least 1.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 因为路径压缩使*x*和*y*有相同的父节��，所以在路径压缩后，我们有*x*.*p*.*rank* = *y*.*p*.*rank*。由于路径压缩可能会改变*y*的父节点，但如果改变了，*y*的新父节点的等级与路径压缩之前*y*的父节点的等级要么相同要么更高。由于*x*.*rank*不会改变，所以路径压缩后，![艺术](images/Art_P593.jpg)。根据iter函数的定义(19.5)，iter(*x*)的值从*i*增加到至少*i*
    + 1。根据引理19.10，*ϕ*[*q*](*x*) ≤ *ϕ*[*q*−1](*x*) − 1，因此*x*的潜力至少减少1。
- en: The amortized cost of the FIND-SET operation is the actual cost plus the change
    in potential. The actual cost is *O*(*s*), and we have shown that the total potential
    decreases by at least max {0, *s* − (*α*(*n*) + 2)}. The amortized cost, therefore,
    is at most *O*(*s*) − (*s* − (*α*(*n*) + 2)) = *O*(*s*) − *s* + *O*(*α*(*n*))
    = *O*(*α*(*n*)), since we can scale up the units of potential to dominate the
    constant hidden in *O*(*s*). (See Exercise 19.4-6.)
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: FIND-SET操作的摊销成本是实际成本加上潜在变化。实际成本是*O*(*s*)，我们已经证明总潜力至少减少max {0, *s* − (*α*(*n*)
    + 2)}。因此，摊销成本最多为*O*(*s*) − (*s* − (*α*(*n*) + 2)) = *O*(*s*) − *s* + *O*(*α*(*n*))
    = *O*(*α*(*n*))，因为我们可以扩大潜力单位来主导*O*(*s*)中隐藏的常数。 (参见练习19.4-6。)
- en: ▪
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Putting the preceding lemmas together yields the following theorem.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 将前述引理放在一起得到以下定理。
- en: '***Theorem 19.14***'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理19.14***'
- en: A sequence of *m* MAKE-SET, UNION, and FIND-SET operations, *n* of which are
    MAKE-SET operations, can be performed on a disjoint-set forest with union by rank
    and path compression in *O*(*m α*(*n*)) time.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 一系列*m*个MAKE-SET、UNION和FIND-SET操作可以在具有按秩合并和路径压缩的不相交集森林上以*O*(*m α*(*n*))的时间内完成，其中*n*个是MAKE-SET操作。
- en: '***Proof***   Immediate from Lemmas 19.7, 19.11, 19.12, and 19.13.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   根据引理19.7、19.11、19.12和19.13，立即可得。'
- en: ▪
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Exercises**'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***19.4-1***'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.4-1***'
- en: Prove Lemma 19.4.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 证明引理19.4。
- en: '***19.4-2***'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.4-2***'
- en: Prove that every node has rank at most ⌊lg *n*⌋.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 证明每个节点的等级最多为⌊lg *n*⌋。
- en: '***19.4-3***'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.4-3***'
- en: In light of Exercise 19.4-2, how many bits are necessary to store *x*.*rank*
    for each node *x*?
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 根据练习19.4-2，为了存储每个节点*x*的*x*.*rank*需要多少位？
- en: '***19.4-4***'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.4-4***'
- en: Using Exercise 19.4-2, give a simple proof that operations on a disjoint-set
    forest with union by rank but without path compression run in *O*(*m* lg *n*)
    time.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 利用练习19.4-2，简要证明具有按秩合并但没有路径压缩的不相交集森林上的操作在*O*(*m* lg *n*)时间内运行。
- en: '***19.4-5***'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.4-5***'
- en: Professor Dante reasons that because node ranks increase strictly along a simple
    path to the root, node levels must monotonically increase along the path. In other
    words, if *x*.*rank >* 0 and *x*.*p* is not a root, then level(*x*) ≤ level(*x*.*p*).
    Is the professor correct?
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 但丁教授推断，因为节点等级沿着到根的简单路径严格增加，所以节点级别必须沿着路径单调增加。换句话说，如果 *x*.*rank >* 0 并且 *x*.*p*
    不是根，�� level(*x*) ≤ level(*x*.*p*)。教授正确吗？
- en: '***19.4-6***'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '***19.4-6***'
- en: The proof of Lemma 19.13 ends with scaling the units of potential to dominate
    the constant hidden in the *O*(*s*) term. To be more precise in the proof, you
    need to change the definition (19.7) of the potential function to multiply each
    of the two cases by a constant, say *c*, that dominates the constant in the *O*(*s*)
    term. How must the rest of the analysis change to accommodate this updated potential
    function?
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 引理 19.13 的证明以扩大潜在单位来主导 *O*(*s*) 项中隐藏的常数结束。为了在证明中更加精确，你需要改变潜在函数（19.7）的定义，将两种情况分别乘以一个主导
    *O*(*s*) 项中的常数 *c*。分析的其余部分如何改变以适应这个更新后的潜在函数？
- en: ★ ***19.4-7***
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***19.4-7***
- en: 'Consider the function *α*′(*n*) = min {*k* : *A[k]*(1) ≥ lg(*n* + 1)}. Show
    that *α*′(*n*) ≤ 3 for all practical values of *n* and, using Exercise 19.4-2,
    show how to modify the potential-function argument to prove that performing a
    sequence of *m* MAKE-SET, UNION, and FIND-SET operations, *n* of which are MAKE-SET
    operations, on a disjoint-set forest with union by rank and path compression takes
    *O*(*mα*′(*n*)) time.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑函数 *α*′(*n*) = min {*k* : *A[k]*(1) ≥ lg(*n* + 1)}。证明对于所有实际值的 *n*，*α*′(*n*)
    ≤ 3，并使用练习 19.4-2，展示如何修改潜在函数论证来证明在具有按秩合并和路径压缩的不相交集森林上执行一系列 *m* 个 MAKE-SET、UNION
    和 FIND-SET 操作，其中 *n* 个是 MAKE-SET 操作，需要 *O*(*mα*′(*n*)) 的时间。'
- en: '**Problems**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '***19-1     Offline minimum***'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '***19-1     离线最小***'
- en: 'In the ***offline minimum problem***, you maintain a dynamic set *T* of elements
    from the domain {1, 2, … , *n*} under the operations INSERT and EXTRACT-MIN. The
    input is a sequence *S* of *n* INSERT and *m* EXTRACT-MIN calls, where each key
    in {1, 2, … , *n*} is inserted exactly once. Your goal is to determine which key
    is returned by each EXTRACT-MIN call. Specifically, you must fill in an array
    *extracted*[1: *m*], where for *i* = 1, 2, … , *m*, *extracted*[*i*] is the key
    returned by the *i*th EXTRACT-MIN call. The problem is “offline” in the sense
    that you are allowed to process the entire sequence *S* before determining any
    of the returned keys.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '在***离线最小问题***中，你在操作 INSERT 和 EXTRACT-MIN 下维护一个来自域 {1, 2, … , *n*} 的元素的动态集合
    *T*。输入是一个包含 *n* 个 INSERT 和 *m* 个 EXTRACT-MIN 调用的序列 *S*，其中 {1, 2, … , *n*} 中的每个键仅插入一次。你的目标是确定每个
    EXTRACT-MIN 调用返回哪个键。具体来说，你必须填写一个数组 *extracted*[1: *m*]，其中对于 *i* = 1, 2, … , *m*，*extracted*[*i*]
    是第 *i* 个 EXTRACT-MIN 调用返回的键。这个问题是“离线”的，意味着你可以在确定任何返回的键之前处理整个序列 *S*。'
- en: '***a.*** Consider the following instance of the offline minimum problem, in
    which each operation INSERT(*i*) is represented by the value of *i* and each EXTRACT-MIN
    is represented by the letter E:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 考虑离线最小问题的以下实例，其中每个操作 INSERT(*i*) 由 *i* 的值表示，每个 EXTRACT-MIN 由字母 E 表示：'
- en: 4, 8, E, 3, E, 9, 2, 6, E, E, E, 1, 7, E, 5.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 4, 8, E, 3, E, 9, 2, 6, E, E, E, 1, 7, E, 5.
- en: Fill in the correct values in the *extracted* array.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 填写 *extracted* 数组中的正确值。
- en: To develop an algorithm for this problem, break the sequence *S* into homogeneous
    subsequences. That is, represent *S* by
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 要为这个问题开发算法，将序列 *S* 分解为同质子序列。也就是说，用以下方式表示 *S*
- en: I[1], E, I[2], E, I[3], … , I*[m]*, E, I[*m*+1],
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: I[1], E, I[2], E, I[3], … , I*[m]*, E, I[*m*+1],
- en: where each E represents a single EXTRACT-MIN call and each I*[j]* represents
    a (possibly empty) sequence of INSERT calls. For each subsequence I*[j]*, initially
    place the keys inserted by these operations into a set *K[j]*, which is empty
    if I*[j]* is empty. Then execute the OFFLINE-MINIMUM procedure.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 E 代表一个单独的 EXTRACT-MIN 调用，每个 I*[j]* 代表一个（可能为空）的 INSERT 调用序列。对于每个子序列 I*[j]*，最初将这些操作插入的键放入一个集合
    *K[j]* 中，如果 I*[j]* 为空，则 *K[j]* 为空。然后执行 OFFLINE-MINIMUM 程序。
- en: OFFLINE-MINIMUM(*m*, *n*)
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: OFFLINE-MINIMUM(*m*, *n*)
- en: '| 1 | **for** *i* = 1 **to** *n* |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **对于** *i* = 1 **到** *n* |'
- en: '| 2 | determine *j* such that *i* ∈ *K[j]* |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 确定 *j*，使得 *i* ∈ *K[j]* |'
- en: '| 3 | **if** *j* ≠ *m* + 1 |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **如果** *j* ≠ *m* + 1 |'
- en: '| 4 | *extracted*[*j*] = *i* |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *extracted*[*j*] = *i* |'
- en: '| 5 | let *l* be the smallest value greater than *j* for which set *K[l]* exists
    |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 让 *l* 是大于 *j* 的最小值，使得集合 *K[l]* 存在 |'
- en: '| 6 | *K[l]* = *K[j]* ∪ *K[l]*, destroying *K[j]* |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| 6 | *K[l]* = *K[j]* ∪ *K[l]*，破坏 *K[j]* |'
- en: '| 7 | **return** *extracted* |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| 7 | **返回** *extracted* |'
- en: '***b.*** Argue that the array *extracted* returned by OFFLINE-MINIMUM is correct.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 论证 OFFLINE-MINIMUM 返回的数组 *extracted* 是正确的。'
- en: '***c.*** Describe how to implement OFFLINE-MINIMUM efficiently with a disjoint-set
    data structure. Give as tight a bound as you can on the worst-case running time
    of your implementation.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 描述如何使用不相交集数据结构高效实现 OFFLINE-MINIMUM。尽可能紧密地给出你的实现的最坏情况运行时间的上界。'
- en: '***19-2     Depth determination***'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '***19-2     深度确定***'
- en: 'In the ***depth-determination problem***, you maintain a forest ℱ = {*T[i]*}
    of rooted trees under three operations:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在***深度确定问题***中，你维护一个根树的森林 ℱ = {*T[i]*}，支持三种操作：
- en: MAKE-TREE(*v*) creates a tree whose only node is *v*.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: MAKE-TREE(*v*) 创建一个只有节点 *v* 的树。
- en: FIND-DEPTH(*v*) returns the depth of node *v* within its tree.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: FIND-DEPTH(*v*) 返回节点 *v* 在其树中的深度。
- en: GRAFT(*r*, *v*) makes node *r*, which is assumed to be the root of a tree, become
    the child of node *v*, which is assumed to be in a different tree from *r* but
    may or may not itself be a root.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: GRAFT(*r*, *v*) 使节点 *r*（假定为树的根）成为节点 *v* 的子节点，假定 *v* 位于与 *r* 不同的树中，但可能是或不是根节点。
- en: '***a.*** Suppose that you use a tree representation similar to a disjoint-set
    forest: *v*.*p* is the parent of node *v*, except that *v*.*p* = *v* if *v* is
    a root. Suppose further that you implement GRAFT(*r*, *v*) by setting *r*.*p*
    = *v* and FIND-DEPTH(*v*) by following the find path from *v* up to the root,
    returning a count of all nodes other than *v* encountered. Show that the worst-case
    running time of a sequence of *m* MAKE-TREE, FIND-DEPTH, and GRAFT operations
    is Θ(*m*²).'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 假设您使用类似于不相交集森林的树表示：*v*.*p* 是节点 *v* 的父节点，除非 *v* 是根节点。进一步假设您通过设置 *r*.*p*
    = *v* 来实现 GRAFT(*r*, *v*)，并通过从 *v* 开始沿着查找路径执行 FIND-DEPTH(*v*)，返回除 *v* 外遇到的所有节点的计数。证明一系列
    *m* 个 MAKE-TREE、FIND-DEPTH 和 GRAFT 操作的最坏情况运行时间为 Θ(*m*²)。'
- en: By using the union-by-rank and path-compression heuristics, you can reduce the
    worst-case running time. Use the disjoint-set forest S = {*S[i]*}, where each
    set *S[i]* (which is itself a tree) corresponds to a tree *T[i]* in the forest
    ℱ. The tree structure within a set *S[i]*, however, does not necessarily correspond
    to that of *T[i]*. In fact, the implementation of *S[i]* does not record the exact
    parent-child relationships but nevertheless allows you to determine any node’s
    depth in *T[i]*.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用秩和路径压缩启发式方法，您可以减少最坏情况的运行时间。使用不相交集森林 S = {*S[i]*}，其中每个集合 *S[i]*（它本身是一棵树）对应于森林
    ℱ 中的树 *T[i]*。然而，集合 *S[i]* 中的树结构不一定对应于 *T[i]* 的结构。实际上，*S[i]* 的实现并不记录确切的父子关系，但仍然允许您确定
    *T[i]* 中任何节点的深度。
- en: The key idea is to maintain in each node *v* a “pseudodistance” *v*.*d*, which
    is defined so that the sum of the pseudodistances along the simple path from *v*
    to the root of its set *S[i]* equals the depth of *v* in *T[i]*. That is, if the
    simple path from *v* to its root in *S[i]* is *v*[0], *v*[1], … , *v[k]*, where
    *v*[0] = *v* and *v[k]* is *S[i]*’s root, then the depth of *v* in *T[i]* is ![art](images/Art_P594.jpg).
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 关键思想是在每个节点 *v* 中维护一个“伪距离” *v*.*d*，定义为沿着从 *v* 到其集合 *S[i]* 根的简单路径的伪距离之和等于 *v*
    在 *T[i]* 中的深度。也就是说，如果 *v* 到其在 *S[i]* 中的根的简单路径是 *v*[0], *v*[1], … , *v[k]*，其中 *v*[0]
    = *v*，*v[k]* 是 *S[i]* 的根，则 *v* 在 *T[i]* 中的深度为 ![art](images/Art_P594.jpg)。
- en: '***b.*** Give an implementation of MAKE-TREE.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 给出 MAKE-TREE 的实现。'
- en: '***c.*** Show how to modify FIND-SET to implement FIND-DEPTH. Your implementation
    should perform path compression, and its running time should be linear in the
    length of the find path. Make sure that your implementation updates pseudodistances
    correctly.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 展示如何修改 FIND-SET 来实现 FIND-DEPTH。您的实现应执行路径压缩，并且其运行时间应该与查找路径的长度成线性关系。确保您的实现正确更新伪距禇。'
- en: '***d.*** Show how to implement GRAFT(*r*, *v*), which combines the sets containing
    *r* and *v*, by modifying the UNION and LINK procedures. Make sure that your implementation
    updates pseudodistances correctly. Note that the root of a set *S[i]* is not necessarily
    the root of the corresponding tree *T[i]*.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 展示如何实现 GRAFT(*r*, *v*)，通过修改 UNION 和 LINK 程序来合并包含 *r* 和 *v* 的集合，并确保您的实现正确更新伪距离。请注意，集合
    *S[i]* 的根不一定是相应树 *T[i]* 的根。'
- en: '***e.*** Give a tight bound on the worst-case running time of a sequence of
    *m* MAKE-TREE, FIND-DEPTH, and GRAFT operations, *n* of which are MAKE-TREE operations.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** 给出一系列 *m* 个 MAKE-TREE、FIND-DEPTH 和 GRAFT 操作的最坏情况运行时间的紧密界限，其中 *n* 个是
    MAKE-TREE 操作。'
- en: '***19-3     Tarjan’s offline lowest-common-ancestors algorithm***'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '***19-3     Tarjan 的离线最近公共祖先算法***'
- en: The ***lowest common ancestor*** of two nodes *u* and *v* in a rooted tree *T*
    is the node *w* that is an ancestor of both *u* and *v* and that has the greatest
    depth in *T*. In the ***offline lowest-common-ancestors problem***, you are given
    a rooted tree *T* and an arbitrary set *P* = {{*u*, *v*}} of unordered pairs of
    nodes in *T*, and you wish to determine the lowest common ancestor of each pair
    in *P*.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 在根树 *T* 中，两个节点 *u* 和 *v* 的***最近公共祖先***是一个节点 *w*，它是 *u* 和 *v* 的祖先，并且在 *T* 中具有最大深度。在***离线最近公共祖先问题***中，给定一个根树
    *T* 和一个任意集合 *P* = {{*u*, *v*}}，其中 *T* 中节点的无序对，并且您希望确定 *P* 中每对的最近公共祖先。
- en: To solve the offline lowest-common-ancestors problem, the LCA procedure on the
    following page performs a tree walk of *T* with the initial call LCA(*T*.*root*).
    Assume that each node is colored WHITE prior to the walk.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决离线最近公共祖先问题，下一页的 LCA 程序在初始调用 LCA(*T*.*root*) 时对 *T* 执行树遍历。假设每个节点在遍历之前都被涂成白色。
- en: '***a.*** Argue that line 10 executes exactly once for each pair {*u*, *v*}
    ∈ *P*.'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 论证第 10 行对于每对 {*u*, *v*} ∈ *P* 恰好执行一次。'
- en: '***b.*** Argue that at the time of the call LCA(*u*), the number of sets in
    the disjoint-set data structure equals the depth of *u* in *T*.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 论证在调用 LCA(*u*) 时，不相交集数据结构中集合的数量等于 *u* 在 *T* 中的深度。'
- en: LCA(*u*)
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: LCA(*u*)
- en: '|   1 | MAKE-SET(*u*) |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '|   1 | MAKE-SET(*u*) |'
- en: '|   2 | FIND-SET(*u*).*ancestor* = *u* |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '|   2 | FIND-SET(*u*).*ancestor* = *u* |'
- en: '|   3 | **for** each child *v* of *u* in *T* |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '|   3 | **对于** *T* 中 *u* 的每个子节点 *v* |'
- en: '|   4 | LCA(*v*) |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '|   4 | LCA(*v*) |'
- en: '|   5 | UNION(*u*, *v*) |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '|   5 | UNION(*u*, *v*) |'
- en: '|   6 | FIND-SET(*u*).*ancestor* = *u* |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '|   6 | FIND-SET(*u*).*ancestor* = *u* |'
- en: '|   7 | *u*.*color* = BLACK |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '|   7 | *u*.*color* = 黑色 |'
- en: '|   8 | **for** each node *v* such that {*u*, *v*} ∈ *P* |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '|   8 | **对于** 每个节点 *v*，使得 {*u*, *v*} ∈ *P* |'
- en: '|   9 | **if** *v*.*color* == BLACK |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|   9 | **如果** *v*.*color* == 黑色 |'
- en: '| 10 | print “The lowest common ancestor of” |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 打印“最近公共祖先为” |'
- en: '|  | *u* “and” *v* “is” FIND-SET(*v*).*ancestor* |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '|  | *u* “和” *v* “是” FIND-SET(*v*).*ancestor* |'
- en: '***c.*** Prove that LCA correctly prints the lowest common ancestor of *u*
    and *v* for each pair {*u*, *v*} ∈ *P*.'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 证明 LCA 对于每对 {*u*, *v*} ∈ *P* 正确打印最近公共祖先。'
- en: '***d.*** Analyze the running time of LCA, assuming that you use the implementation
    of the disjoint-set data structure in [Section 19.3](chapter019.xhtml#Sec_19.3).'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 分析 LCA 的运行时间，假设您在 [第19.3节](chapter019.xhtml#Sec_19.3) 中使用不相交集数据结构的实现。'
- en: '**Chapter notes**'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节注释**'
- en: Many of the important results for disjoint-set data structures are due at least
    in part to R. E. Tarjan. Using aggregate analysis, Tarjan [[427](bibliography001.xhtml#endnote_427),
    [429](bibliography001.xhtml#endnote_429)] gave the first tight upper bound in
    terms of the very slowly growing inverse ![art](images/Art_P595.jpg) of Ackermann’s
    function. (The function *A[k]*(*j*) given in [Section 19.4](chapter019.xhtml#Sec_19.4)
    is similar to Ackermann’s function, and the function *α*(*n*) is similar to ![art](images/Art_P595.jpg).
    Both *α*(*n*) and ![art](images/Art_P595.jpg) are at most 4 for all conceivable
    values of *m* and *n*.) An upper bound of *O*(*m* lg* *n*) was proven earlier
    by Hopcroft and Ullman [[5](bibliography001.xhtml#endnote_5), [227](bibliography001.xhtml#endnote_227)].
    The treatment in [Section 19.4](chapter019.xhtml#Sec_19.4) is adapted from a later
    analysis by Tarjan [[431](bibliography001.xhtml#endnote_431)], which is based
    on an analysis by Kozen [[270](bibliography001.xhtml#endnote_270)]. Harfst and
    Reingold [[209](bibliography001.xhtml#endnote_209)] give a potential-based version
    of Tarjan’s earlier bound.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 许多关于不相交集数据结构的重要结果至少部分归功于 R. E. Tarjan。通过聚合分析，Tarjan [[427](bibliography001.xhtml#endnote_427),
    [429](bibliography001.xhtml#endnote_429)] 在 Ackermann 函数的倒数非常缓慢增长的情况下给出了第一个紧密的上界。(*A[k]*(*j*)
    函数在 [Section 19.4](chapter019.xhtml#Sec_19.4) 中给出，类似于 Ackermann 函数，而 *α*(*n*)
    函数类似于 ![art](images/Art_P595.jpg)。对于所有可想象的 *m* 和 *n* 值，*α*(*n*) 和 ![art](images/Art_P595.jpg)
    最多为 4。) Hopcroft 和 Ullman [[5](bibliography001.xhtml#endnote_5), [227](bibliography001.xhtml#endnote_227)]
    早先证明了 *O*(*m* lg* *n*) 的上界。[Section 19.4](chapter019.xhtml#Sec_19.4) 中的处理是根据 Tarjan
    [[431](bibliography001.xhtml#endnote_431)] 的后续分析进行的，该分析基于 Kozen [[270](bibliography001.xhtml#endnote_270)]
    的分析。Harfst 和 Reingold [[209](bibliography001.xhtml#endnote_209)] 给出了 Tarjan 较早上界的基于潜力的版本。
- en: Tarjan and van Leeuwen [[432](bibliography001.xhtml#endnote_432)] discuss variants
    on the path-compression heuristic, including “one-pass methods,” which sometimes
    offer better constant factors in their performance than do two-pass methods. As
    with Tarjan’s earlier analyses of the basic path-compression heuristic, the analyses
    by Tarjan and van Leeuwen are aggregate. Harfst and Reingold [[209](bibliography001.xhtml#endnote_209)]
    later showed how to make a small change to the potential function to adapt their
    path-compression analysis to these one-pass variants. Goel et al. [[182](bibliography001.xhtml#endnote_182)]
    prove that linking disjoint-set trees randomly yields the same asymptotic running
    time as union by rank. Gabow and Tarjan [[166](bibliography001.xhtml#endnote_166)]
    show that in certain applications, the disjoint-set operations can be made to
    run in *O*(*m*) time.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: Tarjan 和 van Leeuwen [[432](bibliography001.xhtml#endnote_432)] 讨论了路径压缩启发式的变体，包括“一遍方法”，有时在性能上比两遍方法具有更好的常数因子。与
    Tarjan 早期对基本路径压缩启发式的分析一样，Tarjan 和 van Leeuwen 的分析是聚合的。Harfst 和 Reingold [[209](bibliography001.xhtml#endnote_209)]
    后来展示了如何对潜力函数进行小改动，以适应这些一遍方法的路径压缩分析。Goel 等人 [[182](bibliography001.xhtml#endnote_182)]
    证明了随机链接不相交集树与按秩合并具有相同的渐近运行时间。Gabow 和 Tarjan [[166](bibliography001.xhtml#endnote_166)]
    表明在某些应用中，不相交集操作可以在 *O*(*m*) 时间内运行。
- en: Tarjan [[428](bibliography001.xhtml#endnote_428)] showed that a lower bound
    of ![art](images/Art_P598.jpg) time is required for operations on any disjoint-set
    data structure satisfying certain technical conditions. This lower bound was later
    generalized by Fredman and Saks [[155](bibliography001.xhtml#endnote_155)], who
    showed that in the worst case, ![art](images/Art_P599.jpg) (lg *n*)-bit words
    of memory must be accessed.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: Tarjan [[428](bibliography001.xhtml#endnote_428)] 表明对于满足特定技术条件的任何不相交集数据结构，操作需要
    ![art](images/Art_P598.jpg) 时间的下界。这个下界后来被 Fredman 和 Saks [[155](bibliography001.xhtml#endnote_155)]
    推广，他们表明在最坏情况下，必须访问 ![art](images/Art_P599.jpg) (lg *n*) 位的内存。
