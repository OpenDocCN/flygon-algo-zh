- en: '[**29        Linear Programming**](toc.xhtml#chap-29)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[**29        线性规划**](toc.xhtml#chap-29)'
- en: Many problems take the form of maximizing or minimizing an objective, given
    limited resources and competing constraints. If you can specify the objective
    as a linear function of certain variables, and if you can specify the constraints
    on resources as equalities or inequalities on those variables, then you have a
    ***linear-programming problem***. Linear programs arise in a variety of practical
    applications. We begin by studying an application in electoral politics.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多问题采取最大化或最小化目标的形式，考虑到有限的资源和竞争性约束。如果您可以将目标指定为某些变量的线性函数，并且可以将资源的约束规定为这些变量的等式或不等式，那么您就有了一个***线性规划问题***。线性规划在各种实际应用中出现。我们首先研究选举政治中的一个应用。
- en: '**A political problem**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个政治问题**'
- en: Suppose that you are a politician trying to win an election. Your district has
    three different types of areas—urban, suburban, and rural. These areas have, respectively,
    100,000, 200,000, and 50,000 registered voters. Although not all the registered
    voters actually go to the polls, you decide that to govern effectively, you would
    like at least half the registered voters in each of the three regions to vote
    for you. You are honorable and would never consider supporting policies you don’t
    believe in. You realize, however, that certain issues may be more effective in
    winning votes in certain places. Your primary issues are preparing for a zombie
    apocalypse, equipping sharks with lasers, building highways for flying cars, and
    allowing dolphins to vote.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您是一名试图赢得选举的政治家。您的选区有三种不同类型的地区——城市、郊区和农村。这些地区分别有10万、20万和5万名注册选民。尽管并非所有注册选民都会去投票，但您决定为了有效地治理，您希望每个地区至少有一半的注册选民投票支持您。您是光荣的，绝不会考虑支持您不相信的政策。然而，您意识到某些问题可能在某些地方赢得选票时更有效。您的主要问题是为了应对僵尸启示，给鲨鱼装激光器，修建飞车高速公路和允许海豚投票。
- en: According to your campaign staff’s research, you can estimate how many votes
    you win or lose from each population segment by spending $1,000 on advertising
    on each issue. This information appears in the table of [Figure 29.1](chapter029.xhtml#Fig_29-1).
    In this table, each entry indicates the number of thousands of either urban, suburban,
    or rural voters who would be won over by spending $1,000 on advertising in support
    of a particular issue. Negative entries denote votes that would be lost. Your
    task is to figure out the minimum amount of money that you need to spend in order
    to win 50,000 urban votes, 100,000 suburban votes, and 25,000 rural votes.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 根据您的竞选团队的研究，您可以估计通过在每个问题上花费$1,000广告赢得或失去多少选票。这些信息显示在[图29.1](chapter029.xhtml#Fig_29-1)的表中。在这个表中，每个条目表示通过在支持特定问题的广告上花费$1,000可以赢得多少城市、郊区或农村选民的数千人。负数条目表示将失去的选票。您的任务是找出您需要花费的最少金额，以赢得5万城市选票、10万郊区选票和2.5万农村选票。
- en: You could, by trial and error, devise a strategy that wins the required number
    of votes, but the strategy you come up with might not be the least expensive one.
    For example, you could devote $20,000 of advertising to preparing for a zombie
    apocalypse, $0 to equipping sharks with lasers, $4,000 to building highways for
    flying cars, and $9,000 to allowing dolphins to vote. In this case, you would
    win (20 · −2) + (0 · 8) + (4 · 0) + (9 · 10) = 50 thousand urban votes, (20 ·
    5) + (0 · 2) + (4 · 0) + (9 · 0) = 100 thousand suburban votes, and (20 · 3) +
    (0 · −5) + (4 · 10) + (9 · −2) = 82 thousand rural votes. You would win the exact
    number of votes desired in the urban and suburban areas and more than enough votes
    in the rural area. (In fact, according to your model, in the rural area you would
    receive more votes than there are voters.) In order to garner these votes, you
    would have paid for 20 + 0 + 4 + 9 = 33 thousand dollars of advertising.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过试错来设计一种赢得所需选票的策略，但您想出的策略可能不是最便宜的。例如，您可以将$20,000用于应对僵尸启示的广告，$0用于给鲨鱼装激光器，$4,000用于修建飞车高速公路，$9,000用于允许海豚投票。在这种情况下，您将赢得（20
    · -2）+（0 · 8）+（4 · 0）+（9 · 10）= 5万城市选票，（20 · 5）+（0 · 2）+（4 · 0）+（9 · 0）= 10万郊区选票，以及（20
    · 3）+（0 · -5）+（4 · 10）+（9 · -2）= 8.2万农村选票。您将在城市和郊区地区赢得所需的选票数量，而在农村地区赢得的选票超过了所需数量。（实际上，根据您的模型，在农村地区您将获得比选民更多的选票。）为了赢得这些选票，您将支付20
    + 0 + 4 + 9 = 3.3万美元的广告费。
- en: '![art](images/Art_P976.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P976.jpg)'
- en: '**Figure 29.1** The effects of policies on voters. Each entry describes the
    number of thousands of urban, suburban, or rural voters who could be won over
    by spending $1,000 on advertising support of a policy on a particular issue. Negative
    entries denote votes that would be lost.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**图29.1** 政策对选民的影响。每个条目描述了在特定问题上花费$1,000广告支持能赢得多少城市、郊区或农村选民的数千人。负数条目表示将失去的选票。'
- en: It’s natural to wonder whether this strategy is the best possible. That is,
    can you achieve your goals while spending less on advertising? Additional trial
    and error might help you to answer this question, but a better approach is to
    formulate (or ***model***) this question mathematically.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 自然而然地会想知道这种策略是否是最佳的。也就是说，您是否可以在广告上花费更少的情况下实现您的目标？额外的试验和错误可能会帮助您回答这个问题，但更好的方法是通过数学方式来形式化（或***建模***）这个问题。
- en: 'The first step is to decide what decisions you have to make and to introduce
    variables that capture these decisions. Since you have four decisions, you introduce
    four ***decision variables***:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是决定您必须做出的决策，并引入捕捉这些决策的变量。由于您有四个决策，您引入了四个***决策变量***：
- en: '*x*[1] is the number of thousands of dollars spent on advertising on preparing
    for a zombie apocalypse,'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x*[1] 是在为应对僵尸启示的广告上花费的数千美元，'
- en: '*x*[2] is the number of thousands of dollars spent on advertising on equipping
    sharks with lasers,'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x*[2] 是在给鲨鱼装激光器的广告上花费的数千美元，'
- en: '*x*[3] is the number of thousands of dollars spent on advertising on building
    highways for flying cars, and'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x*[3] 是用于在建造飞行汽车的高速公路上进行广告投放的数千美元，以及'
- en: '*x*[4] is the number of thousands of dollars spent on advertising on allowing
    dolphins to vote.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*x*[4] 是用于让海豚投票进行广告投放的数千美元。'
- en: You then think about ***constraints***, which are limits, or restrictions, on
    the values that the decision variables can take. You can write the requirement
    that you win at least 50,000 urban votes as
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 然后您考虑***约束***，这是对决策变量可以取值的限制或限制。您可以将至少赢得5万城市选票的要求写成
- en: '![art](images/Art_P977.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P977.jpg)'
- en: Similarly, you can write the requirements that you win at least 100,000 suburban
    votes and 25,000 rural votes as
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以将您至少赢得10万市区选票和2.5万农村选票的要求写成
- en: '![art](images/Art_P978.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P978.jpg)'
- en: and
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '![art](images/Art_P979.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P979.jpg)'
- en: Any setting of the variables *x*[1], *x*[2], *x*[3], *x*[4] that satisfies inequalities
    (29.1)–(29.3) yields a strategy that wins a sufficient number of each type of
    vote.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 任何满足不等式(29.1)–(29.3)的变量 *x*[1], *x*[2], *x*[3], *x*[4] 的设置都会产生赢得足够数量的每种类型选票的策略。
- en: Finally, you think about your ***objective***, which is the quantity that you
    wish to either minimize or maximize. In order to keep costs as small as possible,
    you would like to minimize the amount spent on advertising. That is, you want
    to minimize the expression
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您考虑您的***目标***，这是您希望最小化或最大化的数量。为了尽可能降低成本，您希望最小化广告支出。也就是说，您希望最小化表达式
- en: '![art](images/Art_P980.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P980.jpg)'
- en: Although negative advertising often occurs in political campaigns, there is
    no such thing as negative-cost advertising. Consequently, you require that
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管负面广告经常出现在政治竞选中，但不存在负成本广告这种事情。因此，您要求
- en: '![art](images/Art_P981.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P981.jpg)'
- en: Combining inequalities (29.1)–(29.3) and (29.5) with the objective of minimizing
    (29.4) produces what is known as a “linear program.” We can format this problem
    tabularly as
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 将不等式(29.1)–(29.3)和(29.5)与最小化(29.4)的目标相结合，产生了所谓的“线性规划”。我们可以将这个问题以表格形式格式化为
- en: '![art](images/Art_P982.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P982.jpg)'
- en: subject to
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 受限于
- en: '![art](images/Art_P983.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P983.jpg)'
- en: The solution to this linear program yields your optimal strategy.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这个线性规划的解决方案会给出您的最佳策略。
- en: The remainder of this chapter covers how to formulate linear programs and is
    an introduction to modeling in general. Modeling refers to the general process
    of converting a problem into a mathematical form amenable to solution by an algorithm.
    [Section 29.1](chapter029.xhtml#Sec_29.1) discusses briefly the algorithmic aspects
    of linear programming, although it does not include the details of a linear-programming
    algorithm. Throughout this book, we have seen ways to model problems, such as
    by shortest paths and connectivity in a graph. When modeling a problem as a linear
    program, you go through the steps used in this political example—identifying the
    decision variables, specifying the constraints, and formulating the objective
    function. In order to model a problem as a linear program, the constraints and
    objectives must be linear. In [Section 29.2](chapter029.xhtml#Sec_29.2), we will
    see several other examples of modeling via linear programs. [Section 29.3](chapter029.xhtml#Sec_29.3)
    discusses duality, an important concept in linear programming and other optimization
    algorithms.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的其余部分涵盖了如何制定线性规划，并介绍了建模的概念。建模是指将问题转化为数学形式，以便通过算法解决。[第29.1节](chapter029.xhtml#Sec_29.1)简要讨论了线性规划的算法方面，尽���没有包括线性规划算法的细节。在本书中，我们已经看到了通过最短路径和图中的连通性等方式对问题进行建模。将问题建模为线性规划时，您需要经历这个政治示例中使用的步骤——确定决策变量，指定约束条件，并制定目标函数。为了将问题建模为线性规划，约束条件和目标必须是线性的。在[第29.2节](chapter029.xhtml#Sec_29.2)中，我们将看到几个其他通过线性规划进行建模的示例。[第29.3节](chapter029.xhtml#Sec_29.3)讨论了对偶性，这是线性规划和其他优化算法中的一个重要概念。
- en: '[**29.1    Linear programming formulations and algorithms**](toc.xhtml#Rh1-167)'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '[**29.1    线性规划公式和算法**](toc.xhtml#Rh1-167)'
- en: Linear programs take a particular form, which we will examine in this section.
    Multiple algorithms have been developed to solve linear programs. Some run in
    polynomial time, some do not, but they are all too complicated to show here. Instead,
    we will give an example that demonstrates some ideas behind the simplex algorithm,
    which is currently the most commonly deployed solution method.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 线性规划采用特定形式，我们将在本节中进行讨论。已经开发了多种算法来解决线性规划问题。有些算法在多项式时间内运行，有些则不是，但它们都太复杂，无法在此展示。相反，我们将给出一个示例，演示单纯形算法背后的一些思想，这是目前最常用的解决方法。
- en: '**General linear programs**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**一般线性规划**'
- en: In the general linear-programming problem, we wish to optimize a linear function
    subject to a set of linear inequalities. Given a set of real numbers *a*[1], *a*[2],
    … , *a[n]* and a set of variables *x*[1], *x*[2], … , *x[n]*, we define a ***linear
    function*** *f* on those variables by
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般线性规划问题中，我们希望优化一个线性函数，受一组线性不等式的限制。给定一组实数 *a*[1], *a*[2], … , *a[n]* 和一组变量
    *x*[1], *x*[2], … , *x[n]*，我们通过以下方式定义这些变量的***线性函数*** *f*
- en: '![art](images/Art_P984.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P984.jpg)'
- en: If *b* is a real number and *f* is a linear function, then the equation
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *b* 是一个实数，*f* 是一个线性函数，那么方程
- en: '*f*(*x*[1], *x*[2], … , *x[n]*) = *b*'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*x*[1], *x*[2], … , *x[n]*) = *b*'
- en: is a ***linear equality*** and the inequalities
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 是一个***线性等式*** 和不等式
- en: '*f*(*x*[1], *x*[2], … , *x[n]*) ≤ *b* and *f*(*x*[1], *x*[2], … , *x[n]*) ≥
    *b*'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*(*x*[1], *x*[2], … , *x[n]*) ≤ *b* 和 *f*(*x*[1], *x*[2], … , *x[n]*) ≥ *b*'
- en: are ***linear inequalities***. We use the general term ***linear constraints***
    to denote either linear equalities or linear inequalities. Linear programming
    does not allow strict inequalities. Formally, a ***linear-programming problem***
    is the problem of either minimizing or maximizing a linear function subject to
    a finite set of linear constraints. If minimizing, we call the linear program
    a ***minimization linear program***, and if maximizing, we call the linear program
    a ***maximization linear program***.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 是***线性不等式***。我们使用通用术语***线性约束***来表示线性等式或线性不等式。线性规划不允许严格不等式。形式上，一个***线性规划问题***是要么最小化要么最大化一个线性函数，受限于一组有限的线性约束。如果是最小化，我们称线性规划为***最小化线性规划***，如果是最大化，我们称线性规划为***最大化线性规划***。
- en: In order to discuss linear-programming algorithms and properties, it will be
    helpful to use a standard notation for the input. By convention, a maximization
    linear program takes as input *n* real numbers *c*[1], *c*[2], … , *c[n]*; *m*
    real numbers *b*[1], *b*[2], … , *b[m]*; and *mn* real numbers *a[ij]* for *i*
    = 1, 2, … , *m* and *j* = 1, 2, … , *n*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了讨论线性规划算法和性质，使用标准符号来描述输入将会很有帮助。按照惯例，最大化线性规划的输入是*n*个实数*c*[1]，*c*[2]，…，*c[n]；*m*个实数*b*[1]，*b*[2]，…，*b[m]；以及*mn*个实数*a[ij]*，其中*i*
    = 1，2，…，*m*，*j* = 1，2，…，*n*。
- en: The goal is to find *n* real numbers *x*[1], *x*[2], … , *x[n]* that
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是找到*n*个实数*x*[1]，*x*[2]，…，*x[n]*，使得
- en: '![art](images/Art_P985.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P985.jpg)'
- en: subject to
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 满足于
- en: '![art](images/Art_P986.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P986.jpg)'
- en: We call expression (29.11) the ***objective function*** and the *n* + *m* inequalities
    in lines (29.12) and (29.13) the ***constraints***. The *n* constraints in line
    (29.13) are the ***nonnegativity constraints***. It can sometimes be more convenient
    to express a linear program in a more compact form. If we create an *m* × *n*
    matrix *A* = (*a[ij]*), an *m*-vector *b* = (*b[i]*), an *n*-vector *c* = (*c[j]*),
    and an *n*-vector *x* = (*x[j]*), then we can rewrite the linear program defined
    in (29.11)–(29.13) as
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将(29.11)式称为***目标函数***，将第(29.12)和(29.13)行中的*n* + *m*个不等式称为***约束条件***。第(29.13)行中的*n*个约束条件是***非负约束条件***。有时，以更紧凑的形式表达线性规划可能更方便。如果我们创建一个*m*×*n*矩阵*A*
    = (*a[ij]*)，一个*m*向量*b* = (*b[i]*)，���个*n*向量*c* = (*c[j]*)，和一个*n*向量*x* = (*x[j]*)，那么我们可以将(29.11)–(29.13)中定义的线性规划重写为
- en: '![art](images/Art_P987.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P987.jpg)'
- en: subject to
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 满足于
- en: '![art](images/Art_P988.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P988.jpg)'
- en: In line (29.14), *c*^T*x* is the inner product of two *n*-vectors. In inequality
    (29.15), *Ax* is the *m*-vector that is the product of an *m* × *n* matrix and
    an *n*-vector, and in inequality (29.16), *x* ≥ 0 means that each entry of the
    vector *x* must be nonnegative. We call this representation the ***standard form***
    for a linear program, and we adopt the convention that *A*, *b*, and *c* always
    have the dimensions given above.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在第(29.14)行，*c*^T*x*是两个*n*向量的内积。在不等式(29.15)中，*Ax*是一个*m*向量，是一个*m*×*n*矩阵和一个*n*向量的乘积，在不等式(29.16)中，*x*
    ≥ 0表示向量*x*的每个条目必须是非负的。我们称这种表示为线性规划的***标准形式***，并采用*A*，*b*和*c*始终具有上述维度的约定。
- en: The standard form above may not naturally correspond to real-life situations
    you are trying to model. For example, you might have equality constraints or variables
    that can take on negative values. Exercises 29.1-6 and 29.1-7 ask you to show
    how to convert any linear program into this standard form.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 上述标准形式可能不自然地对应于您试图建模的现实情况。例如，您可能有相等约束或变量可以取负值。练习29.1-6和29.1-7要求您展示如何将任何线性规划转换为这个标准形式。
- en: 'We now introduce terminology to describe solutions to linear programs. We denote
    a particular setting of the values in a variable, say *x*, by putting a bar over
    the variable name: *x*. If *x* satisfies all the constraints, then it is a ***feasible
    solution***, but if it fails to satisfy at least one constraint, then it is an
    ***infeasible solution***. We say that a solution *x* has ***objective value*** *c*^T*x*.
    A feasible solution *x* whose objective value is maximum over all feasible solutions
    is an ***optimal solution***, and we call its objective value *c*^T*x* the ***optimal
    objective value***. If a linear program has no feasible solutions, we say that
    the linear program is ***infeasible***, and otherwise, it is ***feasible***. The
    set of points that satisfy all the constraints is the ***feasible region***. If
    a linear program has some feasible solutions but does not have a finite optimal
    objective value, then the feasible region is ***unbounded*** and so is the linear
    program. Exercise 29.1-5 asks you to show that a linear program can have a finite
    optimal objective value even if the feasible region is unbounded.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在引入术语来描述线性规划的解。我们通过在变量名上加一条线来表示变量*x*的特定值设置：*x*。如果*x*满足所有约束条件，则它是一个***可行解***，但如果它至少不满足一个约束条件，则它是一个***不可行解***。我们说一个解*x*的***目标值***为*c*^T*x*。一个目标值最大的可行解*x*是一个***最优解***，我们称其目标值为*c*^T*x*的***最优目标值***。如果一个线性规划没有可行解，我们说这个线性规划是***不可行的***，否则，它是***可行的***。满足所有约束条件的点的集合是***可行区域***。如果一个线性规划有一些可行解但没有有限的最优目标值，那么可行区域是***无界的***，因此线性规划也是无界的。练习29.1-5要求你展示，即使可行区域是无界的，线性规划也可以有有限的最优目标值。
- en: One of the reasons for the power and popularity of linear programming is that
    linear programs can, in general, be solved efficiently. There are two classes
    of algorithms, known as ellipsoid algorithms and interior-point algorithms, that
    solve linear programs in polynomial time. In addition, the simplex algorithm is
    widely used. Although it does not run in polynomial time in the worst case, it
    tends to perform well in practice.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 线性规划的强大和受欢迎之处之一是线性规划通常可以高效地解决。有两类算法，称为椭球算法和内点算法，可以在多项式时间内解决线性规划。此外，单纯形算法被广泛使用。尽管在最坏情况下它不是多项式时间运行，但在实践中它往往表现良好。
- en: We will not give a detailed algorithm for linear programming, but will discuss
    a few important ideas. First, we will give an example of using a geometric procedure
    to solve a two-variable linear program. Although this example does not immediately
    generalize to an efficient algorithm for larger problems, it introduces some important
    concepts for linear programming and for optimization in general.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不会详细介绍线性规划的算法，但会讨论一些重要的思想。首先，我们将给出一个使用几何程序解决双变量线性规划的示例。尽管这个示例不能立即推广到更大问题的有效算法，但它介绍了线性规划和一般优化的一些重要概念。
- en: '**A two-variable linear program**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**双变量线性规划**'
- en: 'Let us first consider the following linear program with two variables:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先考虑以下双变量线性规划：
- en: '![art](images/Art_P989.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P989.jpg)'
- en: subject to
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 限制条件
- en: '![art](images/Art_P990.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P990.jpg)'
- en: '[Figure 29.2(a)](chapter029.xhtml#Fig_29-2) graphs the constraints in the (*x*[1],
    *x*[2])-Cartesian coordinate system. The feasible region in the two-dimensional
    space (highlighted in blue in the figure) is convex.^([1](#footnote_1)) Conceptually,
    you could evaluate the objective function *x*[1] + *x*[2] at each point in the
    feasible region, and then identify a point that has the maximum objective value
    as an optimal solution. For this example (and for most linear programs), however,
    the feasible region contains an infinite number of points, and so to solve this
    linear program, you need an efficient way to find a point that achieves the maximum
    objective value without explicitly evaluating the objective function at every
    point in the feasible region.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 29.2（a）](chapter029.xhtml#Fig_29-2)在（*x*[1]，*x*[2]）笛卡尔坐标系中绘制了约束条件。二维空间中的可行区域（在图中用蓝色突出显示）是凸的。^([1](#footnote_1))
    从概念上讲，您可以在可行区域中的每个点处评估目标函数*x*[1] + *x*[2]，然后确定具有最大目标值的点作为最优解。然而，对于这个例子（以及大多数线性规划问题），可行区域包含无限多个点，因此要解决这个线性规划问题，您需要一种有效的方法，在不显式评估可行区域中的每个点的情况下找到实现最大目标值的点。'
- en: In two dimensions, you can optimize via a graphical procedure. The set of points
    for which *x*[1] + *x*[2] = *z*, for any *z*, is a line with a slope of −1\. Plotting
    *x*[1] + *x*[2] = 0 produces the line with slope −1 through the origin, as in
    [Figure 29.2(b)](chapter029.xhtml#Fig_29-2). The intersection of this line and
    the feasible region is the set of feasible solutions that have an objective value
    of 0\. In this case, that intersection of the line with the feasible region is
    the single point (0, 0). More generally, for any value *z*, the intersection of
    the line *x*[1] + *x*[2] = *z* and the feasible region is the set of feasible
    solutions that have objective value *z*. [Figure 29.2(b)](chapter029.xhtml#Fig_29-2)
    shows the lines *x*[1] + *x*[2] = 0, *x*[1] + *x*[2] = 4, and *x*[1] + *x*[2]
    = 8\. Because the feasible region in [Figure 29.2](chapter029.xhtml#Fig_29-2)
    is bounded, there must be some maximum value *z* for which the intersection of
    the line *x*[1] + *x*[2] = *z* and the feasible region is nonempty. Any point
    in the feasible region that maximizes *x*[1] + *x*[2] is an optimal solution to
    the linear program, which in this case is the vertex of the feasible region at
    *x*[1] = 2 and *x*[2] = 6, with objective value 8.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在二维空间中，您可以通过图形化程序进行优化。对于任何*z*，使*x*[1] + *x*[2] = *z*的点集是斜率为-1的一条直线。绘制*x*[1]
    + *x*[2] = 0会产生通过原点的斜率为-1的直线，如[图 29.2（b）](chapter029.xhtml#Fig_29-2)所示。这条直线与可行区域的交点是具有目标值为0的可行解集。在这种情况下，该直线与可行区域的交点是单个点（0,
    0）。更一般地，对于任何值*z*，直线*x*[1] + *x*[2] = *z*与可行区域的交点是具有目标值*z*的可行解集。[图 29.2（b）](chapter029.xhtml#Fig_29-2)展示了直线*x*[1]
    + *x*[2] = 0、*x*[1] + *x*[2] = 4和*x*[1] + *x*[2] = 8。由于[图 29.2](chapter029.xhtml#Fig_29-2)中的可行区域是有界的，必须存在某个最大值*z*，使得直线*x*[1]
    + *x*[2] = *z*与可行区域的交集非空。可行区域中最大化*x*[1] + *x*[2]的任何点都是线性规划的最优解，本例中是可行区域的顶点*x*[1]
    = 2和*x*[2] = 6，目标值为8。
- en: '![art](images/Art_P991.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P991.jpg)'
- en: '**Figure 29.2 (a)** The linear program given in (29.18)–(29.21). Each constraint
    is represented by a line and a direction. The intersection of the constraints,
    which is the feasible region, is highlighted in blue. **(b)** The red lines show,
    respectively, the points for which the objective value is 0, 4, and 8\. The optimal
    solution to the linear program is *x*[1] = 2 and *x*[2] = 6 with objective value
    8.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 29.2（a）** 给定于（29.18）-（29.21）中的线性规划。每个约束由一条线和一个方向表示。约束的交集，即可行区域，用蓝色突出显示。**(b)**
    红线分别显示了目标值为0、4和8的点。线性规划的最优解为*x*[1] = 2和*x*[2] = 6，目标值为8。'
- en: It is no accident that an optimal solution to the linear program occurs at a
    vertex of the feasible region. The maximum value of *z* for which the line *x*[1]
    + *x*[2] = *z* intersects the feasible region must be on the boundary of the feasible
    region, and thus the intersection of this line with the boundary of the feasible
    region is either a single vertex or a line segment. If the intersection is a single
    vertex, then there is just one optimal solution, and it is that vertex. If the
    intersection is a line segment, every point on that line segment must have the
    same objective value. In particular, both endpoints of the line segment are optimal
    solutions. Since each endpoint of a line segment is a vertex, there is an optimal
    solution at a vertex in this case as well.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 线性规划的最优解恰好出现在可行区域的顶点上并非偶然。使直线*x*[1] + *x*[2] = *z*与可行区域相交的最大*z*值必须在可行区域的边界上，因此该直线与可行区域边界的交点要么是单个顶点，要么是一条线段。如果交点是单个顶点，则只有一个最优解，即该顶点。如果交点是一条线段，则该线段上的每个点必须具有相同的目标值。特别地，线段的两个端点都是最优解。由于线段的每个端点都是一个顶点，因此在这种情况下，最优解也存在于顶点上。
- en: Although you cannot easily graph linear programs with more than two variables,
    the same intuition holds. If you have three variables, then each constraint corresponds
    to a half-space in three-dimensional space. The intersection of these half-spaces
    forms the feasible region. The set of points for which the objective function
    obtains a given value *z* is now a plane (assuming no degenerate conditions).
    If all coefficients of the objective function are nonnegative, and if the origin
    is a feasible solution to the linear program, then as you move this plane away
    from the origin, in a direction normal to the objective function, you find points
    of increasing objective value. (If the origin is not feasible or if some coefficients
    in the objective function are negative, the intuitive picture becomes slightly
    more complicated.) As in two dimensions, because the feasible region is convex,
    the set of points that achieve the optimal objective value must include a vertex
    of the feasible region. Similarly, if you have *n* variables, each constraint
    defines a half-space in *n*-dimensional space. We call the feasible region formed
    by the intersection of these half-spaces a ***simplex***. The objective function
    is now a hyperplane and, because of convexity, an optimal solution still occurs
    at a vertex of the simplex. Any algorithm for linear programming must also identify
    linear programs that have no solutions, as well as linear programs that have no
    finite optimal solution.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你不能轻松地绘制具有两个以上变量的线性规划，但相同的直觉仍然成立。如果你有三个变量，那么每个约束对应于三维空间中的一个半空间。这些半空间的交集形成了可行区域。使目标函数获得给定值*z*的点集现在是一个平面（假设没有退化条件）。如果目标函数的所有系数都是非负的，并且原点是线性规划的一个可行解，那么当你将这个平面沿着垂直于目标函数的方向远离原点时，你会找到目标值增加的点。（如果原点不可行或者目标函数中的一些系数为负，直观图像会变���稍微复杂。）与二维情况类似，因为可行区域是凸的，能够实现最优目标值的点集必须包括可行区域的一个顶点。同样，如果你有*n*个变量，每个约束在*n*维空间中定义一个半空间。我们称由这些半空间的交集形成的可行区域为一个***单纯形***。目标函数现在是一个超平面，由于凸性，最优解仍然出现在单纯形的一个顶点。任何线性规划算法还必须识别没有解的线性规划，以及没有有限最优解的线性规划。
- en: The ***simplex algorithm*** takes as input a linear program and returns an optimal
    solution. It starts at some vertex of the simplex and performs a sequence of iterations.
    In each iteration, it moves along an edge of the simplex from a current vertex
    to a neighboring vertex whose objective value is no smaller than that of the current
    vertex (and usually is larger.) The simplex algorithm terminates when it reaches
    a local maximum, which is a vertex from which all neighboring vertices have a
    smaller objective value. Because the feasible region is convex and the objective
    function is linear, this local optimum is actually a global optimum. In [Section
    29.3](chapter029.xhtml#Sec_29.3), we’ll see an important concept called “duality,”
    which we’ll use to prove that the solution returned by the simplex algorithm is
    indeed optimal.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '***单纯形算法***接受一个线性规划作为输入并返回一个最优解。它从单纯形的某个顶点开始，并执行一系列迭代。在每次迭代中，它沿着单纯形的一条边从当前顶点移动到一个相邻顶点，其目标值不小于当前顶点（通常更大）。单纯形算法在达到局部最大值时终止，这是一个顶点，其所有相邻顶点的目标值都更小。由于可行区域是凸的，目标函数是线性的，这个局部最优实际上是全局最优。在[第29.3节](chapter029.xhtml#Sec_29.3)中，我们将看到一个重要概念叫做“对偶性”，我们将用它来证明单纯形算法返回的解确实是最优的。'
- en: The simplex algorithm, when implemented carefully, often solves general linear
    programs quickly in practice. With some carefully contrived inputs, however, the
    simplex algorithm can require exponential time. The first polynomial-time algorithm
    for linear programming was the ***ellipsoid algorithm***, which runs slowly in
    practice. A second class of polynomial-time algorithms are known as ***interior-point
    methods***. In contrast to the simplex algorithm, which moves along the exterior
    of the feasible region and maintains a feasible solution that is a vertex of the
    simplex at each iteration, these algorithms move through the interior of the feasible
    region. The intermediate solutions, while feasible, are not necessarily vertices
    of the simplex, but the final solution is a vertex. For large inputs, interior-point
    algorithms can run as fast as, and sometimes faster than, the simplex algorithm.
    The chapter notes point you to more information about these algorithms.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当细心实现时，单纯形算法通常能够快速解决一般的线性规划问题。然而，对于一些精心设计的输入，单纯形算法可能需要指数时间。线性规划的第一个多项式时间算法是***椭球算法***，在实践中运行速度较慢。第二类多项式时间算法被称为***内点法***。与单纯形算法相反，内点法沿着可行区域的内部移动。中间解虽然可行，但不一定是单纯形的顶点，但最终解是一个顶点。对于大规模输入，内点算法可以与单纯形算法一样快，有时甚至更快。章节注释会指引你获取更多关于这些算法的信息。
- en: If you add to a linear program the additional requirement that all variables
    take on integer values, you have an ***integer linear program***. Exercise 34.5-3
    on page 1098 asks you to show that just finding a feasible solution to this problem
    is NP-hard. Since no polynomial-time algorithms are known for any NP-hard problems,
    there is no known polynomial-time algorithm for integer linear programming. In
    contrast, a general linear-programming problem can be solved in polynomial time.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你在一个线性规划中增加额外的要求，即所有变量都取整数值，那么你就得到了一个***整数线性规划***。第1098页的练习34.5-3要求你证明仅仅找到这个问题的一个可行解就是NP难题。由于对于任何NP难题都没有已知的多项式时间算法，因此也没有已知的整数线性规划的多项式时间算法。相比之下，一般的线性规划问题可以在多项式时间内解决。
- en: '**Exercises**'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***29.1-1***'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.1-1***'
- en: Consider the linear program
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑线性规划
- en: minimize −2*x*[1] + 3*x*[2]
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化 −2*x*[1] + 3*x*[2]
- en: subject to
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 限制条件
- en: '| *x*[1] + *x*[2] | = | 7 |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1] + *x*[2] | = | 7 |'
- en: '| *x*[1] − 2*x*[2] | ≤ | 4 |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1] − 2*x*[2] | ≤ | 4 |'
- en: '| *x*[1] | ≥ | 0. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1] | ≥ | 0. |'
- en: Give three feasible solutions to this linear program. What is the objective
    value of each one?
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 给出这个线性规划的三个可行解。每个的目标值是多少？
- en: '***29.1-2***'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.1-2***'
- en: 'Consider the following linear program, which has a nonpositivity constraint:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下具有非正约束的线性规划问题：
- en: minimize 2*x*[1] + 7*x*[2] + *x*[3]
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 最小化 2*x*[1] + 7*x*[2] + *x*[3]
- en: subject to
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下为条件
- en: '| *x*[1] | − *x*[3] | = | 7 |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1] | − *x*[3] | = | 7 |'
- en: '| 3*x*[1] + *x*[2] |  | ≥ | 24 |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 3*x*[1] + *x*[2] |  | ≥ | 24 |'
- en: '|  | *x*[2] | ≥ | 0 |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|  | *x*[2] | ≥ | 0 |'
- en: '|  | *x*[3] | ≤ | 0. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|  | *x*[3] | ≤ | 0. |'
- en: Give three feasible solutions to this linear program. What is the objective
    value of each one?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 给出这个线性规划的三个可行解。每个的目标值是多少？
- en: '***29.1-3***'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.1-3***'
- en: 'Show that the following linear program is infeasible:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 证明以下线性规划问题是不可行的：
- en: maximize 3*x*[1] − 2*x*[2]
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 最大化 3*x*[1] − 2*x*[2]
- en: subject to
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下为条件
- en: '| *x*[1] + *x*[2] | ≤ | 2 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1] + *x*[2] | ≤ | 2 |'
- en: '| −2*x*[1] − 2*x*[2] | ≤ | −10 |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| −2*x*[1] − 2*x*[2] | ≤ | −10 |'
- en: '| *x*[1], *x*[2] | ≥ | 0. |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1], *x*[2] | ≥ | 0. |'
- en: '***29.1-4***'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.1-4***'
- en: 'Show that the following linear program is unbounded:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 证明以下线性规划问题是无界的：
- en: maximize *x*[1] − *x*[2]
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最大化 *x*[1] − *x*[2]
- en: subject to
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以以下为条件
- en: '| −2*x*[1] + *x*[2] | ≤ | −1 |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| −2*x*[1] + *x*[2] | ≤ | −1 |'
- en: '| −*x*[1] − 2*x*[2] | ≤ | −2 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| −*x*[1] − 2*x*[2] | ≤ | −2 |'
- en: '| *x*[1], *x*[2] | ≥ | 0. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1], *x*[2] | ≥ | 0. |'
- en: '***29.1-5***'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.1-5***'
- en: Give an example of a linear program for which the feasible region is not bounded,
    but the optimal objective value is finite.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个线性规划的例子，其中可行区域无界，但最优目标值是有限的。
- en: '***29.1-6***'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.1-6***'
- en: Sometimes, in a linear program, you need to convert constraints from one form
    to another.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，在线性规划中，您需要将约束从一种形式转换为另一种形式。
- en: '***a.*** Show how to convert an equality constraint into an equivalent set
    of inequalities. That is, given a constraint ![art](images/Art_P992.jpg), give
    a set of inequalities that will be satisfied if and only if ![art](images/Art_P993.jpg),'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 展示如何将等式约束转换为等效的不等式集合。也就是说，给定约束条件![art](images/Art_P992.jpg)，给出一组不等式，只有当![art](images/Art_P993.jpg)时才满足，'
- en: '***b.*** Show how to convert an inequality constraint ![art](images/Art_P994.jpg)
    into an equality constraint and a nonnegativity constraint. You will need to introduce
    an additional variable *s*, and use the constraint that *s* ≥ 0.'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 展示如何将不等式约束![art](images/Art_P994.jpg)转换为等式约束和非负约束。您需要引入一个额外的变量 *s*，并使用约束条件
    *s* ≥ 0。'
- en: '***29.1-7***'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.1-7***'
- en: Explain how to convert a minimization linear program to an equivalent maximization
    linear program, and argue that your new linear program is equivalent to the original
    one.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 解释如何将最小化线性规划转换为等效的最大化线性规划，并论证您的新线性规划与原始线���规划等效。
- en: '***29.1-8***'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.1-8***'
- en: In the political problem at the beginning of this chapter, there are feasible
    solutions that correspond to winning more voters than there actually are in the
    district. For example, you can set *x*[2] to 200, *x*[3] to 200, and *x*[1] =
    *x*[4] = 0\. That solution is feasible, yet it seems to say that you will win
    400,000 suburban voters, even though there are only 200,000 actual suburban voters.
    What constraints can you add to the linear program to ensure that you never seem
    to win more voters than there actually are? Even if you don’t add these constraints,
    argue that the optimal solution to this linear program can never win more voters
    than there actually are in the district.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章开头的政治问题中，存在对应于赢得更多选民的可行解。例如，您可以将 *x*[2] 设为200，*x*[3] 设为200，*x*[1] = *x*[4]
    = 0。那个解是可行的，但似乎表明您将赢得40万郊区选民，即使实际上只有20万郊区选民。您可以添加哪些约束条件到线性规划中，以确保您永远不会赢得比实际选民更多的选民？即使您不添加这些约束条件，也要论证这个线性规划的最优解永远不会赢得比实际选民更多的选民。
- en: '[**29.2    Formulating problems as linear programs**](toc.xhtml#Rh1-168)'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[**29.2    将问题制定为线性规划**](toc.xhtml#Rh1-168)'
- en: 'Linear programming has many applications. Any textbook on operations research
    is filled with examples of linear programming, and linear programming has become
    a standard tool taught to students in most business schools. The election scenario
    is one typical example. Here are two more examples:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 线性规划有许多应用。运筹学的任何教科书都充满了线性规划的例子，线性规划已成为大多数商学院学生学习的标准工具。选举场景是一个典型的例子。以下是另外两个例子：
- en: An airline wishes to schedule its flight crews. The Federal Aviation Administration
    imposes several constraints, such as limiting the number of consecutive hours
    that each crew member can work and insisting that a particular crew work only
    on one model of aircraft during each month. The airline wants to schedule crews
    on all of its flights using as few crew members as possible.
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一家航空公司希望安排其飞行机组。联邦航空管理局设定了几个限制条件，例如限制每位机组成员连续工作的小时数，并坚持要求特定机组在每个月只在一种飞机型号上工作。航空公司希望在尽可能少的机组成员的情况下为其所有航班安排机组。
- en: An oil company wants to decide where to drill for oil. Siting a drill at a particular
    location has an associated cost and, based on geological surveys, an expected
    payoff of some number of barrels of oil. The company has a limited budget for
    locating new drills and wants to maximize the amount of oil it expects to find,
    given this budget.
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一家石油公司想决定在哪里钻探石油。在特定位置设置钻井有相关成本，并且根据地质调查，预期的回报是一定数量的桶石油。公司对于确定新钻井位置的预算有限，并希望在给定预算的情况下最大化预期发现的石油量。
- en: Linear programs also model and solve graph and combinatorial problems, such
    as those appearing in this book. We have already seen a special case of linear
    programming used to solve systems of difference constraints in [Section 22.4](chapter022.xhtml#Sec_22.4).
    In this section, we’ll study how to formulate several graph and network-flow problems
    as linear programs. [Section 35.4](chapter035.xhtml#Sec_35.4) uses linear programming
    as a tool to find an approximate solution to another graph problem.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 线性规划还可以对图和组合问题进行建模和求解，例如本书中出现的问题。我们已经看到线性规划的特殊情况用于解决[第22.4节](chapter022.xhtml#Sec_22.4)中的差分约束系统。在本节中，我们将学习如何将几个图和网络流问题表述为线性规划。[第35.4节](chapter035.xhtml#Sec_35.4)使用线性规划作为工具来找到另一个图问题的近似解。
- en: Perhaps the most important aspect of linear programming is to be able to recognize
    when you can formulate a problem as a linear program. Once you cast a problem
    as a polynomial-sized linear program, you can solve it in polynomial time by the
    ellipsoid algorithm or interior-point methods. Several linear-programming software
    packages can solve problems efficiently, so that once the problem is in the form
    of a linear program, such a package can solve it.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 线性规划最重要的一点也许是能够识别何时可以将问题表述为线性规划。一旦你将问题转化为多项式大小的线性规划，你就可以通过椭球算法或内点方法在多项式时间内解决它。几个线性规划软件包可以高效地解决问题，因此一旦问题以线性规划的形式出现，这样的软件包就可以解决它。
- en: 'We’ll look at several concrete examples of linear-programming problems. We
    start with two problems that we have already studied: the single-source shortest-paths
    problem from [Chapter 22](chapter022.xhtml) and the maximum-flow problem from
    [Chapter 24](chapter024.xhtml). We then describe the minimum-cost-flow problem.
    (Although the minimum-cost-flow problem has a polynomial-time algorithm that is
    not based on linear programming, we won’t describe the algorithm.) Finally, we
    describe the multicommodity-flow problem, for which the only known polynomial-time
    algorithm is based on linear programming.'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将看几个具体的线性规划问题示例。我们从已经学过的两个问题开始：来自[第22章](chapter022.xhtml)的单源最短路径问题和来自[第24章](chapter024.xhtml)的最大流问题。然后我们描述最小费用流问题。（尽管最小费用流问题有一个不基于线性规划的多项式时间算法，我们不会描述这个算法。）最后，我们描述多商品流问题，对于这个问题，唯一已知的多项式时间算法是基于线性规划的。
- en: When we solved graph problems in [Part VI](part006.xhtml), we used attribute
    notation, such as *v*.*d* and (*u*, *v*).*f*. Linear programs typically use subscripted
    variables rather than objects with attached attributes, however. Therefore, when
    we express variables in linear programs, we indicate vertices and edges through
    subscripts. For example, we denote the shortest-path weight for vertex *v* not
    by *v*.*d* but by *d[v]*, and we denote the flow from vertex *u* to vertex *v*
    not by (*u*, *v*).*f* but by *f[uv]*. For quantities that are given as inputs
    to problems, such as edge weights or capacities, we continue to use notations
    such as *w*(*u*, *v*) and *c*(*u*, *v*).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在[第六部分](part006.xhtml)解决图问题时，我们使用属性表示法，如*v*.*d*和(*u*, *v*).*f*。然而，线性规划通常使用带下标的变量而不是带附加属性的对象。因此，当我们在线性规划中表示变量时，我们通过下标表示顶点和边。例如，我们用*d[v]*表示顶点*v*的最短路径权重，而不是*v*.*d*，我们用*f[uv]*表示从顶点*u*到顶点*v*的流量，而不是(*u*,
    *v*).*f*。对于作为问题输入的数量，如边权重或容量，我们继续使用*w*(*u*, *v*)和*c*(*u*, *v*)等符号。
- en: '**Shortest paths**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**最短路径**'
- en: We can formulate the single-source shortest-paths problem as a linear program.
    We’ll focus on how to formulate the single-pair shortest-path problem, leaving
    the extension to the more general single-source shortest-paths problem as Exercise
    29.2-2.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可���将单源最短路径问题表述为线性规划。我们将重点放在如何将单对最短路径问题表述，将更一般的单源最短路径问题的扩展作为练习29.2-2。
- en: 'In the single-pair shortest-path problem, the input is a weighted, directed
    graph *G* = (*V*, *E*), with weight function *w* : *E* → ℝ mapping edges to real-valued
    weights, a source vertex *s*, and destination vertex *t*. The goal is to compute
    the value *d[t]*, which is the weight of a shortest path from *s* to *t*. To express
    this problem as a linear program, you need to determine a set of variables and
    constraints that define when you have a shortest path from *s* to *t*. The triangle
    inequality (Lemma 22.10 on page 633) gives *d[v]* ≤ *d[u]* + *w*(*u*, *v*) for
    each edge (*u*, *v*) ∈ *E*. The source vertex initially receives a value *d[s]*
    = 0, which never changes. Thus the following linear program expresses the shortest-path
    weight from *s* to *t*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在单对最短路径问题中，输入是一个带权重的有向图*G* = (*V*, *E*)，权重函数*w*：*E* → ℝ将边映射到实值权重，源顶点*s*和目标顶点*t*。目标是计算值*d[t]*，即从*s*到*t*的最短路径的权重。要将这个问题表述为线性规划，你需要确定一组变量和约束条件，定义何时有从*s*到*t*的最短路径。三角不等式（第22.10页的引理）给出*d[v]*
    ≤ *d[u]* + *w*(*u*, *v*)对于每条边(*u*, *v*) ∈ *E*。源顶点最初接收值*d[s]* = 0，这个值永远不会改变。因此，以下线性规划表达了从*s*到*t*的最短路径权重：
- en: '![art](images/Art_P995.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P995.jpg)'
- en: subject to
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 满足
- en: '![art](images/Art_P996.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P996.jpg)'
- en: 'You might be surprised that this linear program maximizes an objective function
    when it is supposed to compute shortest paths. Minimizing the objective function
    would be a mistake, because when all the edge weights are nonnegative, setting
    *d[v]* = 0 for all *v* ∈ *V* (recall that a bar over a variable name denotes a
    specific setting of the variable’s value) would yield an optimal solution to the
    linear program without solving the shortest-paths problem. Maximizing is the right
    thing to do because an optimal solution to the shortest-paths problem sets each
    *d[v]* to min {*d[u]* + *w*(*u*, *v*) : *u* ∈ *V* and (*u*, *v*) ∈ *E*}, so that
    *d[v]* is the largest value that is less than or equal to all of the values in
    the set {*d[u]* + *w*(*u*, *v*). Therefore, it makes sense to maximize *d[v]*
    for all vertices *v* on a shortest path from *s* to *t* subject to these constraints,
    and maximizing *d[t]* achieves this goal.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会惊讶，这个线性程序在计算最短路径时最大化了一个目标函数。最小化目标函数将是一个错误，因为当所有边的权重都是非负时，为所有*v* ∈ *V*设置*d[v]*
    = 0（请记住，变量名上的横线表示变量值的特定设置）将得到线性程序的最优解，而无需解决最短路径问题。最大化是正确的做法，因为最短路径问题的最优解将每个*d[v]*
    设置为min {*d[u]* + *w*(*u*, *v*)：*u* ∈ *V*且(*u*, *v*) ∈ *E*，使得*d[v]*是小于或等于集合{*d[u]*
    + *w*(*u*, *v*)}中所有值的最大值。因此，对于从*s*到*t*的最短路径上的所有顶点*v*，在这些约束条件下最大化*d[v]*是有意义的，而最大化*d[t]*可以实现这一目标。
- en: 'This linear program has |*V*| variables *d[v]*, one for each vertex *v* ∈ *V*.
    It also has |*E*| + 1 constraints: one for each edge, plus the additional constraint
    that the source vertex’s shortest-path weight always has the value 0.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这个线性程序有|*V*|个变量*d[v]*，每个顶点*v* ∈ *V*一个。它还有|*E*| + 1个约束：每条边一个，再加上源顶点的最短路径权重始终为0的额外约束。
- en: '**Maximum flow**'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '**最大流**'
- en: 'Next, let’s express the maximum-flow problem as a linear program. Recall that
    the input is a directed graph *G* = (*V*, *E*) in which each edge (*u*, *v*) ∈
    *E* has a nonnegative capacity *c*(*u*, *v*) ≥ 0, and two distinguished vertices:
    a source *s* and a sink *t*. As defined in [Section 24.1](chapter024.xhtml#Sec_24.1),
    a flow is a nonnegative real-valued function *f* : *V* × *V* → ℝ that satisfies
    the capacity constraint and flow conservation. A maximum flow is a flow that satisfies
    these constraints and maximizes the flow value, which is the total flow coming
    out of the source minus the total flow into the source. A flow, therefore, satisfies
    linear constraints, and the value of a flow is a linear function. Recalling also
    that we assume that *c*(*u*, *v*) = 0 if (*u*, *v*) ∉ *E* and that there are no
    antiparallel edges, the maximum-flow problem can be expressed as a linear program:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将最大流问题表达为一个线性程序。回想一下，输入是一个有向图*G* = (*V*, *E*)，其中每条边(*u*, *v*) ∈ *E*具有非负容量*c*(*u*,
    *v*) ≥ 0，并且有两个特殊的顶点：源*s*和汇*t*。如[第24.1节](chapter024.xhtml#Sec_24.1)中定义的，流是一个满足容量约束和流量守恒的非负实值函数*f*：*V*
    × *V* �� ℝ。最大流是满足这些约束并最大化流值的流，即源顶点流出的总流量减去源顶点流入的总流量。因此，流满足线性约束，流的值是一个线性函数。还要记住，我们假设如果(*u*,
    *v*) ∉ *E*，则*c*(*u*, *v*) = 0，并且没有反向边，最大流问题可以表示为一个线性程序：
- en: '![art](images/Art_P997.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P997.jpg)'
- en: subject to
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 满足
- en: '![art](images/Art_P998.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P998.jpg)'
- en: This linear program has |*V*|² variables, corresponding to the flow between
    each pair of vertices, and it has 2 |*V*|² + |*V*| − 2 constraints.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这个线性程序有|*V*|²个变量，对应于每对顶点之间的流量，并且有2|*V*|² + |*V*| − 2个约束。
- en: It is usually more efficient to solve a smaller-sized linear program. The linear
    program in (29.25)–(29.28) has, for ease of notation, a flow and capacity of 0
    for each pair of vertices *u*, *v* with (*u*, *v*) ∉ *E*. It is more efficient
    to rewrite the linear program so that it has *O*(*V* + *E*) constraints. Exercise
    29.2-4 asks you to do so.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 解决一个规模较小的线性程序通常更有效。为了简化表示，线性程序(29.25)–(29.28)中对于每对顶点*u*, *v*，如果(*u*, *v*) ∉
    *E*，则流量和容量均为0。将线性程序重写为具有*O*(*V* + *E*)个约束更为高效。练习29.2-4要求你这样做。
- en: '**Minimum-cost flow**'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '**最小成本流**'
- en: In this section, we have used linear programming to solve problems for which
    we already knew efficient algorithms. In fact, an efficient algorithm designed
    specifically for a problem, such as Dijkstra’s algorithm for the single-source
    shortest-paths problem, will often be more efficient than linear programming,
    both in theory and in practice.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们已经使用线性规划来解决我们已经知道有效算法的问题。事实上，专门为问题设计的高效算法，例如单源最短路径问题的Dijkstra算法，通常在理论和实践中都比线性规划更有效。
- en: The real power of linear programming comes from the ability to solve new problems.
    Recall the problem faced by the politician in the beginning of this chapter. The
    problem of obtaining a sufficient number of votes, while not spending too much
    money, is not solved by any of the algorithms that we have studied in this book,
    yet it can be solved by linear programming. Books abound with such real-world
    problems that linear programming can solve. Linear programming is also particularly
    useful for solving variants of problems for which we may not already know of an
    efficient algorithm.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 线性规划的真正力量来自于解决新问题的能力。回想一下本章开头政治家面临的问题。在不花费太多钱的情况下获得足够的选票，这个问题并不是我们在本书中研究的任何算法所能解决的，但它可以通过线性规划来解决。书中充斥着线性规划可以解决的这类现实世界问题。线性规划对于解决我们可能尚不知道有效算法的问题的变体也特别有用。
- en: '![art](images/Art_P999.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P999.jpg)'
- en: '**Figure 29.3 (a)** An example of a minimum-cost-flow problem. Capacities are
    denoted by *c* and costs by *a*. Vertex *s* is the source, and vertex *t* is the
    sink. The goal is to send 4 units of flow from *s* to *t*. **(b)** A solution
    to the minimum-cost flow problem in which 4 units of flow are sent from *s* to
    *t*. For each edge, the flow and capacity are written as flow/capacity.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 29.3（a）** 最小成本流问题的示例。容量用*c*表示，成本用*a*表示。顶点*s*是源，顶点*t*是汇。目标是从*s*发送4个单位的流到*t*。**(b)**
    最小成本流问题的解决方案，其中从*s*到*t*发送了4个单位的流。对于每条边，流量和容量写为流量/容量。'
- en: Consider, for example, the following generalization of the maximum-flow problem.
    Suppose that, in addition to a capacity *c*(*u*, *v*) for each edge (*u*, *v*),
    you are given a real-valued cost *a*(*u*, *v*). As in the maximum-flow problem,
    assume that *c*(*u*, *v*) = 0 if (*u*, *v*) ∉ *E* and that there are no antiparallel
    edges. If you send *f[uv]* units of flow over edge (*u*, *v*), you incur a cost
    of *a*(*u*, *v*) · *f[uv]*. You are also given a flow demand *d*. You wish to
    send *d* units of flow from *s* to *t* while minimizing the total cost ∑[(*u*,*v*)∈*E*] *a*(*u*,
    *v*) · *f[uv]* incurred by the flow. This problem is known as the ***minimum-cost-flow
    problem***.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑最大流问题的以下推广。假设除了每条边(*u*, *v*)的容量*c*(*u*, *v*)之外，还给定了实值成本*a*(*u*, *v*)。与最大流问题一样，假设如果(*u*,
    *v*) ∉ *E*，则*c*(*u*, *v*) = 0，并且没有反向边。如果在边(*u*, *v*)上发送*f[uv]*单位的流，则会产生成本*a*(*u*,
    *v*) · *f[uv]*。还给定了流需求*d*。您希望在从*s*到*t*发送*d*单位的流的同时，最小化流产生的总成本∑[(*u*,*v*)∈*E*] *a*(*u*,
    *v*) · *f[uv]*。这个问题被称为***最小成本流问题***。
- en: '[Figure 29.3(a)](chapter029.xhtml#Fig_29-3) shows an example of the minimum-cost-flow
    problem, with a goal of sending 4 units of flow from *s* to *t* while incurring
    the minimum total cost. Any particular legal flow, that is, a function *f* satisfying
    constraints (29.26)–(29.28), incurs a total cost of ∑[(*u*,*v*)∈*E*] *a*(*u*,
    *v*) · *f[uv]*. What is the particular 4-unit flow that minimizes this cost? [Figure
    29.3(b)](chapter029.xhtml#Fig_29-3) shows an optimal solution, with total cost
    ∑[(*u*,*v*)∈*E*] *a*(*u*, *v*) · *f[uv]* = (2 · 2) + (5 · 2) + (3 · 1) + (7 ·
    1) + (1 · 3) = 27.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[图29.3（a）](chapter029.xhtml#Fig_29-3)展示了最小成本流问题的一个示例，目标是在产生最小总成本的情况下从*s*发送4个单位的流到*t*。任何特定的合法流，即满足约束条件(29.26)–(29.28)的函数*f*，产生的总成本为∑[(*u*,*v*)∈*E*] *a*(*u*,
    *v*) · *f[uv]*。什么样的4单位流可以使这个成本最小化？[图29.3（b）](chapter029.xhtml#Fig_29-3)展示了一个最优解，总成本∑[(*u*,*v*)∈*E*] *a*(*u*,
    *v*) · *f[uv]* = (2 · 2) + (5 · 2) + (3 · 1) + (7 · 1) + (1 · 3) = 27。'
- en: 'There are polynomial-time algorithms specifically designed for the minimum-cost-flow
    problem, but they are beyond the scope of this book. The minimum-cost-flow problem
    can be expressed as a linear program, however. The linear program looks similar
    to the one for the maximum-flow problem with the additional constraint that the
    value of the flow must be exactly *d* units, and with the new objective function
    of minimizing the cost:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 有专门设计用于最小成本流问题的多项式时间算法，但这超出了本书的范围。然而，最小成本流问题可以表示为线性规划。线性规划看起来类似于最大流问题的线性规划，但有一个额外的约束条件，即流的值必须恰好为*d*单位，并且具有新的最小化成本的目标函数：
- en: '![art](images/Art_P1000.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1000.jpg)'
- en: subject to
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 受限于
- en: '![art](images/Art_P1001.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1001.jpg)'
- en: '**Multicommodity flow**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**多商品流**'
- en: As a final example, let’s consider another flow problem. Suppose that the Lucky
    Puck company from [Section 24.1](chapter024.xhtml#Sec_24.1) decides to diversify
    its product line and ship not only hockey pucks, but also hockey sticks and hockey
    helmets. Each piece of equipment is manufactured in its own factory, has its own
    warehouse, and must be shipped, each day, from factory to warehouse. The sticks
    are manufactured in Vancouver and are needed in Saskatoon, and the helmets are
    manufactured in Edmonton and must be shipped to Regina. The capacity of the shipping
    network does not change, however, and the different items, or ***commodities***,
    must share the same network.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个例子，让我们考虑另一个流问题。假设幸运冰球公司从[第24.1节](chapter024.xhtml#Sec_24.1)决定多样化其产品线，不仅运送冰球，还要运送冰球棍和冰球头盔。每种设备在自己的工厂制造，有自己的仓库，并且每天必须从工厂运送到仓库。冰球棍在温哥华制造，需要在萨斯卡通使用，头盔在埃德蒙顿制造，必须运送到里贾纳。然而，运输网络的容量不会改变，不同的物品，或***商品***，必须共享同一网络。
- en: 'This example is an instance of a ***multicommodity-flow problem***. The input
    to this problem is once again a directed graph *G* = (*V*, *E*) in which each
    edge (*u*, *v*) ∈ *E* has a nonnegative capacity *c*(*u*, *v*) ≥ 0\. As in the
    maximum-flow problem, implicitly assume that *c*(*u*, *v*) = 0 for (*u*, *v*)
    ∉ *E* and that the graph has no antiparallel edges. In addition, there are *k*
    different commodities, *K*[1], *K*[2], … , *K[k]*, with commodity *i* specified
    by the triple *K[i]* = (*s[i]*, *t[i]*, *d[i]*). Here, vertex *s[i]* is the source
    of commodity *i*, vertex *t[i]* is the sink of commodity *i*, and *d[i]* is the
    demand for commodity *i*, which is the desired flow value for the commodity from
    *s[i]* to *t[i]*. We define a flow for commodity *i*, denoted by *f[i]*, (so that
    *f[iuv]* is the flow of commodity *i* from vertex *u* to vertex *v*) to be a real-valued
    function that satisfies the flow-conservation and capacity constraints. We define
    *f[uv]*, the ***aggregate flow***, to be the sum of the various commodity flows,
    so that ![art](images/Art_P1002.jpg). The aggregate flow on edge (*u*, *v*) must
    be no more than the capacity of edge (*u*, *v*). This problem has no objective
    function: the question is to determine whether such a flow exists. Thus the linear
    program for this problem has a “null” objective function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子是一个***多商品流问题***的实例。这个问题的输入再次是一个有向图*G* = (*V*, *E*)，其中每条边(*u*, *v*) ∈ *E*具有非负容量*c*(*u*,
    *v*) ≥ 0。与最大流问题一样，隐含地假设对于(*u*, *v*) ∉ *E*，*c*(*u*, *v*) = 0，并且图中没有反向边。此外，有*k*个不同的商品，*K*[1],
    *K*[2], … , *K[k]*，其中商品*i*由三元组*K[i]* = (*s[i]*, *t[i]*, *d[i]*)指定。这里，顶点*s[i]*是商品*i*的源点，顶点*t[i]*是商品*i*的汇点，*d[i]*是商品*i*的需求，即从*s[i]*到*t[i]*的商品所需的流量值。我们定义商品*i*的流量，记为*f[i]*，(所以*f[iuv]*是从顶点*u*到顶点*v*的商品*i*的流量)，是满足流量守恒和容量约束的实值函数。我们定义*F[uv]*，***总流量***，为各种商品流量的总和，使得![艺术](images/Art_P1002.jpg)。边(*u*,
    *v*)上的总流量不能超过边(*u*, *v*)的容量。这个问题没有目标函数：问题是确定是否存在这样的流。因此，这个问题的线性规划有一个“空”目标函数：
- en: '![art](images/Art_P1003.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1003.jpg)'
- en: The only known polynomial-time algorithm for this problem expresses it as a
    linear program and then solves it with a polynomial-time linear-programming algorithm.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的唯一已知多项式时间算法将其表达为一个线性规划，然后用一个多项式时间的线性规划算法来解决。
- en: '**Exercises**'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***29.2-1***'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.2-1***'
- en: Write out explicitly the linear program corresponding to finding the shortest
    path from vertex *s* to vertex *x* in [Figure 22.2(a)](chapter022.xhtml#Fig_22-2)
    on page 609.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 明确写出对应于在[图22.2(a)](chapter022.xhtml#Fig_22-2)第609页上找到从顶点*s*到顶点*x*的最短路径的线性规划。
- en: '***29.2-2***'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.2-2***'
- en: Given a graph *G*, write a linear program for the single-source shortest-paths
    problem. The solution should have the property that *d[v]* is the shortest-path
    weight from the source vertex *s* to *v* for each vertex *v* ∈ *V*.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个图*G*，为单源最短路径问题写出一个线性规划。解应该具有这样的性质，即对于每个顶点*v* ∈ *V*，*d[v]*是从源顶点*s*到*v*的最短路径权重。
- en: '***29.2-3***'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.2-3***'
- en: Write out explicitly the linear program corresponding to finding the maximum
    flow in [Figure 24.1(a)](chapter024.xhtml#Fig_24-1).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 明确写出对应于在[图24.1(a)](chapter024.xhtml#Fig_24-1)中找到最大流的线性规划。
- en: '***29.2-4***'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.2-4***'
- en: Rewrite the linear program for maximum flow (29.25)–(29.28) so that it uses
    only *O*(*V* + *E*) constraints.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 重写最大流的线性规划(29.25)–(29.28)，使其只使用*O*(*V* + *E*)个约束。
- en: '***29.2-5***'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.2-5***'
- en: Write a linear program that, given a bipartite graph *G* = (*V*, *E*), solves
    the maximum-bipartite-matching problem.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 写出一个线性规划，给定一个二分图*G* = (*V*, *E*)，解决最大二分匹配问题。
- en: '***29.2-6***'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.2-6***'
- en: There can be more than one way to model a particular problem as a linear program.
    This exercise gives an alternative formulation for the maximum-flow problem. Let
    *P* = {*P*[1], *P*[2], … , *P[p]*} be the set of *all* possible directed simple
    paths from source *s*  to sink *t*. Using decision variables *x*[1], … , *x[p]*,
    where *x[i]* is the amount of flow on path *i*, formulate a linear program for
    the maximum-flow problem. What is an upper bound on *p*, the number of directed
    simple paths from *s* to *t*?
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个特定问题，可能有多种建模为线性规划的方式。这个练习为最大流问题提供了另一种表述。设*P* = {*P*[1], *P*[2], … , *P[p]*}为从源点*s*到汇点*t*的*所有*可能的有向简单路径集合。使用决策变量*x*[1],
    … , *x[p]*，其中*x[i]*是路径*i*上的流量量，为最大流问题制定一个线性规划。有多少个从*s*到*t*的有向简单路径*p*的上界是多少？
- en: '***29.2-7***'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.2-7***'
- en: In the ***minimum-cost multicommodity-flow problem***, the input is a directed
    graph *G* = (*V*, *E*) in which each edge (*u*, *v*) ∈ *E* has a nonnegative capacity
    *c*(*u*, *v*) ≥ 0 and a cost *a*(*u*, *v*). As in the multicommodity-flow problem,
    there are *k* different commodities, *K*[1], *K*[2], … , *K[k]*, with commodity
    *i* specified by the triple *K[i]* = (*s[i]*, *t[i]*, *d[i]*). We define the flow
    *f[i]* for commodity *i* and the aggregate flow *f[uv]* on edge (*u*, *v*) as
    in the multicommodity-flow problem. A feasible flow is one in which the aggregate
    flow on each edge (*u*, *v*) is no more than the capacity of edge (*u*, *v*).
    The cost of a flow is ∑[*u*,*v*∈*E*] *a*(*u*, *v*) · *f[uv]*, and the goal is
    to find the feasible flow of minimum cost. Express this problem as a linear program.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在***最小成本多商品流问题***中，输入是一个有向图*G* = (*V*, *E*)，其中每条边(*u*, *v*) ∈ *E*具有非负容量*c*(*u*,
    *v*) ≥ 0和成本*a*(*u*, *v*)。与多商品流问题一样，有*k*个不同的商品，*K*[1], *K*[2], … , *K[k]*，其中商品*i*由三元组*K[i]*
    = (*s[i]*, *t[i]*, *d[i]*)指���。我们定义商品*i*的流量*f[i]*和边(*u*, *v*)上的总流量*f[uv]*与多商品流问题中的定义相同。可行流是每条边(*u*,
    *v*)上的总流量不超过边(*u*, *v*)的容量。流的成本是∑[*u*,*v*∈*E*] *a*(*u*, *v*) · *f[uv]*，目标是找到最小成本的可行流。将这个问题表达为一个线性规划。
- en: '[**29.3    Duality**](toc.xhtml#Rh1-169)'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '[**29.3    对偶性**](toc.xhtml#Rh1-169)'
- en: We will now introduce a powerful concept called ***linear-programming duality***.
    In general, given a maximization problem, duality allows you to formulate a related
    minimization problem that has the same objective value. The idea of duality is
    actually more general than linear programming, but we restrict our attention to
    linear programming in this section.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将介绍一个强大的概念，称为***线性规划对偶性***。一般来说，给定一个最大化问题，对偶性允许您制定一个相关的最小化问题，其目标值相同。对偶性的概念实际上比线性规划更一般化，但在本节中我们将注意力限制在线性规划上。
- en: 'Duality enables us to prove that a solution is indeed optimal. We saw an example
    of duality in [Chapter 24](chapter024.xhtml) with Theorem 24.6, the max-flow min-cut
    theorem. Suppose that, given an instance of a maximum-flow problem, you find a
    flow *f* with value |*f*|. How do you know whether *f* is a maximum flow? By the
    max-flow min-cut theorem, if you can find a cut whose value is also |*f*|, then
    you have verified that *f* is indeed a maximum flow. This relationship provides
    an example of duality: given a maximization problem, define a related minimization
    problem such that the two problems have the same optimal objective values.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 对偶性使我们能够证明解决方案确实是最优的。我们在[第24章](chapter024.xhtml)中看到了对偶的一个例子，即定理24.6，最大流最小割定理。假设给定一个最大流问题的实例，您找到一个值为|*f*|的流*f*。您如何知道*f*是否是最大流？通过最大流最小割定理，如果您可以找到一个值也为|*f*|的割，则您已经验证了*f*确实是最大流。这种关系提供了对偶的一个例子：给定一个最大化问题，定义一个相关的最小化问题，使得这两个问题具有相同的最优目标值。
- en: Given a linear program in standard form in which the objective is to maximize,
    let’s see how to formulate a ***dual*** linear program in which the objective
    is to minimize and whose optimal value is identical to that of the original linear
    program. When referring to dual linear programs, we call the original linear program
    the ***primal***.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在标准形式的线性规划中，目标是最大化，让我们看看如何制定一个***对偶***线性规划，其目标是最小化，其最优值与原始线性规划相同。在提到对偶线性规划时，我们称原始线性规划为***原始***。
- en: Given the primal linear program
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 给定原始线性规划
- en: '![art](images/Art_P1004.jpg)'
  id: totrans-170
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1004.jpg)'
- en: subject to
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 以及
- en: '![art](images/Art_P1005.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1005.jpg)'
- en: its dual is
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 其对偶是
- en: '![art](images/Art_P1006.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1006.jpg)'
- en: subject to
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 以及
- en: '![art](images/Art_P1007.jpg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1007.jpg)'
- en: 'Mechanically, to form the dual, change the maximization to a minimization,
    exchange the roles of coefficients on the right-hand sides and in the objective
    function, and replace each ≤ by ≥. Each of the *m* constraints in the primal corresponds
    to a variable *y[i]* in the dual. Likewise, each of the *n* constraints in the
    dual corresponds to a variable *x[j]* in the primal. For example, consider the
    following primal linear program:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 机械地，为了形成对偶问题，将最大化改为最小化，交换右侧系数和目标函数中的角色，并将每个≤替换为≥。原始中的*m*个约束条件中的每一个对应于对偶中的变量*y[i]*。同样，对偶中的*n*个约束条件中的每一个对应于原始中的变量*x[j]*。例如，考虑以下原始线性规划：
- en: '![art](images/Art_P1008.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1008.jpg)'
- en: subject to
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 以及
- en: '![art](images/Art_P1009.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1009.jpg)'
- en: Its dual is
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 其对偶是
- en: '![art](images/Art_P1010.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1010.jpg)'
- en: subject to
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 以及
- en: '![art](images/Art_P1011.jpg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1011.jpg)'
- en: Although forming the dual can be considered a mechanical operation, there is
    an intuitive explanation. Consider the primal maximization problem (29.37)–(29.41).
    Each constraint gives an upper bound on the objective function. In addition, if
    you take one or more constraints and add together nonnegative multiples of them,
    you get a valid constraint. For example, you can add constraints (29.38) and (29.39)
    to obtain the constraint 3*x*[1] + 3*x*[2] + 8*x*[3] ≤ 54\. Any feasible solution
    to the primal must satisfy this new constraint, but there is something else interesting
    about it. Comparing this new constraint to the objective function (29.37), you
    can see that for each variable, the corresponding coefficient is at least as large
    as the coefficient in the objective function. Thus, since the variables *x*[1],
    *x*[2] and *x*[3] are nonnegative, we have that
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管形成对偶可以被认为是一个机械操作，但有一个直观的解释。考虑原始最大化问题(29.37)–(29.41)。每个约束条件都给出了目标函数的上界。此外，如果您取一个或多个约束条件，并将它们的非负倍数相加，您将得到一个有效的约束条件。例如，您可以将约束条件(29.38)和(29.39)相加，得到约束条件3*x*[1]
    + 3*x*[2] + 8*x*[3] ≤ 54。原始问题的任何可行解都必须满足这个新约束条件，但它还有其他有趣的地方。将这个新约束条件与目标函数(29.37)进行比较，您会发现对于每个变量，相应的系数至少与目标函数中的系数一样大。因此，由于变量*x*[1]、*x*[2]和*x*[3]*是非负的，我们有
- en: 3*x*[1] + *x*[2] + 4*x*[3] ≤ 3*x*[1] + 3*x*[2] + 8*x*[3] ≤ 54,
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 3*x*[1] + *x*[2] + 4*x*[3] ≤ 3*x*[1] + 3*x*[2] + 8*x*[3] ≤ 54,
- en: and so the solution value to the primal is at most 54\. In other words, adding
    these two constraints together has generated an upper bound on the objective value.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，原始问题的解决方案值最多为54。换句话说，将这两个约束条件相加产生了目标值的上界。
- en: In general, for any nonnegative multipliers *y*[1], *y*[2], and *y*[3], you
    can generate a constraint
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，对于任何非负乘数*y*[1]、*y*[2]和*y*[3]，您可以生成一个约束条件
- en: '*y*[1](*x*[1]+*x*[2]+3*x*[3])+*y*[2](2*x*[1]+2*x*[2]+5*x*[3])+*y*[3](4*x*[1]+*x*[2]+2*x*[3])
    ≤ 30*y*[1]+24*y*[2]+36*y*[3]'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*[1](*x*[1]+*x*[2]+3*x*[3])+*y*[2](2*x*[1]+2*x*[2]+5*x*[3])+*y*[3](4*x*[1]+*x*[2]+2*x*[3])
    ≤ 30*y*[1]+24*y*[2]+36*y*[3]'
- en: from the primal constraints or, by distributing and regrouping,
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 从原始约束条件或者通过分配和重新分组，
- en: (*y*[1]+2*y*[2]+4*y*[3])*x*[1]+(*y*[1]+2*y*[2]+*y*[3])*x*[2]+(3*y*[1]+5*y*[2]+2*y*[3])*x*[3]
    ≤ 30*y*[1]+24*y*[2]+36*y*[3].
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: (*y*[1]+2*y*[2]+4*y*[3])*x*[1]+(*y*[1]+2*y*[2]+*y*[3])*x*[2]+(3*y*[1]+5*y*[2]+2*y*[3])*x*[3]
    ≤ 30*y*[1]+24*y*[2]+36*y*[3].
- en: Now, as long as this constraint has coefficients of *x*[1], *x*[2], and *x*[3]
    that are at least their objective-function coefficients, it is a valid upper bound.
    That is, as long as
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，只要这个约束条件的系数*x*[1]、*x*[2]和*x*[3]*至少与它们的目标函数系数一样大，它就是一个有效的上界。也就是说，只要
- en: '| *y*[1] + 2*y*[2] + 4*y*[3] | ≥ | 3, |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| *y*[1] + 2*y*[2] + 4*y*[3] | ≥ | 3, |'
- en: '| *y*[1] + 2*y*[2] + *y*[3] | ≥ | 1, |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| *y*[1] + 2*y*[2] + *y*[3] | ≥ | 1, |'
- en: '| 3*y*[1] + 5*y*[2] + 2*y*[3] | ≥ | 4, |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 3*y*[1] + 5*y*[2] + 2*y*[3] | ≥ | 4, |'
- en: you have a valid upper bound of 30*y*[1]+24*y*[2]+36*y*[3]. The multipliers
    *y*[1], *y*[2], and *y*[3] must be nonnegative, because otherwise you cannot combine
    the inequalities. Of course, you would like the upper bound to be as small as
    possible, and so you want to choose *y* to minimize 30*y*[1] + 24*y*[2] + 36*y*[3].
    Observe that we have just described the dual linear program as the problem of
    finding the smallest possible upper bound on the primal.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个有效的上界30*y*[1]+24*y*[2]+36*y*[3]。乘数*y*[1]、*y*[2]和*y*[3]必须是非负的，否则你无法组合这些不等式。当然，你希望上界尽可能小，因此你想选择*y*以最小化30*y*[1]
    + 24*y*[2] + 36*y*[3]。请注意，我们刚刚描述了对偶线性规划，即寻找原始问题��小可能上界的问题。
- en: We’ll formalize this idea and show in Theorem 29.4 that, if the linear program
    and its dual are feasible and bounded, then the optimal value of the dual linear
    program is always equal to the optimal value of the primal linear program. We
    begin by demonstrating ***weak duality***, which states that any feasible solution
    to the primal linear program has a value no greater than that of any feasible
    solution to the dual linear program.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将形式化这个想法，并在定理29.4中展示，如果线性规划及其对偶问题都是可行且有界的，那么对偶线性规划的最优值总是等于原始线性规划的最优值。我们首先展示***弱对偶性***，它表明原始线性规划的任何可行解的值都不会超过对偶线性规划的任何可行解的值。
- en: '***Lemma 29.1 (Weak linear-programming duality)***'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理29.1（弱线性规划对偶性）***'
- en: Let *x* be any feasible solution to the primal linear program in (29.31)–(29.33),
    and let *ӯ* be any feasible solution to its dual linear program in (29.34)–(29.36).
    Then
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 设*x*是定理(29.31)–(29.33)中原始线性规划的任何可行解，*ӯ*是其对偶线性规划(29.34)–(29.36)的任何可行解。那么
- en: '![art](images/Art_P1012.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1012.jpg)'
- en: '***Proof***   We have'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   我们有'
- en: '![art](images/Art_P1013.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1013.jpg)'
- en: ▪
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Corollary 29.2***'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论29.2***'
- en: Let *x* be a feasible solution to the primal linear program in (29.31)–(29.33),
    and let *ӯ* be a feasible solution to its dual linear program in (29.34)–(29.36).
    If
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 设*x*是定理(29.31)–(29.33)中原始线性规划的可行解，*ӯ*是其对偶线性规划(29.34)–(29.36)的可行解。如果
- en: '![art](images/Art_P1014.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1014.jpg)'
- en: then *x* and *ӯ* are optimal solutions to the primal and dual linear programs,
    respectively.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 那么*x*和*ӯ*分别是原始线性规划和对偶线性规划的最优解。
- en: '***Proof***   By Lemma 29.1, the objective value of a feasible solution to
    the primal cannot exceed that of a feasible solution to the dual. The primal linear
    program is a maximization problem and the dual is a minimization problem. Thus,
    if feasible solutions *x* and *ӯ* have the same objective value, neither can be
    improved.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   根据引理29.1，原始问题的可行解的目���值不会超过对偶问题的可行解的目标值。原始线性规划是一个最大化问题，对偶是一个最小化问题。因此，如果可行解*x*和*ӯ*具有相同的目标值，则两者都无法改进。'
- en: ▪
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: We now show that, at optimality, the primal and dual objective values are indeed
    equal. To prove linear programming duality, we will require one lemma from linear
    algebra, known as Farkas’s lemma, the proof of which Problem 29-4 asks you to
    provide. Farkas’s lemma can take several forms, each of which is about when a
    set of linear equalities has a solution. In stating the lemma, we use *m* + 1
    as a dimension because it matches our use below.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在展示，在最优性时，原始和对偶的目标值确实相等。为了证明线性规划对偶性，我们将需要线性代数中的一个引理，即法尔卡斯引理，问题29-4要求您提供其证明。法尔卡斯引理可以有几种形式，每种形式都是关于一组线性等式何时有解的。在陈述引理时，我们使用*m*
    + 1作为维度，因为它与下面的用法相匹配。
- en: '***Lemma 29.3 (Farkas’s lemma)***'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理29.3（法尔卡斯引理）***'
- en: 'Given *M* ∈ ℝ^((*m*+1)×*n*) and *g* ∈ ℝ^(*m*+1), exactly one of the following
    statements is true:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 给定*M* ∈ ℝ^((*m*+1)×*n*)和*g* ∈ ℝ^(*m*+1)，以下陈述中只有一个是真的：
- en: There exists *v* ∈ ℝ*^n* such that *Mv* ≤ *g*,
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在*v* ∈ ℝ*^n*，使得*Mv* ≤ *g*，
- en: There exists *w* ∈ ℝ^(*m*+1) such that *w* ≥ 0, *w*^T*M* = 0 (an *n*-vector
    of all zeros), and *w*^Tg < 0.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在*w* ∈ ℝ^(*m*+1)，使得*w* ≥ 0，*w*^T*M* = 0（全零*n*向量），且*w*^Tg < 0。
- en: ▪
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Theorem 29.4 (Linear-programming duality)***'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理29.4（线性规划对偶性）***'
- en: Given the primal linear program in (29.31)–(29.33) and its corresponding dual
    in (29.34)–(29.36), if both are feasible and bounded, then for optimal solutions
    *x** and *y**, we have *c*^T*x** = *b*^T*y**.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 给定定理(29.31)–(29.33)中的原始线性规划及其对应的对偶问题(29.34)–(29.36)，如果两者都是可行且有界的，那么对于最优解*x*和*y*，我们有*c*^T*x*
    = *b*^T*y*。
- en: '***Proof***   Let *μ* = *b*^T*y** be the optimal value of the dual linear program
    given in (29.34)–(29.36). Consider an augmented set of primal constraints in which
    we add a constraint to (29.31)–(29.33) that the objective value is at least *μ*.
    We write out this ***augmented primal*** as'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   设*μ* = *b*^T*y*是定理(29.34)–(29.36)中对偶线性规划的最优值。考虑一个增广的原始约束集，其中我们添加一个约束到(29.31)–(29.33)，即目标值至少为*μ*。我们将这个***增广原始问题***写为'
- en: '![art](images/Art_P1015.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1015.jpg)'
- en: We can multiply (29.48) through by −1 and rewrite (29.47)–(29.48) as
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过乘以-1将(29.48)乘以-1，并将(29.47)–(29.48)重写为
- en: '![art](images/Art_P1016.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1016.jpg)'
- en: Here, ![art](images/Art_P1017.jpg) denotes an (*m*+1)×*n* matrix, *x* is an
    *n*-vector, and ![art](images/Art_P1018.jpg) denotes an (*m* + 1)-vector.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，![艺术](images/Art_P1017.jpg)表示一个(*m*+1)×*n*矩阵，*x*是一个*n*向量，![艺术](images/Art_P1018.jpg)表示一个(*m*
    + 1)-向量。
- en: We claim that if there is a feasible solution *x* to the augmented primal, then
    the theorem is proved. To establish this claim, observe that *x* is also a feasible
    solution to the original primal and that it has objective value at least *μ*.
    We can then apply Lemma 29.1, which states that the objective value of the primal
    is at most *μ*, to complete the proof of the theorem.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声称，如果增广原始问题存在可行解*x*，那么定理就被证明了。为了证明这一点，注意*x*也是原始问题的可行解，并且其目标值至少为*μ*。然后我们可以应用引理29.1，该引理表明原始问题的目标值最多为*μ*，从而完成了定理的证明。
- en: It therefore remains to show that the augmented primal has a feasible solution.
    Suppose, for the purpose of contradiction, that the augmented primal is infeasible,
    which means that there is no *v* ∈ ℝ*^n* such that ![art](images/Art_P1019.jpg).
    We can apply Farkas’s lemma, Lemma 29.3, to inequalty (29.49) with
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，剩下的是要证明增广原始问题有一个可行解。假设为了推导出矛盾，增广原始问题是不可行的，这意味着不存在*v* ∈ ℝ*^n*使得![艺术](images/Art_P1019.jpg)。我们可以应用Farkas引理，第29.3引理，将不等式(29.49)与
- en: '![art](images/Art_P1020.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1020.jpg)'
- en: Because the augmented primal is infeasible, condition 1 of Farkas’s lemma does
    not hold. Therefore, condition 2 must apply, so that there must exist a *w* ∈
    ℝ^(*m*+1) such that *w* ≥ 0, *w*^T*M* = 0, and *w*^T*g* < 0\. Let’s write *w*
    as ![art](images/Art_P1021.jpg) for some *ӯ* ∈ ℝ*^m* and *λ* ∈ ℝ, where *ӯ* ≥
    0 and *λ* ≥ 0\. Substituting for *w*, *M*, and *g* in condition 2 gives
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 因为增广原始问题是不可行的，所以Farkas引理的条件1不成立。因此，条件2必须适用，这意味着必须存在一个*w* ∈ ℝ^(*m*+1)，使得*w* ≥
    0，*w*^T*M* = 0，并且*w*^T*g* < 0。让我们将*w*写为![艺术](images/Art_P1021.jpg)对应的*ӯ* ∈ ℝ*^m*和*λ*
    ∈ ℝ，其中*ӯ* ≥ 0且*λ* ≥ 0。将条件2中的*w*，*M*和*g*代入得到
- en: '![art](images/Art_P1022.jpg)'
  id: totrans-227
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1022.jpg)'
- en: Unpacking the matrix notation gives
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 展开矩阵表示为
- en: '![art](images/Art_P1023.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1023.jpg)'
- en: We now show that the requirements in (29.50) contradict the assumption that
    *μ* is the optimal solution value for the dual linear program. We consider two
    cases.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们展示(29.50)中的要求与*μ*是对偶线性规划的最优解值的假设相矛盾。我们考虑两种情况。
- en: The first case is when *λ* = 0\. In this case, (29.50) simplifies to
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种情况是当*λ* = 0时。在这种情况下，(29.50)简化为
- en: '![art](images/Art_P1024.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1024.jpg)'
- en: We’ll now construct a dual feasible solution *y*′ with an objective value smaller
    than *b*^T*y**. Set *y*′ = *y** + *ϵ ӯ*, for any *ϵ* > 0\. Since
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将构造一个对偶可行解*y*′，其目标值小于*b*^T*y**。设*y*′ = *y** + *ϵ ӯ*，对于任意*ϵ* > 0。由于
- en: '| *y*′^T*A* | = | (*y** + *ϵ ӯ*)^T*A* |  |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| *y*′^T*A* | = | (*y** + *ϵ ӯ*)^T*A* |  |'
- en: '|  | = | *y**^T*A* + *ϵ ӯ*^T*A* |  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *y**^T*A* + *ϵ ӯ*^T*A* |  |'
- en: '|  | = | *y**^T*A* | (by (29.51)) |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *y**^T*A* | (根据(29.51)) |'
- en: '|  | ≥ | *c*^T | (because *y** is feasible), |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '|  | ≥ | *c*^T | (因为*y**是可行的), |'
- en: '*y*′ is feasible. Now consider the objective value'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*′是可行的。现在考虑目标值'
- en: '| *b*^T*y*′ | = | *b*^T(*y** + *ϵ ӯ*) |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| *b*^T*y*′ | = | *b*^T(*y** + *ϵ ӯ*) |'
- en: '|  | = | *b*^T*y** + *ϵ b*^T*ӯ* |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *b*^T*y** + *ϵ b*^T*ӯ* |'
- en: '|  | < | *b*^T*y**, |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '|  | < | *b*^T*y**, |'
- en: where the last inequality follows because *ϵ* > 0 and, by (29.51), *ӯ*^T*b*
    = *b*^T*ӯ* < 0 (since both *ӯ*^T*b* and *b*^T*ӯ* are the inner product of *b*
    and *ӯ*), and so their product is negative. Thus we have a feasible dual solution
    of value less than *μ*, which contradicts *μ* being the optimal objective value.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个不等式是因为*ϵ* > 0，并且根据(29.51)，*ӯ*^T*b* = *b*^T*ӯ* < 0（因为*ӯ*^T*b*和*b*^T*ӯ*都是*b*和*ӯ*的内积），所以它们的乘积是负的。因此，我们有一个比*μ*小的可行对偶解，这与*μ*是最优目标值相矛盾。
- en: We now consider the second case, where *λ* > 0\. In this case, we can take (29.50)
    and divide through by *λ* to obtain
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们考虑第二种情况，即*λ* > 0。在这种情况下，我们可以通过*λ*除以(29.50)得到
- en: '![art](images/Art_P1025.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1025.jpg)'
- en: Now set *y*′ = *ӯ*/*λ* in (29.52), giving
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在(29.52)中设*y*�� = *ӯ*/*λ*，得到
- en: '*y*′^T*A* = *c*^T and *y*′^T*b* < *μ*.'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '*y*′^T*A* = *c*^T 和 *y*′^T*b* < *μ*。'
- en: Thus, *y*′ is a feasible dual solution with objective value strictly less than
    *μ*, a contradiction. We conclude that the augmented primal has a feasible solution,
    and the theorem is proved.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*y*′是一个可行的对偶解，其目标值严格小于*μ*，这与事实矛盾。我们得出增广原始问题有一个可行解的结论，定理得证。
- en: ▪
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Fundamental theorem of linear programming**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性规划的基本定理**'
- en: We conclude this chapter by stating the fundamental theorem of linear programming,
    which extends Theorem 29.4 to the cases when the linear program may be either
    feasible or unbounded. Exercise 29.3-8 asks you to provide the proof.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过陈述线性规划的基本定理来结束这一章，该定理将第29.4定理扩展到线性规划可能是可行的或无界的情况。练习29.3-8要求你提供证明。
- en: '***Theorem 29.5 (Fundamental theorem of linear programming)***'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理29.5（线性规划的基本定理）***'
- en: Any linear program, given in standard form, either
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 任何给定标准形式的线性规划，要么
- en: has an optimal solution with a finite objective value,
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 具有有限目标值的最优解，
- en: is infeasible, or
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是不可行的，或者
- en: is unbounded.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是无界的。
- en: ▪
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Exercises**'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***29.3-1***'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.3-1***'
- en: Formulate the dual of the linear program given in lines (29.6)–(29.10) on page
    852.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对第852页(29.6)–(29.10)行给出的线性规划的对偶进行公式化。
- en: '***29.3-2***'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.3-2***'
- en: You have a linear program that is not in standard form. You could produce the
    dual by first converting it to standard form, and then taking the dual. It would
    be more convenient, however, to produce the dual directly. Explain how to directly
    take the dual of an arbitrary linear program.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一个不符合标准形式的线性规划。你可以通过先将其转换为标准形式，然后再求对偶来得到对偶问题。然而，直接求对偶会更方便。解释如何直接求解任意线性规划的对偶问题。
- en: '***29.3-3***'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.3-3***'
- en: Write down the dual of the maximum-flow linear program, as given in lines (29.25)–(29.28)
    on page 862\. Explain how to interpret this formulation as a minimum-cut problem.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 写出最大流线性规划的对偶，如第862页的(29.25)–(29.28)行所示。解释如何将这个公式解释为最小割问题。
- en: '***29.3-4***'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.3-4***'
- en: Write down the dual of the minimum-cost-flow linear program, as given in lines
    (29.29)–(29.30) on page 864\. Explain how to interpret this problem in terms of
    graphs and flows.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 写出最小成本流线性规划的对偶，如第864页的(29.29)–(29.30)行所示。解释如何从图和流的角度解释这个问题。
- en: '***29.3-5***'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.3-5***'
- en: Show that the dual of the dual of a linear program is the primal linear program.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 展示线性规划的对偶的对偶是原始线性规划。
- en: '***29.3-6***'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.3-6***'
- en: Which result from [Chapter 24](chapter024.xhtml) can be interpreted as weak
    duality for the maximum-flow problem?
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '[第24章](chapter024.xhtml)的哪个结果可以解释为最大流问题的弱对偶性？'
- en: '***29.3-7***'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.3-7***'
- en: 'Consider the following 1-variable primal linear program:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下一元原始线性规划：
- en: '| maximize | *tx* |  |  |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 最大化 | *tx* |  |  |'
- en: '| subject to |  |  |  |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 限制 |  |  |  |'
- en: '|  | *rx* | ≤ | *s* |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '|  | *rx* | ≤ | *s* |'
- en: '|  | *x* | ≥ | 0, |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|  | *x* | ≥ | 0, |'
- en: where *r*, *s*, and *t* are arbitrary real numbers. State for which values of
    *r*, *s*, and *t* you can assert that
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*r*、*s*和*t*是任意实数。说明在哪些*r*、*s*和*t*的值上你可以断言
- en: Both the primal linear program and its dual have optimal solutions with finite
    objective values.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始线性规划和其对偶都有有限目标值的最优解。
- en: The primal is feasible, but the dual is infeasible.
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始是可行的，但对偶是不可行的。
- en: The dual is feasible, but the primal is infeasible.
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对偶是可行的，但原始是不可行的。
- en: Neither the primal nor the dual is feasible.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始和对偶都不可行。
- en: '***29.3-8***'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '***29.3-8***'
- en: Prove the fundamental theorem of linear programming, Theorem 29.5.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 证明线性规划的基本定理，定理29.5。
- en: '**Problems**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '***29-1     Linear-inequality feasibility***'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '***29-1     线性不等式可行性***'
- en: Given a set of *m* linear inequalities on *n* variables *x*[1], *x*[2], … ,
    *x[n]*, the ***linear-inequality feasibility problem*** asks whether there is
    a setting of the variables that simultaneously satisfies each of the inequalities.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 给定*n*个变量*x*[1]、*x*[2]、…，*x[n]*上的*m*个线性不等式集合，***线性不等式可行性问题***询问是否存在一组变量设置，同时满足每个不等式。
- en: '***a.*** Given an algorithm for the linear-programming problem, show how to
    use it to solve a linear-inequality feasibility problem. The number of variables
    and constraints that you use in the linear-programming problem should be polynomial
    in *n* and *m*.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 给定线性规划问题的算法，展示如何使用它来解决线性不等式可行性问题。在线性规划问题中使用的变量和约束的数量应该是多项式*n*和*m*的。'
- en: '***b.*** Given an algorithm for the linear-inequality feasibility problem,
    show how to use it to solve a linear-programming problem. The number of variables
    and linear inequalities that you use in the linear-inequality feasibility problem
    should be polynomial in *n* and *m*, the number of variables and constraints in
    the linear program.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 给定线性不等式可行性问题的算法，展示如何使用它来解决线性规划问题。在线性不等式可行性问题中使用的变量和线性不等式的数量应该是多项式*n*和*m*的。'
- en: '***29-2     Complementary slackness***'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '***29-2     互补松弛***'
- en: '***Complementary slackness*** describes a relationship between the values of
    primal variables and dual constraints and between the values of dual variables
    and primal constraints. Let *x* be a feasible solution to the primal linear program
    given in (29.31)–(29.33), and let *ӯ* be a feasible solution to the dual linear
    program given in (29.34)–(29.36). Complementary slackness states that the following
    conditions are necessary and sufficient for *x* and *ӯ* to be optimal:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '***互补松弛***描述了原始变量值与对偶约束之间以及对偶变量值与原始约束之间的关系。设*x*是给定在(29.31)–(29.33)中的原始线性规划的可行解，*ӯ*是给定在(29.34)–(29.36)中的对偶线性规划的可行解。互补松弛表明，以下条件对于*x*和*ӯ*是最优的是必要且充分的：'
- en: '![art](images/Art_P1026.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1026.jpg)'
- en: and
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '![art](images/Art_P1027.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1027.jpg)'
- en: '***a.*** Verify that complementary slackness holds for the linear program in
    lines (29.37)–(29.41).'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 验证互补松弛对于在(29.37)–(29.41)中的线性规划成立。'
- en: '***b.*** Prove that complementary slackness holds for any primal linear program
    and its corresponding dual.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 证明任何原���线性规划及其对应对偶的互补松弛成立。'
- en: '***c.*** Prove that a feasible solution *x* to a primal linear program given
    in lines (29.31)–(29.33) is optimal if and only if there exist values *ӯ* = (*ӯ*[1],
    *ӯ*[2], … , *ӯ[m]*) such that'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 证明给定在(29.31)–(29.33)中的原始线性规划的可行解*x*是最优的当且仅当存在值*ӯ* = (*ӯ*[1]、*ӯ*[2]、…，*ӯ[m]*)使得'
- en: '*ӯ* is a feasible solution to the dual linear program given in (29.34)–(29.36),'
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*ӯ*是给定在(29.34)–(29.36)中的对偶线性规划的可行解，'
- en: '![art](images/Art_P1028.jpg) for all *j* such that *x[j]* > 0, and'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '![艺术](images/Art_P1028.jpg) 对于所有*x[j]* > 0，和'
- en: '*ӯ[i]* = 0 for all *i* such that ![art](images/Art_P1029.jpg).'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*ӯ[i]* = 0对于所有*i*使得![艺术](images/Art_P1029.jpg)。'
- en: '***29-3     Integer linear programming***'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '***29-3     整数线性规划***'
- en: An ***integer linear-programming problem*** is a linear-programming problem
    with the additional constraint that the variables *x* must take on integer values.
    Exercise 34.5-3 on page 1098 shows that just determining whether an integer linear
    program has a feasible solution is NP-hard, which means that there is no known
    polynomial-time algorithm for this problem.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '***整数线性规划问题***是带有额外约束条件的线性规划问题，即变量*x*必须取整数值。第1098页的练习34.5-3表明，仅确定整数线性规划是否有可行解就是NP难的，这意味着目前没有已知的多项式时间算法解决这个问题。'
- en: '***a.*** Show that weak duality (Lemma 29.1) holds for an integer linear program.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 证明整数线性规划的弱对偶性（引理29.1）成立。'
- en: '***b.*** Show that duality (Theorem 29.4) does not always hold for an integer
    linear program.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 证明对偶性（定理29.4）并不总是适用于整数线性规划。'
- en: '***c.*** Given a primal linear program in standard form, let *P* be the optimal
    objective value for the primal linear program, *D* be the optimal objective value
    for its dual, *IP* be the optimal objective value for the integer version of the
    primal (that is, the primal with the added constraint that the variables take
    on integer values), and *ID* be the optimal objective value for the integer version
    of the dual. Assuming that both the primal integer program and the dual integer
    program are feasible and bounded, show that'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 给定标准形式下的原始线性规划，让*P*为原始线性规划的最优目标值，*D*为其对偶的最优目标值，*IP*为原始整数版本的最优目标值（即，带有变量取整值的原始问题），*ID*为对偶整数版本的最优目标值。假设原始整数规划和对偶整数规划都是可行且有界的，证明'
- en: '*IP* ≤ *P* = *D* ≤ *ID*.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '*IP* ≤ *P* = *D* ≤ *ID*。'
- en: '***29-4     Farkas’s lemma***'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '***29-4     法尔卡斯引理***'
- en: Prove Farkas’s lemma, Lemma 29.3.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 证明法尔卡斯引理，引理29.3。
- en: '***29-5     Minimum-cost circulation***'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '***29-5     最小成本流***'
- en: This problem considers a variant of the minimum-cost-flow problem from [Section
    29.2](chapter029.xhtml#Sec_29.2) in which there is no demand, source, or sink.
    Instead, the input, as before, contains a flow network, capacity constraints *c*(*u*,
    *v*), and edge costs *a*(*u*, *v*). A flow is feasible if it satisfies the capacity
    constraint on every edge and flow conservation at *every* vertex. The goal is
    to find, among all feasible flows, the one of minimum cost. We call this problem
    the ***minimum-cost-circulation problem.***
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题考虑了[第29.2节](chapter029.xhtml#Sec_29.2)中的最小成本流问题的一个变体，其中没有需求、源或汇。相反，输入与以前一样包含一个流网络、容量约束*c*(*u*,
    *v*)和边缘成本*a*(*u*, *v*)。如果流满足每条边的容量约束和每个顶点的流量守恒，则流是可行的。目标是在所有可行流中找到成本最低的流。我们称这个问题为***最小成本流问题***。
- en: '***a.*** Formulate the minimum-cost-circulation problem as a linear program.'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 将最小成本流问题制定为线性规划。'
- en: '***b.*** Suppose that for all edges (*u*, *v*) ∈ *E*, we have *a*(*u*, *v*)
    > 0\. What does an optimal solution to the minimum-cost-circulation problem look
    like?'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 假设对于所有边(*u*, *v*) ∈ *E*，我们有*a*(*u*, *v*) > 0\. 那么最小成本流问题的最优解是什么样的？'
- en: '***c.*** Formulate the maximum-flow problem as a minimum-cost-circulation problem
    linear program. That is, given a maximum-flow problem instance *G* = (*V*, *E*)
    with source *s*, sink *t* and edge capacities *c*, create a minimum-cost-circulation
    problem by giving a (possibly different) network *G*′ = (*V*′, *E*′) with edge
    capacities *c*′ and edge costs *a*′ such that you can derive a solution to the
    maximum-flow problem from a solution to the minimum-cost-circulation problem.'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 将最大流问题制定为最小成本流问题的线性规划。也就是说，给定一个最大流问题实例*G* = (*V*, *E*)，源*s*，汇*t*和边容量*c*，通过给出一个(可能不同的)网络*G*′
    = (*V*′, *E*′)、边容量*c*′和边成本*a*′，可以从最小成本流问题的解导出最大流问题的解。'
- en: '***d.*** Formulate the single-source shortest-path problem as a minimum-cost-circulation
    problem linear program.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 将单源最短路径问题制定为最小成本流问题的线性规划。'
- en: '**Chapter notes**'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节注释**'
- en: This chapter only begins to study the wide field of linear programming. A number
    of books are devoted exclusively to linear programming, including those by Chvátal
    [[94](bibliography001.xhtml#endnote_94)], Gass [[178](bibliography001.xhtml#endnote_178)],
    Karloff [[246](bibliography001.xhtml#endnote_246)], Schrijver [[398](bibliography001.xhtml#endnote_398)],
    and Vanderbei [[444](bibliography001.xhtml#endnote_444)]. Many other books give
    a good coverage of linear programming, including those by Papadimitriou and Steiglitz
    [[353](bibliography001.xhtml#endnote_353)] and Ahuja, Magnanti, and Orlin [[7](bibliography001.xhtml#endnote_7)].
    The coverage in this chapter draws on the approach taken by Chvátal.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 本章仅开始研究广泛的线性规划领域。有许多专门致力于线性规划的书籍，包括Chvátal的[[94](bibliography001.xhtml#endnote_94)]、Gass的[[178](bibliography001.xhtml#endnote_178)]、Karloff的[[246](bibliography001.xhtml#endnote_246)]、Schrijver的[[398](bibliography001.xhtml#endnote_398)]和Vanderbei的[[444](bibliography001.xhtml#endnote_444)]。许多其他书籍涵盖了线性规划，包括Papadimitriou和Steiglitz的[[353](bibliography001.xhtml#endnote_353)]以及Ahuja、Magnanti和Orlin的[[7](bibliography001.xhtml#endnote_7)]。本章的内容借鉴了Chvátal的方法。
- en: The simplex algorithm for linear programming was invented by G. Dantzig in 1947\.
    Shortly after, researchers discovered how to formulate a number of problems in
    a variety of fields as linear programs and solve them with the simplex algorithm.
    As a result, applications of linear programming flourished, along with several
    algorithms. Variants of the simplex algorithm remain the most popular methods
    for solving linear-programming problems. This history appears in a number of places,
    including the notes in [[94](bibliography001.xhtml#endnote_94)] and [[246](bibliography001.xhtml#endnote_246)].
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 线性规划的单纯形算法是由G. Dantzig在1947年发明的。不久之后，研究人员发现如何将各种领域的一些问题制定为线性规划，并用单纯形算法解决它们。因此，线性规划的应用得到了发展，同时还出现了几种算法。单纯形算法的变体仍然是解决线性规划问题最流行的方法。这段历史出现在许多地方，包括[[94](bibliography001.xhtml#endnote_94)]和[[246](bibliography001.xhtml#endnote_246)]中的注释。
- en: The ellipsoid algorithm was the first polynomial-time algorithm for linear programming
    and is due to L. G. Khachian in 1979\. It was based on earlier work by N. Z. Shor,
    D. B. Judin, and A. S. Nemirovskii. Grötschel, Lovász, and Schrijver [[201](bibliography001.xhtml#endnote_201)]
    describe how to use the ellipsoid algorithm to solve a variety of problems in
    combinatorial optimization. To date, the ellipsoid algorithm does not appear to
    be competitive with the simplex algorithm in practice.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 椭球算法是线性规划的第一个多项式时间算法，由L. G. Khachian于1979年提出。它基于N. Z. Shor、D. B. Judin和A. S.
    Nemirovskii的早期工作。Grötschel、Lovász和Schrijver[[201](bibliography001.xhtml#endnote_201)]描述了如何使用椭球算法解决组合优化中的各种问题。迄今为止，椭球算法在实践中似乎与单纯形算法不竞争。
- en: Karmarkar’s paper [[247](bibliography001.xhtml#endnote_247)] includes a description
    of the first interior-point algorithm. Many subsequent researchers designed interior-point
    algorithms. Good surveys appear in the article of Goldfarb and Todd [[189](bibliography001.xhtml#endnote_189)]
    and the book by Ye [[463](bibliography001.xhtml#endnote_463)].
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: Karmarkar的论文[[247](bibliography001.xhtml#endnote_247)]包括第一个内点算法的描述。许多后续研究人员设计了内点算法。Goldfarb和Todd的文章[[189](bibliography001.xhtml#endnote_189)]和Ye的书[[463](bibliography001.xhtml#endnote_463)]中有很好的调查。
- en: Analysis of the simplex algorithm remains an active area of research. V. Klee
    and G. J. Minty constructed an example on which the simplex algorithm runs through
    2*^n* − 1 iterations. The simplex algorithm usually performs well in practice,
    and many researchers have tried to give theoretical justification for this empirical
    observation. A line of research begun by K. H. Borgwardt, and carried on by many
    others, shows that under certain probabilistic assumptions on the input, the simplex
    algorithm converges in expected polynomial time. Spielman and Teng [[421](bibliography001.xhtml#endnote_421)]
    made progress in this area, introducing the “smoothed analysis of algorithms”
    and applying it to the simplex algorithm.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 单纯形算法的分析仍然是一个活跃的研究领域。V. Klee和G. J. Minty构建了一个示例，单纯形算法在该示例上经过2*^n* − 1次迭代。单纯形算法通常在实践中表现良好，许多研究人员试图为这一经验观察提供理论上的解释。K.
    H. Borgwardt开展的一系列研究，以及许多其他人继续进行的研究表明，在输入上满足某些概率假设的情况下，单纯形算法在期望多项式时间内收敛。Spielman和Teng[[421](bibliography001.xhtml#endnote_421)]在这一领域取得了进展，引入了“算法的平滑分析”并将其应用于单纯形算法。
- en: The simplex algorithm is known to run efficiently in certain special cases.
    Particularly noteworthy is the network-simplex algorithm, which is the simplex
    algorithm, specialized to network-flow problems. For certain network problems,
    including the shortest-paths, maximum-flow, and minimum-cost-flow problems, variants
    of the network-simplex algorithm run in polynomial time. See, for example, the
    article by Orlin [[349](bibliography001.xhtml#endnote_349)] and the citations
    therein.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 单纯形算法在某些特殊情况下被认为运行效率高。特别值得注意的是网络单纯形算法，它是单纯形算法专门针对网络流问题而设计的。对于某些网络问题，包括最短路径、最大流和最小费用流等问题，网络单纯形算法的变体在多项式时间内运行。例如，参见Orlin的文章[[349](bibliography001.xhtml#endnote_349)]及其中的引用。
- en: '[¹](#footnote_ref_1) An intuitive definition of a convex region is that it
    fulfills the requirement that for any two points in the region, all points on
    a line segment between them are also in the region.'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '[¹](#footnote_ref_1) 对于凸区域的直观定义是，它满足这样的要求：对于区域内的任意两点，连接它们的线段上的所有点也在该区域内。'
