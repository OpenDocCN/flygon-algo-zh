- en: '[**1          The Role of Algorithms in Computing**](toc.xhtml#chap-1)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[**1          计算中的算法角色**](toc.xhtml#chap-1)'
- en: What are algorithms? Why is the study of algorithms worthwhile? What is the
    role of algorithms relative to other technologies used in computers? This chapter
    will answer these questions.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是算法？为什么研究算法是值得的？算法在计算机中的其他技术中的作用是什么？本章将回答这些问题。
- en: '[**1.1      Algorithms**](toc.xhtml#Rh1-2)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[**1.1      算法**](toc.xhtml#Rh1-2)'
- en: Informally, an ***algorithm*** is any well-defined computational procedure that
    takes some value, or set of values, as ***input*** and produces some value, or
    set of values, as ***output*** in a finite amount of time. An algorithm is thus
    a sequence of computational steps that transform the input into the output.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式地说，一个***算法***是任何明确定义的计算过程，它将一些值或一组值作为***输入***，并在有限时间内产生一些值或一组值作为***输出***。因此，算法是一系列将输入转换为输出的计算步骤。
- en: You can also view an algorithm as a tool for solving a well-specified ***computational
    problem***. The statement of the problem specifies in general terms the desired
    input/output relationship for problem instances, typically of arbitrarily large
    size. The algorithm describes a specific computational procedure for achieving
    that input/output relationship for all problem instances.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将算法视为解决一个明确定义的***计算问题***的工具。问题的陈述以一般术语指定了问题实例的所需输入/输出关系，通常是任意大的尺寸。算法描述了实现所有问题实例的输入/输出关系的特定计算过程。
- en: 'As an example, suppose that you need to sort a sequence of numbers into monotonically
    increasing order. This problem arises frequently in practice and provides fertile
    ground for introducing many standard design techniques and analysis tools. Here
    is how we formally define the ***sorting problem***:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，假设您需要将一系列数字按单调递增顺序排序。这个问题在实践中经常出现，并为引入许多标准设计技术和分析工具提供了肥沃的土壤。以下是我们如何正式定义***排序问题***：
- en: '**Input:** A sequence of *n* numbers 〈*a*[1], *a*[2], … , *a[n]*〉.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入:** 一个包含*n*个数字的序列 〈*a*[1], *a*[2], … , *a[n]*〉。'
- en: '**Output:** A permutation (reordering) ![art](images/Art_P1.jpg) of the input
    sequence such that ![art](images/Art_P2.jpg).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出:** 输入序列的一个排列（重新排序）![art](images/Art_P1.jpg)，使得![art](images/Art_P2.jpg)。'
- en: Thus, given the input sequence 〈31, 41, 59, 26, 41, 58〉, a correct sorting algorithm
    returns as output the sequence 〈26, 31, 41, 41, 58, 59〉. Such an input sequence
    is called an ***instance*** of the sorting problem. In general, an ***instance
    of a problem***^([1](#footnote_1)) consists of the input (satisfying whatever
    constraints are imposed in the problem statement) needed to compute a solution
    to the problem.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，给定输入序列 〈31, 41, 59, 26, 41, 58〉，一个正确的排序算法将输出序列 〈26, 31, 41, 41, 58, 59〉。这样的输入序列被称为排序问题的一个***实例***。一般来说，一个***问题的实例***^([1](#footnote_1))包括计算问题解所需的输入（满足问题陈述中施加的任何约束）。
- en: 'Because many programs use it as an intermediate step, sorting is a fundamental
    operation in computer science. As a result, you have a large number of good sorting
    algorithms at your disposal. Which algorithm is best for a given application depends
    on—among other factors—the number of items to be sorted, the extent to which the
    items are already somewhat sorted, possible restrictions on the item values, the
    architecture of the computer, and the kind of storage devices to be used: main
    memory, disks, or even—archaically—tapes.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 由于许多程序将其用作中间步骤，排序在计算机科学中是一个基本操作。因此，您可以使用大量优秀的排序算法。对于给定应用程序来说，哪种算法最好取决于—除其他因素外—要排序的项目数量，项目已经有多少程度上排序，项目值可能的限制，计算机的架构，以及要使用的存储设备类型：主存储器、磁盘，甚至—古老的—磁带。
- en: An algorithm for a computational problem is ***correct*** if, for every problem
    instance provided as input, it ***halts***—finishes its computing in finite time—and
    outputs the correct solution to the problem instance. A correct algorithm ***solves***
    the given computational problem. An incorrect algorithm might not halt at all
    on some input instances, or it might halt with an incorrect answer. Contrary to
    what you might expect, incorrect algorithms can sometimes be useful, if you can
    control their error rate. We’ll see an example of an algorithm with a controllable
    error rate in [Chapter 31](chapter031.xhtml) when we study algorithms for finding
    large prime numbers. Ordinarily, however, we’ll concern ourselves only with correct
    algorithms.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 对于作为输入提供的每个问题实例，计算问题的算法如果***终止***—在有限时间内完成计算—并输出问题实例的正确解，则算法是***正确***的。一个正确的算法***解决***了给定的计算问题。一个不正确的算法在某些输入实例上可能根本不会终止，或者在错误答案下终止。与您可能期望的相反，如果您可以控制其错误率，不正确的算法有时可能是有用的。当我们研究用于查找大素数的算法时，我们将在[第31章](chapter031.xhtml)看到一个具有可控错误率的算法示例。然而，通常情况下，我们只关注正确的算法。
- en: An algorithm can be specified in English, as a computer program, or even as
    a hardware design. The only requirement is that the specification must provide
    a precise description of the computational procedure to be followed.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 一个算法可以用英语、计算机程序，甚至硬件设计来指定。唯一的要求是规范必须提供一个精确描述要遵循的计算过程。
- en: '**What kinds of problems are solved by algorithms?**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法解决哪些问题？**'
- en: 'Sorting is by no means the only computational problem for which algorithms
    have been developed. (You probably suspected as much when you saw the size of
    this book.) Practical applications of algorithms are ubiquitous and include the
    following examples:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 排序绝不是唯一一个为其开发算法的计算问题。（当您看到本书的大小时，您可能已经怀疑到了。）算法的实际应用是无处不在的，包括以下示例：
- en: The Human Genome Project has made great progress toward the goals of identifying
    all the roughly 30,000 genes in human DNA, determining the sequences of the roughly
    3 billion chemical base pairs that make up human DNA, storing this information
    in databases, and developing tools for data analysis. Each of these steps requires
    sophisticated algorithms. Although the solutions to the various problems involved
    are beyond the scope of this book, many methods to solve these biological problems
    use ideas presented here, enabling scientists to accomplish tasks while using
    resources efficiently. Dynamic programming, as in [Chapter 14](chapter014.xhtml),
    is an important technique for solving several of these biological problems, particularly
    ones that involve determining similarity between DNA sequences. The savings realized
    are in time, both human and machine, and in money, as more information can be
    extracted by laboratory techniques.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 人类基因组计划在确定人类DNA中大约30,000个基因、确定构成人类DNA的大约30亿个化学碱基对的序列、将这些信息存储在数据库中以及开发数据分析工具方面取得了巨大进展。每个步骤都需要复杂的算法。虽然这些问题的解决方案超出了本书的范围，但许多解决这些生物问题的方法使用了本书中���绍的思想，使科学家能够在使用资源高效的同时完成任务。动态规划，如[第14章](chapter014.xhtml)中所述，是解决这些生物问题的重要技术，特别是涉及确定DNA序列之间相似性的问题。节省的时间（包括人类和机器的时间）和金钱，因为实验室技术可以提取更多信息。
- en: The internet enables people all around the world to quickly access and retrieve
    large amounts of information. With the aid of clever algorithms, sites on the
    internet are able to manage and manipulate this large volume of data. Examples
    of problems that make essential use of algorithms include finding good routes
    on which the data travels (techniques for solving such problems appear in [Chapter
    22](chapter022.xhtml)), and using a search engine to quickly find pages on which
    particular information resides (related techniques are in [Chapters 11](chapter011.xhtml)
    and [32](chapter032.xhtml)).
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 互联网使全世界的人们能够快速访问和检索大量信息。在巧妙算法的帮助下，互联网上的网站能够管理和操纵这些大量数据。需要算法的问题的例子包括寻找数据传输的良好路线（解决这类问题的技术出现在[第22章](chapter022.xhtml)中），以及使用搜索引擎快速找到包含特定信息的页面（相关技术在[第11章](chapter011.xhtml)和[32章](chapter032.xhtml)中）。
- en: Electronic commerce enables goods and services to be negotiated and exchanged
    electronically, and it depends on the privacy of personal information such as
    credit card numbers, passwords, and bank statements. The core technologies used
    in electronic commerce include public-key cryptography and digital signatures
    (covered in [Chapter 31](chapter031.xhtml)), which are based on numerical algorithms
    and number theory.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 电子商务使商品和服务能够通过电子方式进行协商和交换，并且依赖于个人信息的隐私，如信用卡号码、密码和银行对账单。电子商务中使用的核心技术包括公钥加密和数字签名（在[第31章](chapter031.xhtml)中介绍），这些技术基于数值算法和数论。
- en: Manufacturing and other commercial enterprises often need to allocate scarce
    resources in the most beneficial way. An oil company might wish to know where
    to place its wells in order to maximize its expected profit. A political candidate
    might want to determine where to spend money buying campaign advertising in order
    to maximize the chances of winning an election. An airline might wish to assign
    crews to flights in the least expensive way possible, making sure that each flight
    is covered and that government regulations regarding crew scheduling are met.
    An internet service provider might wish to determine where to place additional
    resources in order to serve its customers more effectively. All of these are examples
    of problems that can be solved by modeling them as linear programs, which [Chapter
    29](chapter029.xhtml) explores.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制造业和其他商业企业经常需要以最有利的方式分配稀缺资源。一家石油公司可能希望知道在哪里放置其油井以最大化预期利润。政治候选人可能想确定在哪里花钱购买竞选广告以最大化赢得选举的机会。航空公司可能希望以最经济的方式为航班分配机组人员，确保每个航班都有人员配备，并满足政府关于机组排班的规定。互联网服务提供商可能希望确定在哪里增加资源以更有效地为客户提供服务。所有这些都是可以通过将其建模为线性规划来解决的问题的示例，[第29章](chapter029.xhtml)对此进行了探讨。
- en: 'Although some of the details of these examples are beyond the scope of this
    book, we do give underlying techniques that apply to these problems and problem
    areas. We also show how to solve many specific problems, including the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这些示例的一些细节超出了本书的范围，但我们提供了适用于这些问题和问题领域的基本技术。我们还展示了如何解决许多具体问题，包括以下内容：
- en: You have a road map on which the distance between each pair of adjacent intersections
    is marked, and you wish to determine the shortest route from one intersection
    to another. The number of possible routes can be huge, even if you disallow routes
    that cross over themselves. How can you choose which of all possible routes is
    the shortest? You can start by modeling the road map (which is itself a model
    of the actual roads) as a graph (which we will meet in [Part VI](part006.xhtml)
    and [Appendix B](appendix002.xhtml)). In this graph, you wish to find the shortest
    path from one vertex to another. [Chapter 22](chapter022.xhtml) shows how to solve
    this problem efficiently.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你有一张道路地图，上面标有相邻交叉口之间的距离，并且希望确定从一个交叉口到另一个交叉口的最短路径。即使不允许跨越自身的路径，可能的路径数量也可能非常庞大。你如何选择所有可能路径中最短的路径？你可以通过将道路地图（本身就是实际道路的模型）建模为图（我们将在[第六部分](part006.xhtml)和[附录B](appendix002.xhtml)中介绍），在这个图中，你希望找到从一个顶点到另一个顶点的最短路径。[第22章](chapter022.xhtml)展示了如何高效解决这个问题。
- en: Given a mechanical design in terms of a library of parts, where each part may
    include instances of other parts, list the parts in order so that each part appears
    before any part that uses it. If the design comprises *n* parts, then there are
    *n*! possible orders, where *n*! denotes the factorial function. Because the factorial
    function grows faster than even an exponential function, you cannot feasibly generate
    each possible order and then verify that, within that order, each part appears
    before the parts using it (unless you have only a few parts). This problem is
    an instance of topological sorting, and [Chapter 20](chapter020.xhtml) shows how
    to solve this problem efficiently.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 给定一个机械设计，其中包含一个零件库，每个零件可能包含其他零件的实例，列出零件的顺序，使得每个零件都出现在使用它的任何零件之前。如果设计包括*n*个零件，那么可能有*n*!种可能的顺序，其中*n*!表示阶乘函数。因为阶乘函数增长速度甚至比指数函数还快，你不可能生成每个可能的顺序，然后验证在该顺序中，每个零件都出现在使用它的零件之前（除非你只有很少的零件）。这个问题是拓扑排序的一个实例，[第20章](chapter020.xhtml)展示了如何高效解决这个问题。
- en: A doctor needs to determine whether an image represents a cancerous tumor or
    a benign one. The doctor has available images of many other tumors, some of which
    are known to be cancerous and some of which are known to be benign. A cancerous
    tumor is likely to be more similar to other cancerous tumors than to benign tumors,
    and a benign tumor is more likely to be similar to other benign tumors. By using
    a clustering algorithm, as in [Chapter 33](chapter033.xhtml), the doctor can identify
    which outcome is more likely.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一位医生需要确定一幅图像是否代表一个恶性肿瘤还是良性肿瘤。医生可以使用许多其他肿瘤的图像，其中一些已知是恶性的，一些已知是良性的。恶性肿瘤更可能与其他恶性肿瘤相似，而良性肿瘤更可能与其他良性肿瘤相似。通过使用聚类算法，如[第33章](chapter033.xhtml)，医生可以确定哪种结果更有可能。
- en: You need to compress a large file containing text so that it occupies less space.
    Many ways to do so are known, including “LZW compression,” which looks for repeating
    character sequences. [Chapter 15](chapter015.xhtml) studies a different approach,
    “Huffman coding,” which encodes characters by bit sequences of various lengths,
    with characters occurring more frequently encoded by shorter bit sequences.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要压缩一个包含文本的大文件，以便占用更少的空间。已知有许多压缩方法，包括“LZW压缩”，它寻找重复的字符序列。[第15章](chapter015.xhtml)研究了一种不同的方法，“赫夫曼编码”，它通过不同长度的比特序列对字符进行编码，出现频率更高的字符用较短的比特序列编码。
- en: 'These lists are far from exhaustive (as you again have probably surmised from
    this book’s heft), but they exhibit two characteristics common to many interesting
    algorithmic problems:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这些列表远非详尽（正如你可能从本书的厚度中推测出来的那样），但它们展示了许多有趣的算法问题共有的两个特征：
- en: They have many candidate solutions, the overwhelming majority of which do not
    solve the problem at hand. Finding one that does, or one that is “best,” without
    explicitly examining each possible solution, can present quite a challenge.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们有许多候选解决方案，其中绝大多数都不能解决手头的问题。找到一个解决方案，或者一个“最佳”解决方案，而不是明确检查每个可能的解决方案，可能会带来相当大的挑战。
- en: They have practical applications. Of the problems in the above list, finding
    the shortest path provides the easiest examples. A transportation firm, such as
    a trucking or railroad company, has a financial interest in finding shortest paths
    through a road or rail network because taking shorter paths results in lower labor
    and fuel costs. Or a routing node on the internet might need to find the shortest
    path through the network in order to route a message quickly. Or a person wishing
    to drive from New York to Boston might want to find driving directions using a
    navigation app.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它们具有实际应用。在上述列表中的问题中，寻找最短路径提供了最简单的例子。像卡车公司或铁路公司这样的运输公司有兴趣通过道路或铁路网络找到最短路径，因为走更短的路径会导致更低的劳动力和燃料成本。或者互联网上的路由节点可能需要通过网络找到最短路径以快速路由消息。或者一个想要从纽约开车到波士顿的人可能想要使用导航应用找到驾驶路线。
- en: Not every problem solved by algorithms has an easily identified set of candidate
    solutions. For example, given a set of numerical values representing samples of
    a signal taken at regular time intervals, the discrete Fourier transform converts
    the time domain to the frequency domain. That is, it approximates the signal as
    a weighted sum of sinusoids, producing the strength of various frequencies which,
    when summed, approximate the sampled signal. In addition to lying at the heart
    of signal processing, discrete Fourier transforms have applications in data compression
    and multiplying large polynomials and integers. [Chapter 30](chapter030.xhtml)
    gives an efficient algorithm, the fast Fourier transform (commonly called the
    FFT), for this problem. The chapter also sketches out the design of a hardware
    FFT circuit.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 并非每个由算法解决的问题都有���个易于识别的候选解决方案集。例如，给定一组表示在规则时间间隔内取样的信号样本的数值值，离散傅立叶变换将时间域转换为频率域。也就是说，它将信号近似为一组正弦波的加权和，产生各种频率的强度，这些频率的总和近似于取样信号。除了在信号处理中起着核心作用外，离散傅立叶变换还在数据压缩和乘法大多项式和整数方面有应用。[第30章](chapter030.xhtml)提供了一个高效的算法，快速傅立叶变换（通常称为FFT），用于解决这个问题。该章还概述了硬件FFT电路的设计。
- en: '**Data structures**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**数据结构**'
- en: This book also presents several data structures. A ***data structure*** is a
    way to store and organize data in order to facilitate access and modifications.
    Using the appropriate data structure or structures is an important part of algorithm
    design. No single data structure works well for all purposes, and so you should
    know the strengths and limitations of several of them.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 本书还介绍了几种数据结构。***数据结构***是一种存储和组织数据以便于访问和修改的方式。使用适当的数据结构或结构是算法设计的重要部分。没有一种单一的数据结构适用于所有目的，因此你应该了解其中几种的优势和局限性。
- en: '**Technique**'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**技术**'
- en: Although you can use this book as a “cookbook” for algorithms, you might someday
    encounter a problem for which you cannot readily find a published algorithm (many
    of the exercises and problems in this book, for example). This book will teach
    you techniques of algorithm design and analysis so that you can develop algorithms
    on your own, show that they give the correct answer, and analyze their efficiency.
    Different chapters address different aspects of algorithmic problem solving. Some
    chapters address specific problems, such as finding medians and order statistics
    in [Chapter 9](chapter009.xhtml), computing minimum spanning trees in [Chapter
    21](chapter021.xhtml), and determining a maximum flow in a network in [Chapter
    24](chapter024.xhtml). Other chapters introduce techniques, such as divide-and-conquer
    in [Chapters 2](chapter002.xhtml) and [4](chapter004.xhtml), dynamic programming
    in [Chapter 14](chapter014.xhtml), and amortized analysis in [Chapter 16](chapter016.xhtml).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然你可以将本书当作算法的“食谱”，但你可能会在某一天遇到一个问题，你无法立即找到已发表的算法（例如本书中的许多练习和问题）。本书将教会你算法设计和分析技巧，以便你可以自己开发算法，展示它们给出正确答案，并分析它们的效率。不同章节涉及算法问题解决的不同方面。一些章节涉及特定问题，比如在[第9章](chapter009.xhtml)中找到中位数和顺序统计量，在[第21章](chapter021.xhtml)中计算最小生成树，在[第24章](chapter024.xhtml)中确定网络中的最大流。其他章节介绍技术，比如在[第2章](chapter002.xhtml)和[第4章](chapter004.xhtml)中的分治法，[第14章](chapter014.xhtml)中的动态规划，以及[第16章](chapter016.xhtml)中的摊销分析。
- en: '**Hard problems**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**困难问题**'
- en: 'Most of this book is about efficient algorithms. Our usual measure of efficiency
    is speed: how long does an algorithm take to produce its result? There are some
    problems, however, for which we know of no algorithm that runs in a reasonable
    amount of time. [Chapter 34](chapter034.xhtml) studies an interesting subset of
    these problems, which are known as NP-complete.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分本书讨论的是高效算法。我们通常衡量效率的标准是速度：算法产生结果需要多长时间？然而，有一些问题，我们却不知道有没有算法能在合理的时间内运行。[第34章](chapter034.xhtml)研究了这些问题的一个有趣子集，被称为NP完全问题。
- en: Why are NP-complete problems interesting? First, although no efficient algorithm
    for an NP-complete problem has ever been found, nobody has ever proven that an
    efficient algorithm for one cannot exist. In other words, no one knows whether
    efficient algorithms exist for NP-complete problems. Second, the set of NP-complete
    problems has the remarkable property that if an efficient algorithm exists for
    any one of them, then efficient algorithms exist for all of them. This relationship
    among the NP-complete problems makes the lack of efficient solutions all the more
    tantalizing. Third, several NP-complete problems are similar, but not identical,
    to problems for which we do know of efficient algorithms. Computer scientists
    are intrigued by how a small change to the problem statement can cause a big change
    to the efficiency of the best known algorithm.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么NP完全问题很有趣？首先，尽管从未找到NP完全问题的高效算法，但也从未有人证明不存在高效算法。换句话说，没有人知道是否存在NP完全问题的高效算法。其次，NP完全问题集合具有一个引人注目的特性，即���果存在任何一个NP完全问题的高效算法，那么所有NP完全问题都存在高效算法。NP完全问题之间的这种关系使得缺乏高效解决方案更加诱人。第三，几个NP完全问题与我们已知的高效算法类似，但并非相同。计算机科学家对问题陈述的微小变化如何导致最佳已知算法效率的巨大变化感到着迷。
- en: You should know about NP-complete problems because some of them arise surprisingly
    often in real applications. If you are called upon to produce an efficient algorithm
    for an NP-complete problem, you are likely to spend a lot of time in a fruitless
    search. If, instead, you can show that the problem is NP-complete, you can spend
    your time developing an efficient approximation algorithm, that is, an algorithm
    that gives a good, but not necessarily the best possible, solution.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该了解NP完全问题，因为它们在实际应用中出现得令人惊讶地频繁。如果你被要求为一个NP完全问题设计���效算法，你可能会花费很多时间进行无果的搜索。相反，如果你能证明问题是NP完全的，你可以花时间开发一个高效的近似算法，即一个给出良好但不一定是最佳解决方案的算法。
- en: As a concrete example, consider a delivery company with a central depot. Each
    day, it loads up delivery trucks at the depot and sends them around to deliver
    goods to several addresses. At the end of the day, each truck must end up back
    at the depot so that it is ready to be loaded for the next day. To reduce costs,
    the company wants to select an order of delivery stops that yields the lowest
    overall distance traveled by each truck. This problem is the well-known “traveling-salesperson
    problem,” and it is NP-complete.^([2](#footnote_2)) It has no known efficient
    algorithm. Under certain assumptions, however, we know of efficient algorithms
    that compute overall distances close to the smallest possible. [Chapter 35](chapter035.xhtml)
    discusses such “approximation algorithms.”
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 举个具体例子，考虑一个有中央仓库的快递公司。每天，它在仓库装载交付卡车，并将它们派送到几个地址。一天结束时，每辆卡车必须回到仓库，以便为第二天装载做好准备。为了降低成本，公司希望选择一个交付站点顺序，使每辆卡车的总行驶距离最小。这个问题就是著名的“旅行推销员问题”，它是NP完全的。^([2](#footnote_2))
    它没有已知的高效算法。然而，在某些假设下，我们知道可以计算接近最小可能总距离的高效算法。[第35章](chapter035.xhtml)讨论了这样的“近似算法”。
- en: '**Alternative computing models**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**替代计算模型**'
- en: 'For many years, we could count on processor clock speeds increasing at a steady
    rate. Physical limitations present a fundamental roadblock to ever-increasing
    clock speeds, however: because power density increases superlinearly with clock
    speed, chips run the risk of melting once their clock speeds become high enough.
    In order to perform more computations per second, therefore, chips are being designed
    to contain not just one but several processing “cores.” We can liken these multicore
    computers to several sequential computers on a single chip. In other words, they
    are a type of “parallel computer.” In order to elicit the best performance from
    multicore computers, we need to design algorithms with parallelism in mind. [Chapter
    26](chapter026.xhtml) presents a model for “task-parallel” algorithms, which take
    advantage of multiple processing cores. This model has advantages from both theoretical
    and practical standpoints, and many modern parallel-programming platforms embrace
    something similar to this model of parallelism.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 多年来，我们一直可以依靠处理器时钟速度稳定增长。然而，物理限制对不断增加的时钟速度构成了根本障碍：因为功率密度随着时钟速度的增加呈超线性增长，一旦时钟速度足够高，芯片就有融化的风险。因此，为了每秒执行更多计算，芯片被设计为不仅包含一个而是多个处理“核心”。我们可以将这些多核计算机比作单个芯片上的几台顺序计算机。换句话说，它们是一种“并行计算机”。为了从多核计算机中获得最佳性能，我们需要设计考虑并行性的算法。[第26章](chapter026.xhtml)提出了一种“任务并行”算法模型，利用了多个处理核心。这种模型在理论和实践上都有优势，许多现代并行编程平台都采用了类似于这种并行性模型。
- en: Most of the examples in this book assume that all of the input data are available
    when an algorithm begins running. Much of the work in algorithm design makes the
    same assumption. For many important real-world examples, however, the input actually
    arrives over time, and the algorithm must decide how to proceed without knowing
    what data will arrive in the future. In a data center, jobs are constantly arriving
    and departing, and a scheduling algorithm must decide when and where to run a
    job, without knowing what jobs will be arriving in the future. Traffic must be
    routed in the internet based on the current state, without knowing about where
    traffic will arrive in the future. Hospital emergency rooms make triage decisions
    about which patients to treat first without knowing when other patients will be
    arriving in the future and what treatments they will need. Algorithms that receive
    their input over time, rather than having all the input present at the start,
    are ***online algorithms***, which [Chapter 27](chapter027.xhtml) examines.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的大多数示例假设算法开始运行时所有输入数据都可用。然而，算法设计中的许多重要真实世界示例实际上是随时间到达输入数据，算法必须在不知道未来将到达哪些数据的情况下决定如何继续。在数据中心，作业不断到达和离开，调度算法必须决定何时何地运行作业，而不知道未来将到达哪些作业。基于当前状态，在互联网中必须路由流量，而不知道未来流量将到达何处。医院急诊室在不知道未来将到达哪些患者和他们将需要什么治疗的情况下，对哪些患者优先治疗做出分类决策。接收输入数据随时间而来的算法，而不是在开始时就有所有输入的算法，是***在线算法***，[第27章](chapter027.xhtml)对此进行了探讨。
- en: '**Exercises**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***1.1-1***'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '***1.1-1***'
- en: Describe your own real-world example that requires sorting. Describe one that
    requires finding the shortest distance between two points.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 描述一个需要排序的真实世界示例。描述一个需要找到两点之间最短距离的示例。
- en: '***1.1-2***'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '***1.1-2***'
- en: Other than speed, what other measures of efficiency might you need to consider
    in a real-world setting?
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了速度之外，在真实世界环境中，您可能需要考虑哪些其他效率指标？
- en: '***1.1-3***'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '***1.1-3***'
- en: Select a data structure that you have seen, and discuss its strengths and limitations.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: ���择一个您见过的数据结构，并讨论其优势和局限性。
- en: '***1.1-4***'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '***1.1-4***'
- en: How are the shortest-path and traveling-salesperson problems given above similar?
    How are they different?
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 上述最短路径和旅行推销员问题有何相似之处？它们又有何不同？
- en: '***1.1-5***'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '***1.1-5***'
- en: Suggest a real-world problem in which only the best solution will do. Then come
    up with one in which “approximately” the best solution is good enough.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 提出一个只有最佳解决方案才行的真实世界问题。然后想出一个“近似”最佳解决方案就足够的问题。
- en: '***1.1-6***'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '***1.1-6***'
- en: Describe a real-world problem in which sometimes the entire input is available
    before you need to solve the problem, but other times the input is not entirely
    available in advance and arrives over time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 描述一个真实世界问题，有时在需要解决问题之前整个输入可用，但其他时候输入并非完全提前可用，而是随时间到达。
- en: '[**1.2      Algorithms as a technology**](toc.xhtml#Rh1-3)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[**1.2      算法作为一种技术**](toc.xhtml#Rh1-3)'
- en: If computers were infinitely fast and computer memory were free, would you have
    any reason to study algorithms? The answer is yes, if for no other reason than
    that you would still like to be certain that your solution method terminates and
    does so with the correct answer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计算机速度无限快，计算机内存是免费的，您是否有理由学习算法？答案是肯定的，即使出于其他原因，您仍希望确保您的解决方法终止并且得到正确答案。
- en: If computers were infinitely fast, any correct method for solving a problem
    would do. You would probably want your implementation to be within the bounds
    of good software engineering practice (for example, your implementation should
    be well designed and documented), but you would most often use whichever method
    was the easiest to implement.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计算机速度无限快，解决问题的任何正确方法都可以。您可能希望您的实现在良好的软件工程实践范围内（例如，您的实现应设计良好并有文档），但您通常会使用最容易实现的方法。
- en: 'Of course, computers may be fast, but they are not infinitely fast. Computing
    time is therefore a bounded resource, which makes it precious. Although the saying
    goes, “Time is money,” time is even more valuable than money: you can get back
    money after you spend it, but once time is spent, you can never get it back. Memory
    may be inexpensive, but it is neither infinite nor free. You should choose algorithms
    that use the resources of time and space efficiently.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，计算机可能很快，但它们并不是无限快的。计算时间是一种有限的资源，因此它是宝贵的。尽管有句谚语说：“时间就是金钱”，但时间比金钱更宝贵：花掉金钱后你可以再赚回来，但一旦时间花掉了，你就再也无法拿回来。内存可能便宜，但它既不是无限的，也不是免费的。你应该选择能够高效利用���间和空间资源的算法。
- en: '**Efficiency**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**效率**'
- en: Different algorithms devised to solve the same problem often differ dramatically
    in their efficiency. These differences can be much more significant than differences
    due to hardware and software.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为解决同一问题而设计的不同算法在效率上往往有显著差异。这些差异可能比硬件和软件造成的差异更为显著。
- en: As an example, [Chapter 2](chapter002.xhtml) introduces two algorithms for sorting.
    The first, known as ***insertion sort***, takes time roughly equal to *c*[1]*n*²
    to sort *n* items, where *c*[1] is a constant that does not depend on *n*. That
    is, it takes time roughly proportional to *n*². The second, ***merge sort***,
    takes time roughly equal to *c*[2]*n* lg *n*, where lg *n* stands for log[2] *n*
    and *c*[2] is another constant that also does not depend on *n*. Insertion sort
    typically has a smaller constant factor than merge sort, so that *c*[1] < *c*[2].
    We’ll see that the constant factors can have far less of an impact on the running
    time than the dependence on the input size *n*. Let’s write insertion sort’s running
    time as *c*[1]*n* · *n* and merge sort’s running time as *c*[2]*n* · lg *n*. Then
    we see that where insertion sort has a factor of *n* in its running time, merge
    sort has a factor of lg *n*, which is much smaller. For example, when *n* is 1000,
    lg *n* is approximately 10, and when *n* is 1,000,000, lg *n* is approximately
    only 20\. Although insertion sort usually runs faster than merge sort for small
    input sizes, once the input size *n* becomes large enough, merge sort’s advantage
    of lg *n* versus *n* more than compensates for the difference in constant factors.
    No matter how much smaller *c*[1] is than *c*[2], there is always a crossover
    point beyond which merge sort is faster.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，[第二章](chapter002.xhtml)介绍了两种排序算法。第一种被称为***插入排序***，排序*n*个项目大约需要时间*c*[1]*n*²，其中*c*[1]是一个不依赖于*n*的常数。也就是说，它的时间大约与*n*²成正比。第二种***归并排序***，排序*n*个项目大约需要时间*c*[2]*n*
    lg *n*，其中lg *n*代表log[2] *n*，*c*[2]是另一个不依赖于*n*的常数。插入排序通常比归并排序有更小的常数因子，因此*c*[1]
    < *c*[2]。我们将看到常数因子对运行时间的影响远不及对输入大小*n*的依赖。我们将插入排序的运行时间写为*c*[1]*n* · *n*，归并排序的运行时间写为*c*[2]*n*
    · lg *n*。然后我们看到插入排序在其运行时间中有一个*n*的因子，而归并排序有一个lg *n*的因子，后者要小得多。例如，当*n*为1000时，lg
    *n*大约为10，当*n*为1,000,000时，lg *n*大约只有20。尽管插入排序通常在小输入大小时运行得比归并排序快，但一旦输入大小*n*足够大，归并排序的lg
    *n*优势远远超过常数因子的差异。无论*c*[1]比*c*[2]小多少，总会有一个交叉点，超过这个点，归并排序就更快了。
- en: For a concrete example, let us pit a faster computer (computer A) running insertion
    sort against a slower computer (computer B) running merge sort. They each must
    sort an array of 10 million numbers. (Although 10 million numbers might seem like
    a lot, if the numbers are eight-byte integers, then the input occupies about 80
    megabytes, which fits in the memory of even an inexpensive laptop computer many
    times over.) Suppose that computer A executes 10 billion instructions per second
    (faster than any single sequential computer at the time of this writing) and computer
    B executes only 10 million instructions per second (much slower than most contemporary
    computers), so that computer A is 1000 times faster than computer B in raw computing
    power. To make the difference even more dramatic, suppose that the world’s craftiest
    programmer codes insertion sort in machine language for computer A, and the resulting
    code requires 2*n*² instructions to sort *n* numbers. Suppose further that just
    an average programmer implements merge sort, using a high-level language with
    an inefficient compiler, with the resulting code taking 50 *n* lg *n* instructions.
    To sort 10 million numbers, computer A takes
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 举个具体的例子，让我们让一个更快的计算机（计算机A）运行插入排序与一个更慢的计算机（计算机B）运行归并排序进行比较。它们各自必须对一个包含1000万个数字的数组进行排序。（虽然1000万个数字可能看起来很多，但如果这些数字是8字节整数，那么输入大约占用80兆字节的内存，这适用于即使是价格便宜的笔记本电脑的内存多次。）假设计算机A每秒执行100亿条指令（比目前任何单个顺序计算机都要快），计算机B每秒只执行1000万条指令（比大多数当代计算机要慢得多），因此计算机A在原始计算能力上比计算机B快1000倍。为了使差异更加明显，假设世界上最狡猾的程序员为计算机A用机器语言编写插入排序，结果代码需要2*n*²条指令来对*n*个数字进行排序。进一步假设只是一个普通程序员使用效率低下的编译器用高级语言实现归并排序，结果代码需要50
    *n* lg *n*条指令。对于排序1000万个数字，计算机A需要
- en: '![art](images/Art_P3.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P3.jpg)'
- en: while computer B takes
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当计算机B执行时
- en: '![art](images/Art_P4.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P4.jpg)'
- en: 'By using an algorithm whose running time grows more slowly, even with a poor
    compiler, computer B runs more than 17 times faster than computer A! The advantage
    of merge sort is even more pronounced when sorting 100 million numbers: where
    insertion sort takes more than 23 days, merge sort takes under four hours. Although
    100 million might seem like a large number, there are more than 100 million web
    searches every half hour, more than 100 million emails sent every minute, and
    some of the smallest galaxies (known as ultra-compact dwarf galaxies) contain
    about 100 million stars. In general, as the problem size increases, so does the
    relative advantage of merge sort.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用一个运行时间增长较慢的算法，即使使用一个较差的编译器，计算机B的运行速度比计算机A快了17倍以上！当对1亿个数字进行排序时，归并排序的优势更加明显：插入排序需要超过23天，而归并排序只需要不到4小时。虽然1亿可能看起来是一个很大的数字，但每半小时有超过1亿次网络搜索，每分钟发送超过1亿封电子邮件，一些最小的星系（被称为超紧凑矮星系）包含大约1亿颗星星。一般来说，随着问题规模的增加，归并排序的相对优势也会增加。
- en: '**Algorithms and other technologies**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法和其他技术**'
- en: The example above shows that you should consider algorithms, like computer hardware,
    as a ***technology***. Total system performance depends on choosing efficient
    algorithms as much as on choosing fast hardware. Just as rapid advances are being
    made in other computer technologies, they are being made in algorithms as well.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的例子表明，你应该将算法视为***技术***，就像计算机硬件一样。整个系统的性能取决于选择高效的算法，就像选择快速硬件一样重要。就像其他计算机技术正在快速发展一样，算法也在快速发展。
- en: You might wonder whether algorithms are truly that important on contemporary
    computers in light of other advanced technologies, such as
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道在其他先进技术（如
- en: advanced computer architectures and fabrication technologies,
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 先进的计算机架构和制造技术，
- en: easy-to-use, intuitive, graphical user interfaces (GUIs),
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 易于使用、直观的图形用户界面（GUI），
- en: object-oriented systems,
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 面向对象的系统，
- en: integrated web technologies,
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成的网络技术，
- en: fast networking, both wired and wireless,
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 快速的有线和无线网络，
- en: machine learning,
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 机器学习，
- en: and mobile devices.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 和移动设备。
- en: The answer is yes. Although some applications do not explicitly require algorithmic
    content at the application level (such as some simple, web-based applications),
    many do. For example, consider a web-based service that determines how to travel
    from one location to another. Its implementation would rely on fast hardware,
    a graphical user interface, wide-area networking, and also possibly on object
    orientation. It would also require algorithms for operations such as finding routes
    (probably using a shortest-path algorithm), rendering maps, and interpolating
    addresses.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是肯定的。尽管一些应用程序在应用程序级别不明确需要算法内容（例如一些简单的基于Web的应用程序），但许多应用程序需要。例如，考虑一个确定如何从一个位置到另一个位置旅行的基于Web的服务。其实现将依赖于快速硬件、图形用户界面、广域网和可能还依赖于面向对象。它还需要算法来执行诸如查找路线（可能使用最短路径算法）、渲染地图和插值地址等操作。
- en: Moreover, even an application that does not require algorithmic content at the
    application level relies heavily upon algorithms. Does the application rely on
    fast hardware? The hardware design used algorithms. Does the application rely
    on graphical user interfaces? The design of any GUI relies on algorithms. Does
    the application rely on networking? Routing in networks relies heavily on algorithms.
    Was the application written in a language other than machine code? Then it was
    processed by a compiler, interpreter, or assembler, all of which make extensive
    use of algorithms. Algorithms are at the core of most technologies used in contemporary
    computers.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，即使一个应用程序在应用程序级别不需要算法内容，也严重依赖算法。应用程序依赖快速硬件吗？硬件设计使用了算法。应用程序依赖图形用户界面吗？任何GUI的设计都依赖于算法。应用程序依赖网络吗？网络中的路由非常依赖算法。应用程序是用机器码之外的语言编写的吗？那么它经过了编译器、解释器或汇编器的处理，所有这些都广泛使用算法。算法是当代计算机中使用的大多数技术的核心。
- en: Machine learning can be thought of as a method for performing algorithmic tasks
    without explicitly designing an algorithm, but instead inferring patterns from
    data and thereby automatically learning a solution. At first glance, machine learning,
    which automates the process of algorithmic design, may seem to make learning about
    algorithms obsolete. The opposite is true, however. Machine learning is itself
    a collection of algorithms, just under a different name. Furthermore, it currently
    seems that the successes of machine learning are mainly for problems for which
    we, as humans, do not really understand what the right algorithm is. Prominent
    examples include computer vision and automatic language translation. For algorithmic
    problems that humans understand well, such as most of the problems in this book,
    efficient algorithms designed to solve a specific problem are typically more successful
    than machine-learning approaches.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 机器学习可以被认为是一种执行算法任务的方法，而不是明确设计算法，而是从数据中推断模式，从而自动学习解决方案。乍一看，自动化算法设计的机器学习似乎使学习算法变得过时。然而，事实恰恰相反。机器学习本身就是一系列算法，只是用了一个不同的名字。此外，目前似乎机器学习的成功主要是针对我们作为人类不真正理解正确算法的问题。著名的例子包括计算机视觉和自动语言翻译。对于人类理解良好的算法问题，例如本书中的大多数问题，通常比机器学习方法更成功地设计出解决特定问题的高效算法。
- en: Data science is an interdisciplinary field with the goal of extracting knowledge
    and insights from structured and unstructured data. Data science uses methods
    from statistics, computer science, and optimization. The design and analysis of
    algorithms is fundamental to the field. The core techniques of data science, which
    overlap significantly with those in machine learning, include many of the algorithms
    in this book.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 数据科学是一个跨学科领域，其目标是从结构化和非结构化数据中提取知识和见解。数据科学使用统计学、计算机科学和优化方法。算法的设计和分析对该领域至关重要。数据科学的核心技术与机器学习中的技术有很大重叠，包括本书中的许多算法。
- en: Furthermore, with the ever-increasing capacities of computers, we use them to
    solve larger problems than ever before. As we saw in the above comparison between
    insertion sort and merge sort, it is at larger problem sizes that the differences
    in efficiency between algorithms become particularly prominent.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，随着计算机容量的不断增加，我们使用它们来解决比以往更大的问题。正如我们在上面插入排序和归并排序之间的比较中看到的，算法之间的效率差异在更大的问题规模下变得尤为显著。
- en: Having a solid base of algorithmic knowledge and technique is one characteristic
    that defines the truly skilled programmer. With modern computing technology, you
    can accomplish some tasks without knowing much about algorithms, but with a good
    background in algorithms, you can do much, much more.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有扎实的算法知识和技巧是定义真正熟练程序员的一个特征。借助现代计算技术，你可以完成一些任务而不需要了解太多算法，但是有了良好的算法基础，你可以做更多、更多的事情。
- en: '**Exercises**'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***1.2-1***'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '***1.2-1***'
- en: Give an example of an application that requires algorithmic content at the application
    level, and discuss the function of the algorithms involved.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个需要应用级别算法内容的应用示例，并讨论所涉及算法的功能。
- en: '***1.2-2***'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '***1.2-2***'
- en: Suppose that for inputs of size *n* on a particular computer, insertion sort
    runs in 8*n*² steps and merge sort runs in 64 *n* lg *n* steps. For which values
    of *n* does insertion sort beat merge sort?
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在特定计算机上，对于大小为*n*的输入，插入排序需要8*n*²步，而归并排序需要64 *n* lg *n*步。对于哪些*n*值，插入排序胜过归并排序？
- en: '***1.2-3***'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '***1.2-3***'
- en: What is the smallest value of *n* such that an algorithm whose running time
    is 100*n*² runs faster than an algorithm whose running time is 2*^n* on the same
    machine?
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是*n*的最小值，使得运行时间为100*n*²的算法在同一台机器上比运行时间为2*^n*的算法更快？
- en: '**Problems**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '***1-1     Comparison of running times***'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '***1-1     运行时间的比较***'
- en: For each function *f* (*n*) and time *t* in the following table, determine the
    largest size *n* of a problem that can be solved in time *t*, assuming that the
    algorithm to solve the problem takes *f* (*n*) microseconds.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个函数*f*(*n*)和时间*t*在下表中，确定在时间*t*内可以解决的问题的最大规模*n*，假设解决问题的算法需要*f*(*n*)微秒。
- en: '![art](images/Art_P5.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P5.jpg)'
- en: '**Chapter notes**'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节注释**'
- en: There are many excellent texts on the general topic of algorithms, including
    those by Aho, Hopcroft, and Ullman [[5](bibliography001.xhtml#endnote_5), [6](bibliography001.xhtml#endnote_6)],
    Dasgupta, Papadimitriou, and Vazirani [[107](bibliography001.xhtml#endnote_107)],
    Edmonds [[133](bibliography001.xhtml#endnote_133)], Erickson [[135](bibliography001.xhtml#endnote_135)],
    Goodrich and Tamassia [[195](bibliography001.xhtml#endnote_195), [196](bibliography001.xhtml#endnote_196)],
    Kleinberg and Tardos [[257](bibliography001.xhtml#endnote_257)], Knuth [[259](bibliography001.xhtml#endnote_259),
    [260](bibliography001.xhtml#endnote_260), [261](bibliography001.xhtml#endnote_261),
    [262](bibliography001.xhtml#endnote_262), [263](bibliography001.xhtml#endnote_263)],
    Levitin [[298](bibliography001.xhtml#endnote_298)], Louridas [[305](bibliography001.xhtml#endnote_305)],
    Mehlhorn and Sanders [[325](bibliography001.xhtml#endnote_325)], Mitzenmacher
    and Upfal [[331](bibliography001.xhtml#endnote_331)], Neapolitan [[342](bibliography001.xhtml#endnote_342)],
    Roughgarden [[385](bibliography001.xhtml#endnote_385), [386](bibliography001.xhtml#endnote_386),
    [387](bibliography001.xhtml#endnote_387), [388](bibliography001.xhtml#endnote_388)],
    Sanders, Mehlhorn, Dietzfelbinger, and Dementiev [[393](bibliography001.xhtml#endnote_393)],
    Sedgewick and Wayne [[402](bibliography001.xhtml#endnote_402)], Skiena [[414](bibliography001.xhtml#endnote_414)],
    Soltys-Kulinicz [[419](bibliography001.xhtml#endnote_419)], Wilf [[455](bibliography001.xhtml#endnote_455)],
    and Williamson and Shmoys [[459](bibliography001.xhtml#endnote_459)]. Some of
    the more practical aspects of algorithm design are discussed by Bentley [[49](bibliography001.xhtml#endnote_49),
    [50](bibliography001.xhtml#endnote_50), [51](bibliography001.xhtml#endnote_51)],
    Bhargava [[54](bibliography001.xhtml#endnote_54)], Kochenderfer and Wheeler [[268](bibliography001.xhtml#endnote_268)],
    and McGeoch [[321](bibliography001.xhtml#endnote_321)]. Surveys of the field of
    algorithms can also be found in books by Atallah and Blanton [[27](bibliography001.xhtml#endnote_27),
    [28](bibliography001.xhtml#endnote_28)] and Mehta and Sahhi [[326](bibliography001.xhtml#endnote_326)].
    For less technical material, see the books by Christian and Griffiths [[92](bibliography001.xhtml#endnote_92)],
    Cormen [[104](bibliography001.xhtml#endnote_104)], Erwig [[136](bibliography001.xhtml#endnote_136)],
    MacCormick [[307](bibliography001.xhtml#endnote_307)], and Vöcking et al. [[448](bibliography001.xhtml#endnote_448)].
    Overviews of the algorithms used in computational biology can be found in books
    by Jones and Pevzner [[240](bibliography001.xhtml#endnote_240)], Elloumi and Zomaya
    [[134](bibliography001.xhtml#endnote_134)], and Marchisio [[315](bibliography001.xhtml#endnote_315)].
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多关于算法这一一般主题的优秀文本，包括Aho，Hopcroft和Ullman的文本[[5](bibliography001.xhtml#endnote_5),
    [6](bibliography001.xhtml#endnote_6)]，Dasgupta，Papadimitriou和Vazirani的文本[[107](bibliography001.xhtml#endnote_107)]，Edmonds的文本[[133](bibliography001.xhtml#endnote_133)]，Erickson的文本[[135](bibliography001.xhtml#endnote_135)]，Goodrich和Tamassia的文本[[195](bibliography001.xhtml#endnote_195),
    [196](bibliography001.xhtml#endnote_196)]，Kleinberg和Tardos的文本[[257](bibliography001.xhtml#endnote_257)]，Knuth的文本[[259](bibliography001.xhtml#endnote_259),
    [260](bibliography001.xhtml#endnote_260), [261](bibliography001.xhtml#endnote_261),
    [262](bibliography001.xhtml#endnote_262), [263](bibliography001.xhtml#endnote_263)]，Levitin的文本[[298](bibliography001.xhtml#endnote_298)]，Louridas的文本[[305](bibliography001.xhtml#endnote_305)]，Mehlhorn和Sanders的文本[[325](bibliography001.xhtml#endnote_325)]，Mitzenmacher和Upfal的文本[[331](bibliography001.xhtml#endnote_331)]，Neapolitan的文本[[342](bibliography001.xhtml#endnote_342)]，Roughgarden的文本[[385](bibliography001.xhtml#endnote_385),
    [386](bibliography001.xhtml#endnote_386), [387](bibliography001.xhtml#endnote_387),
    [388](bibliography001.xhtml#endnote_388)]，Sanders，Mehlhorn，Dietzfelbinger和Dementiev的文本[[393](bibliography001.xhtml#endnote_393)]，Sedgewick和Wayne的文本[[402](bibliography001.xhtml#endnote_402)]，Skiena的文本[[414](bibliography001.xhtml#endnote_414)]，Soltys-Kulinicz的文本[[419](bibliography001.xhtml#endnote_419)]，Wilf的文本[[455](bibliography001.xhtml#endnote_455)]，以及Williamson和Shmoys的文本[[459](bibliography001.xhtml#endnote_459)]。有关算法设计更实际方面的讨论可以参考Bentley的文本[[49](bibliography001.xhtml#endnote_49),
    [50](bibliography001.xhtml#endnote_50), [51](bibliography001.xhtml#endnote_51)]，Bhargava的文本[[54](bibliography001.xhtml#endnote_54)]，Kochenderfer和Wheeler的文本[[268](bibliography001.xhtml#endnote_268)]，以及McGeoch的文本[[321](bibliography001.xhtml#endnote_321)]。算法领域的概述也可以在Atallah和Blanton的书中找到[[27](bibliography001.xhtml#endnote_27),
    [28](bibliography001.xhtml#endnote_28)]，以及Mehta和Sahhi的书中[[326](bibliography001.xhtml#endnote_326)]。对于较少技术性的材料，请参阅Christian和Griffiths的书籍[[92](bibliography001.xhtml#endnote_92)]，Cormen的书籍[[104](bibliography001.xhtml#endnote_104)]，Erwig的书籍[[136](bibliography001.xhtml#endnote_136)]，MacCormick的书籍[[307](bibliography001.xhtml#endnote_307)]，以及Vöcking等人的书籍[[448](bibliography001.xhtml#endnote_448)]。计算生物学中使用的算法概述可以在Jones和Pevzner的书籍中找到[[240](bibliography001.xhtml#endnote_240)]，Elloumi和Zomaya的书籍中找到[[134](bibliography001.xhtml#endnote_134)]，以及Marchisio的书籍中找到[[315](bibliography001.xhtml#endnote_315)]。
- en: '[¹](#footnote_ref_1) Sometimes, when the problem context is known, problem
    instances are themselves simply called “problems.”'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '[¹](#footnote_ref_1) 有时，当问题背景已知时，问题实例本身简称为“问题”。'
- en: '[²](#footnote_ref_2) To be precise, only decision problems—those with a “yes/no”
    answer—can be NP-complete. The decision version of the traveling salesperson problem
    asks whether there exists an order of stops whose distance totals at most a given
    amount.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '[²](#footnote_ref_2) 更确切地说，只有决策问题——即具有“是/否”答案的问题——才能是NP完全的。旅行推销员问题的决策版本询问是否存在一种顺序的停靠点，其距离总和最多为给定数量。'
