- en: '[**4          Divide-and-Conquer**](toc.xhtml#chap-4)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[**4          分治**](toc.xhtml#chap-4)'
- en: The divide-and-conquer method is a powerful strategy for designing asymptotically
    efficient algorithms. We saw an example of divide-and-conquer in [Section 2.3.1](chapter002.xhtml#Sec_2.3.1)
    when learning about merge sort. In this chapter, we’ll explore applications of
    the divide-and-conquer method and acquire valuable mathematical tools that you
    can use to solve the recurrences that arise when analyzing divide-and-conquer
    algorithms.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 分治方法是设计渐进有效算法的强大策略。我们在[Section 2.3.1](chapter002.xhtml#Sec_2.3.1)中学习归并排序时看到了分治的一个例子。在本章中，我们将探讨分治方法的应用，并获得有价值的数学工具，可用于解决分治算法分析时出现的递归式。
- en: 'Recall that for divide-and-conquer, you solve a given problem (instance) recursively.
    If the problem is small enough—the ***base case***—you just solve it directly
    without recursing. Otherwise—the ***recursive case***—you perform three characteristic
    steps:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，对于分治，你会递归地解决给定问题（实例）。如果问题足够小——***基本情况***，你只需直接解决它而不递归。否则——***递归情况***，你执行三个特征步骤：
- en: '**Divide** the problem into one or more subproblems that are smaller instances
    of the same problem.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**分**问题为一个或多个更小的相同问题的子问题。'
- en: '**Conquer** the subproblems by solving them recursively.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**征服**通过递归解决子问题。'
- en: '**Combine** the subproblem solutions to form a solution to the original problem.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**合**子问题的解以形成原始问题的解。'
- en: A divide-and-conquer algorithm breaks down a large problem into smaller subproblems,
    which themselves may be broken down into even smaller subproblems, and so forth.
    The recursion ***bottoms out*** when it reaches a base case and the subproblem
    is small enough to solve directly without further recursing.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 分治算法将一个大问题分解为更小的子问题，这些子问题本身可能会被进一步分解为更小的子问题，依此类推。当递归到达基本情况并且子问题足够小以直接解决而无需进一步递归时，递归***结束***。
- en: '**Recurrences**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归**'
- en: To analyze recursive divide-and-conquer algorithms, we’ll need some mathematical
    tools. A ***recurrence*** is an equation that describes a function in terms of
    its value on other, typically smaller, arguments. Recurrences go hand in hand
    with the divide-and-conquer method because they give us a natural way to characterize
    the running times of recursive algorithms mathematically. You saw an example of
    a recurrence in [Section 2.3.2](chapter002.xhtml#Sec_2.3.2) when we analyzed the
    worst-case running time of merge sort.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 要分析递归分治算法，我们需要一些数学工具。一个***递归式***是一个方程，它描述了一个函数在其他通常更小的参数上的值。递归式与分治方法相辅相成，因为它们为我们提供了一种数学上表征递归算法运行时间的自然方式。在[Section
    2.3.2](chapter002.xhtml#Sec_2.3.2)中分析归并排序的最坏情况运行时间时，你看到了一个递归式的例子。
- en: For the divide-and-conquer matrix-multiplication algorithms presented in [Sections
    4.1](chapter004.xhtml#Sec_4.1) and [4.2](chapter004.xhtml#Sec_4.2), we’ll derive
    recurrences that describe their worst-case running times. To understand why these
    two divide-and-conquer algorithms perform the way they do, you’ll need to learn
    how to solve the recurrences that describe their running times. [Sections 4.3](chapter004.xhtml#Sec_4.3)–[4.7](chapter004.xhtml#Sec_4.7)
    teach several methods for solving recurrences. These sections also explore the
    mathematics behind recurrences, which can give you stronger intuition for designing
    your own divide-and-conquer algorithms.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 对于在[Sections 4.1](chapter004.xhtml#Sec_4.1)和[4.2](chapter004.xhtml#Sec_4.2)中介绍的分治矩阵乘法算法，我们将推导描述它们最坏情况运行时间的递归式。要理解为什么这两个分治算法表现出这样的性能，你需要学会如何解决描述它们运行时间的递归式。[Sections
    4.3](chapter004.xhtml#Sec_4.3)–[4.7](chapter004.xhtml#Sec_4.7)介绍了解决递归式的几种方法。这些部分还探讨了递归式背后的数学，这可以让你更好地设计自己的分治算法。
- en: We want to get to the algorithms as soon as possible. So, let’s just cover a
    few recurrence basics now, and then we’ll look more deeply at recurrences, especially
    how to solve them, after we see the matrix-multiplication examples.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望尽快了解算法。因此，现在让我们简要介绍一些递归基础知识，然后在看到矩阵乘法示例后，我们将更深入地了解递归，特别是如何解决它们。
- en: The general form of a recurrence is an equation or inequality that describes
    a function over the integers or reals using the function itself. It contains two
    or more cases, depending on the argument. If a case involves the recursive invocation
    of the function on different (usually smaller) inputs, it is a ***recursive case***.
    If a case does not involve a recursive invocation, it is a ***base case***. There
    may be zero, one, or many functions that satisfy the statement of the recurrence.
    The recurrence is ***well defined*** if there is at least one function that satisfies
    it, and ***ill defined*** otherwise.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 递归的一般形式是一个方程或不等式，它使用函数本身来描述整数或实数上的函数。它包含两个或多个情况，取决于参数。如果一个情况涉及在不同（通常更小）输入上递归调用函数，则它是一个***递归情况***。如果一个情况不涉及递归调用，则它是一个***基本情况***。可能有零个、一个或多个满足递归陈述的函数。如果至少有一个函数满足递归，则递归是***良定义的***，否则是***不良定义的***。
- en: '**Algorithmic recurrences**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**算法递归**'
- en: 'We’ll be particularly interested in recurrences that describe the running times
    of divide-and-conquer algorithms. A recurrence *T* (*n*) is ***algorithmic***
    if, for every sufficiently large ***threshold*** constant *n*[0] > 0, the following
    two properties hold:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别关注描述分治算法运行时间的递归式。如果递归式*T*(*n*)是***算法的***，那么对于每个足够大的***阈值***常数*n*[0] > 0，以下两个属性成立：
- en: 1\. For all *n* < *n*[0], we have *T* (*n*) = Θ(1).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 对于所有*n* < *n*[0]，我们有*T*(*n*) = Θ(1)。
- en: 2\. For all *n* ≥ *n*[0], every path of recursion terminates in a defined base
    case within a finite number of recursive invocations.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 对于所有*n* ≥ *n*[0]，���条递归路径在有限次递归调用内终止于一个定义的基本情况。
- en: Similar to how we sometimes abuse asymptotic notation (see page 60), when a
    function is not defined for all arguments, we understand that this definition
    is constrained to values of *n* for which *T* (*n*) is defined.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于我们有时滥用渐近符号（参见第 60 页），当一个函数并非对所有参数都定义时，我们理解这个定义受限于 *T* (*n*) 被定义的值。
- en: Why would a recurrence *T* (*n*) that represents a (correct) divide-and-conquer
    algorithm’s worst-case running time satisfy these properties for all sufficiently
    large threshold constants? The first property says that there exist constants
    *c*[1], *c*[2] such that 0 < *c*[1] ≤ *T* (*n*) ≤ *c*[2] for *n* < *n*[0]. For
    every legal input, the algorithm must output the solution to the problem it’s
    solving in finite time (see [Section 1.1](chapter001.xhtml#Sec_1.1)). Thus we
    can let *c*[1] be the minimum amount of time to call and return from a procedure,
    which must be positive, because machine instructions need to be executed to invoke
    a procedure. The running time of the algorithm may not be defined for some values
    of *n* if there are no legal inputs of that size, but it must be defined for at
    least one, or else the “algorithm” doesn’t solve any problem. Thus we can let
    *c*[2] be the algorithm’s maximum running time on any input of size *n* < *n*[0],
    where *n*[0] is sufficiently large that the algorithm solves at least one problem
    of size less than *n*[0]. The maximum is well defined, since there are at most
    a finite number of inputs of size less than *n*[0], and there is at least one
    if *n*[0] is sufficiently large. Consequently, *T* (*n*) satisfies the first property.
    If the second property fails to hold for *T* (*n*), then the algorithm isn’t correct,
    because it would end up in an infinite recursive loop or otherwise fail to compute
    a solution. Thus, it stands to reason that a recurrence for the worst-case running
    time of a correct divide-and-conquer algorithm would be algorithmic.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么一个代表（正确）分治算法最坏情况运行时间的递归 *T* (*n*) 会满足所有足够大阈值常数的这些属性？第一个属性表明存在常数 *c*[1]，*c*[2]，使得对于
    *n* < *n*[0]，有 0 < *c*[1] ≤ *T* (*n*) ≤ *c*[2]。对于每个合法输入，算法必须在有限时间内输出解决的问题的解（参见[第
    1.1 节](chapter001.xhtml#Sec_1.1)）。因此，我们可以让 *c*[1] 是调用过程并从过程返回所需的最短时间，这必须是正的，因为需要执行机器指令来调用过程。如果某些值的
    *n* 没有合法输入，则算法的运行时间可能未定义，但至少必须定义一个，否则“算法”就无法解决任何问题。因此，我们可以让 *c*[2] 是算法在任何大小为 *n*
    < *n*[0] 的输入上的最大运行时间，其中 *n*[0] 足够大，以至少解决一个小于 *n*[0] 大小的问题。最大值是明确定义的，因为小于 *n*[0]
    的输入数量最多是有限的，如果 *n*[0] 足够大，则至少有一个。因此，*T* (*n*) 满足第一个属性。如果 *T* (*n*) 的第二个属性不成立，则算法不正确，因为它将陷入无限递归循环或无法计算解决方案。因此，可以推断出，正确的分治算法最坏情况运行时间的递归将是算法的。
- en: '**Conventions for recurrences**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归的约定**'
- en: 'We adopt the following convention:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采用以下约定：
- en: '*Whenever a recurrence is stated without an explicit base case, we assume that
    the recurrence is algorithmic.*'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '*每当一个递归没有明确的基本情况时，我们假设该递归是算法的。*'
- en: That means you’re free to pick any sufficiently large threshold constant *n*[0]
    for the range of base cases where *T* (*n*) = Θ(1). Interestingly, the asymptotic
    solutions of most algorithmic recurrences you’re likely to see when analyzing
    algorithms don’t depend on the choice of threshold constant, as long as it’s large
    enough to make the recurrence well defined.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着你可以选择任何足够大的阈值常数 *n*[0] 作为基本情况范围，其中 *T* (*n*) = Θ(1)。有趣的是，当分析算法时，你可能会看到大多数算法递归的渐近解并不取决于阈值常数的选择，只要足够大以使递归定义良好即可。
- en: Asymptotic solutions of algorithmic divide-and-conquer recurrences also don’t
    tend to change when we drop any floors or ceilings in a recurrence defined on
    the integers to convert it to a recurrence defined on the reals. [Section 4.7](chapter004.xhtml#Sec_4.7)
    gives a sufficient condition for ignoring floors and ceilings that applies to
    most of the divide-and-conquer recurrences you’re likely to see. Consequently,
    we’ll frequently state algorithmic recurrences without floors and ceilings. Doing
    so generally simplifies the statement of the recurrences, as well as any math
    that we do with them.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 算法分治递归的渐近解在将递归定义在整数上转换为定义在实数上时，通常不会因为去掉递归中的地板或天花板而改变。[第 4.7 节](chapter004.xhtml#Sec_4.7)
    给出了一个忽略地板和天花板的充分条件，适用于你可能会看到的大多数分治递归。因此，我们经常会陈述算法递归而不带地板和天花板。这样做通常简化了递归的陈述，以及我们对其进行的任何数学运算。
- en: You may sometimes see recurrences that are not equations, but rather inequalities,
    such as *T* (*n*) ≤ 2*T* (*n*/2) + Θ(*n*). Because such a recurrence states only
    an upper bound on *T* (*n*), we express its solution using *O*-notation rather
    than Θ-notation. Similarly, if the inequality is reversed to *T* (*n*) ≥ 2*T*
    (*n*/2) + Θ(*n*), then, because the recurrence gives only a lower bound on *T*
    (*n*), we use Ω-notation in its solution.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你可能会看到不是方程而是不等式的递归，比如 *T* (*n*) ≤ 2*T* (*n*/2) + Θ(*n*)。因为这样的递归仅陈述了 *T* (*n*)
    的上界，我们使用 *O* 表示法而不是 Θ 表示法来表达其解。同样，如果不等式反转为 *T* (*n*) ≥ 2*T* (*n*/2) + Θ(*n*)，那么因为递归仅给出
    *T* (*n*) 的下界，我们在解中使用 Ω 表示法。
- en: '**Divide-and-conquer and recurrences**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**分治和递归**'
- en: This chapter illustrates the divide-and-conquer method by presenting and using
    recurrences to analyze two divide-and-conquer algorithms for multiplying *n* ×
    *n* matrices. [Section 4.1](chapter004.xhtml#Sec_4.1) presents a simple divide-and-conquer
    algorithm that solves a matrix-multiplication problem of size *n* by breaking
    it into four subproblems of size *n*/2, which it then solves recursively. The
    running time of the algorithm can be characterized by the recurrence
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过展示和使用递归来分析两个分治算法来说明分��方法，这两个算法用于矩阵相乘 *n* × *n*。[第 4.1 节](chapter004.xhtml#Sec_4.1)
    展示了一个简单的分治算法，通过将大小为 *n* 的矩阵乘法问题分解为四个大小为 *n*/2 的子问题，然后递归解决。算法的运行时间可以用递归来描述
- en: '*T* (*n*) = 8*T* (*n*/2) + Θ(1),'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '*T* (*n*) = 8*T* (*n*/2) + Θ(1),'
- en: which turns out to have the solution *T* (*n*) = Θ(*n*³). Although this divide-and-conquer
    algorithm is no faster than the straightforward method that uses a triply nested
    loop, it leads to an asymptotically faster divide-and-conquer algorithm due to
    V. Strassen, which we’ll explore in [Section 4.2](chapter004.xhtml#Sec_4.2). Strassen’s
    remarkable algorithm divides a problem of size *n* into seven subproblems of size
    *n*/2 which it solves recursively. The running time of Strassen’s algorithm can
    be described by the recurrence
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 其解为 *T* (*n*) = Θ(*n*³)。虽然这种分治算法并不比使用三重嵌套循环的直接方法更快，但由于 V. 斯特拉森提出的一种渐进更快的分治算法，我们将在[第4.2节](chapter004.xhtml#Sec_4.2)中探讨。斯特拉森的杰出算法将一个大小为
    *n* 的问题分解为七个大小为 *n*/2 的子问题，然后递归地解决。斯特拉森算法的运行时间可以用递归描述为
- en: '*T* (*n*) = 7*T* (*n*/2) + Θ(*n*²),'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*T* (*n*) = 7*T* (*n*/2) + Θ(*n*²),'
- en: which has the solution *T* (*n*) = Θ(*n*^(lg 7)) = *O*(*n*^(2.81)). Strassen’s
    algorithm beats the straightforward looping method asymptotically.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 其解为 *T* (*n*) = Θ(*n*^(lg 7)) = *O*(*n*^(2.81))。斯特拉森的算法在渐进意义上超越了直接循环方法。
- en: These two divide-and-conquer algorithms both break a problem of size *n* into
    several subproblems of size *n*/2\. Although it is common when using divide-and-conquer
    for all the subproblems to have the same size, that isn’t always the case. Sometimes
    it’s productive to divide a problem of size *n* into subproblems of different
    sizes, and then the recurrence describing the running time reflects the irregularity.
    For example, consider a divide-and-conquer algorithm that divides a problem of
    size *n* into one subproblem of size *n*/3 and another of size 2*n*/3, taking
    Θ(*n*) time to divide the problem and combine the solutions to the subproblems.
    Then the algorithm’s running time can be described by the recurrence
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种分治算法都将大小为 *n* 的问题分解为几个大小为 *n*/2 的子问题。尽管在使用分治时，所有子问题的大小通常相同，但并非总是如此。有时将大小为
    *n* 的问题分解为不同大小的子问题是有益的，此时描述运行时间的递归反映了不规则性。例如，考虑一种将大小为 *n* 的问题分解为一个大小为 *n*/3 和另一个大小为
    2*n*/3 的子问题的分治算法，需要 Θ(*n*) 的时间来分解问题并合并子问题的解。然后该算法的运行时间可以用递归描述为
- en: '*T* (*n*) = *T* (*n*/3) + *T* (2*n*/3) + Θ(*n*),'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '*T* (*n*) = *T* (*n*/3) + *T* (2*n*/3) + Θ(*n*),'
- en: which turns out to have solution *T* (*n*) = Θ(*n* lg *n*). We’ll even see an
    algorithm in [Chapter 9](chapter009.xhtml) that solves a problem of size *n* by
    recursively solving a subproblem of size *n*/5 and another of size 7*n*/10, taking
    Θ(*n*) time for the divide and combine steps. Its performance satisfies the recurrence
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 其解为 *T* (*n*) = Θ(*n* lg *n*)。我们甚至会在[第9章](chapter009.xhtml)中看到一个算法，通过递归解决大小为
    *n*/5 和另一个大小为 7*n*/10 的子问题，需要 Θ(*n*) 的时间来进行分解和合并步骤。其性能满足递归
- en: '*T* (*n*) = *T* (*n*/5) + *T* (7*n*/10) + Θ(*n*),'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '*T* (*n*) = *T* (*n*/5) + *T* (7*n*/10) + Θ(*n*),'
- en: which has solution *T* (*n*) = Θ(*n*).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 其解为 *T* (*n*) = Θ(*n*)。
- en: Although divide-and-conquer algorithms usually create subproblems with sizes
    a constant fraction of the original problem size, that’s not always the case.
    For example, a recursive version of linear search (see Exercise 2.1-4) creates
    just one subproblem, with one element less than the original problem. Each recursive
    call takes constant time plus the time to recursively solve a subproblem with
    one less element, leading to the recurrence
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然分治算法通常会创建大小为原始问题大小的常数分数的子问题，但并非总是如此。例如，线性搜索的递归版本（参见练习2.1-4）只创建一个子问题，比原始问题少一个元素。每次递归调用需要常数时间加上递归解决一个少一个元素的子问题的时间，导致递归为
- en: '*T* (*n*) = *T* (*n* – 1) + Θ(1),'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '*T* (*n*) = *T* (*n* – 1) + Θ(1),'
- en: which has solution *T* (*n*) = Θ(*n*). Nevertheless, the vast majority of efficient
    divide-and-conquer algorithms solve subproblems that are a constant fraction of
    the size of the original problem, which is where we’ll focus our efforts.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 其解为 *T* (*n*) = Θ(*n*)。然而，绝大多数高效的分治算法解决的子问题大小是原始问题大小的一个常数分数，这也是我们将集中精力的地方。
- en: '**Solving recurrences**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**解递归**'
- en: 'After learning about divide-and-conquer algorithms for matrix multiplication
    in [Sections 4.1](chapter004.xhtml#Sec_4.1) and [4.2](chapter004.xhtml#Sec_4.2),
    we’ll explore several mathematical tools for solving recurrences—that is, for
    obtaining asymptotic Θ-, *O*-, or Ω-bounds on their solutions. We want simple-to-use
    tools that can handle the most commonly occurring situations. But we also want
    general tools that work, perhaps with a little more effort, for less common cases.
    This chapter offers four methods for solving recurrences:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第4.1节](chapter004.xhtml#Sec_4.1)和[第4.2节](chapter004.xhtml#Sec_4.2)中学习了矩阵乘法的分治算法后，我们将探讨几种解决递归的数学工具，即获得其解的渐进
    Θ、*O* 或 Ω 界限。我们希望有简单易用的工具，可以处理最常见的情况。但我们也希望有通用工具，可以在少见情况下，稍微努力一点，也能工作。本章提供了四种解决递归的方法：
- en: In the ***substitution method*** ([Section 4.3](chapter004.xhtml#Sec_4.3)),
    you guess the form of a bound and then use mathematical induction to prove your
    guess correct and solve for constants. This method is perhaps the most robust
    method for solving recurrences, but it also requires you to make a good guess
    and to produce an inductive proof.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在***替换法***（[第4.3节](chapter004.xhtml#Sec_4.3)）中，你猜测一个界的形式，然后使用数学归纳证明你的猜测正确并解出常数。这种方法可能是解决递归的最稳健方法，但也需要你做出一个好的猜测并提供归纳证明。
- en: The ***recursion-tree method*** ([Section 4.4](chapter004.xhtml#Sec_4.4)) models
    the recurrence as a tree whose nodes represent the costs incurred at various levels
    of the recursion. To solve the recurrence, you determine the costs at each level
    and add them up, perhaps using techniques for bounding summations from [Section
    A.2](appendix001.xhtml#Sec_A.2). Even if you don’t use this method to formally
    prove a bound, it can be helpful in guessing the form of the bound for use in
    the substitution method.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***递归树方法***（[第 4.4 节](chapter004.xhtml#Sec_4.4)）将递归建模为一棵树，其节点表示递归各级别的成本。要解决递归，您需要确定每个级别的成本并将它们相加，可能使用从
    [附录 A.2 节](appendix001.xhtml#Sec_A.2) 的求和边界技术。即使您不使用此方法正式证明一个界限，它在猜测替换方法中使用的界限形式时也可能有所帮助。'
- en: The ***master method*** ([Sections 4.5](chapter004.xhtml#Sec_4.5) and [4.6](chapter004.xhtml#Sec_4.6))
    is the easiest method, when it applies. It provides bounds for recurrences of
    the form
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***主方法***（[第 4.5 节](chapter004.xhtml#Sec_4.5) 和 [第 4.6 节](chapter004.xhtml#Sec_4.6)）是最简单的方法，当适用时。它为形式为的递归提供界限'
- en: '*T* (*n*) = *aT* (*n*/*b*) + *f* (*n*),'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*T* (*n*) = *aT* (*n*/*b*) + *f* (*n*),'
- en: where *a* > 0 and *b* > 1 are constants and *f* (*n*) is a given “driving” function.
    This type of recurrence tends to arise more frequently in the study of algorithms
    than any other. It characterizes a divide-and-conquer algorithm that creates *a*
    subproblems, each of which is 1/*b* times the size of the original problem, using
    *f* (*n*) time for the divide and combine steps. To apply the master method, you
    need to memorize three cases, but once you do, you can easily determine asymptotic
    bounds on running times for many divide-and-conquer algorithms.
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 其中 *a* > 0 和 *b* > 1 是常数，*f* (*n*) 是给定的“驱动”函数。这种类型的递归在算法研究中比其他任何递归更频繁地出现。它表征了一个分而治之算法，创建
    *a* 个子问题，每个子问题的大小是原始问题的 1/*b* 倍，使用 *f* (*n*) 时间进行分割和合并步骤。要应用主方法，您需要记住三种情况，但一旦掌握，您就可以轻松确定许多分而治之算法的运行时间的渐近界限。
- en: The ***Akra-Bazzi method*** ([Section 4.7](chapter004.xhtml#Sec_4.7)) is a general
    method for solving divide-and-conquer recurrences. Although it involves calculus,
    it can be used to attack more complicated recurrences than those addressed by
    the master method.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '***Akra-Bazzi 方法***（[第 4.7 节](chapter004.xhtml#Sec_4.7)）是解决分而治之递归的通用方法。尽管涉及微积分，但它可用于攻击比主方法处理的更复杂的递归。'
- en: '[**4.1      Multiplying square matrices**](toc.xhtml#Rh1-16)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '[**4.1      矩阵相乘**](toc.xhtml#Rh1-16)'
- en: We can use the divide-and-conquer method to multiply square matrices. If you’ve
    seen matrices before, then you probably know how to multiply them. (Otherwise,
    you should read [Section D.1](appendix004.xhtml#Sec_D.1).) Let *A* = (*a[ik]*)
    and *B* = (*b[jk]*) be square *n* × *n* matrices. The matrix product *C* = *A*
    · *B* is also an *n* × *n* matrix, where for *i*, *j* = 1, 2, … , *n*, the (*i*,
    *j*) entry of *C* is given by
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用分而治之方法来相乘方阵。如果您以前见过矩阵，那么您可能知道如何相乘。（否则，您应该阅读 [第 D.1 节](appendix004.xhtml#Sec_D.1)。）设
    *A* = (*a[ik]*) 和 *B* = (*b[jk]*) 是方阵 *n* × *n*，矩阵乘积 *C* = *A* · *B* 也是一个 *n*
    × *n* 矩阵，其中对于 *i*, *j* = 1, 2, … , *n*，*C* 的 (*i*, *j*) 条目由以下给出
- en: '![art](images/Art_P100.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P100.jpg)'
- en: Generally, we’ll assume that the matrices are ***dense***, meaning that most
    of the *n*² entries are not 0, as opposed to ***sparse***, where most of the *n*²
    entries are 0 and the nonzero entries can be stored more compactly than in an
    *n* × *n* array.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，我们假设矩阵是***密集***的，意味着大多数的 *n*² 个条目不为 0，与***稀疏***相对，其中大多数 *n*² 个条目为 0，非零条目可以比在
    *n* × *n* 数组中更紧凑地存储。
- en: Computing the matrix *C* requires computing *n*² matrix entries, each of which
    is the sum of *n* pairwise products of input elements from *A* and *B*. The MATRIX-MULTIPLY
    procedure implements this strategy in a straightforward manner, and it generalizes
    the problem slightly. It takes as input three *n* × *n* matrices *A*, *B*, and
    *C*, and it adds the matrix product *A* · *B* to *C*, storing the result in *C*.
    Thus, it computes *C* = *C* + *A* · *B*, instead of just *C* = *A* · *B*. If only
    the product *A* · *B* is needed, just initialize all *n*² entries of *C* to 0
    before calling the procedure, which takes an additional Θ(*n*²) time. We’ll see
    that the cost of matrix multiplication asymptotically dominates this initialization
    cost.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 计算矩阵 *C* 需要计算 *n*² 个矩阵条目，每个条目是来自 *A* 和 *B* 输入元素的 *n* 个成对乘积的和。MATRIX-MULTIPLY
    程序以一种直接的方式实现了这种策略，并略微推广了问题。它以三个 *n* × *n* 矩阵 *A*, *B* 和 *C* 作为输入，并将矩阵乘积 *A* ·
    *B* 添加到 *C* 中，将结果存储在 *C* 中。因此，它计算 *C* = *C* + *A* · *B*，而不仅仅是 *C* = *A* · *B*。如果只需要乘积
    *A* · *B*，则在调用该过程之前将 *C* 的所有 *n*² 个条目初始化为 0，这需要额外的 Θ(*n*²) 时间。我们将看到，矩阵乘法的成本在渐近意义上支配了这种初始化成本。
- en: MATRIX-MULTIPLY(*A*, *B*, *C*, *n*)
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵相乘(*A*, *B*, *C*, *n*)
- en: '| 1 | **for** *i* = 1 **to** *n* | **//** compute entries in each of *n* rows
    |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **对于** *i* = 1 **到** *n* | **//** 计算 *n* 行中的每个条目 |'
- en: '| 2 | **for** *j* = 1 **to** *n* | **//** compute *n* entries in row *i* |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **对于** *j* = 1 **到** *n* | **//** 计算第 *i* 行的 *n* 个条目 |'
- en: '| 3 | **for** *k* = 1 **to** *n* |  |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **对于** *k* = 1 **到** *n* |  |'
- en: '| 4 | *c[ij]* = *c[ij]* + *a[ik]* · *b[kj]* | **//** add in another term of
    equation (4.1) |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *c[ij]* = *c[ij]* + *a[ik]* · *b[kj]* | **//** 添加方程式 (4.1) 的另一个项 |'
- en: The pseudocode for MATRIX-MULTIPLY works as follows. The **for** loop of lines
    1–4 computes the entries of each row *i*, and within a given row *i*, the **for**
    loop of lines 2–4 computes each of the entries *c[ij]* for each column *j*. Each
    iteration of the **for** loop of lines 3–4 adds in one more term of equation (4.1).
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 矩阵相乘的伪代码工作如下。第 1-4 行的**for**循环计算每行 *i* 的条目，而在给定行 *i* 中，第 2-4 行的**for**循环计算每列
    *j* 的条目 *c[ij]*。第 3-4 行的**for**循环的每次迭代都添加方程式 (4.1) 的一个额外项。
- en: Because each of the triply nested **for** loops runs for exactly *n* iterations,
    and each execution of line 4 takes constant time, the MATRIX-MULTIPLY procedure
    operates in Θ(*n*³) time. Even if we add in the Θ(*n*²) time for initializing
    *C* to 0, the running time is still Θ(*n*³).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个三重嵌套的**for**循环都恰好运行*n*次，而第4行的执行时间是常数，所以MATRIX-MULTIPLY过程的运行时间为Θ(*n*³)。即使我们加上将*C*初始化为0所需的Θ(*n*²)时间，运行时间仍然是Θ(*n*³)。
- en: '**A simple divide-and-conquer algorithm**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个简单的分治算法**'
- en: Let’s see how to compute the matrix product *A* · *B* using divide-and-conquer.
    For *n* > 1, the divide step partitions the *n* × *n* matrices into four *n*/2
    × *n*/2 submatrices. We’ll assume that *n* is an exact power of 2, so that as
    the algorithm recurses, we are guaranteed that the submatrix dimensions are integer.
    (Exercise 4.1-1 asks you to relax this assumption.) As with MATRIX-MULTIPLY, we’ll
    actually compute *C* = *C* + *A* · *B*. But to simplify the math behind the algorithm,
    let’s assume that *C* has been initialized to the zero matrix, so that we are
    indeed computing *C* = *A* · *B*.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用分治算法计算矩阵乘积*A* · *B*。对于*n* > 1，分割步骤将*n* × *n*矩阵分割为四个*n*/2 × *n*/2的子矩阵。我们将假设*n*是2的幂，因此当算法递归时，我们保证子矩阵的维度是整数。（练习4.1-1要求你放宽这个假设。）与MATRIX-MULTIPLY一样，我们实际上计算*C*
    = *C* + *A* · *B*。但为了简化算法背后的数学，让我们假设*C*已经初始化为零矩阵，这样我们确实计算*C* = *A* · *B*。
- en: 'The divide step views each of the *n* × *n* matrices *A*, *B*, and *C* as four
    *n*/2 × *n*/2 submatrices:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 分割步骤将每个*n* × *n*矩阵*A*、*B*和*C*视为四个*n*/2 × *n*/2的子矩阵：
- en: '![art](images/Art_P101.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P101.jpg)'
- en: Then we can write the matrix product as
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们可以将矩阵乘积写为
- en: '![art](images/Art_P102.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P102.jpg)'
- en: which corresponds to the equations
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 对应于方程
- en: '![art](images/Art_P103.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P103.jpg)'
- en: Equations (4.5)–(4.8) involve eight *n*/2 × *n*/2 multiplications and four additions
    of *n*/2 × *n*/2 submatrices.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 方程（4.5）-（4.8）涉及八个*n*/2 × *n*/2的乘法和四个*n*/2 × *n*/2的子矩阵的加法。
- en: As we look to transform these equations to an algorithm that can be described
    with pseudocode, or even implemented for real, there are two common approaches
    for implementing the matrix partitioning.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们试图将这些方程转化为可以用伪代码描述甚至实现的算法时，有两种常见的方法可以实现矩阵分割。
- en: One strategy is to allocate temporary storage to hold *A*’s four submatrices
    *A*[11], *A*[12], *A*[21], and *A*[22] and *B*’s four submatrices *B*[11], *B*[12],
    *B*[21], and *B*[22]. Then copy each element in *A* and *B* to its corresponding
    location in the appropriate submatrix. After the recursive conquer step, copy
    the elements in each of *C*’s four submatrices *C*[11], *C*[12], *C*[21], and
    *C*[22] to their corresponding locations in *C*. This approach takes Θ(*n*²) time,
    since 3*n*² elements are copied.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 一种策略是分配临时存储空间来容纳*A*的四个子矩阵*A*[11]、*A*[12]、*A*[21]和*A*[22]，以及*B*的四个子矩阵*B*[11]、*B*[12]、*B*[21]和*B*[22]。然后将*A*和*B*中的每个元素复制到相应子矩阵的适当位置。在递归的征服步骤之后，将*C*的四个子矩阵*C*[11]、*C*[12]、*C*[21]和*C*[22]中的元素复制到*C*的相应位置。这种方法需要Θ(*n*²)的时间，因为需要复制3*n*²个元素。
- en: The second approach uses index calculations and is faster and more practical.
    A submatrix can be specified within a matrix by indicating where within the matrix
    the submatrix lies without touching any matrix elements. Partitioning a matrix
    (or recursively, a submatrix) only involves arithmetic on this location information,
    which has constant size independent of the size of the matrix. Changes to the
    submatrix elements update the original matrix, since they occupy the same storage.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 第二种方法使用索引计算，更快更实用。可以通过指示子矩阵在矩阵中的位置来指定子矩阵，而不触及任何矩阵元素。分割矩阵（或递归地，子矩阵）仅涉及对此位置信息的算术运算，该信息的大小与矩阵的大小无关。对子矩阵元素的更改会更新原始矩阵，因为它们占用相同的存储空间。
- en: Going forward, we’ll assume that index calculations are used and that partitioning
    can be performed in Θ(1) time. Exercise 4.1-3 asks you to show that it makes no
    difference to the overall asymptotic running time of matrix multiplication, however,
    whether the partitioning of matrices uses the first method of copying or the second
    method of index calculation. But for other divide-and-conquer matrix calculations,
    such as matrix addition, it can make a difference, as Exercise 4.1-4 asks you
    to show.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将假设索引计算被使用，并且分区可以在Θ(1)时间内完成。练习4.1-3要求你展示，无论矩阵乘法的分区使用第一种复制方法还是第二种索引计算方法，都不会对整体渐近运行时间产生影响。但对于其他分治矩阵计算，比如矩阵加法，可能会有影响，正如练习4.1-4要求你展示的那样。
- en: The procedure MATRIX-MULTIPLY-RECURSIVE uses equations (4.5)–(4.8) to implement
    a divide-and-conquer strategy for square-matrix multiplication. Like MATRIX-MULTIPLY,
    the procedure MATRIX-MULTIPLY-RECURSIVE computes *C* = *C* + *A* · *B* since,
    if necessary, *C* can be initialized to 0 before the procedure is called in order
    to compute only *C* = *A* · *B*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: MATRIX-MULTIPLY-RECURSIVE过程使用方程（4.5）-（4.8）来实现矩阵乘法的分治策略。与MATRIX-MULTIPLY一样，MATRIX-MULTIPLY-RECURSIVE过程计算*C*
    = *C* + *A* · *B*，因为如果需要，可以在调用过程之前将*C*初始化为0，以便仅计算*C* = *A* · *B*。
- en: MATRIX-MULTIPLY-RECURSIVE(*A*, *B*, *C*, *n*)
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: MATRIX-MULTIPLY-RECURSIVE(*A*, *B*, *C*, *n*)
- en: '|   1 | **if** *n* == 1 |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|   1 | **如果** *n* == 1 |'
- en: '|   2 | **//** Base case. |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|   2 | **//** 基本情况。 |'
- en: '|   3 | *c*[11] = *c*[11] + *a*[11] · *b*[11] |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|   3 | *c*[11] = *c*[11] + *a*[11] · *b*[11] |'
- en: '|   4 | **return** |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|   4 | **返回** |'
- en: '|   5 | **//** Divide. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|   5 | **//** 分割。 |'
- en: '|   6 | partition *A*, *B*, and *C* into *n*/2 × *n*/2 submatrices*A*[11],
    *A*[12], *A*[21], *A*[22]; *B*[11], *B*[12], *B*[21], *B*[22]; and *C*[11], *C*[12],
    *C*[21], *C*[22]; respectively |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|   6 | 将*A*、*B*和*C*分割为*n*/2 × *n*/2的子矩阵*A*[11]、*A*[12]、*A*[21]、*A*[22]；*B*[11]、*B*[12]、*B*[21]、*B*[22]；以及*C*[11]、*C*[12]、*C*[21]、*C*[22]；分别
    |'
- en: '|   7 | **//** Conquer. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|   7 | **//** 征服。 |'
- en: '|   8 | MATRIX-MULTIPLY-RECURSIVE(*A*[11], *B*[11], *C*[11], *n*/2) |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|   8 | MATRIX-MULTIPLY-RECURSIVE(*A*[11], *B*[11], *C*[11], *n*/2) |'
- en: '|   9 | MATRIX-MULTIPLY-RECURSIVE(*A*[11], *B*[12], *C*[12], *n*/2) |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|   9 | MATRIX-MULTIPLY-RECURSIVE(*A*[11], *B*[12], *C*[12], *n*/2) |'
- en: '| 10 | MATRIX-MULTIPLY-RECURSIVE(*A*[21], *B*[11], *C*[21], *n*/2) |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 10 | MATRIX-MULTIPLY-RECURSIVE(*A*[21], *B*[11], *C*[21], *n*/2) |'
- en: '| 11 | MATRIX-MULTIPLY-RECURSIVE(*A*[21], *B*[12], *C*[22], *n*/2) |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 矩阵相乘递归(*A*[21], *B*[12], *C*[22], *n*/2) |'
- en: '| 12 | MATRIX-MULTIPLY-RECURSIVE(*A*[12], *B*[21], *C*[11], *n*/2) |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 矩阵相乘递归(*A*[12], *B*[21], *C*[11], *n*/2) |'
- en: '| 13 | MATRIX-MULTIPLY-RECURSIVE(*A*[12], *B*[22], *C*[12], *n*/2) |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 13 | 矩阵相乘递归(*A*[12], *B*[22], *C*[12], *n*/2) |'
- en: '| 14 | MATRIX-MULTIPLY-RECURSIVE(*A*[22], *B*[21], *C*[21], *n*/2) |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 14 | 矩阵相乘递归(*A*[22], *B*[21], *C*[21], *n*/2) |'
- en: '| 15 | MATRIX-MULTIPLY-RECURSIVE(*A*[22], *B*[22], *C*[22], *n*/2) |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 矩阵相乘递归(*A*[22], *B*[22], *C*[22], *n*/2) |'
- en: As we walk through the pseudocode, we’ll derive a recurrence to characterize
    its running time. Let *T* (*n*) be the worst-case time to multiply two *n* × *n*
    matrices using this procedure.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们逐步走过伪代码时，我们将推导一个描述其运行时间的递归式。设 *T* (*n*) 为使用此过程乘以两个 *n* × *n* 矩阵的最坏情况时间。
- en: In the base case, when *n* = 1, line 3 performs just the one scalar multiplication
    and one addition, which means that *T* (1) = Θ(1). As is our convention for constant
    base cases, we can omit this base case in the statement of the recurrence.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本情况下，当 *n* = 1 时，第3行仅执行一个标量乘法和一个加法，这意味着 *T* (1) = Θ(1)。按照我们对于常数基本情况的约定，我们可以在递归的陈述中省略这个基本情况。
- en: The recursive case occurs when *n* > 1\. As discussed, we’ll use index calculations
    to partition the matrices in line 6, taking Θ(1) time. Lines 8–15 recursively
    call MATRIX-MULTIPLY-RECURSIVE a total of eight times. The first four recursive
    calls compute the first terms of equations (4.5)–(4.8), and the subsequent four
    recursive calls compute and add in the second terms. Each recursive call adds
    the product of a submatrix of *A* and a submatrix of *B* to the appropriate submatrix
    of *C* in place, thanks to index calculations. Because each recursive call multiplies
    two *n*/2 × *n*/2 matrices, thereby contributing *T* (*n*/2) to the overall running
    time, the time taken by all eight recursive calls is 8*T* (*n*/2). There is no
    combine step, because the matrix *C* is updated in place. The total time for the
    recursive case, therefore, is the sum of the partitioning time and the time for
    all the recursive calls, or Θ(1) + 8*T* (*n*/2).
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 递归情况发生在 *n* > 1 时。如讨论的，我们将使用索引计算在第6行中对矩阵进行分割，需要 Θ(1) 的时间。第8至15行总共递归调用 MATRIX-MULTIPLY-RECURSIVE
    八次。前四次递归调用计算方程式(4.5)–(4.8)的第一项，后续四次递归调用计算并添加第二项。每次递归调用将 *A* 的一个子矩阵与 *B* 的一个子矩阵相乘并加到
    *C* 的适当子矩阵中，由于索引计算，这些操作都是原地进行的。因为每次递归调用都会将两个 *n*/2 × *n*/2 矩阵相乘，从而为总体运行时间贡献 *T*
    (*n*/2)，所有八次递归调用的时间为 8*T* (*n*/2)。没有合并步骤，因为矩阵 *C* 是原地更新的。因此，递归情况的总时间是分割时间和所有递归调用时间的总和，即
    Θ(1) + 8*T* (*n*/2)。
- en: Thus, omitting the statement of the base case, our recurrence for the running
    time of MATRIX-MULTIPLY-RECURSIVE is
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，省略基本情况的陈述，我们对 MATRIX-MULTIPLY-RECURSIVE 的运行时间的递归式为
- en: '![art](images/Art_P104.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P104.jpg)'
- en: As we’ll see from the master method in [Section 4.5](chapter004.xhtml#Sec_4.5),
    recurrence (4.9) has the solution *T* (*n*) = Θ(*n*³), which means that it has
    the same asymptotic running time as the straightforward MATRIX-MULTIPLY procedure.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在[第4.5节](chapter004.xhtml#Sec_4.5)中从主方法中看到的，递归式(4.9)的解为 *T* (*n*) = Θ(*n*³)，这意味着它与直接的矩阵相乘过程具有相同的渐近运行时间。
- en: Why is the Θ(*n*³) solution to this recurrence so much larger than the Θ(*n*
    lg *n*) solution to the merge-sort recurrence (2.3) on page 41? After all, the
    recurrence for merge sort contains a Θ(*n*) term, whereas the recurrence for recursive
    matrix multiplication contains only a Θ(1) term.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么这个递归式的 Θ(*n*³) 解比第41页上合并排序递归式(2.3)的 Θ(*n* lg *n*) 解大得多？毕竟，合并排序的递归式包含一个 Θ(*n*)
    项，而递归矩阵相乘的递归式只包含一个 Θ(1) 项。
- en: 'Let’s think about what the recursion tree for recurrence (4.9) would look like
    as compared with the recursion tree for merge sort, illustrated in [Figure 2.5](chapter002.xhtml#Fig_2-5)
    on page 43\. The factor of 2 in the merge-sort recurrence determines how many
    children each tree node has, which in turn determines how many terms contribute
    to the sum at each level of the tree. In comparison, for the recurrence (4.9)
    for MATRIX-MULTIPLY-RECURSIVE, each internal node in the recursion tree has eight
    children, not two, leading to a “bushier” recursion tree with many more leaves,
    despite the fact that the internal nodes are each much smaller. Consequently,
    the solution to recurrence (4.9) grows much more quickly than the solution to
    recurrence (2.3), which is borne out in the actual solutions: Θ(*n*³) versus Θ(*n*
    lg *n*).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想想递归式(4.9)的递归树与合并排序的递归树的比较，合并排序的递归树在第43页的[图2.5](chapter002.xhtml#Fig_2-5)中有所说明。合并排序递归式中的2因子决定了每��树节点有多少子节点，进而决定了每个树级别上有多少项参与求和。相比之下，对于矩阵相乘递归式(4.9)，递归树中的每个内部节点有八个子节点，而不是两个，导致一个“更加丰满”的递归树，拥有更多的叶子节点，尽管内部节点实际上更小。因此，递归式(4.9)的解比递归式(2.3)的解增长更快，这在实际解中得到了证实：Θ(*n*³)
    对比 Θ(*n* lg *n*)。
- en: '**Exercises**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '*Note:* You may wish to read [Section 4.5](chapter004.xhtml#Sec_4.5) before
    attempting some of these exercises.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意:* 在尝试这些练习之前，您可能希望阅读[第4.5节](chapter004.xhtml#Sec_4.5)。'
- en: '***4.1-1***'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.1-1***'
- en: Generalize MATRIX-MULTIPLY-RECURSIVE to multiply *n* × *n* matrices for which
    *n* is not necessarily an exact power of 2\. Give a recurrence describing its
    running time. Argue that it runs in Θ(*n*³) time in the worst case.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 将矩阵相乘递归推广到乘以 *n* × *n* 的矩阵，其中 *n* 不一定是2的幂。给出描述其运行时间的递归式。证明在最坏情况下它的运行时间为 Θ(*n*³)。
- en: '***4.1-2***'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.1-2***'
- en: How quickly can you multiply a *k n* × *n* matrix (*k n* rows and *n* columns)
    by an *n* × *k n* matrix, where *k* ≥ 1, using MATRIX-MULTIPLY-RECURSIVE as a
    subroutine? Answer the same question for multiplying an *n* × *k n* matrix by
    a *k n* × *n* matrix. Which is asymptotically faster, and by how much?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MATRIX-MULTIPLY-RECURSIVE 作为子例程，您可以多快地将一个 *k n* × *n* 矩阵（*k n* 行和 *n* 列）乘以一个
    *n* × *k n* 矩阵？对于将一个 *n* × *k n* 矩阵乘以一个 *k n* × *n* 矩阵，您可以回答相同的问题吗？哪个渐近更快，快多少？
- en: '***4.1-3***'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.1-3***'
- en: Suppose that instead of partitioning matrices by index calculation in MATRIX-MULTIPLY-RECURSIVE,
    you copy the appropriate elements of *A*, *B*, and *C* into separate *n*/2 × *n*/2
    submatrices *A*[11], *A*[12], *A*[21], *A*[22]; *B*[11], *B*[12], *B*[21], *B*[22];
    and *C*[11], *C*[12], *C*[21], *C*[22], respectively. After the recursive calls,
    you copy the results from *C*[11], *C*[12], *C*[21], and *C*[22] back into the
    appropriate places in *C*. How does recurrence (4.9) change, and what is its solution?
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在MATRIX-MULTIPLY-RECURSIVE中不是通过索引计算来分割矩阵，而是将*A*、*B*和*C*的适当元素复制到单独的*n*/2 ×
    *n*/2子矩阵*A*[11]、*A*[12]、*A*[21]、*A*[22]；*B*[11]、*B*[12]、*B*[21]、*B*[22]；和*C*[11]、*C*[12]、*C*[21]、*C*[22]中。在递归调用之后，将*C*[11]、*C*[12]、*C*[21]和*C*[22]的结果复制回*C*的适当位置。递归（4.9）会如何改变，其解决方案是什么？
- en: '***4.1-4***'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.1-4***'
- en: Write pseudocode for a divide-and-conquer algorithm MATRIX-ADD-RECURSIVE that
    sums two *n* × *n* matrices *A* and *B* by partitioning each of them into four
    *n*/2 × *n*/2 submatrices and then recursively summing corresponding pairs of
    submatrices. Assume that matrix partitioning uses Θ(1)-time index calculations.
    Write a recurrence for the worst-case running time of MATRIX-ADD-RECURSIVE, and
    solve your recurrence. What happens if you use Θ(*n*²)-time copying to implement
    the partitioning instead of index calculations?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个分治算法MATRIX-ADD-RECURSIVE的伪代码，通过将它们分割成四个*n*/2 × *n*/2子矩阵，然后递归地对应子矩阵的对应对进行求和，来求和两个*n*
    × *n*矩阵*A*和*B*。假设矩阵分割使用Θ(1)时间的索引计算。为MATRIX-ADD-RECURSIVE的最坏情况运行时间写一个递归，并解决你的递归。如果使用Θ(*n*²)时间的复制来实现分割，而不是索引计算，会发生什么？
- en: '[**4.2      Strassen’s algorithm for matrix multiplication**](toc.xhtml#Rh1-17)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '[**4.2      Strassen矩阵乘法算法**](toc.xhtml#Rh1-17)'
- en: You might find it hard to imagine that any matrix multiplication algorithm could
    take less than Θ(*n*³) time, since the natural definition of matrix multiplication
    requires *n*³ scalar multiplications. Indeed, many mathematicians presumed that
    it was not possible to multiply matrices in *o*(*n*³) time until 1969, when V.
    Strassen [[424](bibliography001.xhtml#endnote_424)] published a remarkable recursive
    algorithm for multiplying *n* × *n* matrices. Strassen’s algorithm runs in Θ(*n*^(lg
    7)) time. Since lg 7 = 2.8073549 …, Strassen’s algorithm runs in *O*(*n*^(2.81))
    time, which is asymptotically better than the Θ(*n*³) MATRIX-MULTIPLY and MATRIX-MULTIPLY-RECURSIVE
    procedures.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能很难想象任何矩阵乘法算法可以花费少于Θ(*n*³)的时间，因为矩阵乘法的自然定义需要*n*³个标量乘法。事实上，直到1969年，许多数学家都认为不可能在*o*(*n*³)的时间内乘以矩阵，直到V.
    Strassen在1969年发表了一个令人瞩目的递归算法来相乘*n* × *n*矩阵。Strassen算法的运行时间为Θ(*n*^(lg 7))。由于lg
    7 = 2.8073549 …，Strassen算法的运行时间为*O*(*n*^(2.81))，这在渐近意义上比Θ(*n*³)的MATRIX-MULTIPLY和MATRIX-MULTIPLY-RECURSIVE过程更好。
- en: The key to Strassen’s method is to use the divide-and-conquer idea from the
    MATRIX-MULTIPLY-RECURSIVE procedure, but make the recursion tree less bushy. We’ll
    actually increase the work for each divide and combine step by a constant factor,
    but the reduction in bushiness will pay off. We won’t reduce the bushiness from
    the eight-way branching of recurrence (4.9) all the way down to the two-way branching
    of recurrence (2.3), but we’ll improve it just a little, and that will make a
    big difference. Instead of performing eight recursive multiplications of *n*/2
    × *n*/2 matrices, Strassen’s algorithm performs only seven. The cost of eliminating
    one matrix multiplication is several new additions and subtractions of *n*/2 ×
    *n*/2 matrices, but still only a constant number. Rather than saying “additions
    and subtractions” everywhere, we’ll adopt the common terminology of calling them
    both “additions” because subtraction is structurally the same computation as addition,
    except for a change of sign.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Strassen方法的关键在于利用MATRIX-MULTIPLY-RECURSIVE过程中的分治思想，但使递归树变得不那么繁茂。实际上，我们会通过一个常数因子增加每个分治和合并步骤的工作量，但减少繁茂性将会带来回报。我们不会将递归的分支从八路分支（4.9）一直减少到两路分支（2.3），但我们会稍微改进一下，这将产生很大的不同。Strassen算法不是执行8次*n*/2
    × *n*/2矩阵的递归乘法，而是只执行7次。消除一个矩阵乘法的成本是进行几次新的*n*/2 × *n*/2矩阵的加法和减法，但仍然只是一个常数。我们将不再到处说“加法和减法”，而是采用通用术语将它们都称为“加法”，因为减法在结构上与加法是相同的计算，只是符号不同。
- en: 'To get an inkling how the number of multiplications might be reduced, as well
    as why reducing the number of multiplications might be desirable for matrix calculations,
    suppose that you have two numbers *x* and *y*, and you want to calculate the quantity
    *x*² – *y*². The straightforward calculation requires two multiplications to square
    *x* and *y*, followed by one subtraction (which you can think of as a “negative
    addition”). But let’s recall the old algebra trick *x*² – *y*² = *x*² – *xy* +
    *xy* – *y*² = *x*(*x* – *y*) + *y*(*x* – *y*) = (*x* + *y*)(*x* – *y*). Using
    this formulation of the desired quantity, you could instead compute the sum *x*
    + *y* and the difference *x* – *y* and then multiply them, requiring only a single
    multiplication and two additions. At the cost of an extra addition, only one multiplication
    is needed to compute an expression that looks as if it requires two. If *x* and
    *y* are scalars, there’s not much difference: both approaches require three scalar
    operations. If *x* and *y* are large matrices, however, the cost of multiplying
    outweighs the cost of adding, in which case the second method outperforms the
    first, although not asymptotically.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了大致了解如何减少乘法的次数，以及为什么减少乘法的次数对矩阵计算是可取的，假设你有两个数*x*和*y*，你想计算*x*² – *y*²的数量。直接计算需要两次乘法来平方*x*和*y*，然后是一次减法（你可以将其视为“负加法”）。但让我们回想一下旧的代数技巧*x*²
    – *y*² = *x*² – *xy* + *xy* – *y*² = *x*(*x* – *y*) + *y*(*x* – *y*) = (*x* +
    *y*)(*x* – *y*)。使用这个所需数量的公式，你可以计算出*x* + *y*的和和*x* – *y*的差，然后将它们相乘，只需要一次乘法和两次加法。以额外的加法为代价，只需要一次乘法来计算一个看起来需要两次乘法的表达式。如果*x*和*y*是标量，那么两种方法没有太大区别：两种方法都需要三次标量运算。然而，如果*x*和*y*是大矩阵，那么乘法的成本超过了加法的成本，在这种情况下，第二种方法优于第一种方法，尽管在渐近意义上不是这样。
- en: 'Strassen’s strategy for reducing the number of matrix multiplications at the
    expense of more matrix additions is not at all obvious—perhaps the biggest understatement
    in this book! As with MATRIX-MULTIPLY-RECURSIVE, Strassen’s algorithm uses the
    divide-and-conquer method to compute *C* = *C* + *A* · *B*, where *A*, *B*, and
    *C* are all *n* × *n* matrices and *n* is an exact power of 2\. Strassen’s algorithm
    computes the four submatrices *C*[11], *C*[12], *C*[21], and *C*[22] of *C* from
    equations (4.5)–(4.8) on page 82 in four steps. We’ll analyze costs as we go along
    to develop a recurrence *T* (*n*) for the overall running time. Let’s see how
    it works:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: Strassen的策略是通过增加更多的矩阵加法来减少矩阵乘法的次数，这一点并不明显——也许是本书中最大的低估！与MATRIX-MULTIPLY-RECURSIVE一样，Strassen的算法使用分治方法来计算*C*
    = *C* + *A* · *B*，其中*A*、*B*和*C*都是*n* × *n*矩阵，*n*是2的幂。Strassen的算法从第82页的方程(4.5)–(4.8)中的四个步骤中计算*C*的四个子矩阵*C*[11]、*C*[12]、*C*[21]和*C*[22]。我们将在分析成本的同时开发总体运行时间的递归*T*(*n*)。让我们看看它是如何工作的：
- en: If *n* = 1, the matrices each contain a single element. Perform a single scalar
    multiplication and a single scalar addition, as in line 3 of MATRIX-MULTIPLY-RECURSIVE,
    taking Θ(1) time, and return. Otherwise, partition the input matrices *A* and
    *B* and output matrix *C* into *n*/2 × *n*/2 submatrices, as in equation (4.2).
    This step takes Θ(1) time by index calculation, just as in MATRIX-MULTIPLY-RECURSIVE.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*n* = 1，则每个矩阵都包含一个单独的元素。执行单个标量乘法和单个标量加法，就像MATRIX-MULTIPLY-RECURSIVE的第3行一样，需要Θ(1)的时间，然后返回。否则，将输入矩阵*A*和*B*以及输出矩阵*C*分割为*n*/2
    × *n*/2子矩阵，就像方程(4.2)中一样。这一步通过索引计算需要Θ(1)的时间，就像在MATRIX-MULTIPLY-RECURSIVE中一样。
- en: Create *n*/2 × *n*/2 matrices *S*[1], *S*[2], … , *S*[10], each of which is
    the sum or difference of two submatrices from step 1\. Create and zero the entries
    of seven *n*/2 × *n*/2 matrices *P*[1], *P*[2], … , *P*[7] to hold seven *n*/2
    × *n*/2 matrix products. All 17 matrices can be created, and the *P[i]* initialized,
    in Θ(*n*²) time.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '创建*n*/2 × *n*/2矩阵*S*[1]、*S*[2]、…、*S*[10]，每个矩阵都是步骤1中两个子矩阵的和或差。创建并清零七个*n*/2 ×
    *n*/2矩阵*P*[1]、*P*[2]、…、*P*[7]，用于保存七个*n*/2 × *n*/2矩阵的乘积。所有17个矩阵可以在Θ(*n*²)时间内创建，并初始化*P[i]*。 '
- en: Using the submatrices from step 1 and the matrices *S*[1], *S*[2], … , *S*[10]
    created in step 2, recursively compute each of the seven matrix products *P*[1],
    *P*[2], … , *P*[7], taking 7*T* (*n*/2) time.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用步骤1中的子矩阵和步骤2中创建的*S*[1]、*S*[2]、…、*S*[10]矩阵，递归计算每个七个矩阵乘积*P*[1]、*P*[2]、…、*P*[7]，需要7*T*(*n*/2)的时间。
- en: Update the four submatrices *C*[11], *C*[12], *C*[21], *C*[22] of the result
    matrix *C* by adding or subtracting various *P[i]* matrices, which takes Θ(*n*²)
    time.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加或减去各种*P[i]*矩阵来更新结果矩阵*C*的四个子矩阵*C*[11]、*C*[12]、*C*[21]和*C*[22]，这需要Θ(*n*²)的时间。
- en: 'We’ll see the details of steps 2–4 in a moment, but we already have enough
    information to set up a recurrence for the running time of Strassen’s method.
    As is common, the base case in step 1 takes Θ(1) time, which we’ll omit when stating
    the recurrence. When *n* > 1, steps 1, 2, and 4 take a total of Θ(*n*²) time,
    and step 3 requires seven multiplications of *n*/2 × *n*/2 matrices. Hence, we
    obtain the following recurrence for the running time of Strassen’s algorithm:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的步骤2–4中看到细节，但我们已经有足够的信息来建立Strassen方法运行时间的递归。通常情况下，步骤1的基本情况需要Θ(1)的时间，我们在陈述递归时将其省略。当*n*
    > 1时，步骤1、2和4共需Θ(*n*²)的时间，步骤3需要七次*n*/2 × *n*/2矩阵的乘法。因此，我们得到Strassen算法运行时间的以下递归：
- en: '![art](images/Art_P105.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P105.jpg)'
- en: Compared with MATRIX-MULTIPLY-RECURSIVE, we have traded off one recursive submatrix
    multiplication for a constant number of submatrix additions. Once you understand
    recurrences and their solutions, you’ll be able to see why this trade-off actually
    leads to a lower asymptotic running time. By the master method in [Section 4.5](chapter004.xhtml#Sec_4.5),
    recurrence (4.10) has the solution *T* (*n*) = Θ(*n*^(lg 7)) = *O*(*n*^(2.81)),
    beating the Θ(*n*³)-time algorithms.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 与MATRIX-MULTIPLY-RECURSIVE相比，我们为一个递归子矩阵乘法交换了一个恒定数量的子矩阵加法。一旦你理解了递归及其解决方案，你就能看到为���么这种权衡实际上会导致更低的渐近运行时间。通过[第4.5节](chapter004.xhtml#Sec_4.5)中的主方法，递归(4.10)的解为*T*(*n*)
    = Θ(*n*^(lg 7)) = *O*(*n*^(2.81))，超过了Θ(*n*³)时间算法。
- en: 'Now, let’s delve into the details. Step 2 creates the following 10 matrices:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入细节。第2步创建以下10个矩阵：
- en: '| *S*[1] | = | *B*[12] – *B*[22], |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| *S*[1] | = | *B*[12] – *B*[22], |'
- en: '| *S*[2] | = | *A*[11] + *A*[12], |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| *S*[2] | = | *A*[11] + *A*[12], |'
- en: '| *S*[3] | = | *A*[21] + *A*[22], |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| *S*[3] | = | *A*[21] + *A*[22], |'
- en: '| *S*[4] | = | *B*[21] – *B*[11,] |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| *S*[4] | = | *B*[21] – *B*[11,] |'
- en: '| *S*[5] | = | *A*[11] + *A*[22], |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| *S*[5] | = | *A*[11] + *A*[22], |'
- en: '| *S*[6] | = | *B*[11] + *B*[22], |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| *S*[6] | = | *B*[11] + *B*[22], |'
- en: '| *S*[7] | = | *A*[12] – *A*[22], |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| *S*[7] | = | *A*[12] – *A*[22], |'
- en: '| *S*[8] | = | *B*[21] + *B*[22], |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| *S*[8] | = | *B*[21] + *B*[22], |'
- en: '| *S*[9] | = | *A*[11] – *A*[21,] |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| *S*[9] | = | *A*[11] – *A*[21,] |'
- en: '| *S*[10] | = | *B*[11] + *B*[12]. |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| *S*[10] | = | *B*[11] + *B*[12]. |'
- en: This step adds or subtracts *n*/2 × *n*/2 matrices 10 times, taking Θ(*n*²)
    time.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这一步添加或减去*n*/2 × *n*/2矩阵10次，需要Θ(*n*²)时间。
- en: 'Step 3 recursively multiplies *n*/2 × *n*/2 matrices 7 times to compute the
    following *n*/2 × *n*/2 matrices, each of which is the sum or difference of products
    of *A* and *B* submatrices:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 第3步递归地相乘*n*/2 × *n*/2矩阵7次，以计算以下*n*/2 × *n*/2矩阵，每个矩阵都是*A*和*B*子矩阵的乘积的和或差：
- en: '| *P*[1] | = | *A*[11] · *S*[1] | (= *A*[11] · *B*[12] – *A*[11] · *B*[22]),
    |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| *P*[1] | = | *A*[11] · *S*[1] | (= *A*[11] · *B*[12] – *A*[11] · *B*[22]),
    |'
- en: '| *P*[2] | = | *S*[2] · *B*[22] | (= *A*[11] · *B*[22] + *A*[12] · *B*[22]),
    |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| *P*[2] | = | *S*[2] · *B*[22] | (= *A*[11] · *B*[22] + *A*[12] · *B*[22]),
    |'
- en: '| *P*[3] | = | *S*[3] · *B*[11] | (= *A*[21] · *B*[11] + *A*[22] · *B*[11]),
    |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| *P*[3] | = | *S*[3] · *B*[11] | (= *A*[21] · *B*[11] + *A*[22] · *B*[11]),
    |'
- en: '| *P*[4] | = | *A*[22] · *S*[4] | (= *A*[22] · *B*[21] – *A*[22] · *B*[11]),
    |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| *P*[4] | = | *A*[22] · *S*[4] | (= *A*[22] · *B*[21] – *A*[22] · *B*[11]),
    |'
- en: '| *P*[5] | = | *S*[5] · *S*[6] | (= *A*[11] · *B*[11] + *A*[11] · *B*[22] +
    *A*[22] · *B*[11] + *A*[22] · *B*[22]), |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| *P*[5] | = | *S*[5] · *S*[6] | (= *A*[11] · *B*[11] + *A*[11] · *B*[22] +
    *A*[22] · *B*[11] + *A*[22] · *B*[22]), |'
- en: '| *P*[6] | = | *S*[7] · *S*[8] | (= *A*[12] · *B*[21] + *A*[12] · *B*[22] –
    *A*[22] · *B*[21] – *A*[22] · *B*[22]), |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| *P*[6] | = | *S*[7] · *S*[8] | (= *A*[12] · *B*[21] + *A*[12] · *B*[22] –
    *A*[22] · *B*[21] – *A*[22] · *B*[22]), |'
- en: '| *P*[7] | = | *S*[9] · *S*[10] | (= *A*[11] · *B*[11] + *A*[11] · *B*[12]
    – *A*[21] · *B*[11] – *A*[21] · *B*[12]). |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| *P*[7] | = | *S*[9] · *S*[10] | (= *A*[11] · *B*[11] + *A*[11] · *B*[12]
    – *A*[21] · *B*[11] – *A*[21] · *B*[12]). |'
- en: The only multiplications that the algorithm performs are those in the middle
    column of these equations. The right-hand column just shows what these products
    equal in terms of the original submatrices created in step 1, but the terms are
    never explicitly calculated by the algorithm.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 算法执行的唯一乘法是这些方程的中间列。右侧列只显示这些乘积如何等于步骤1中创建的原始子矩阵的术语，但算法从未明确计算这些术语。
- en: Step 4 adds to and subtracts from the four *n*/2 × *n*/2 submatrices of the
    product *C* the various *P[i]* matrices created in step 3\. We start with
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第4步将在乘积*C*的四个*n*/2 × *n*/2子矩阵中添加和减去在第3步中创建的各种*P[i]*矩阵。我们从以下开始
- en: '*C*[11] = *C*[11] + *P*[5] + *P*[4] – *P*[2] + *P*[6].'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '*C*[11] = *C*[11] + *P*[5] + *P*[4] – *P*[2] + *P*[6].'
- en: Expanding the calculation on the right-hand side, with the expansion of each
    *P[i]* on its own line and vertically aligning terms that cancel out, we see that
    the update to *C*[11] equals
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 展开右侧的计算，将每个*P[i]*的展开放在自己的一行上，并垂直对齐抵消的项，我们看到*C*[11]的更新等于
- en: '![art](images/Art_P106.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P106.jpg)'
- en: which corresponds to equation (4.5). Similarly, setting
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 对应方程（4.5）。类似地，设置
- en: '*C*[12] = *C*[12] + *P*[1] + *P*[2]'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '*C*[12] = *C*[12] + *P*[1] + *P*[2]'
- en: means that the update to *C*[12] equals
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着*C*[12]的更新等于
- en: '![art](images/Art_P107.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P107.jpg)'
- en: corresponding to equation (4.6). Setting
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 对应方程（4.6）。设置
- en: '*C*[21] = *C*[21] + *P*[3] + *P*[4]'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '*C*[21] = *C*[21] + *P*[3] + *P*[4]'
- en: means that the update to *C*[21] equals
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着*C*[21]的更新等于
- en: '![art](images/Art_P108.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P108.jpg)'
- en: corresponding to equation (4.7). Finally, setting
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 对应方程（4.7）。最后，设置
- en: '*C*[22] = *C*[22] + *P*[5] + *P*[1] – *P*[3] – *P*[7]'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '*C*[22] = *C*[22] + *P*[5] + *P*[1] – *P*[3] – *P*[7]'
- en: means that the update to *C*[22] equals
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着*C*[22]的更新等于
- en: '![art](images/Art_P109.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P109.jpg)'
- en: which corresponds to equation (4.8). Altogether, since we add or subtract *n*/2×*n*/2
    matrices 12 times in step 4, this step indeed takes Θ(*n*²) time.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 对应方程（4.8）。总的来说，在第4步中，由于我们在步骤4中添加或减去*n*/2×*n*/2矩阵12次，因此这一步确实需要Θ(*n*²)时间。
- en: We can see that Strassen’s remarkable algorithm, comprising steps 1–4, produces
    the correct matrix product using 7 submatrix multiplications and 18 submatrix
    additions. We can also see that recurrence (4.10) characterizes its running time.
    Since [Section 4.5](chapter004.xhtml#Sec_4.5) shows that this recurrence has the
    solution *T* (*n*) = Θ(*n*^(lg 7)) = *o*(*n*³), Strassen’s method asymptotically
    beats the Θ(*n*³) MATRIX-MULTIPLY and MATRIX-MULTIPLY-RECURSIVE procedures.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到Strassen的remarkable算法，包括步骤1-4，使用7个子矩阵乘法和18个子矩阵加法产生正确的矩阵乘积。我们还可以看到递归（4.10）表征了它的运行时间。由于[第4.5节](chapter004.xhtml#Sec_4.5)显示这个递归的解决方案为*T*(*n*)
    = Θ(*n*^(lg 7)) = *o*(*n*³)，Strassen的方法在渐近上击败了Θ(*n*³) MATRIX-MULTIPLY和MATRIX-MULTIPLY-RECURSIVE程序。
- en: '**Exercises**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '*Note:* You may wish to read [Section 4.5](chapter004.xhtml#Sec_4.5) before
    attempting some of these exercises.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '*注意：* 在尝试这些练习之前，您可能希望阅读[第4.5节](chapter004.xhtml#Sec_4.5)。'
- en: '***4.2-1***'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.2-1***'
- en: Use Strassen’s algorithm to compute the matrix product
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Strassen算法计算矩阵乘积
- en: '![art](images/Art_P110.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P110.jpg)'
- en: Show your work.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 展示你的工作。
- en: '***4.2-2***'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.2-2***'
- en: Write pseudocode for Strassen’s algorithm.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为Strassen算法编写伪代码。
- en: '***4.2-3***'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.2-3***'
- en: What is the largest *k* such that if you can multiply 3 × 3 matrices using *k*
    multiplications (not assuming commutativity of multiplication), then you can multiply
    *n* × *n* matrices in *o*(*n*^(lg 7)) time? What is the running time of this algorithm?
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当你可以使用*k*次乘法（不假设乘法的交换性）来相乘3×3矩阵时，最大的*k*是多少，那么你可以在*o*(*n*^(lg 7))时间内相乘*n*×*n*矩阵？这个算法的运行时间是多少？
- en: '***4.2-4***'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.2-4***'
- en: V. Pan discovered a way of multiplying 68 × 68 matrices using 132,464 multiplications,
    a way of multiplying 70 × 70 matrices using 143,640 multiplications, and a way
    of multiplying 72 × 72 matrices using 155,424 multiplications. Which method yields
    the best asymptotic running time when used in a divide-and-conquer matrix-multiplication
    algorithm? How does it compare with Strassen’s algorithm?
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: V. Pan发现了一种使用132,464次乘法来计算68 × 68矩阵乘法的方法，一种使用143,640次乘法来计算70 × 70矩阵乘法的方法，以及一种使用155,424次乘法来计算72
    × 72矩阵乘法的方法。在使用分治矩阵乘法算法时，哪种方法提供了最佳的渐近运行时间？它与Strassen算法相比如何？
- en: '***4.2-5***'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.2-5***'
- en: Show how to multiply the complex numbers *a* + *bi* and *c* + *d i* using only
    three multiplications of real numbers. The algorithm should take *a*, *b*, *c*,
    and *d* as input and produce the real component *ac* – *bd* and the imaginary
    component *ad* + *bc* separately.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何仅使用三次实数乘法来计算复数*a* + *bi*和*c* + *d i*的乘积。该算法应该以*a*、*b*、*c*和*d*作为输入，并分别产生实部*ac*
    – *bd*和虚部*ad* + *bc*。
- en: '***4.2-6***'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.2-6***'
- en: Suppose that you have a Θ(*n^α*)-time algorithm for squaring *n* × *n* matrices,
    where *α* ≥ 2\. Show how to use that algorithm to multiply two different *n* ×
    *n* matrices in Θ(*n^α*) time.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有一个Θ(*n^α*)时间复杂度的算法用于计算*n* × *n*矩阵的平方，其中*α* ≥ 2。展示如何使用该算法在Θ(*n^α*)时间内计算两个不同的*n*
    × *n*矩阵的乘积。
- en: '[**4.3      The substitution method for solving recurrences**](toc.xhtml#Rh1-18)'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '[**4.3      解递归的替换法**](toc.xhtml#Rh1-18)'
- en: 'Now that you have seen how recurrences characterize the running times of divide-and-conquer
    algorithms, let’s learn how to solve them. We start in this section with the ***substitution
    method***, which is the most general of the four methods in this chapter. The
    substitution method comprises two steps:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 现在您已经了解了递归如何描述分治算法的运行时间，让我们学习如何解决它们。我们从本节开始介绍***替换法***，这是本章四种方法中最通用的方法。替换法包括两个步骤：
- en: Guess the form of the solution using symbolic constants.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用符号常数猜测解的形式。
- en: Use mathematical induction to show that the solution works, and find the constants.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数学归纳法证明解的有效性，并找出常数。
- en: To apply the inductive hypothesis, you substitute the guessed solution for the
    function on smaller values—hence the name “substitution method.” This method is
    powerful, but you must guess the form of the answer. Although generating a good
    guess might seem difficult, a little practice can quickly improve your intuition.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用归纳假设，您将替换较小值上函数的猜测解—因此得名“替换法”。这种方法很强大，但您必须猜测答案的形式。尽管生成一个好的猜测可能看起来困难，但稍微练习一下就可以迅速提高您的直觉。
- en: You can use the substitution method to establish either an upper or a lower
    bound on a recurrence. It’s usually best not to try to do both at the same time.
    That is, rather than trying to prove a Θ-bound directly, first prove an *O*-bound,
    and then prove an Ω-bound. Together, they give you a Θ-bound (Theorem 3.1 on page
    56).
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用替换法来建立递归的上界或下界。通常最好不要同时尝试两者。也就是说，不要直接尝试证明Θ-界，而是先证明一个*O*-界，然后证明一个Ω-界。它们一起给出了Θ-界（第56页的定理3.1）。
- en: 'As an example of the substitution method, let’s determine an asymptotic upper
    bound on the recurrence:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 作为替换法的一个示例，让我们确定递归的渐近上界：
- en: '![art](images/Art_P111.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P111.jpg)'
- en: This recurrence is similar to recurrence (2.3) on page 41 for merge sort, except
    for the floor function, which ensures that *T* (*n*) is defined over the integers.
    Let’s guess that the asymptotic upper bound is the same—*T* (*n*) = *O*(*n* lg
    *n*)—and use the substitution method to prove it.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这个递归类似于第41页上合并排序的递归（2.3），除了地板函数，它确保了*T* (*n*)在整数上定义。让我们猜测渐近上界是相同的—*T* (*n*)
    = *O*(*n* lg *n*)—并使用替换法来证明它。
- en: We’ll adopt the inductive hypothesis that *T* (*n*) ≤ *c n* lg *n* for all *n*
    ≥ *n*[0], where we’ll choose the specific constants *c* > 0 and *n*[0] > 0 later,
    after we see what constraints they need to obey. If we can establish this inductive
    hypothesis, we can conclude that *T* (*n*) = *O*(*n* lg *n*). It would be dangerous
    to use *T* (*n*) = *O*(*n* lg *n*) as the inductive hypothesis because the constants
    matter, as we’ll see in a moment in our discussion of pitfalls.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用归纳假设，即对于所有*n* ≥ *n*[0]，*T* (*n*) ≤ *c n* lg *n*，其中我们稍后会选择特定的常数*c* > 0和*n*[0]
    > 0，看看它们需要遵守什么约束。如果我们能建立这个归纳假设，我们就可以得出结论，*T* (*n*) = *O*(*n* lg *n*)。在归纳假设中使用*T*
    (*n*) = *O*(*n* lg *n*)是危险的，因为常数很重要，我们将在讨论陷阱时看到。
- en: Assume by induction that this bound holds for all numbers at least as big as
    *n*[0] and less than *n*. In particular, therefore, if *n* ≥ 2*n*[0], it holds
    for ⌊*n*/2⌋, yielding *T* (⌊*n*/2 ⌋) ≤ *c* ⌊*n*/2⌋ lg(⌊*n*/2⌋). Substituting into
    recurrence (4.11)—hence the name “substitution” method—yields
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设通过归纳法，这个界对所有大于等于*n*[0]且小于*n*的数字都成立。特别地，如果*n* ≥ 2*n*[0]，它对⌊*n*/2⌋成立，得到 *T*
    (⌊*n*/2 ⌋) ≤ *c* ⌊*n*/2⌋ lg(⌊*n*/2⌋)。将其代入递归式(4.11)——因此得名“替换法”——得到
- en: '| *T* (*n*) | ≤ | 2(*c* ⌊*n*/2⌋ lg(⌊*n*/2⌋)) + Θ(*n*) |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| *T* (*n*) | ≤ | 2(*c* ⌊*n*/2⌋ lg(⌊*n*/2⌋)) + Θ(*n*) |'
- en: '|  | ≤ | 2(*c*(*n*/2) lg(*n*/2)) + Θ(*n*) |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | 2(*c*(*n*/2) lg(*n*/2)) + Θ(*n*) |'
- en: '|  | = | *cn* lg(*n*/2) + Θ(*n*) |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *cn* lg(*n*/2) + Θ(*n*) |'
- en: '|  | = | *cn* lg *n* – *cn* lg 2 + Θ(*n*) |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *cn* lg *n* – *cn* lg 2 + Θ(*n*) |'
- en: '|  | = | *cn* lg *n* – *cn* + Θ(*n*) |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *cn* lg *n* – *cn* + Θ(*n*) |'
- en: '|  | ≤ | *cn* lg *n*, |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | *cn* lg *n*, |'
- en: where the last step holds if we constrain the constants *n*[0] and *c* to be
    sufficiently large that for *n* ≥ 2*n*[0], the quantity *cn* dominates the anonymous
    function hidden by the Θ(*n*) term.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们限制常数*n*[0]和*c*足够大，使得对于*n* ≥ 2*n*[0]，*cn*支配了被Θ(*n*)项隐藏的匿名函数，那么最后一步成立。
- en: We’ve shown that the inductive hypothesis holds for the inductive case, but
    we also need to prove that the inductive hypothesis holds for the base cases of
    the induction, that is, that *T* (*n*) ≤ *cn* lg *n* when *n*[0] ≤ *n* < 2*n*[0].
    As long as *n*[0] > 1 (a new constraint on *n*[0]), we have lg *n* > 0, which
    implies that *n* lg *n* > 0\. So let’s pick *n*[0] = 2\. Since the base case of
    recurrence (4.11) is not stated explicitly, by our convention, *T* (*n*) is algorithmic,
    which means that *T* (2) and *T* (3) are constant (as they should be if they describe
    the worst-case running time of any real program on inputs of size 2 or 3). Picking
    *c* = max {*T* (2), *T* (3)} yields *T* (2) ≤ *c* < (2 lg 2)*c* and *T* (3) ≤
    *c* < (3 lg 3)*c*, establishing the inductive hypothesis for the base cases.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经证明了归纳假设对归纳情况成立，但我们还需要证明归纳假设对归纳的基本情况也成立，也就是说，当 *n*[0] ≤ *n* < 2*n*[0] 时，*T*
    (*n*) ≤ *cn* lg *n*。只要 *n*[0] > 1（对 *n*[0] 的新约束），我们有 lg *n* > 0，这意味着 *n* lg *n*
    > 0。所以让我们选择 *n*[0] = 2。由于递归（4.11）的基本情况没有明确说明，按照我们的约定，*T* (*n*) 是算法性的，这意味着 *T*
    (2) 和 *T* (3) 是常数（如果它们描述了任何实际程序在大小为 2 或 3 的输入上的最坏情况运行时间，那么它们应该是常数）。选择 *c* = max
    {*T* (2), *T* (3)} 可以得到 *T* (2) ≤ *c* < (2 lg 2)*c* 和 *T* (3) ≤ *c* < (3 lg 3)*c*，为基本情况建立了归纳假设。
- en: Thus, we have *T* (*n*) ≤ *cn* lg *n* for all *n* ≥ 2, which implies that the
    solution to recurrence (4.11) is *T* (*n*) = *O*(*n* lg *n*).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有对于所有 *n* ≥ 2，*T* (*n*) ≤ *cn* lg *n*，这意味着递归（4.11）的解为 *T* (*n*) = *O*(*n*
    lg *n*)。
- en: In the algorithms literature, people rarely carry out their substitution proofs
    to this level of detail, especially in their treatment of base cases. The reason
    is that for most algorithmic divide-and-conquer recurrences, the base cases are
    all handled in pretty much the same way. You ground the induction on a range of
    values from a convenient positive constant *n*[0] up to some constant ![art](images/Art_P112.jpg)
    such that for ![art](images/Art_P113.jpg), the recurrence always bottoms out in
    a constant-sized base case between *n*[0] and ![art](images/Art_P114.jpg). (This
    example used ![art](images/Art_P115.jpg).) Then, it’s usually apparent, without
    spelling out the details, that with a suitably large choice of the leading constant
    (such as *c* for this example), the inductive hypothesis can be made to hold for
    all the values in the range from *n*[0] to ![art](images/Art_P116.jpg).
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在算法文献中，人们很少在替换证明中进行这种详细的处理，尤其是在处理基本情况时。原因是对于大多数算法分治递归，基本情况都以几乎相同的方式处理。你可以将归纳基于从方便的正常常数
    *n*[0] 到某个常数 ![art](images/Art_P112.jpg) 的值范围，使得对于 ![art](images/Art_P113.jpg)，递归总是在
    *n*[0] 和 ![art](images/Art_P114.jpg) 之间的一个常数大小的基本情况中结束。（本例使用 ![art](images/Art_P115.jpg)。）然后，通常很明显，不用详细说明细节，只需选择合适的主导常数（例如本例中的
    *c*），归纳假设就可以适用于从 *n*[0] 到 ![art](images/Art_P116.jpg) 范围内的所有值。
- en: '**Making a good guess**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**做出良好猜测**'
- en: Unfortunately, there is no general way to correctly guess the tightest asymptotic
    solution to an arbitrary recurrence. Making a good guess takes experience and,
    occasionally, creativity. Fortunately, learning some recurrence-solving heuristics,
    as well as playing around with recurrences to gain experience, can help you become
    a good guesser. You can also use recursion trees, which we’ll see in [Section
    4.4](chapter004.xhtml#Sec_4.4), to help generate good guesses.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，没有一种通用方法可以正确猜测任意递归的最紧密渐近解。做出良好猜测需要经验，有时还需要创造力。幸运的是，学习一些递归求解启发式方法，以及通过处理递归来积累经验，可以帮助你成为一个好的猜测者。你还可以使用递归树，我们将在[第
    4.4 节](chapter004.xhtml#Sec_4.4)中看到，以帮助生成良好的猜测。
- en: If a recurrence is similar to one you’ve seen before, then guessing a similar
    solution is reasonable. As an example, consider the recurrence
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个递归类似于你之前见过的递归，那么猜测一个类似的解决方案是合理的。例如，考虑递归
- en: '*T* (*n*) = 2*T* (*n*/2 + 17) + Θ(*n*),'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '*T* (*n*) = 2*T* (*n*/2 + 17) + Θ(*n*)'
- en: 'defined on the reals. This recurrence looks somewhat like the merge-sort recurrence
    (2.3), but it’s more complicated because of the added “17” in the argument to
    *T* on the right-hand side. Intuitively, however, this additional term shouldn’t
    substantially affect the solution to the recurrence. When *n* is large, the relative
    difference between *n*/2 and *n*/2 + 17 is not that large: both cut *n* nearly
    in half. Consequently, it makes sense to guess that *T* (*n*) = *O*(*n* lg *n*),
    which you can verify is correct using the substitution method (see Exercise 4.3-1).'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在实数上定义。这个递归看起来有点像归并排序递归（2.3），但由于右侧 *T* 参数中添加了“17”，所以更复杂。然而，直观上，这个额外项不应该对递归的解产生实质影响。当
    *n* 很大时，*n*/2 和 *n*/2 + 17 之间的相对差异并不大：两者几乎将 *n* 对半分。因此，猜测 *T* (*n*) = *O*(*n*
    lg *n*) 是有道理的，你可以使用替换方法验证这是正确的（参见练习 4.3-1）。
- en: Another way to make a good guess is to determine loose upper and lower bounds
    on the recurrence and then reduce your range of uncertainty. For example, you
    might start with a lower bound of *T* (*n*) = Ω(*n*) for recurrence (4.11), since
    the recurrence includes the term Θ(*n*), and you can prove an initial upper bound
    of *T* (*n*) = *O*(*n*²). Then split your time between trying to lower the upper
    bound and trying to raise the lower bound until you converge on the correct, asymptotically
    tight solution, which in this case is *T* (*n*) = Θ(*n* lg *n*).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种做出良好猜测的方法是确定递归的宽松上下界，然后缩小不确定性范围。例如，你可以从 *T* (*n*) = Ω(*n*) 的下界开始考虑递归（4.11），因为递归包含
    Θ(*n*) 项，你可以证明初始上界为 *T* (*n*) = *O*(*n*²)。然后在尝试降低上界和提高下界之间分配时间，直到收敛于正确的、渐近紧密的解决方案，本例中为
    *T* (*n*) = Θ(*n* lg *n*)。
- en: '**A trick of the trade: subtracting a low-order term**'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个行业技巧：减去低阶项**'
- en: Sometimes, you might correctly guess a tight asymptotic bound on the solution
    of a recurrence, but somehow the math fails to work out in the induction proof.
    The problem frequently turns out to be that the inductive assumption is not strong
    enough. The trick to resolving this problem is to revise your guess by *subtracting*
    a lower-order term when you hit such a snag. The math then often goes through.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你可能正确猜测了递归解的紧密渐近界限，但是数学证明中却出现问题。问题通常是归纳假设不够强。解决这个问题的技巧是在遇到这种困难时通过*减去*一个低阶项来修改你的猜测。这样做通常会让数学证明顺利进行。
- en: Consider the recurrence
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑递归式
- en: '![art](images/Art_P117.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P117.jpg)'
- en: defined on the reals. Let’s guess that the solution is *T* (*n*) = *O*(*n*)
    and try to show that *T* (*n*) ≤ *cn* for *n* ≥ *n*[0], where we choose the constants
    *c*, *n*[0] > 0 suitably. Substituting our guess into the recurrence, we obtain
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 定义在实数上。让我们猜测解是 *T* (*n*) = *O*(*n*)，并尝试证明对于 *n* ≥ *n*[0]，*T* (*n*) ≤ *cn*，其中我们适当选择常数
    *c*，*n*[0] > 0。将我们的猜测代入递归式，我们得到
- en: '| *T* (*n*) | ≤ | 2(*c*(*n*/2)) + Θ(1) |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| *T* (*n*) | ≤ | 2(*c*(*n*/2)) + Θ(1) |'
- en: '|  | = | *cn* + Θ(1), |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *cn* + Θ(1), |'
- en: which, unfortunately, does not imply that *T* (*n*) ≤ *cn* for *any* choice
    of *c*. We might be tempted to try a larger guess, say *T* (*n*) = *O*(*n*²).
    Although this larger guess works, it provides only a loose upper bound. It turns
    out that our original guess of *T* (*n*) = *O*(*n*) is correct and tight. In order
    to show that it is correct, however, we must strengthen our inductive hypothesis.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这并不意味着 *T* (*n*) ≤ *cn* 对于*任何*选择的 *c* 都成立。我们可能会尝试一个更大的猜测，比如 *T* (*n*) = *O*(*n*²)。尽管这个更大的猜测有效，但它只提供了一个宽松的上界。事实证明，我们最初的猜测
    *T* (*n*) = *O*(*n*) 是正确且紧密的。然而，为了证明它是正确的，我们必须加强我们的归纳假设。
- en: 'Intuitively, our guess is nearly right: we are off only by Θ(1), a lower-order
    term. Nevertheless, mathematical induction requires us to prove the *exact* form
    of the inductive hypothesis. Let’s try our trick of subtracting a lower-order
    term from our previous guess: *T* (*n*) ≤ *cn* – *d*, where *d* ≥ 0 is a constant.
    We now have'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 直观上，我们的猜测几乎正确：我们只差 Θ(1)，一个低阶项。然而，数学归纳要求我们证明归纳假设的*确切*形式。让我们尝试从先前的猜测中减去一个低阶项的技巧：*T*
    (*n*) ≤ *cn* – *d*，其中 *d* ≥ 0 是一个常数。我们现在有
- en: '| *T* (*n*) | ≤ | 2(*c*(*n*/2) – *d*) + Θ(1) |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| *T* (*n*) | ≤ | 2(*c*(*n*/2) – *d*) + Θ(1) |'
- en: '|  | = | *cn* – 2*d* + Θ(1) |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *cn* – 2*d* + Θ(1) |'
- en: '|  | ≤ | *cn* – *d* – (*d* – Θ(1)) |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | *cn* – *d* – (*d* – Θ(1)) |'
- en: '|  | ≤ | *cn* – *d* |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | *cn* ��� *d* |'
- en: as long as we choose *d* to be larger than the anonymous upper-bound constant
    hidden by the Θ-notation. Subtracting a lower-order term works! Of course, we
    must not forget to handle the base case, which is to choose the constant *c* large
    enough that *cn* – *d* dominates the implicit base cases.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 只要我们选择 *d* 大于 Θ-符号隐藏的匿名上界常数。减去一个低阶项是有效的！当然，我们不能忘记处理基本情况，即选择足够大的常数 *c*，使得 *cn*
    – *d* 主导隐含的基本情况。
- en: You might find the idea of subtracting a lower-order term to be counterintuitive.
    After all, if the math doesn’t work out, shouldn’t you increase your guess? Not
    necessarily! When the recurrence contains more than one recursive invocation (recurrence
    (4.12) contains two), if you add a lower-order term to the guess, then you end
    up adding it once for each of the recursive invocations. Doing so takes you even
    further away from the inductive hypothesis. On the other hand, if you subtract
    a lower-order term from the guess, then you get to subtract it once for each of
    the recursive invocations. In the above example, we subtracted the constant *d*
    twice because the coefficient of *T* (*n*/2) is 2\. We ended up with the inequality
    *T* (*n*) ≤ *cn* – *d* – (*d* – Θ(1)), and we readily found a suitable value for
    *d*.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会觉得减去一个低阶项的想法有些反直觉。毕竟，如果数学不成立，你应该增加你的猜测吗？不一定！当递归包含多个递归调用时（递归式（4.12）包含两个），如果你为猜测添加一个低阶项，那么你最终会为每个递归调用添加一次。这样做会让你离归纳假设更远。另一方面，如果你从猜测中减去一个低阶项，那么你可以为每个递归调用减去一次。在上面的例子中，我们减去常数
    *d* 两次，因为 *T* (*n*/2) 的系数是 2。我们得到了不等式 *T* (*n*) ≤ *cn* – *d* – (*d* – Θ(1))，然后我们很容易找到一个合适的
    *d* 的值。
- en: '**Avoiding pitfalls**'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '**避免陷阱**'
- en: 'Avoid using asymptotic notation in the inductive hypothesis for the substitution
    method because it’s error prone. For example, for recurrence (4.11), we can falsely
    “prove” that *T* (*n*) = *O*(*n*) if we unwisely adopt *T* (*n*) = *O*(*n*) as
    our inductive hypothesis:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在替换方法中，避免在归纳假设中使用渐近符号，因为这样容易出错。例如，对于递归式（4.11），如果我们不明智地采用 *T* (*n*) = *O*(*n*)
    作为我们的归纳假设，我们可能会错误地“证明” *T* (*n*) = *O*(*n*)：
- en: '| *T* (*n*) | ≤ | 2 · *O*(⌊*n*/2⌋) + Θ(*n*) |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '| *T* (*n*) | ≤ | 2 · *O*(⌊*n*/2⌋) + Θ(*n*) |'
- en: '|  | = | 2 · *O*(*n*) + Θ(*n*) |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 2 · *O*(*n*) + Θ(*n*) |'
- en: '|  | = | *O*(*n*). | ![art](images/arrow.jpg) *wrong*! |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *O*(*n*). | ![艺术](images/arrow.jpg) *错误*！ |'
- en: The problem with this reasoning is that the constant hidden by the *O*-notation
    changes. We can expose the fallacy by repeating the “proof” using an explicit
    constant. For the inductive hypothesis, assume that *T* (*n*) ≤ *cn* for all *n*
    ≥ *n*[0], where *c*, *n*[0] > 0 are constants. Repeating the first two steps in
    the inequality chain yields
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 这种推理的问题在于 *O* 符号隐藏的常数会发生变化。我们可以通过使用显式常数重复“证明”来暴露这个谬误。对于归纳假设，假设对于所有 *n* ≥ *n*[0]，*T*
    (*n*) ≤ *cn*，其中 *c*，*n*[0] > 0 是常数。重复不等式链中的前两步得到
- en: '| *T* (*n*) | ≤ | 2(*c* ⌊*n*/2⌋) + Θ(*n*) |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| *T* (*n*) | ≤ | 2(*c* ⌊*n*/2⌋) + Θ(*n*) |'
- en: '|  | ≤ | *cn* + Θ(*n*). |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | *cn* + Θ(*n*). |'
- en: Now, indeed *cn* + Θ(*n*) = *O*(*n*), but the constant hidden by the *O*-notation
    must be larger than *c* because the anonymous function hidden by the Θ(*n*) is
    asymptotically positive. We cannot take the third step to conclude that *cn* +
    Θ(*n*) ≤ *cn*, thus exposing the fallacy.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，确实 *cn* + Θ(*n*) = *O*(*n*), 但是被 *O* 符号隐藏的常数必须大于 *c*，因为被 Θ(*n*) 隐藏的匿名函数是渐近正的。我们不能通过第三步得出
    *cn* + Θ(*n*) ≤ *cn* 的结论，从而暴露了谬误。
- en: When using the substitution method, or more generally mathematical induction,
    you must be careful that the constants hidden by any asymptotic notation are the
    same constants throughout the proof. Consequently, it’s best to avoid asymptotic
    notation in your inductive hypothesis and to name constants explicitly.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用替换方法或更一般的数学归纳时，您必须小心确保任何渐近符号隐藏的常数在整个证明中是相同的。因此，在您的归纳假设中最好避免渐近符号，并明确命名常数。
- en: Here’s another fallacious use of the substitution method to show that the solution
    to recurrence (4.11) is *T* (*n*) = *O*(*n*). We guess *T* (*n*) ≤ *cn* and then
    argue
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是另一个错误使用替换方法来展示递归（4.11）解为*T*(*n*) = *O*(*n*)的例子。我们猜测*T*(*n*) ≤ *cn*，然后进行论证
- en: '| *T* (*n*) | ≤ | 2(*c* ⌊*n*/2⌋) + Θ(*n*) |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| *T*(*n*) | ≤ | 2(*c* ⌊*n*/2⌋) + Θ(*n*) |'
- en: '|  | ≤ | *cn* + Θ(*n*) |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | *cn* + Θ(*n*) |'
- en: '|  | = | *O*(*n*), | ![art](images/arrow.jpg) *wrong*! |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *O*(*n*)， | ![艺术](images/arrow.jpg) *错误*! |'
- en: since *c* is a positive constant. The mistake stems from the difference between
    our goal—to prove that *T* (*n*) = *O*(*n*)—and our inductive hypothesis—to prove
    that *T* (*n*) ≤ *cn*. When using the substitution method, or in any inductive
    proof, you must prove the *exact* statement of the inductive hypothesis. In this
    case, we must explicitly prove that *T* (*n*) ≤ *cn* to show that *T* (*n*) =
    *O*(*n*).
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*c*是一个正常数。错误源于我们的目标之间的差异—证明*T*(*n*) = *O*(*n*)—和我们的归纳假设—证明*T*(*n*) ≤ *cn*。在使用替换方法或任何归纳证明时，您必须证明归纳假设的*确切*陈述。在这种情况下，我们必须明确证明*T*(*n*)
    ≤ *cn*以证明*T*(*n*) = *O*(*n*)。
- en: '**Exercises**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***4.3-1***'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.3-1***'
- en: 'Use the substitution method to show that each of the following recurrences
    defined on the reals has the asymptotic solution specified:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 使用替换方法展示在实数上定义的以下递归的渐近解：
- en: '***a.*** *T* (*n*) = *T* (*n* – 1) + *n* has solution *T* (*n*) = *O*(*n*²).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** *T*(*n*) = *T*(*n* – 1) + *n*的解为*T*(*n*) = *O*(*n*²)。'
- en: '***b.*** *T* (*n*) = *T* (*n*/2) + Θ(1) has solution *T* (*n*) = *O*(lg *n*).'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** *T*(*n*) = *T*(*n*/2) + Θ(1)的解为*T*(*n*) = *O*(lg *n*)。'
- en: '***c.*** *T* (*n*) = 2*T* (*n*/2) + *n* has solution *T* (*n*) = Θ(*n* lg *n*).'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** *T*(*n*) = 2*T*(*n*/2) + *n*的解为*T*(*n*) = Θ(*n* lg *n*)。'
- en: '***d.*** *T* (*n*) = 2*T* (*n*/2 + 17) + *n* has solution *T* (*n*) = *O*(*n*
    lg *n*).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** *T*(*n*) = 2*T*(*n*/2 + 17) + *n*的解为*T*(*n*) = *O*(*n* lg *n*)。'
- en: '***e.*** *T* (*n*) = 2*T* (*n*/3) + Θ(*n*) has solution *T* (*n*) = Θ(*n*).'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** *T*(*n*) = 2*T*(*n*/3) + Θ(*n*)的解为*T*(*n*) = Θ(*n*)。'
- en: '***f.*** *T* (*n*) = 4*T* (*n*/2) + Θ(*n*) has solution *T* (*n*) = Θ(*n*²).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '***f.*** *T*(*n*) = 4*T*(*n*/2) + Θ(*n*)的解为*T*(*n*) = Θ(*n*²)。'
- en: '***4.3-2***'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.3-2***'
- en: The solution to the recurrence *T* (*n*) = 4*T* (*n*/2)+*n* turns out to be
    *T* (*n*) = Θ(*n*²). Show that a substitution proof with the assumption *T* (*n*)
    ≤ *cn*² fails. Then show how to subtract a lower-order term to make a substitution
    proof work.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 递归*T*(*n*) = 4*T*(*n*/2)+*n*的解为*T*(*n*) = Θ(*n*²)。展示一个替换证明失败的假设*T*(*n*) ≤ *cn*²。然后展示如何减去一个低阶项使替换证明有效。
- en: '***4.3-3***'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.3-3***'
- en: The recurrence *T* (*n*) = 2*T* (*n* – 1) + 1 has the solution *T* (*n*) = *O*(2*^n*).
    Show that a substitution proof fails with the assumption *T* (*n*) ≤ *c* 2*^n*,
    where *c* > 0 is constant. Then show how to subtract a lower-order term to make
    a substitution proof work.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 递归*T*(*n*) = 2*T*(*n* – 1) + 1的解为*T*(*n*) = *O*(2*^n*)。展示一个替换证明失败的假设*T*(*n*)
    ≤ *c* 2*^n*，其中*c* > 0是常数。然后展示如何减去一个低阶项使替换证明有效。
- en: '[**4.4      The recursion-tree method for solving recurrences**](toc.xhtml#Rh1-19)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '[**4.4      用于解决递归的递归树方法**](toc.xhtml#Rh1-19)'
- en: Although you can use the substitution method to prove that a solution to a recurrence
    is correct, you might have trouble coming up with a good guess. Drawing out a
    recursion tree, as we did in our analysis of the merge-sort recurrence in [Section
    2.3.2](chapter002.xhtml#Sec_2.3.2), can help. In a ***recursion tree***, each
    node represents the cost of a single subproblem somewhere in the set of recursive
    function invocations. You typically sum the costs within each level of the tree
    to obtain the per-level costs, and then you sum all the per-level costs to determine
    the total cost of all levels of the recursion. Sometimes, however, adding up the
    total cost takes more creativity.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以使用替换方法证明递归的解是正确的，但您可能会在想出一个良好的猜测时遇到困难。绘制递归树，就像我们在[Section 2.3.2](chapter002.xhtml#Sec_2.3.2)中对归并排序递归的分析中所做的那样，可以帮助。在***递归树***中，每个节点代表递归函数调用集合中某个地��的单个子问题的成本。通常，您会在树的每个级别内求和成本以获得每个级别的成本，然后您会将所有每个级别的成本相加以确定递归所有级别的总成本。然而，有时候，计算总成本需要更多的创造力。
- en: A recursion tree is best used to generate intuition for a good guess, which
    you can then verify by the substitution method. If you are meticulous when drawing
    out a recursion tree and summing the costs, however, you can use a recursion tree
    as a direct proof of a solution to a recurrence. But if you use it only to generate
    a good guess, you can often tolerate a small amount of “sloppiness,” which can
    simplify the math. When you verify your guess with the substitution method later
    on, your math should be precise. This section demonstrates how you can use recursion
    trees to solve recurrences, generate good guesses, and gain intuition for recurrences.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 递归树最适合用于生成对递归的一个良好猜测的直觉，然后您可以通过替换方法进行验证。然而，如果您在绘制递归树和求和成本时细致入微，您可以将递归树用作对递归解的直接证明。但是，如果您只是用它来生成一个良好的猜测，通常可以容忍一点“粗心”，这样可以简化数学。当您稍后用替换方法验证您的猜测时，您的数学应该是精确的。本节演示了如何使用递归树来解决递归，生成良好的猜测，并获得对递归的直觉。
- en: '**An illustrative example**'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个说明性例子**'
- en: Let’s see how a recursion tree can provide a good guess for an upper-bound solution
    to the recurrence
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看递归树如何为递归提供一个上界解的好猜测
- en: '![art](images/Art_P118.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P118.jpg)'
- en: '[Figure 4.1](chapter004.xhtml#Fig_4-1) shows how to derive the recursion tree
    for *T* (*n*) = 3*T* (*n*/4) + *cn*², where the constant *c* > 0 is the upper-bound
    constant in the Θ(*n*²) term. Part (a) of the figure shows *T* (*n*), which part
    (b) expands into an equivalent tree representing the recurrence. The *cn*² term
    at the root represents the cost at the top level of recursion, and the three subtrees
    of the root represent the costs incurred by the subproblems of size *n*/4\. Part
    (c) shows this process carried one step further by expanding each node with cost
    *T* (*n*/4) from part (b). The cost for each of the three children of the root
    is *c*(*n*/4)². We continue expanding each node in the tree by breaking it into
    its constituent parts as determined by the recurrence.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.1](chapter004.xhtml#Fig_4-1)展示了如何为*T* (*n*) = 3*T* (*n*/4) + *cn*²推导递归树，其中常数*c*
    > 0是Θ(*n*²)项的上界常数。图的(a)部分展示了*T* (*n*)，而(b)部分将其展开为表示递归的等效树。根节点处的*cn*²项代表了递归的顶层成本，而根节点的三个子树代表了大小为*n*/4的子问题产生的成本。图的(c)部分展示了进一步展开每个来自(b)部分的成本为*T*
    (*n*/4)的过程。根节点的三个子节点的成本为*c*(*n*/4)²。我们继续通过树中的每个节点展开，将其分解为由递归确定的各部分。'
- en: '![art](images/Art_P119.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P119.jpg)'
- en: '**Figure 4.1** Constructing a recursion tree for the recurrence *T* (*n*) =
    3*T* (*n*/4) + *cn*². Part **(a)** shows *T* (*n*), which progressively expands
    in **(b)–(d)** to form the recursion tree. The fully expanded tree in **(d)**
    has height log[4] *n*.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.1** 构建递归树，递归式为*T* (*n*) = 3*T* (*n*/4) + *cn*²。部分**(a)**展示了*T* (*n*)，逐渐在**(b)–(d)**中展开形成递归树。在**(d)**中完全展开的树的高度为log[4] *n*。'
- en: Because subproblem sizes decrease by a factor of 4 every time we go down one
    level, the recursion must eventually bottom out in a base case where *n* < *n*[0].
    By convention, the base case is *T* (*n*) = Θ(1) for *n* < *n*[0], where *n*[0]
    > 0 is any threshold constant sufficiently large that the recurrence is well defined.
    For the purpose of intuition, however, let’s simplify the math a little. Let’s
    assume that *n* is an exact power of 4 and that the base case is *T* (1) = Θ(1).
    As it turns out, these assumptions don’t affect the asymptotic solution.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每次向下一级时子问题大小减少4倍，所以递归最终必须在子问题大小小于*n*[0]的基本情况中结束。按照惯例，基本情况是对于*n* < *n*[0]，*T*
    (*n*) = Θ(1)，其中*n*[0] > 0是任何足够大以使递归定义良好的阈值常数。然而，为了直观起见，让我们简化一下数学。假设*n*是4的幂，并且基本情况是*T*
    (1) = Θ(1)。事实证明，这些假设不会影响渐近解。
- en: What’s the height of the recursion tree? The subproblem size for a node at depth
    *i* is *n*/4*^i*. As we descend the tree from the root, the subproblem size hits
    *n* = 1 when *n*/4*^i* = 1 or, equivalently, when *i* = log[4] *n*. Thus, the
    tree has internal nodes at depths 0, 1, 2, … , log[4] *n* – 1 and leaves at depth
    log[4] *n*.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 递归树的高度是多少？深度为*i*的节点的子问题大小为*n*/4*^i*。当我们从根节点向下遍历树时，当*n*/4*^i* = 1时，即当*i* = log[4] *n*时，子问题大小达到*n*
    = 1。因此，树在深度0、1、2、…，log[4] *n* – 1处有内部节点，叶子在深度log[4] *n*处。
- en: Part (d) of [Figure 4.1](chapter004.xhtml#Fig_4-1) shows the cost at each level
    of the tree. Each level has three times as many nodes as the level above, and
    so the number of nodes at depth *i* is 3*^i*. Because subproblem sizes reduce
    by a factor of 4 for each level further from the root, each internal node at depth
    *i* = 0, 1, 2, … , log[4] *n* – 1 has a cost of *c*(*n*/4*^i*)². Multiplying,
    we see that the total cost of all nodes at a given depth *i* is 3*^ic*(*n*/4*^i*)²
    = (3/16)*^icn*². The bottom level, at depth log[4] *n*, contains ![art](images/Art_P120.jpg)
    leaves (using equation (3.21) on page 66). Each leaf contributes Θ(1), leading
    to a total leaf cost of ![art](images/Art_P121.jpg).
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '[图4.1](chapter004.xhtml#Fig_4-1)的(d)部分展示了树每个级别的成本。每个级别的节点数量是上一级的3倍，因此深度为*i*的节点数量为3*^i*。因为每个级别远离根节点时子问题大小减少4倍，所以深度为*i*
    = 0、1、2、…，log[4] *n* – 1的每个内部节点的成本为*c*(*n*/4*^i*)²。乘以后，我们看到给定深度*i*的所有节点的总成本为3*^ic*(*n*/4*^i*)²
    = (3/16)*^icn*²。底层在深度log[4] *n*处包含![art](images/Art_P120.jpg)个叶子（使用第66页的方程(3.21)）。每个叶子贡献Θ(1)，导致总叶子成本为![art](images/Art_P121.jpg)。'
- en: 'Now we add up the costs over all levels to determine the cost for the entire
    tree:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将所有级别的成本相加，以确定整个树的成本：
- en: '![art](images/Art_P122.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P122.jpg)'
- en: We’ve derived the guess of *T* (*n*) = *O*(*n*²) for the original recurrence.
    In this example, the coefficients of *cn*² form a decreasing geometric series.
    By equation (A.7), the sum of these coefficients is bounded from above by the
    constant 16/13\. Since the root’s contribution to the total cost is *cn*², the
    cost of the root dominates the total cost of the tree.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经推导出*T* (*n*) = *O*(*n*²)是原始递归的猜测。在这个例子中，*cn*²的系数形成一个递减的几何级数。根据方程(A.7)，这些系数的总和上界为常数16/13。由于根节点对总成本的贡献是*cn*²，根节点的成本主导了整个树的总成本。
- en: In fact, if *O*(*n*²) is indeed an upper bound for the recurrence (as we’ll
    verify in a moment), then it must be a tight bound. Why? The first recursive call
    contributes a cost of Θ(*n*²), and so Ω(*n*²) must be a lower bound for the recurrence.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，如果*O*(*n*²)确实是递归的上界（我们马上会验证），那么它必须是一个紧密的上界。为什么？第一个递归调用贡献了Θ(*n*²)的成本，因此Ω(*n*²)必须是递归的下界。
- en: Let’s now use the substitution method to verify that our guess is correct, namely,
    that *T* (*n*) = *O*(*n*²) is an upper bound for the recurrence *T* (*n*) = 3*T*
    (*n*/4)+Θ(*n*²). We want to show that *T* (*n*) ≤ *dn*² for some constant *d*
    > 0\. Using the same constant *c* > 0 as before, we have
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们使用替换法来验证我们的猜测是否正确，即，*T* (*n*) = *O*(*n*²)是递归*T* (*n*) = 3*T* (*n*/4)+Θ(*n*²)的一个上界。我们希望证明存在某个常数*d*
    > 0使得*T* (*n*) ≤ *dn*²。使用与之前相同的常数*c* > 0，我们有
- en: '| *T* (*n*) | ≤ | 3*T* (*n*/4) + *cn*² |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| *T* (*n*) | ≤ | 3*T* (*n*/4) + *cn*² |'
- en: '|  | ≤ | 3*d*(*n*/4)² + *cn*² |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | 3*d*(*n*/4)² + *cn*² |'
- en: '|  | = | ![art](images/Art_P123.jpg) |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '|  | = | ![art](images/Art_P123.jpg) |'
- en: '|  | ≤ | *dn*², |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | *dn*², |'
- en: where the last step holds if we choose *d* ≥ (16/13)*c*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择*d* ≥ (16/13)*c*，则最后一步成立。
- en: For the base case of the induction, let *n*[0] > 0 be a sufficiently large threshold
    constant that the recurrence is well defined when *T* (*n*) = Θ(1) for *n* < *n*[0].
    We can pick *d* large enough that *d* dominates the constant hidden by the Θ,
    in which case *dn*² ≥ *d* ≥ *T* (*n*) for 1 ≤ *n* < *n*[0], completing the proof
    of the base case.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 对于归纳的基本情况，让 *n*[0] > 0 是一个足够大的阈值常数，当 *T* (*n*) = Θ(1) 对于 *n* < *n*[0] 时，递归才是良定义的。我们可以选择足够大的
    *d*，使得 *d* 主导了Θ隐藏的常数，这样对于 1 ≤ *n* < *n*[0]，*dn*² ≥ *d* ≥ *T* (*n*)，完成了基本情况的证明。
- en: The substitution proof we just saw involves two named constants, *c* and *d*.
    We named *c* and used it to stand for the upper-bound constant hidden and guaranteed
    to exist by the Θ-notation. We cannot pick *c* arbitrarily—it’s given to us—although,
    for any such *c*, any constant *c*^′ ≥ *c* also suffices. We also named *d*, but
    we were free to choose any value for it that fit our needs. In this example, the
    value of *d* happened to depend on the value of *c*, which is fine, since *d*
    is constant if *c* is constant.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到的替换证明涉及两个命名常数，*c* 和 *d*。我们命名了 *c* 并用它代表了由Θ-符号隐藏并保证存在的上界常数。我们不能随意选择 *c*
    —— 它是给定的 —— 尽管对于任何这样的 *c*，任何常数 *c*^′ ≥ *c* 也是合适的。我们也命名了 *d*，但我们可以自由选择适合我们需求的任何值。在这个例子中，*d*
    的值恰好取决于 *c* 的值，这是可以接受的，因为如果 *c* 是常数，那么 *d* 也是常数。
- en: '**An irregular example**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个不规则的例子**'
- en: Let’s find an asymptotic upper bound for another, more irregular, example. [Figure
    4.2](chapter004.xhtml#Fig_4-2) shows the recursion tree for the recurrence
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们为另一个更不规则的例子找到一个渐近上界。[图 4.2](chapter004.xhtml#Fig_4-2) 展示了递归关系的递归树
- en: '![art](images/Art_P124.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P124.jpg)'
- en: This recursion tree is unbalanced, with different root-to-leaf paths having
    different lengths. Going left at any node produces a subproblem of one-third the
    size, and going right produces a subproblem of two-thirds the size. Let *n*[0]
    > 0 be the implicit threshold constant such that *T* (*n*) = Θ(1) for 0 < *n*
    < *n*[0], and let *c* represent the upper-bound constant hidden by the Θ(*n*)
    term for *n* ≥ *n*[0]. There are actually two *n*[0] constants here—one for the
    threshold in the recurrence, and the other for the threshold in the Θ-notation,
    so we’ll let *n*[0] be the larger of the two constants.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 这个递归树是不平衡的，不同的从根到叶子的路径长度不同。在任何节点向左移动会产生一个大小为原来的三分之一的子问题，向右移动会产生一个大小为原来的三分之二的子问题。让
    *n*[0] > 0 是隐含的阈值常数，使得对于 0 < *n* < *n*[0]，*T* (*n*) = Θ(1)，让 *c* 代表Θ(*n*)项隐藏的上界常数，对于
    *n* ≥ *n*[0]。这里实际上有两个 *n*[0] 常数 —— 一个是递归中的阈值，另一个是Θ-符号中的阈值，所以我们取 *n*[0] 为这两个常数中较大的一个。
- en: '![art](images/Art_P125.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P125.jpg)'
- en: '**Figure 4.2** A recursion tree for the recurrence *T* (*n*) = *T* (*n*/3)
    + *T* (2*n*/3) + *cn*.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 4.2** 递归关系 *T* (*n*) = *T* (*n*/3) + *T* (2*n*/3) + *cn* 的递归树。'
- en: The height of the tree runs down the right edge of the tree, corresponding to
    subproblems of sizes *n*, (2/3)*n*, (4/9)*n*, … , Θ(1) with costs bounded by *cn*,
    *c*(2*n*/3), *c*(4*n*/9), … , Θ(1), respectively. We hit the rightmost leaf when
    (2/3)*^hn* < *n*[0] ≤ (2/3)^(*h*–1)*n*, which happens when *h* = ⌊log[3/2](*n*/*n*[0])⌋
    + 1 since, applying the floor bounds in equation (3.2) on page 64 with *x* = log[3/2]
    (*n*/*n*[0]), we have (2/3)*^hn* = (2/3)^(⌊*x*⌋+1)*n* < (2/3)*^xn* = (*n*[0]/*n*)*n*
    = *n*[0] and (2/3)^(*h*–1)*n* = (2/3)^(⌊*x*⌋)*n* > (2/3)^(*x*)*n* = (*n*[0]/*n*)*n*
    = *n*[0]. Thus, the height of the tree is *h* = Θ(lg *n*).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 树的高度沿着树的右边缘向下，对应于大小为 *n*、(2/3)*n*、(4/9)*n*，…，Θ(1) 的子问题，成本由 *cn*、*c*(2*n*/3)、*c*(4*n*/9)，…，Θ(1)
    限制。当 (2/3)*^hn* < *n*[0] ≤ (2/3)^(*h*–1)*n* 时，我们到达最右边的叶子，这发生在 *h* = ⌊log[3/2](*n*/*n*[0])⌋
    + 1，因为，应用第 64 页上方程 (3.2) 中 *x* = log[3/2] (*n*/*n*[0]) 的地板边界，我们有 (2/3)*^hn* =
    (2/3)^(⌊*x*⌋+1)*n* < (2/3)*^xn* = (*n*[0]/*n*)*n* = *n*[0] 和 (2/3)^(*h*–1)*n*
    = (2/3)^(⌊*x*⌋)*n* > (2/3)^(*x*)*n* = (*n*[0]/*n*)*n* = *n*[0]。因此，树的高度为 *h* =
    Θ(lg *n*)。
- en: We’re now in a position to understand the upper bound. Let’s postpone dealing
    with the leaves for a moment. Summing the costs of internal nodes across each
    level, we have at most *cn* per level times the Θ(lg *n*) tree height for a total
    cost of *O*(*n* lg *n*) for all internal nodes.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以理解上界了。让我们暂时不处理叶子。对每个级别的内部节点的成本求和，我们每个级别最多有 *cn* 乘以 Θ(lg *n*) 的树高，所有内部节点的总成本为
    *O*(*n* lg *n*)。
- en: It remains to deal with the leaves of the recursion tree, which represent base
    cases, each costing Θ(1). How many leaves are there? It’s tempting to upper-bound
    their number by the number of leaves in a complete binary tree of height *h* =
    ⌊log[3/2](*n*/*n*[0])⌋ + 1, since the recursion tree is contained within such
    a complete binary tree. But this approach turns out to give us a poor bound. The
    complete binary tree has 1 node at the root, 2 nodes at depth 1, and generally
    2*^k* nodes at depth *k*. Since the height is *h* = ⌊log[3/2] *n*⌋ + 1, there
    are ![art](images/Art_P126.jpg) leaves in the complete binary tree, which is an
    upper bound on the number of leaves in the recursion tree. Because the cost of
    each leaf is Θ(1), this analysis says that the total cost of all leaves in the
    recursion tree is ![art](images/Art_P127.jpg), which is an asymptotically greater
    bound than the *O*(*n* lg *n*) cost of all internal nodes. In fact, as we’re about
    to see, this bound is not tight. The cost of all leaves in the recursion tree
    is *O*(*n*)—asymptotically *less* than *O*(*n* lg *n*). In other words, the cost
    of the internal nodes dominates the cost of the leaves, not vice versa.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要处理递归树的叶子，它们代表基本情况，每个成本为Θ(1)。有多少叶子？诱人的是，我们可以通过完全二叉树的叶子数量来上界它们的数量，高度为 *h*
    = ⌊log[3/2](*n*/*n*[0])⌋ + 1，因为递归树包含在这样一个完全二叉树中。但这种方法实际上给出了一个较差的上界。完全二叉树在根部有 1
    个节点，在深度 1 有 2 个节点，一般在深度 *k* 有 2*^k* 个节点。由于高度为 *h* = ⌊log[3/2] *n*⌋ + 1，完全二叉树中有
    ![art](images/Art_P126.jpg) 个叶子，这是递归树中叶子数量的上界。因为每个叶子的成本为Θ(1)，这个分析表明递归树中所有叶子的总成本为
    ![art](images/Art_P127.jpg)，这比所有内部节点的 *O*(*n* lg *n*) 成本更高。实际上，正如我们将要看到的，这个上界并不紧确。递归树中所有叶子的成本是
    *O*(*n*) —— 渐近地 *小于* *O*(*n* lg *n*)。换句话说，内部节点的成本支配了叶子的成��，而不是相反。
- en: Rather than analyzing the leaves, we could quit right now and prove by substitution
    that *T* (*n*) = Θ(*n* lg *n*). This approach works (see Exercise 4.4-3), but
    it’s instructive to understand how many leaves this recursion tree has. You may
    see recurrences for which the cost of leaves dominates the cost of internal nodes,
    and then you’ll be in better shape if you’ve had some experience analyzing the
    number of leaves.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 与分析叶子节点不同，我们可以立即停止并通过替换证明 *T* (*n*) = Θ(*n* lg *n*)。这种方法有效（参见练习 4.4-3），但了解这个递归树有多少叶子节点是很有启发性的。你可能会遇到成本叶子节点支配内部节点成本的递归，那么如果你有一些分析叶子数量的经验，你就会处于更好的状态。
- en: To figure out how many leaves there really are, let’s write a recurrence *L*(*n*)
    for the number of leaves in the recursion tree for *T* (*n*). Since all the leaves
    in *T* (*n*) belong either to the left subtree or the right subtree of the root,
    we have
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 要弄清楚到底有多少叶子节点，让我们为 *T* (*n*) 的递归树编写一个关于叶子节点数量的递归 *L*(*n*)。因为 *T* (*n*) 中的所有叶子节点都属于根节点的左子树或右子树，我们有
- en: '![art](images/Art_P128.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P128.jpg)'
- en: This recurrence is similar to recurrence (4.14), but it’s missing the Θ(*n*)
    term, and it contains an explicit base case. Because this recurrence omits the
    Θ(*n*) term, it is much easier to solve. Let’s apply the substitution method to
    show that it has solution *L*(*n*) = *O*(*n*). Using the inductive hypothesis
    *L*(*n*) ≤ *dn* for some constant *d* > 0, and assuming that the inductive hypothesis
    holds for all values less than *n*, we have
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个递归类似于递归式 (4.14)，但缺少了 Θ(*n*) 项，并包含一个显式的基本情况。因为这个递归省略了 Θ(*n*) 项，所以解决起来要容易得多。让我们应用替换方法来展示它的解为
    *L*(*n*) = *O*(*n*)。使用归纳假设 *L*(*n*) ≤ *dn* 对某个常数 *d* > 0，并假设归纳假设对所有小于 *n* 的值都成立，我们有
- en: '| *L*(*n*) | = | *L*(*n*/3) + *L*(2*n*/3) |'
  id: totrans-280
  prefs: []
  type: TYPE_TB
  zh: '| *L*(*n*) | = | *L*(*n*/3) + *L*(2*n*/3) |'
- en: '|  | ≤ | *dn*/3 + 2(*dn*)/3 |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | *dn*/3 + 2(*dn*)/3 |'
- en: '|  | ≤ | *dn*, |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | *dn*, |'
- en: which holds for any *d* > 0\. We can now choose *d* large enough to handle the
    base case *L*(*n*) = 1 for 0 < *n* < *n*[0], for which *d* = 1 suffices, thereby
    completing the substitution method for the upper bound on leaves. (Exercise 4.4-2
    asks you to prove that *L*(*n*) = Θ(*n*).)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何 *d* > 0。我们现在可以选择足够大的 *d* 来处理基本情况 *L*(*n*) = 1 对于 0 < *n* < *n*[0]，其中 *d*
    = 1 就足够了，从而完成了叶子节点上界的替换方法。（练习 4.4-2 要求你证明 *L*(*n*) = Θ(*n*)。）
- en: Returning to recurrence (4.14) for *T* (*n*), it now becomes apparent that the
    total cost of leaves over all levels must be *L*(*n*) · Θ(1) = Θ(*n*). Since we
    have derived the bound of *O*(*n* lg *n*) on the cost of the internal nodes, it
    follows that the solution to recurrence (4.14) is *T* (*n*) = *O*(*n* lg *n*)
    + Θ(*n*) = *O*(*n* lg *n*). (Exercise 4.4-3 asks you to prove that *T* (*n*) =
    Θ(*n* lg *n*).)
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 回到 *T* (*n*) 的递归式 (4.14)，现在显然可以看出所有级别上叶子节点的总成本必须是 *L*(*n*) · Θ(1) = Θ(*n*)。由于我们已经推导出了内部节点成本为
    *O*(*n* lg *n*) 的上界，因此递归式 (4.14) 的解为 *T* (*n*) = *O*(*n* lg *n*) + Θ(*n*) = *O*(*n*
    lg *n*)。 （练习 4.4-3 要求你证明 *T* (*n*) = Θ(*n* lg *n*)。）
- en: It’s wise to verify any bound obtained with a recursion tree by using the substitution
    method, especially if you’ve made simplifying assumptions. But another strategy
    altogether is to use more-powerful mathematics, typically in the form of the master
    method in the next section (which unfortunately doesn’t apply to recurrence (4.14))
    or the Akra-Bazzi method (which does, but requires calculus). Even if you use
    a powerful method, a recursion tree can improve your intuition for what’s going
    on beneath the heavy math.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用替换方法验证通过递归树获得的任何上界是明智的，特别是如果你已经做出了简化假设。但另一种策略是使用更强大的数学方法，通常以下一节中的主方法的形式（不幸的是不适用于递归
    (4.14)）或 Akra-Bazzi 方法（适用于递归 (4.14)，但需要微积分）。即使你使用了强大的方法，递归树也可以提高你对繁重数学背后发生的事情的直觉。
- en: '**Exercises**'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***4.4-1***'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.4-1***'
- en: For each of the following recurrences, sketch its recursion tree, and guess
    a good asymptotic upper bound on its solution. Then use the substitution method
    to verify your answer.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下每个递归，绘制其递归树，并猜测其解的一个良好渐近上界。然后使用替换方法验证你的答案。
- en: '***a.*** *T* (*n*) = *T* (*n*/2) + *n*³.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** *T* (*n*) = *T* (*n*/2) + *n*³.'
- en: '***b.*** *T* (*n*) = 4*T* (*n*/3) + *n*.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** *T* (*n*) = 4*T* (*n*/3) + *n*.'
- en: '***c.*** *T* (*n*) = 4*T* (*n*/2) + *n*.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** *T* (*n*) = 4*T* (*n*/2) + *n*.'
- en: '***d.*** *T* (*n*) = 3*T* (*n* – 1) + 1.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** *T* (*n*) = 3*T* (*n* – 1) + 1.'
- en: '***4.4-2***'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.4-2***'
- en: Use the substitution method to prove that recurrence (4.15) has the asymptotic
    lower bound *L*(*n*) = Ω(*n*). Conclude that *L*(*n*) = Θ(*n*).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 使用替换方法证明递归式 (4.15) 具有渐近下界 *L*(*n*) = Ω(*n*)。得出 *L*(*n*) = Θ(*n*)。
- en: '***4.4-3***'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.4-3***'
- en: Use the substitution method to prove that recurrence (4.14) has the solution
    *T* (*n*) = Ω(*n* lg *n*). Conclude that *T* (*n*) = Θ(*n* lg *n*).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 使用替换方法证明递归式 (4.14) 的解为 *T* (*n*) = Ω(*n* lg *n*)。得出 *T* (*n*) = Θ(*n* lg *n*)。
- en: '***4.4-4***'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.4-4***'
- en: Use a recursion tree to justify a good guess for the solution to the recurrence
    *T* (*n*) = *T* (*αn*)+*T* ((1–*α*)*n*)+Θ(*n*), where *α* is a constant in the
    range 0 < *α* < 1.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用递归树来证明对于递归 *T* (*n*) = *T* (*αn*)+*T* ((1–*α*)*n*)+Θ(*n*)，其中 *α* 是范围在 0 <
    *α* < 1 的常数，一个好猜测的解。
- en: '[**4.5      The master method for solving recurrences**](toc.xhtml#Rh1-20)'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[**4.5      解递归的主方法**](toc.xhtml#Rh1-20)'
- en: The master method provides a “cookbook” method for solving algorithmic recurrences
    of the form
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 主方法提供了一种解决形式为
- en: '![art](images/Art_P129.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P129.jpg)'
- en: where *a* > 0 and *b* > 1 are constants. We call *f* (*n*) a ***driving function***,
    and we call a recurrence of this general form a ***master recurrence***. To use
    the master method, you need to memorize three cases, but then you’ll be able to
    solve many master recurrences quite easily.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *a* > 0 和 *b* > 1 是常数。我们称 *f* (*n*) 为***驱动函数***，称这种一般形式的递归为***主递归***。要使用主方法，你需要记住三种情况，然后你就能很容易地解决许多主递归。
- en: A master recurrence describes the running time of a divide-and-conquer algorithm
    that divides a problem of size *n* into *a* subproblems, each of size *n*/*b*
    < *n*. The algorithm solves the *a* subproblems recursively, each in *T* (*n*/*b*)
    time. The driving function *f* (*n*) encompasses the cost of dividing the problem
    before the recursion, as well as the cost of combining the results of the recursive
    solutions to subproblems. For example, the recurrence arising from Strassen’s
    algorithm is a master recurrence with *a* = 7, *b* = 2, and driving function *f*
    (*n*) = Θ(*n*²).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 主递归描述了将大小为*n*的问题分成*a*个大小为*n*/*b* < *n*的子问题的分治算法的运行时间。该算法递归解决*a*个子问题，每个子问题需要*T*
    (*n*/*b*)的时间。驱动函数*f* (*n*)包括在递归之前划分问题的成本，以及组合递归解决方案的成本。例如，Strassen算法产生的递归是一个主递归，其中*a*
    = 7，*b* = 2，驱动函数*f* (*n*) = Θ(*n*²)。
- en: As we have mentioned, in solving a recurrence that describes the running time
    of an algorithm, one technicality that we’d often prefer to ignore is the requirement
    that the input size *n* be an integer. For example, we saw that the running time
    of merge sort can be described by recurrence (2.3), *T* (*n*) = 2*T* (*n*/2) +
    Θ(*n*), on page 41\. But if *n* is an odd number, we really don’t have two problems
    of exactly half the size. Rather, to ensure that the problem sizes are integers,
    we round one subproblem down to size ⌊*n*/2⌋ and the other up to size ⌈*n*/2⌉,
    so the true recurrence is *T* (*n*) = *T* (⌈*n*/2⌉ + *T* (⌊*n*/2⌋) + Θ(*n*). But
    this floors-and-ceilings recurrence is longer to write and messier to deal with
    than recurrence (2.3), which is defined on the reals. We’d rather not worry about
    floors and ceilings, if we don’t have to, especially since the two recurrences
    have the same Θ(*n* lg *n*) solution.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所提到的，在解决描述算法运行时间的递归中，我们通常更愿意忽略的一个技术细节是要求输入大小*n*为整数。例如，我们看到归并排序的运行时间可以用递归(2.3)描述，*T*
    (*n*) = 2*T* (*n*/2) + Θ(*n*)，在第41页。但是如果*n*是奇数，我们实际上并没有两个完全一半大小的问题。相反，为了确保问题大小为整数，我们将一个子问题缩小到⌊*n*/2⌋的大小，将另一个扩大到⌈*n*/2⌉的大小，因此真正的递归是*T*
    (*n*) = *T* (⌈*n*/2⌉ + *T* (⌊*n*/2⌋) + Θ(*n*)。但是这种地板和天花板的递归写起来更麻烦，处理起来更混乱，比起定义在实数上的递归(2.3)更麻烦。如果没有必要，我们宁愿不去担心地板和天花板，特别是因为这两个递归有相同的Θ(*n*
    lg *n*)解。
- en: The master method allows you to state a master recurrence without floors and
    ceilings and implicitly infer them. No matter how the arguments are rounded up
    or down to the nearest integer, the asymptotic bounds that it provides remain
    the same. Moreover, as we’ll see in [Section 4.6](chapter004.xhtml#Sec_4.6), if
    you define your master recurrence on the reals, without implicit floors and ceilings,
    the asymptotic bounds still don’t change. Thus you can ignore floors and ceilings
    for master recurrences. [Section 4.7](chapter004.xhtml#Sec_4.7) gives sufficient
    conditions for ignoring floors and ceilings in more general divide-and-conquer
    recurrences.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 主方法允许您陈述一个主递归，而无需地板和天花板，并隐含推断它们。无论参数如何四舍五入到最近的整数，它提供的渐近界限仍然保持不变。此外，正如我们将在[第4.6节](chapter004.xhtml#Sec_4.6)中看到的，如果您在实数上定义主递归，而没有隐含的地板和天花板，渐近界限仍然不会改变。因此，您可以忽略主递归中的地板和天花板。[第4.7节](chapter004.xhtml#Sec_4.7)给出了更一般的分治递归中忽略地板和天花板的充分条件。
- en: '**The master theorem**'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '**主定理**'
- en: The master method depends upon the following theorem.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 主方法依赖于以下定理。
- en: '***Theorem 4.1 (Master theorem)***'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理4.1（主定理）***'
- en: Let *a* > 0 and *b* > 1 be constants, and let *f* (*n*) be a driving function
    that is defined and nonnegative on all sufficiently large reals. Define the recurrence
    *T* (*n*) on *n* ∈ N by
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 设*a* > 0且*b* > 1为常数，*f* (*n*)为定义并在所有足够大的实数上非负的驱动函数。通过*n* ∈ N定义递归*T* (*n*)，其中
- en: '![art](images/Art_P130.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P130.jpg)'
- en: 'where *aT* (*n*/*b*) actually means *a*^′*T* (⌊*n*/*b*⌋) + *a*^″*T* (⌈*n*/*b*⌉)
    for some constants *a*^′ ≥ 0 and *a*^″ ≥ 0 satisfying *a* = *a*^′ + *a*^″. Then
    the asymptotic behavior of *T* (*n*) can be characterized as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*aT* (*n*/*b*)实际上表示为*a*^′*T* (⌊*n*/*b*⌋) + *a*^″*T* (⌈*n*/*b*⌉)，其中*a*^′ ≥
    0且*a*^″ ≥ 0，满足*a* = *a*^′ + *a*^″。那么*T* (*n*)的渐近行为可以描述如下：
- en: If there exists a constant *ϵ* > 0 such that ![art](images/Art_P131.jpg), then
    ![art](images/Art_P132.jpg).
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在一个常数*ϵ* > 0，使得![art](images/Art_P131.jpg)，那么![art](images/Art_P132.jpg)。
- en: If there exists a constant *k* ≥ 0 such that ![art](images/Art_P133.jpg), then
    ![art](images/Art_P134.jpg).
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在一个常数*k* ≥ 0，使得![art](images/Art_P133.jpg)，那么![art](images/Art_P134.jpg)。
- en: If there exists a constant *ϵ* > 0 such that ![art](images/Art_P135.jpg), and
    if *f* (*n*) additionally satisfies the ***regularity condition*** *af* (*n*/*b*)
    ≤ *cf* (*n*) for some constant *c* < 1 and all sufficiently large *n*, then *T*
    (*n*) = Θ(*f* (*n*)).
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在一个常数*ϵ* > 0，使得![art](images/Art_P135.jpg)，并且如果*f* (*n*)还满足***正则条件*** *af*
    (*n*/*b*) ≤ *cf* (*n*)，其中*c* < 1为常数，对所有足够大的*n*成立，则*T* (*n*) = Θ(*f* (*n*)).
- en: ▪
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Before applying the master theorem to some examples, let’s spend a few moments
    to understand broadly what it says. The function ![art](images/Art_P136.jpg) is
    called the ***watershed function***. In each of the three cases, we compare the
    driving function *f* (*n*) to the watershed function ![art](images/Art_P137.jpg).
    Intuitively, if the watershed function grows asymptotically faster than the driving
    function, then case 1 applies. Case 2 applies if the two functions grow at nearly
    the same asymptotic rate. Case 3 is the “opposite” of case 1, where the driving
    function grows asymptotically faster than the watershed function. But the technical
    details matter.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在将主定理应用于一些示例之前，让��们花一些时间广泛理解它所说的内容。函数![art](images/Art_P136.jpg)被称为***分水岭函数***。在这三种情况中，我们将驱动函数*f*
    (*n*)与分水岭函数![art](images/Art_P137.jpg)进行比较。直观地说，如果分水岭函数的增长速度渐近快于驱动函数，则适用于情况1。如果两个函数的增长速度几乎相同，则适用于情况2。情况3是情况1的“相反”，其中驱动函数的增长速度渐近快于分水岭函数。但技术细节很重要。
- en: In case 1, not only must the watershed function grow asymptotically faster than
    the driving function, it must grow *polynomially* faster. That is, the watershed
    function ![art](images/Art_P138.jpg) must be asymptotically larger than the driving
    function *f* (*n*) by at least a factor of Θ(*n^ϵ*) for some constant *ϵ* > 0\.
    The master theorem then says that the solution is ![art](images/Art_P139.jpg).
    In this case, if we look at the recursion tree for the recurrence, the cost per
    level grows at least geometrically from root to leaves, and the total cost of
    leaves dominates the total cost of the internal nodes.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在情况1中，分水岭函数不仅必须渐近地比驱动函数增长更快，而且必须*多项式*增长。也就是说，分水岭函数![art](images/Art_P138.jpg)必须至少以Θ(*n^ϵ*)的因子（其中常数*ϵ*>0）渐近地大于驱动函数*f*(*n*)。然后主定理表明解为![art](images/Art_P139.jpg)。在这种情况下，如果我们看一下递归的树形结构，每个层级的成本至少从根节点到叶节点呈几何级增长，而叶节点的总成本支配了内部节点的总成本。
- en: In case 2, the watershed and driving functions grow at nearly the same asymptotic
    rate. But more specifically, the driving function grows faster than the watershed
    function by a factor of Θ(lg*^k n*), where *k* ≥ 0\. The master theorem says that
    we tack on an extra lg *n* factor to *f* (*n*), yielding the solution ![art](images/Art_P140.jpg).
    In this case, each level of the recursion tree costs approximately the same—![art](images/Art_P141.jpg)—and
    there are Θ(lg *n*) levels. In practice, the most common situation for case 2
    occurs when *k* = 0, in which case the watershed and driving functions have the
    same asymptotic growth, and the solution is ![art](images/Art_P142.jpg).
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在情况2中，分水岭和驱动函数以几乎相同的渐近速率增长。但更具体地说，驱动函数比分水岭函数快Θ(lg*^k n*)的因子增长，其中*k*≥0。主定理表明我们在*f*(*n*)上增加额外的lg
    *n*因子，得到解答![art](images/Art_P140.jpg)。在这种情况下，递归树的每个层级成本大致相同——![art](images/Art_P141.jpg)——并且有Θ(lg
    *n*)个层级。实际上，情况2最常见的情况是*k*=0，这种情况下分水岭和驱动函数具有相同的渐近增长，解为![art](images/Art_P142.jpg)。
- en: Case 3 mirrors case 1\. Not only must the driving function grow asymptotically
    faster than the watershed function, it must grow *polynomially* faster. That is,
    the driving function *f* (*n*) must be asymptotically larger than the watershed
    function ![art](images/Art_P143.jpg) by at least a factor of Θ(*n^ϵ*) for some
    constant *ϵ* > 0\. Moreover, the driving function must satisfy the regularity
    condition that *af* (*n*/*b*) ≤ *cf* (*n*). This condition is satisfied by most
    of the polynomially bounded functions that you’re likely to encounter when applying
    case 3\. The regularity condition might not be satisfied if the driving function
    grows slowly in local areas, yet relatively quickly overall. (Exercise 4.5-5 gives
    an example of such a function.) For case 3, the master theorem says that the solution
    is *T* (*n*) = Θ(*f* (*n*)). If we look at the recursion tree, the cost per level
    drops at least geometrically from the root to the leaves, and the root cost dominates
    the cost of all other nodes.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 情况3与情况1相似。驱动函数不仅必须渐近地比分水岭函数增长更快，而且必须*多项式*增长。也就是说，驱动函数*f*(*n*)必须至少以Θ(*n^ϵ*)的因子（其中常数*ϵ*>0）渐近地大于分水岭函数![art](images/Art_P143.jpg)。此外，驱动函数必须满足正则条件*af*(*n*/b)
    ≤ *cf*(*n*)。当应用情况3时，大多数多项式有界函数都满足这个正则条件。如果驱动函数在局部区域增长缓慢，但整体增长较快，则可能不满足正则条件（练习4.5-5给出了这样一个函数的例子）。对于情况3，主定理表明解为*T*(*n*)
    = Θ(*f*(*n*))。如果我们看递归树，每个层级的成本至少从根节点到叶节点呈几何级下降，根节点成本支配了所有其他节点的成本。
- en: It’s worth looking again at the requirement that there be polynomial separation
    between the watershed function and the driving function for either case 1 or case
    3 to apply. The separation doesn’t need to be much, but it must be there, and
    it must grow polynomially. For example, for the recurrence *T* (*n*) = 4*T* (*n*/2)
    + *n*^(1.99) (admittedly not a recurrence you’re likely to see when analyzing
    an algorithm), the watershed function is ![art](images/Art_P144.jpg). Hence the
    driving function *f* (*n*) = *n*^(1.99) is polynomially smaller by a factor of
    *n*^(0.01). Thus case 1 applies with *ϵ* = 0.01.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 值得再次看一下情况1或情况3适用的分水岭函数和驱动函数之间需要多项式分离的要求。分离不需要很大，但必须存在，并且必须多项式增长。例如，对于递归*T*(*n*)
    = 4*T*(*n*/2) + *n*^(1.99)（诚然，这不是你在分析算法时可能会看到的递归），分水岭函数为![art](images/Art_P144.jpg)。因此驱动函数*f*(*n*)
    = *n*^(1.99)比*n*^(0.01)的因子多项式较小。因此情况1适用，*ϵ*=0.01。
- en: '**Using the master method**'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用主方法**'
- en: To use the master method, you determine which case (if any) of the master theorem
    applies and write down the answer.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用主方法，您需要确定主定理适用的情况（如果有的话）并写下答案。
- en: As a first example, consider the recurrence *T* (*n*) = 9*T* (*n*/3) + *n*.
    For this recurrence, we have *a* = 9 and *b* = 3, which implies that ![art](images/Art_P145.jpg).
    Since *f* (*n*) = *n* = *O*(*n*^(2–*ϵ*)) for any constant *ϵ* ≤ 1, we can apply
    case 1 of the master theorem to conclude that the solution is *T* (*n*) = Θ(*n*²).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一个例子，考虑递归*T*(*n*) = 9*T*(*n*/3) + *n*。对于这个递归，我们有*a*=9和*b*=3，这意味着![art](images/Art_P145.jpg)。由于*f*(*n*)
    = *n* = *O*(*n*^(2–*ϵ*))对于任何常数*ϵ*≤1，我们可以应用主定理的情况1得出解为*T*(*n*) = Θ(*n*²)。
- en: Now consider the recurrence *T* (*n*) = *T* (2*n*/3) + 1, which has *a* = 1
    and *b* = 3/2, which means that the watershed function is ![art](images/Art_P146.jpg).
    Case 2 applies since ![art](images/Art_P147.jpg). The solution to the recurrence
    is *T* (*n*) = Θ(lg *n*).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑递归*T*(*n*) = *T*(2*n*/3) + 1，其中*a*=1和*b*=3/2，这意味着分水岭函数为![art](images/Art_P146.jpg)。情况2适用，因为![art](images/Art_P147.jpg)。递归的解为*T*(*n*)
    = Θ(lg *n*)。
- en: For the recurrence *T* (*n*) = 3*T* (*n*/4) + *n* lg *n*, we have *a* = 3 and
    *b* = 4, which means that ![art](images/Art_P148.jpg). Since ![art](images/Art_P149.jpg),
    where *ϵ* can be as large as approximately 0.2, case 3 applies as long as the
    regularity condition holds for *f* (*n*). It does, because for sufficiently large
    *n*, we have that *af* (*n*/*b*) = 3(*n*/4) lg(*n*/4) ≤ (3/4)*n* lg *n* = *cf*
    (*n*) for *c* = 3/4\. By case 3, the solution to the recurrence is *T* (*n*) =
    Θ(*n* lg *n*).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 对于递归*T* (*n*) = 3*T* (*n*/4) + *n* lg *n*，我们有*a* = 3和*b* = 4，这意味着![art](images/Art_P148.jpg)。由于![art](images/Art_P149.jpg)，其中*ϵ*可以大约为0.2，只要正则条件对*f*
    (*n*)成立，情况3适用。它确实成立，因为对于足够大的*n*，我们有*af* (*n*/*b*) = 3(*n*/4) lg(*n*/4) ≤ (3/4)*n*
    lg *n* = *cf* (*n*)，其中*c* = 3/4。根据情况3，递归的解为*T* (*n*) = Θ(*n* lg *n*)。
- en: Next, let’s look at the recurrence *T* (*n*) = 2*T* (*n*/2) + *n* lg *n*, where
    we have *a* = 2, *b* = 2, and ![art](images/Art_P150.jpg). Case 2 applies since
    ![art](images/Art_P151.jpg). We conclude that the solution is *T* (*n*) = Θ(*n*
    lg² *n*).
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们看看递归*T* (*n*) = 2*T* (*n*/2) + *n* lg *n*，其中*a* = 2，*b* = 2，且![art](images/Art_P150.jpg)。情况2适用，因为![art](images/Art_P151.jpg)。我们得出结论，解为*T*
    (*n*) = Θ(*n* lg² *n*)。
- en: We can use the master method to solve the recurrences we saw in [Sections 2.3.2](chapter002.xhtml#Sec_2.3.2),
    [4.1](chapter004.xhtml#Sec_4.1), and [4.2](chapter004.xhtml#Sec_4.2).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用主方法来解决我们在[2.3.2节](chapter002.xhtml#Sec_2.3.2)、[4.1节](chapter004.xhtml#Sec_4.1)和[4.2节](chapter004.xhtml#Sec_4.2)中看到的递归问题。
- en: Recurrence (2.3), *T* (*n*) = 2*T* (*n*/2) + Θ(*n*), on page 41, characterizes
    the running time of merge sort. Since *a* = 2 and *b* = 2, the watershed function
    is ![art](images/Art_P152.jpg). Case 2 applies because *f* (*n*) = Θ(*n*), and
    the solution is *T* (*n*) = Θ(*n* lg *n*).
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 递归（2.3），*T* (*n*) = 2*T* (*n*/2) + Θ(*n*), 在第41页描述了归并排序的运行时间。由于*a* = 2和*b* =
    2，分水岭函数为![art](images/Art_P152.jpg)。情况2适用，因为*f* (*n*) = Θ(*n*)，解为*T* (*n*) = Θ(*n*
    lg *n*)。
- en: Recurrence (4.9), *T* (*n*) = 8*T* (*n*/2) + Θ(1), on page 84, describes the
    running time of the simple recursive algorithm for matrix multiplication. We have
    *a* = 8 and *b* = 2, which means that the watershed function is ![art](images/Art_P153.jpg).
    Since *n*³ is polynomially larger than the driving function *f* (*n*) = Θ(1)—indeed,
    we have *f* (*n*) = *O*(*n*^(3–*ϵ*)) for any positive *ϵ* < 3—case 1 applies.
    We conclude that *T* (*n*) = Θ(*n*³).
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 递归(4.9)，*T* (*n*) = 8*T* (*n*/2) + Θ(1)，在第84页描述了矩阵乘法的简单递归算法的运行时间。我们有*a* = 8���*b*
    = 2，这意味着分水岭函数为![art](images/Art_P153.jpg)。由于*n*³比驱动函数*f* (*n*) = Θ(1)多项式更大—实际上，我们有*f*
    (*n*) = *O*(*n*^(3–*ϵ*))，其中任意正的*ϵ* < 3—情况1适用。我们得出结论，*T* (*n*) = Θ(*n*³)。
- en: Finally, recurrence (4.10), *T* (*n*) = 7*T* (*n*/2) + Θ(*n*²), on page 87,
    arose from the analysis of Strassen’s algorithm for matrix multiplication. For
    this recurrence, we have *a* = 7 and *b* = 2, and the watershed function is ![art](images/Art_P154.jpg).
    Observing that lg 7 = 2.807355 …, we can let *ϵ* = 0.8 and bound the driving function
    *f* (*n*) = Θ(*n*²) = *O*(*n*^(lg 7–*ϵ*)). Case 1 applies with solution *T* (*n*)
    = Θ(*n*^(lg 7)).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，递归(4.10)，*T* (*n*) = 7*T* (*n*/2) + Θ(*n*²)，在第87页描述了Strassen矩阵乘法算法的分析。对于这个递归，我们有*a*
    = 7和*b* = 2，分水岭函数为![art](images/Art_P154.jpg)。观察到lg 7 = 2.807355 …，我们可以让*ϵ* =
    0.8，并限制驱动函数*f* (*n*) = Θ(*n*²) = *O*(*n*^(lg 7–*ϵ*))。情况1适用，解为*T* (*n*) = Θ(*n*^(lg
    7))。
- en: '**When the master method doesn’t apply**'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '**当主方法不适用时**'
- en: There are situations where you can’t use the master theorem. For example, it
    can be that the watershed function and the driving function cannot be asymptotically
    compared. We might have that ![art](images/Art_P155.jpg) for an infinite number
    of values of *n* but also that ![art](images/Art_P156.jpg) for an infinite number
    of different values of *n*. As a practical matter, however, most of the driving
    functions that arise in the study of algorithms can be meaningfully compared with
    the watershed function. If you encounter a master recurrence for which that’s
    not the case, you’ll have to resort to substitution or other methods.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 有些情况下，你无法使用主定理。例如，可能出现分水岭函数和驱动函数无法渐近比较的情况。我们可能会发现对于无限多个*n*值，![art](images/Art_P155.jpg)，但也有对于无限多个不同*n*值，![art](images/Art_P156.jpg)。然而，在实际情况下，大多数算法研究中出现的驱动函数都可以与分水岭函数有意义地比较。如果你遇到一个主递归，而这种情况不适用，你将不得不求助于替代或其他方法。
- en: Even when the relative growths of the driving and watershed functions can be
    compared, the master theorem does not cover all the possibilities. There is a
    gap between cases 1 and 2 when ![art](images/Art_P157.jpg), yet the watershed
    function does not grow polynomially faster than the driving function. Similarly,
    there is a gap between cases 2 and 3 when ![art](images/Art_P158.jpg) and the
    driving function grows more than polylogarithmically faster than the watershed
    function, but it does not grow polynomially faster. If the driving function falls
    into one of these gaps, or if the regularity condition in case 3 fails to hold,
    you’ll need to use something other than the master method to solve the recurrence.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 即使驱动和分水岭函数的相对增长可以比较，主定理也无法涵盖所有可能性。当![art](images/Art_P157.jpg)时，情况1和2之间存在差距，然而分水岭函数并没有多项式增长得更快。同样，在情况2和3之间存在差距，当![art](images/Art_P158.jpg)且驱动函数比分水岭函数多对数增长时，但并没有多项式增长。如果驱动函数落入这些差距之一，或者情况3中的正则条件不成立，你将需要使用主方法以外的方法来解决递归问题。
- en: As an example of a driving function falling into a gap, consider the recurrence
    *T* (*n*) = 2*T* (*n*/2) + *n*/lg *n*. Since *a* = 2 and *b* = 2, the watershed
    function is ![art](images/Art_P159.jpg). The driving function is *n*/lg *n* =
    *o*(*n*), which means that it grows asymptotically more slowly than the watershed
    function *n*. But *n*/lg *n* grows only *logarithmically* slower than *n*, not
    *polynomially* slower. More precisely, equation (3.24) on page 67 says that lg
    *n* = *o*(*n^ϵ*) for any constant *ϵ* > 0, which means that 1/lg *n* = *ω*(*n*^(–*ϵ*))
    and ![art](images/Art_P160.jpg). Thus no constant *ϵ* > 0 exists such that ![art](images/Art_P161.jpg),
    which is required for case 1 to apply. Case 2 fails to apply as well, since ![art](images/Art_P162.jpg),
    where *k* = –1, but *k* must be nonnegative for case 2 to apply.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 作为一个落入间隙的驱动函数的例子，考虑递归式 *T* (*n*) = 2*T* (*n*/2) + *n*/lg *n*。由于 *a* = 2 和 *b*
    = 2，分水岭函数为 ![art](images/Art_P159.jpg)。驱动函数为 *n*/lg *n* = *o*(*n*)，这意味着它的增长比分水岭函数
    *n* 慢。但 *n*/lg *n* 的增长只比 *n* *对数级别* 慢，而不是 *多项式级别* 慢。更准确地说，第 67 页的方程式 (3.24) 表明对于任意常数
    *ϵ* > 0，lg *n* = *o*(*n^ϵ*)，这意味着 1/lg *n* = *ω*(*n*^(–*ϵ*)) 和 ![art](images/Art_P160.jpg)。因此不存在任何常数
    *ϵ* > 0 使得 ![art](images/Art_P161.jpg)，这是第 1 种情况适用所需的。第 2 种情况也不适用，因为 ![art](images/Art_P162.jpg)，其中
    *k* = –1，但 *k* 必须是非负的才能适用第 2 种情况。
- en: To solve this kind of recurrence, you must use another method, such as the substitution
    method ([Section 4.3](chapter004.xhtml#Sec_4.3)) or the Akra-Bazzi method ([Section
    4.7](chapter004.xhtml#Sec_4.7)). (Exercise 4.6-3 asks you to show that the answer
    is Θ(*n* lg lg *n*).) Although the master theorem doesn’t handle this particular
    recurrence, it does handle the overwhelming majority of recurrences that tend
    to arise in practice.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决这种递归式，你必须使用另一种方法，比如代入法（[第 4.3 节](chapter004.xhtml#Sec_4.3)）或 Akra-Bazzi 方法（[第
    4.7 节](chapter004.xhtml#Sec_4.7)）。（练习 4.6-3 要求你证明答案为 Θ(*n* lg lg *n*)。）尽管主定理不处理这种特定的递归式，但它确实处理了在实践中经常出现的绝大多数递归式。
- en: '**Exercises**'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***4.5-1***'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.5-1***'
- en: Use the master method to give tight asymptotic bounds for the following recurrences.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主方法为以下递归式给出紧密的渐近界限。
- en: '***a.*** *T* (*n*) = 2*T* (*n*/4) + 1.'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** *T* (*n*) = 2*T* (*n*/4) + 1.'
- en: '***b.*** *T* (*n*) = 2*T* (*n*/4) + ![art](images/Art_P163.jpg).'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** *T* (*n*) = 2*T* (*n*/4) + ![art](images/Art_P163.jpg).'
- en: '***c.*** *T* (*n*) = 2*T* (*n*/4) + ![art](images/Art_P164.jpg).'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** *T* (*n*) = 2*T* (*n*/4) + ![art](images/Art_P164.jpg).'
- en: '***d.*** *T* (*n*) = 2*T* (*n*/4) + *n*.'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** *T* (*n*) = 2*T* (*n*/4) + *n*.'
- en: '***e.*** *T* (*n*) = 2*T* (*n*/4) + *n*².'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** *T* (*n*) = 2*T* (*n*/4) + *n*².'
- en: '***4.5-2***'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.5-2***'
- en: Professor Caesar wants to develop a matrix-multiplication algorithm that is
    asymptotically faster than Strassen’s algorithm. His algorithm will use the divide-and-conquer
    method, dividing each matrix into *n*/4 × *n*/4 submatrices, and the divide and
    combine steps together will take Θ(*n*²) time. Suppose that the professor’s algorithm
    creates *a* recursive subproblems of size *n*/4\. What is the largest integer
    value of *a* for which his algorithm could possibly run asymptotically faster
    than Strassen’s?
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 凯撒教授想要开发一个矩阵乘法算法，其渐近速度比 Strassen 算法更快。他的算法将使用分治方法，将每个矩阵分成 *n*/4 × *n*/4 的子矩阵，分治和合并步骤一起需要
    Θ(*n*²) 的时间。假设教授的算法创建大小为 *n*/4 的 *a* 个递归子问题。教授的算法可能比 Strassen 算法运行得更快的最大整数值 *a*
    是多少？
- en: '***4.5-3***'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.5-3***'
- en: Use the master method to show that the solution to the binary-search recurrence
    *T* (*n*) = *T* (*n*/2) + Θ(1) is *T* (*n*) = Θ(lg *n*). (See Exercise 2.3-6 for
    a description of binary search.)
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 使用主方法证明二分查找递归式 *T* (*n*) = *T* (*n*/2) + Θ(1) 的解为 *T* (*n*) = Θ(lg *n*)。（有关二分查找的描述，请参见练习
    2.3-6。）
- en: '***4.5-4***'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.5-4***'
- en: Consider the function *f* (*n*) = lg *n*. Argue that although *f* (*n*/2) <
    *f* (*n*), the regularity condition *af* (*n*/*b*) ≤ *cf* (*n*) with *a* = 1 and
    *b* = 2 does not hold for any constant *c* < 1\. Argue further that for any *ϵ*
    > 0, the condition in case 3 that ![art](images/Art_P165.jpg) does not hold.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑函数 *f* (*n*) = lg *n*。论证虽然 *f* (*n*/2) < *f* (*n*)，但正则性条件 *af* (*n*/*b*) ≤
    *cf* (*n*)，其中 *a* = 1 和 *b* = 2，对于任何常数 *c* < 1 都不成立。进一步论证，对于任何 *ϵ* > 0，第 3 种情况中的条件
    ![art](images/Art_P165.jpg) 也不成立。
- en: '***4.5-5***'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.5-5***'
- en: Show that for suitable constants *a*, *b*, and *ϵ*, the function *f* (*n*) =
    2^(⌈lg *n*⌉) satisfies all the conditions in case 3 of the master theorem except
    the regularity condition.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 证明对于适当的常数 *a*、*b* 和 *ϵ*，函数 *f* (*n*) = 2^(⌈lg *n*⌉) 满足主定理第 3 种情况的所有条件，除了正则性条件。
- en: '[★ **4.6      Proof of the continuous master theorem**](toc.xhtml#Rh1-21)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '[★ **4.6      连续主定理的证明**](toc.xhtml#Rh1-21)'
- en: Proving the master theorem (Theorem 4.1) in its full generality, especially
    dealing with the knotty technical issue of floors and ceilings, is beyond the
    scope of this book. This section, however, states and proves a variant of the
    master theorem, called the ***continuous master theorem***^([1](#footnote_1))
    in which the master recurrence (4.17) is defined over sufficiently large positive
    real numbers. The proof of this version, uncomplicated by floors and ceilings,
    contains the main ideas needed to understand how master recurrences behave. [Section
    4.7](chapter004.xhtml#Sec_4.7) discusses floors and ceilings in divide-and-conquer
    recurrences at greater length, presenting sufficient conditions for them not to
    affect the asymptotic solutions.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 证明主定理（定理 4.1）在其完整性上，特别是处理与取整函数有关的棘手技术问题，超出了本书的范围。然而，本节阐述并证明了主定理的一个变体，称为***连续主定理***^([1](#footnote_1))，其中主递归式（4.17）定义在足够大的正实数上。这个版本的证明，不受取整函数的影响，包含了理解主递归式行为所需的主要思想。[第
    4.7 节](chapter004.xhtml#Sec_4.7)更详细地讨论了分治递归中的取整函数，提出了使其不影响渐近解的充分条件。
- en: Of course, since you need not understand the proof of the master theorem in
    order to apply the master method, you may choose to skip this section. But if
    you wish to study more-advanced algorithms beyond the scope of this textbook,
    you may appreciate a better understanding of the underlying mathematics, which
    the proof of the continuous master theorem provides.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你不需要理解主定理的证明就能应用主方法，你可以选择跳过这一部分。但是如果你希望学习超出本教材范围的更高级算法，你可能会欣赏对连续主定理的证明提供的更好的数学基础的理解。
- en: Although we usually assume that recurrences are algorithmic and don’t require
    an explicit statement of a base case, we must be much more careful for proofs
    that justify the practice. The lemmas and theorem in this section explicitly state
    the base cases, because the inductive proofs require mathematical grounding. It
    is common in the world of mathematics to be extraordinarily careful proving theorems
    that justify acting more casually in practice.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们通常假设递归是算法性的，不需要明确说明基本情况，但是对于证明实践的做法，我们必须更加小心。本节中的引理和定理明确说明了基本情况，因为归纳证明需要数学基础。在数学世界中，非常小心地证明能够证明更加随意实践的定理是很常见的。
- en: The proof of the continuous master theorem involves two lemmas. Lemma 4.2 uses
    a slightly simplified master recurrence with a threshold constant of *n*[0] =
    1, rather than the more general *n*[0] > 0 threshold constant implied by the unstated
    base case. The lemma employs a recursion tree to reduce the solution of the simplified
    master recurrence to that of evaluating a summation. Lemma 4.3 then provides asymptotic
    bounds for the summation, mirroring the three cases of the master theorem. Finally,
    the continuous master theorem itself (Theorem 4.4) gives asymptotic bounds for
    master recurrences, while generalizing to an arbitrary threshold constant *n*[0]
    > 0 as implied by the unstated base case.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 连续主定理的证明涉及两个引理。引理 4.2 使用了一个略微简化的主递归，阈值常数为 *n*[0] = 1，而不是未明示基本情况所暗示的更一般的 *n*[0]
    > 0 阈值常数。该引理使用递归树将简化的主递归的解归约为求解求和。然后，引理 4.3 为求和提供了渐近界限，反映了主定理的三种情况。最后，连续主定理本身（定理
    4.4）为主递归提供了渐近界限，同时推广到由未明示基本情况所暗示的任意阈值常数 *n*[0] > 0。
- en: Some of the proofs use the properties described in Problem 3-5 on pages 72–73
    to combine and simplify complicated asymptotic expressions. Although Problem 3-5
    addresses only Θ-notation, the properties enumerated there can be extended to
    *O*-notation and Ω-notation as well.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 一些证明使用了第 72-73 页上描述的问题 3-5 中的性质来组合和简化复杂的渐近表达式。尽管问题 3-5 仅涉及 Θ-符号，但那里列举的性质也可以扩展到
    *O*-符号和 Ω-符号。
- en: Here’s the first lemma.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 这是第一个引理。
- en: '***Lemma 4.2***'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 4.2***'
- en: Let *a* > 0 and *b* > 1 be constants, and let *f* (*n*) be a function defined
    over real numbers *n* ≥ 1\. Then the recurrence
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 让 *a* > 0 和 *b* > 1 为常数，并且让 *f* (*n*) 为定义在实数 *n* ≥ 1 上的函数。那么递归关系
- en: '![art](images/Art_P166.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P166.jpg)'
- en: has solution
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 有解
- en: '![art](images/Art_P167.jpg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P167.jpg)'
- en: '***Proof***   Consider the recursion tree in [Figure 4.3](chapter004.xhtml#Fig_4-3).
    Let’s look first at its internal nodes. The root of the tree has cost *f* (*n*),
    and it has *a* children, each with cost *f* (*n*/*b*). (It is convenient to think
    of *a* as being an integer, especially when visualizing the recursion tree, but
    the mathematics does not require it.) Each of these children has *a* children,
    making *a*² nodes at depth 2, and each of the *a* children has cost *f* (*n*/*b*²).
    In general, there are *a^j* nodes at depth *j*, and each node has cost *f* (*n*/*b^j*).'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   考虑 [图 4.3](chapter004.xhtml#Fig_4-3) 中的递归树。让我们首先看看它的内部节点。树的根节点具有成本
    *f* (*n*)，并且它有 *a* 个子节点，每个子节点的成本为 *f* (*n*/*b*)。（在可视化递归树时，将 *a* 视为整数是方便的，但数学上并不要求。）每个子节点都有
    *a* 个子节点，形成深度为 2 的 *a*² 个节点，而每个子节点的成本为 *f* (*n*/*b*²)。一般来说，���度为 *j* 有 *a^j* 个节点，每个节点的成本为
    *f* (*n*/*b^j*)。'
- en: Now, let’s move on to understanding the leaves. The tree grows downward until
    *n*/*b^j* becomes less than 1\. Thus, the tree has height ⌊log*[b] n*⌋ + 1, because
    ![art](images/Art_P168.jpg) and ![art](images/Art_P169.jpg). Since, as we have
    observed, the number of nodes at depth *j* is *a^j* and all the leaves are at
    depth ⌊log*[b]* *n*⌋ + 1, the tree contains ![art](images/Art_P170.jpg) leaves.
    Using the identity (3.21) on page 66, we have ![art](images/Art_P171.jpg), since
    *a* is constant, and ![art](images/Art_P172.jpg). Consequently, the total number
    of leaves is ![art](images/Art_P173.jpg)—asymptotically, the watershed function.
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续理解叶子节点。树向下生长，直到 *n*/*b^j* 变小于 1。因此，树的高度为 ⌊log*[b] n*⌋ + 1，因为 ![艺术](images/Art_P168.jpg)
    和 ![艺术](images/Art_P169.jpg)。由于，正如我们观察到的，深度为 *j* 的节点数为 *a^j*，而所有叶子节点都在深度为 ⌊log*[b]* *n*⌋
    + 1，所以树包含 ![艺术](images/Art_P170.jpg) 个叶子节点。使用第 66 页上的恒等式 (3.21)，我们有 ![艺术](images/Art_P171.jpg)，因为
    *a* 是常数，以及 ![艺术](images/Art_P172.jpg)。因此，总叶子节点数为 ![艺术](images/Art_P173.jpg)——渐近地，分水岭函数。
- en: 'We are now in a position to derive equation (4.18) by summing the costs of
    the nodes at each depth in the tree, as shown in the figure. The first term in
    the equation is the total costs of the leaves. Since each leaf is at depth ⌊log[*b*]*n*⌋
    + 1 and ![art](images/Art_P174.jpg), the base case of the recurrence gives the
    cost of a leaf: ![art](images/Art_P175.jpg). Hence the cost of all ![art](images/Art_P176.jpg)
    leaves is ![art](images/Art_P177.jpg) by Problem 3-5(d). The second term in equation
    (4.18) is the cost of the internal nodes, which, in the underlying divide-and-conquer
    algorithm, represents the costs of dividing problems into subproblems and then
    recombining the subproblems. Since the cost for all the internal nodes at depth
    *j* is *a^j f* (*n*/*b^j*), the total cost of all internal nodes is'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以通过计算树中每个深度的节点的成本之和来推导方程(4.18)，如图所示。方程中的第一项是叶子节点的总成本。由于每个叶子节点位于深度⌊log[*b*]*n*⌋
    + 1且![art](images/Art_P174.jpg)，递归的基本情况给出了叶子节点的成本：![art](images/Art_P175.jpg)。因此所有![art](images/Art_P176.jpg)个叶子节点的成本是![art](images/Art_P177.jpg)。方程(4.18)中的第二项是内部节点的成本，在基础的分治算法中，它代表了将问题分解为子问题然后重新组合子问题的成本。由于深度*j*处所有内部节点的成本为*a^j
    f* (*n*/*b^j*)，所有内部节点的总成本为
- en: '![art](images/Art_P178.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P178.jpg)'
- en: ▪
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '![art](images/Art_P179.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P179.jpg)'
- en: '**Figure 4.3** The recursion tree generated by *T* (*n*) = *aT* (*n*/*b*) +
    *f* (*n*). The tree is a complete *a*-ary tree with ![art](images/Art_P180.jpg)
    leaves and height ⌊log*[b] n*⌋ + 1\. The cost of the nodes at each depth is shown
    at the right, and their sum is given in equation (4.18).'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**图4.3** 由*T* (*n*) = *aT* (*n*/*b*) + *f* (*n*)生成的递归树。该树是一个完全的*a*叉树，具有![art](images/Art_P180.jpg)个叶子节点和高度⌊log[*b*]
    n*⌋ + 1。每个深度的节点成本显示在右侧，并且它们的总和在方程(4.18)中给出。'
- en: 'As we’ll see, the three cases of the master theorem depend on the distribution
    of the total cost across levels of the recursion tree:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，主定理的三种情况取决于递归树各级别上总成本的分布：
- en: '**Case 1:** The costs increase geometrically from the root to the leaves, growing
    by a constant factor with each level.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '**情况1：** 成本从根到叶子节点按照常数因子呈几何级数增长。'
- en: '**Case 2:** The costs depend on the value of *k* in the theorem. With *k* =
    0, the costs are equal for each level; with *k* = 1, the costs grow linearly from
    the root to the leaves; with *k* = 2, the growth is quadratic; and in general,
    the costs grow polynomially in *k*.'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '**情况2：** 成本取决于定理中的*k*的值。当*k* = 0时，每个级别的成本相等；当*k* = 1时，成本从根到叶子节点线性增长；当*k* =
    2时，增长是二次的；一般来说，成本在*k*中呈多项式增长。'
- en: '**Case 3:** The costs decrease geometrically from the root to the leaves, shrinking
    by a constant factor with each level.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**情况3：** 成本从根到叶子节点按照常数因子呈几何级数减少。'
- en: The summation in equation (4.18) describes the cost of the dividing and combining
    steps in the underlying divide-and-conquer algorithm. The next lemma provides
    asymptotic bounds on the summation’s growth.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 方程(4.18)中的求和描述了基础分治算法中分割和合并步骤的成本��下一个引理提供了求和增长的渐近界限。
- en: '***Lemma 4.3***'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理4.3***'
- en: Let *a* > 0 and *b* > 1 be constants, and let *f* (*n*) be a function defined
    over real numbers *n* ≥ 1\. Then the asymptotic behavior of the function
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 假设*a* > 0且*b* > 1为常数，并且*fn*为定义在实数*n* ≥ 1上的函数。那么函数的渐近行为
- en: '![art](images/Art_P181.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P181.jpg)'
- en: 'defined for *n* ≥ 1, can be characterized as follows:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 定义为*n* ≥ 1，可以描述如下：
- en: If there exists a constant *ϵ* > 0 such that ![art](images/Art_P182.jpg), then
    ![art](images/Art_P183.jpg).
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在常数*ϵ* > 0使得![art](images/Art_P182.jpg)，那么![art](images/Art_P183.jpg)。
- en: If there exists a constant *k* ≥ 0 such that ![art](images/Art_P184.jpg), then
    ![art](images/Art_P185.jpg).
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在常数*k* ≥ 0使得![art](images/Art_P184.jpg)，那么![art](images/Art_P185.jpg)。
- en: If there exists a constant *c* in the range 0 < *c* < 1 such that 0 < *af* (*n*/*b*)
    ≤ *cf* (*n*) for all *n* ≥ 1, then *g*(*n*) = Θ(*f* (*n*)).
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在范围在0 < *c* < 1内的常数*c*，使得对所有*n* ≥ 1都有0 < *af* (*n*/*b*) ≤ *cf* (*n*), 那么*g*(*n*)
    = Θ(*f* (*n*)).
- en: '***Proof***   For case 1, we have ![art](images/Art_P186.jpg), which implies
    that ![art](images/Art_P187.jpg). Substituting into equation (4.19) yields'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   对于情况1，我们有![art](images/Art_P186.jpg)，这意味着![art](images/Art_P187.jpg)。将其代入方程(4.19)得到'
- en: '![art](images/Art_P188.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P188.jpg)'
- en: the last series being geometric. Since *b* and *ϵ* are constants, the *b^ϵ*
    – 1 denominator doesn’t affect the asymptotic growth of *g*(*n*), and neither
    does the –1 in the numerator. Since ![art](images/Art_P189.jpg), we obtain ![art](images/Art_P190.jpg),
    thereby proving case 1.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一系列是等比数列。由于*b*和*ϵ*是常数，*b^ϵ* – 1的分母不影响*g*(*n*)的渐近增长，分子中的-1也不影响。由于![art](images/Art_P189.jpg)，我们得到![art](images/Art_P190.jpg)，从而证明了情况1。
- en: Case 2 assumes that ![art](images/Art_P191.jpg), from which we can conclude
    that ![art](images/Art_P192.jpg). Substituting into equation (4.19) and repeatedly
    applying Problem 3-5(c) yields
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 情况2假设![art](images/Art_P191.jpg)，由此我们可以得出![art](images/Art_P192.jpg)。将其代入方程(4.19)并反复应用问题3-5(c)得到
- en: '![art](images/Art_P193.jpg)'
  id: totrans-387
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P193.jpg)'
- en: 'The summation within the Θ-notation can be bounded from above as follows:'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: Θ-记法中的求和可以从上方界限如下限制：
- en: '![art](images/Art_P194.jpg)'
  id: totrans-389
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P194.jpg)'
- en: Exercise 4.6-1 asks you to show that the summation can similarly be bounded
    from below by ![art](images/Art_P195.jpg). Since we have tight upper and lower
    bounds, the summation is ![art](images/Art_P196.jpg), from which we can conclude
    that ![art](images/Art_P197.jpg), thereby completing the proof of case 2.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 练习4.6-1要求您展示求和可以类似地由![art](images/Art_P195.jpg)从下方界限。由于我们有紧密的上下界，求和为![art](images/Art_P196.jpg)，从中我们可以得出![art](images/Art_P197.jpg)，从而完成了情况2的证明。
- en: For case 3, observe that *f* (*n*) appears in the definition (4.19) of *g*(*n*)
    (when *j* = 0) and that all terms of *g*(*n*) are positive. Therefore, we must
    have *g*(*n*) = Ω(*f* (*n*)), and it only remains to prove that *g*(*n*) = *O*(*f*
    (*n*)). Performing *j* iterations of the inequality *af* (*n*/*b*) ≤ *cf* (*n*)
    yields *a^j f* (*n*/*b^j*) ≤ *c^j f* (*n*). Substituting into equation (4.19),
    we obtain
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 对于情况 3，注意到 *f* (*n*) 出现在 *g*(*n*) 的定义 (4.19) 中（当 *j* = 0），而 *g*(*n*) 的所有项都是正的。因此，我们必须有
    *g*(*n*) = Ω(*f* (*n*))，只剩下要证明 *g*(*n*) = *O*(*f* (*n*)). 对不等式 *af* (*n*/*b*)
    ≤ *cf* (*n*) 进行 *j* 次迭代得到 *a^j f* (*n*/*b^j*) ≤ *c^j f* (*n*)。代入方程 (4.19)，我们得到
- en: '![art](images/Art_P198.jpg)'
  id: totrans-392
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P198.jpg)'
- en: Thus, we can conclude that *g*(*n*) = Θ(*f* (*n*)). With case 3 proved, the
    entire proof of the lemma is complete.
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以得出 *g*(*n*) = Θ(*f* (*n*)). 通过证明情况 3，引理的整个证明就完成了。
- en: ▪
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: We can now state and prove the continuous master theorem.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以陈述并证明连续主定理。
- en: '***Theorem 4.4 (Continuous master theorem)***'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 4.4（连续主定理）***'
- en: Let *a* > 0 and *b* > 1 be constants, and let *f* (*n*) be a driving function
    that is defined and nonnegative on all sufficiently large reals. Define the algorithmic
    recurrence *T* (*n*) on the positive real numbers by
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 让 *a* > 0 和 *b* > 1 为常数，并且让 *f* (*n*) 为一个在所有足够大的实数上定义且非负的驱动函数。通过以下算法递归定义正实数上的
    *T* (*n*)：
- en: '*T* (*n*) = *aT* (*n*/*b*) + *f* (*n*).'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '*T* (*n*) = *aT* (*n*/*b*) + *f* (*n*).'
- en: 'Then the asymptotic behavior of *T* (*n*) can be characterized as follows:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 然后 *T* (*n*) 的渐近行为可以描述如下：
- en: If there exists a constant *ϵ* > 0 such that ![art](images/Art_P199.jpg), then
    ![art](images/Art_P200.jpg).
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在一个常数 *ϵ* > 0 使得 ![art](images/Art_P199.jpg)，那么 ![art](images/Art_P200.jpg)。
- en: If there exists a constant *k* ≥ 0 such that ![art](images/Art_P201.jpg), then
    ![art](images/Art_P202.jpg).
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在一个常数 *k* ≥ 0 使得 ![art](images/Art_P201.jpg)，那么 ![art](images/Art_P202.jpg)。
- en: If there exists a constant *ϵ* > 0 such that ![art](images/Art_P203.jpg), and
    if *f* (*n*) additionally satisfies the regularity condition *af* (*n*/*b*) ≤
    *cf* (*n*) for some constant *c* < 1 and all sufficiently large *n*, then *T*
    (*n*) = Θ(*f* (*n*)).
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果存在一个常数 *ϵ* > 0 使得 ![art](images/Art_P203.jpg)，并且如果 *f* (*n*) 还满足正则条件 *af*
    (*n*/*b*) ≤ *cf* (*n*) 对于某个常数 *c* < 1 和所有足够大的 *n*，那么 *T* (*n*) = Θ(*f* (*n*)).
- en: '***Proof***   The idea is to bound the summation (4.18) from Lemma 4.2 by applying
    Lemma 4.3\. But we must account for Lemma 4.2 using a base case for 0 < *n* <
    1, whereas this theorem uses an implicit base case for 0 < *n* < *n*[0], where
    *n*[0] > 0 is an arbitrary threshold constant. Since the recurrence is algorithmic,
    we can assume that *f* (*n*) is defined for *n* ≥ *n*[0].'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   思路是通过应用引理 4.3 来限制引理 4.2 中的求和 (4.18)。但是我们必须考虑引理 4.2 对于 0 < *n* <
    1 的基本情况，而这个定理使用了一个隐含的基本情况，即 0 < *n* < *n*[0]，其中 *n*[0] > 0 是一个任意的阈值常数。由于递归是算法性的，我们可以假设
    *f* (*n*) 对于 *n* ≥ *n*[0] 是定义的。'
- en: For *n* > 0, let us define two auxiliary functions *T*^′(*n*) = *T* (*n*[0] *n*)
    and *f* ^′(*n*) = *f* (*n*[0] *n*). We have
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *n* > 0，让我们定义两个辅助函数 *T*^′(*n*) = *T* (*n*[0] *n*) 和 *f* ^′(*n*) = *f* (*n*[0] *n*)。我们有
- en: '![art](images/Art_P204.jpg)'
  id: totrans-405
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P204.jpg)'
- en: We have obtained a recurrence for *T* ^′(*n*) that satisfies the conditions
    of Lemma 4.2, and by that lemma, the solution is
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经得到了满足引理 4.2 条件的 *T* ^′(*n*) 的递归，根据该引理，解为
- en: '![art](images/Art_P205.jpg)'
  id: totrans-407
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P205.jpg)'
- en: To solve *T* ^′(*n*), we first need to bound *f* ^′(*n*). Let’s examine the
    individual cases in the theorem.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 要解决 *T* ^′(*n*)，我们首先需要限制 *f* ^′(*n*)。让我们检查定理中的各种情况。
- en: The condition for case 1 is ![art](images/Art_P206.jpg) for some constant *ϵ*
    > 0\. We have
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 情况 1 的条件是 ![art](images/Art_P206.jpg) 对于某个常数 *ϵ* > 0。我们有
- en: '![art](images/Art_P207.jpg)'
  id: totrans-410
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P207.jpg)'
- en: since *a*, *b*, *n*[0], and *ϵ* are all constant. The function *f* ^′(*n*) satisfies
    the conditions of case 1 of Lemma 4.3, and the summation in equation (4.18) of
    Lemma 4.2 evaluates to ![art](images/Art_P208.jpg). Because *a*, *b* and *n*[0]
    are all constants, we have
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 *a*, *b*, *n*[0] 和 *ϵ* 都是常数。函数 *f* ^′(*n*) 满足引理 4.3 的情况 1 的条件，并且引理 4.2 中方程
    (4.18) 的求和结果为 ![art](images/Art_P208.jpg)。由于 *a*, *b* 和 *n*[0] 都是常数，我们有
- en: '![art](images/Art_P209.jpg)'
  id: totrans-412
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P209.jpg)'
- en: thereby completing case 1 of the theorem.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 从而完成了定理的情况 1。
- en: The condition for case 2 is ![art](images/Art_P210.jpg) for some constant *k*
    ≥ 0\. We have
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 情况 2 的条件是 ![art](images/Art_P210.jpg) 对于某个常数 *k* ≥ 0。我们有
- en: '![art](images/Art_P211.jpg)'
  id: totrans-415
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P211.jpg)'
- en: Similar to the proof of case 1, the function *f*^′(*n*) satisfies the conditions
    of case 2 of Lemma 4.3\. The summation in equation (4.18) of Lemma 4.2 is therefore
    ![art](images/Art_P212.jpg), which implies that
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 类似于情况 1 的证明，函数 *f*^′(*n*) 满足引理 4.3 的情况 2 的条件。因此，引理 4.2 中方程 (4.18) 的求和结果为 ![art](images/Art_P212.jpg)，这意味着
- en: '![art](images/Art_P213.jpg)'
  id: totrans-417
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P213.jpg)'
- en: which proves case 2 of the theorem.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 这证明了定理的情况 2。
- en: 'Finally, the condition for case 3 is ![art](images/Art_P214.jpg) for some constant
    *ϵ* > 0 and *f* (*n*) additionally satisfies the regularity condition *af* (*n*/*b*)
    ≤ *cf* (*n*) for all *n* ≥ *n*[0] and some constants *c* < 1 and *n*[0] > 1\.
    The first part of case 3 is like case 1:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，情况 3 的条件是 ![art](images/Art_P214.jpg) 对于某个常数 *ϵ* > 0，并且 *f* (*n*) 还满足正则条件
    *af* (*n*/*b*) ≤ *cf* (*n*) 对于所有 *n* ≥ *n*[0] 和一些常数 *c* < 1 和 *n*[0] > 1。情况 3
    的第一部分类似于情况 1：
- en: '![art](images/Art_P215.jpg)'
  id: totrans-420
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P215.jpg)'
- en: Using the definition of *f* ^′(*n*) and the fact that *n*[0] *n* ≥ *n*[0] for
    all *n* ≥ 1, we have for *n* ≥ 1 that
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 *f* ^′(*n*) 的定义和 *n*[0] *n* ≥ *n*[0] 对于所�� *n* ≥ 1，我们有对于 *n* ≥ 1
- en: '| *af* ^′(*n*/*b*) | = | *af* (*n*[0] *n*/*b*) |'
  id: totrans-422
  prefs: []
  type: TYPE_TB
  zh: '| *af* ^′(*n*/*b*) | = | *af* (*n*[0] *n*/*b*) |'
- en: '|  | ≤ | *cf* (*n*[0] *n*) |'
  id: totrans-423
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | *cf* (*n*[0] *n*) |'
- en: '|  | = | *cf* ^′(*n*). |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *cf* ^′(*n*). |'
- en: Thus *f* ^′(*n*) satisfies the requirements for case 3 of Lemma 4.3, and the
    summation in equation (4.18) of Lemma 4.2 evaluates to Θ(*f* ^′(*n*)), yielding
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*f* ^′(*n*) 满足引理 4.3 的情况 3 的要求，并且引理 4.2 中方程 (4.18) 的求和结果为 Θ(*f* ^′(*n*))，得到
- en: '| *T* (*n*) | = | *T* ^′(*n*/*n*[0]) |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '| *T* (*n*) | = | *T* ^′(*n*/*n*[0]) |'
- en: '|  | = | ![art](images/Art_P216.jpg) |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '|  | = | ![art](images/Art_P216.jpg) |'
- en: '|  | = | Θ(*f* ^′(*n*/*n*[0])) |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '|  | = | Θ(*f* ^′(*n*/*n*[0])) |'
- en: '|  | = | Θ(*f* (*n*)), |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '|  | = | Θ(*f* (*n*)), |'
- en: which completes the proof of case 3 of the theorem and thus the whole theorem.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了定理的第 3 情况的证明，从而完成了整个定理。
- en: ▪
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Exercises**'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***4.6-1***'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.6-1***'
- en: Show that ![art](images/Art_P217.jpg).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 证明 ![art](images/Art_P217.jpg)。
- en: ★ ***4.6-2***
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***4.6-2***
- en: Show that case 3 of the master theorem is overstated (which is also why case
    3 of Lemma 4.3 does not require that ![art](images/Art_P218.jpg) in the sense
    that the regularity condition *af* (*n*/*b*) ≤ *cf* (*n*) for some constant *c*
    < 1 implies that there exists a constant *ϵ* > 0 such that ![art](images/Art_P219.jpg).
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 证明主定理的第 3 情况被夸大了（这也是为什么引理 4.3 的第 3 情况不要求 ![art](images/Art_P218.jpg) 的原因，即正则条件
    *af* (*n*/*b*) ≤ *cf* (*n*) 对于某个常数 *c* < 1 意味着存在常数 *ϵ* > 0，使得 ![art](images/Art_P219.jpg)。
- en: ★ ***4.6-3***
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***4.6-3***
- en: For ![art](images/Art_P220.jpg), prove that the summation in equation (4.19)
    has solution ![art](images/Art_P221.jpg). Conclude that a master recurrence *T*
    (*n*) using *f* (*n*) as its driving function has solution ![art](images/Art_P222.jpg).
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 对��� ![art](images/Art_P220.jpg)，证明方程（4.19）中的求和有解 ![art](images/Art_P221.jpg)。得出结论，使用
    *f* (*n*) 作为驱动函数的主循环 *T* (*n*) 有解 ![art](images/Art_P222.jpg)。
- en: '[★ **4.7      Akra-Bazzi recurrences**](toc.xhtml#Rh1-22)'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '[★ **4.7      Akra-Bazzi 循环**](toc.xhtml#Rh1-22)'
- en: This section provides an overview of two advanced topics related to divide-and-conquer
    recurrences. The first deals with technicalities arising from the use of floors
    and ceilings, and the second discusses the Akra-Bazzi method, which involves a
    little calculus, for solving complicated divide-and-conquer recurrences.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 本节概述了与分治循环相关的两个高级主题。第一个涉及到使用 floors 和 ceilings 引起的技术性问题，第二个讨论了涉及一点微积分的 Akra-Bazzi
    方法，用于解决复杂的分治循环。
- en: In particular, we’ll look at the class of algorithmic divide-and-conquer recurrences
    originally studied by M. Akra and L. Bazzi [[13](bibliography001.xhtml#endnote_13)].
    These ***Akra-Bazzi*** recurrences take the form
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们将研究最初由 M. Akra 和 L. Bazzi 研究的算法分治循环类[[13](bibliography001.xhtml#endnote_13)]。这些***Akra-Bazzi***
    循环的形式为
- en: '![art](images/Art_P223.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P223.jpg)'
- en: where *k* is a positive integer; all the constants *a*[1], *a*[2], … , *a[k]*
    ∈ R are strictly positive; all the constants *b*[1], *b*[2], … , *b[k]* ∈ R are
    strictly greater than 1; and the driving function *f* (*n*) is defined on sufficiently
    large nonnegative reals and is itself nonnegative.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *k* 是正整数；所有常数 *a*[1]，*a*[2]，…，*a[k]* ∈ R 严格为正；所有常数 *b*[1]，*b*[2]，…，*b[k]*
    ∈ R 严格大于 1；驱动函数 *f* (*n*) 在足够大的非负实数上定义，并且本身为非负。
- en: Akra-Bazzi recurrences generalize the class of recurrences addressed by the
    master theorem. Whereas master recurrences characterize the running times of divide-and-conquer
    algorithms that break a problem into equal-sized subproblems (modulo floors and
    ceilings), Akra-Bazzi recurrences can describe the running time of divide-and-conquer
    algorithms that break a problem into different-sized subproblems. The master theorem,
    however, allows you to ignore floors and ceilings, but the Akra-Bazzi method for
    solving Akra-Bazzi recurrences needs an additional requirement to deal with floors
    and ceilings.
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: Akra-Bazzi 循环推广了主定理所涉及的循环类。主循环表征将问题分解为大小相等子问题的分治算法的运行时间（除以 floors 和 ceilings），而
    Akra-Bazzi 循环可以描述将问题分解为不同大小子问题的分治算法的运行时间。然而，主定理允许您忽略 floors 和 ceilings，但解决 Akra-Bazzi
    循环的 Akra-Bazzi 方法需要额外的要求来处理 floors 和 ceilings。
- en: But before diving into the Akra-Bazzi method itself, let’s understand the limitations
    involved in ignoring floors and ceilings in Akra-Bazzi recurrences. As you’re
    aware, algorithms generally deal with integer-sized inputs. The mathematics for
    recurrences is often easier with real numbers, however, than with integers, where
    we must cope with floors and ceilings to ensure that terms are well defined. The
    difference may not seem to be much—especially because that’s often the truth with
    recurrences—but to be mathematically correct, we must be careful with our assumptions.
    Since our end goal is to understand algorithms and not the vagaries of mathematical
    corner cases, we’d like to be casual yet rigorous. How can we treat floors and
    ceilings casually while still ensuring rigor?
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 但在深入了解 Akra-Bazzi 方法之前，让我们了解在 Akra-Bazzi 循环中忽略 floors 和 ceilings 所涉及的限制。正如您所知，算法通常处理整数大小的输入。然而，对于循环，使用实数通常比使用整数更容易，因为我们必须处理
    floors 和 ceilings 以确保术语被明确定义。这种差异可能看起来并不大——尤其是在循环中通常是这样——但为了数学上的正确性，我们必须小心我们的假设。由于我们的最终目标是理解算法而不是数学边缘情况的怪癖，我们希望既随意又严谨。我们如何在确保严谨的同时随意对待
    floors 和 ceilings 呢？
- en: From a mathematical point of view, the difficulty in dealing with floors and
    ceilings is that some driving functions can be really, really weird. So it’s not
    okay in general to ignore floors and ceilings in Akra-Bazzi recurrences. Fortunately,
    most of the driving functions we encounter in the study of algorithms behave nicely,
    and floors and ceilings don’t make a difference.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 从数学角度来看，处理 floors 和 ceilings 的困难在于一些驱动函数可能真的非常奇怪。因此，通常情况下不能忽略 Akra-Bazzi 循环中的
    floors 和 ceilings。幸运的是，在算法研究中遇到的大多数驱动函数表现良好，floors 和 ceilings 不会有影响。
- en: '**The polynomial-growth condition**'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '**多项式增长条件**'
- en: If the driving function *f* (*n*) in equation (4.22) is well behaved in the
    following sense, it’s okay to drop floors and ceilings.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 如果方程（4.22）中的驱动函数 *f* (*n*) 在以下意义上表现良好，则可以忽略 floors 和 ceilings。
- en: 'A function *f* (*n*) defined on all sufficiently large positive reals satisfies
    the ***polynomial-growth condition*** if there exists a constant ![art](images/Art_P224.jpg)
    such that the following holds: for every constant *ϕ* ≥ 1, there exists a constant
    *d* > 1 (depending on *ϕ*) such that *f* (*n*)/*d* ≤ *f* (*ψ n*) ≤ *df* (*n*)
    for all 1 ≤ *ψ* ≤ *ϕ* and ![art](images/Art_P225.jpg).'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有足够大的正实数上定义的函数 *f* (*n*)，如果存在常数 ![art](images/Art_P224.jpg) 使得以下条件成立：对于每个常数
    *ϕ* ≥ 1，存在常数 *d* > 1（取决于 *ϕ*），使得对于所有 1 ≤ *ψ* ≤ *ϕ* 和 ![art](images/Art_P225.jpg)
    都有 *f* (*n*)/*d* ≤ *f* (*ψ n*) ≤ *df* (*n*)。
- en: This definition may be one of the hardest in this textbook to get your head
    around. To a first order, it says that *f* (*n*) satisfies the property that *f*
    (Θ(*n*)) = Θ(*f* (*n*)), although the polynomial-growth condition is actually
    somewhat stronger (see Exercise 4.7-4). The definition also implies that *f* (*n*)
    is asymptotically positive (see Exercise 4.7-3).
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 这个定义可能是这本教材中最难理解的之一。从第一阶开始，它说*f*(*n*)满足*f*(Θ(*n*)) = Θ(*f*(*n*))的性质，尽管多项式增长条件实际上稍微更强（参见练习4.7-4）。该定义还意味着*f*(*n*)在渐近上是正的（参见练习4.7-3）。
- en: Examples of functions that satisfy the polynomial-growth condition include any
    function of the form *f* (*n*) = Θ(*n^α* lg*^β n* lg lg*^γn*), where *α*, *β*,
    and *γ* are constants. Most of the polynomially bounded functions used in this
    book satisfy the condition. Exponentials and superexponentials do not (see Exercise
    4.7-2, for example), and there also exist polynomially bounded functions that
    do not.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 满足多项式增长条件的函数示例包括任何形式为*f*(*n*) = Θ(*n^α* lg*^β n* lg lg*^γn*)的函数，其中*α*、*β*和*γ*是常数。本书中使用的大多数多项式有界函数满足这个条件。指数和超指数不满足（例如，参见练习4.7-2），也存在一些不满足多项式有界条件的函数。
- en: '**Floors and ceilings in “nice” recurrences**'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '**在“好”递归中的取整**'
- en: When the driving function in an Akra-Bazzi recurrence satisfies the polynomial-growth
    condition, floors and ceilings don’t change the asymptotic behavior of the solution.
    The following theorem, which is presented without proof, formalizes this notion.
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 当Akra-Bazzi递归中的驱动函数满足多项式增长条件时，取整不会改变解的渐近行为。下面的定理，没有给出证明，形式化了这个概念。
- en: '***Theorem 4.5***'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理4.5***'
- en: Let *T* (*n*) be a function defined on the nonnegative reals that satisfies
    recurrence (4.22), where *f* (*n*) satisfies the polynomial-growth condition.
    Let *T* ^′(*n*) be another function defined on the natural numbers also satisfying
    recurrence (4.22), except that each *T* (*n*/*b[i]*) is replaced either with *T*
    (⌈*n*/*b[i]*⌉) or with *T* (⌊*n*/*b[i]*⌋). Then we have *T* ^′(*n*) = Θ(*T* (*n*)).
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 让*T*(*n*)是一个定义在非负实数上的函数，满足递归关系(4.22)，其中*f*(*n*)满足多项式增长条件。让*T* ^′(*n*)是另一个定义在自然数上的函数，也满足递归关系(4.22)，除了每个*T*(*n*/*b[i]*)被替换为*T*(⌈*n*/*b[i]*⌉)或*T*(⌊*n*/*b[i]*⌋)。那么我们有*T* ^′(*n*)
    = Θ(*T*(*n*))。
- en: ▪
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Floors and ceilings represent a minor perturbation to the arguments in the recursion.
    By inequality (3.2) on page 64, they perturb an argument by at most 1\. But much
    larger perturbations are tolerable. As long as the driving function *f* (*n*)
    in recurrence (4.22) satisfies the polynomial-growth condition, it turns out that
    replacing any term *T* (*n*/*b[i]*) with *T* (*n*/*b[i]* + *h[i]*(*n*)), where
    |*h[i]*(*n*)| = *O*(*n*/lg^(1+*ϵ*) *n*) for some constant *ϵ* > 0 and sufficiently
    large *n*, leaves the asymptotic solution unaffected. Thus, the divide step in
    a divide-and-conquer algorithm can be moderately coarse without affecting the
    solution to its running-time recurrence.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 取整代表递归中参数的轻微扰动。根据第64页的不等式(3.2)，它们最多使参数扰动1。但更大的扰动是可以容忍的。只要递归(4.22)中的驱动函数*f*(*n*)满足多项式增长条件，就会发现用*T*(*n*/*b[i]*)替换任何项*T*(*n*/*b[i*
    + *h[i]*(*n*)),其中|*h[i]*(*n*)| = *O*(*n*/lg^(1+*ϵ*) *n*)对于某个常数*ϵ* > 0和足够大的*n*，不会影响渐近解。因此，分治算法中的分割步骤可以相对粗糙而不影响其运行时间递归的解。
- en: '**The Akra-Bazzi method**'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: '**Akra-Bazzi方法**'
- en: The Akra-Bazzi method, not surprisingly, was developed to solve Akra-Bazzi recurrences
    (4.22), which by dint of Theorem 4.5, applies in the presence of floors and ceilings
    or even larger perturbations, as just discussed. The method involves first determining
    the unique real number *p* such that ![art](images/Art_P226.jpg). Such a *p* always
    exists, because when *p* → –∞, the sum goes to ∞; it decreases as *p* increases;
    and when *p* → ∞, it goes to 0\. The Akra-Bazzi method then gives the solution
    to the recurrence as
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 不出所料，Akra-Bazzi方法是为了解决Akra-Bazzi递归(4.22)而开发的，根���定理4.5，即使存在取整或更大的扰动，也适用。该方法首先确定唯一实数*p*，使得![艺术](images/Art_P226.jpg)。这样的*p*总是存在，因为当*p*
    → –∞时，总和趋于∞；随着*p*增加而减少；当*p* → ∞时，它趋于0。然后Akra-Bazzi方法给出递归的解
- en: '![art](images/Art_P227.jpg)'
  id: totrans-460
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P227.jpg)'
- en: As an example, consider the recurrence
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑递归
- en: '![art](images/Art_P228.jpg)'
  id: totrans-462
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P228.jpg)'
- en: We’ll see the similar recurrence (9.1) on page 240 when we study an algorithm
    for selecting the *i*th smallest element from a set of *n* numbers. This recurrence
    has the form of equation (4.22), where *a*[1] = *a*[2] = 1, *b*[1] = 5, *b*[2]
    = 10/7, and *f* (*n*) = *n*. To solve it, the Akra-Bazzi method says that we should
    determine the unique *p* satisfying
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们研究从*n*个数字集合中选择第*i*小元素的算法时，我们将在第240页看到类似的递归(9.1)。这个递归具有方程(4.22)的形式，其中*a*[1]
    = *a*[2] = 1，*b*[1] = 5，*b*[2] = 10/7，而*f*(*n*) = *n*。为了解决它，Akra-Bazzi方法说我们应该确定满足唯一*p*的条件
- en: '![art](images/Art_P229.jpg)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P229.jpg)'
- en: Solving for *p* is kind of messy—it turns out that *p* = 0.83978 …—but we can
    solve the recurrence without actually knowing the exact value for *p*. Observe
    that (1/5)⁰ + (7/10)⁰ = 2 and (1/5)¹ + (7/10)¹ = 9/10, and thus *p* lies in the
    range 0 < *p* < 1\. That turns out to be sufficient for the Akra-Bazzi method
    to give us the solution. We’ll use the fact from calculus that if *k* ≠ –1, then
    ∫ *x^kdx* = *x*^(*k* + 1)/(*k* + 1), which we’ll apply with *k* = – *p* ≠ –1\.
    The Akra-Bazzi solution (4.23) gives us
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 解*p*有点混乱——结果*p* = 0.83978 …—但我们可以在不知道*p*的确切值的情况下解决递归。注意到(1/5)⁰ + (7/10)⁰ = 2和(1/5)¹
    + (7/10)¹ = 9/10，因此*p*在范围0 < *p* < 1内。这足以让Akra-Bazzi方法给出我们解。我们将应用微积分中的事实，即如果*k*
    ≠ –1，则∫ *x^kdx* = *x*^(*k* + 1)/(*k* + 1)，我们将应用*k* = – *p* ≠ –1。Akra-Bazzi解(4.23)给出
- en: '![art](images/Art_P230.jpg)'
  id: totrans-466
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P230.jpg)'
- en: Although the Akra-Bazzi method is more general than the master theorem, it requires
    calculus and sometimes a bit more reasoning. You also must ensure that your driving
    function satisfies the polynomial-growth condition if you want to ignore floors
    and ceilings, although that’s rarely a problem. When it applies, the master method
    is much simpler to use, but only when subproblem sizes are more or less equal.
    They are both good tools for your algorithmic toolkit.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Akra-Bazzi方法比主定理更通用，但它需要微积分和有时更多的推理。如果要忽略地板和天花板，还必须确保你的驱动函数满足多项式增长条件，尽管这很少是一个问题。当适用时，主定理使用起来更简单，但只有当子问题大小更多或更少相等时。它们都是你算法工具包中的好工具。
- en: '**Exercises**'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: ★ ***4.7-1***
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***4.7-1***
- en: Consider an Akra-Bazzi recurrence *T* (*n*) on the reals as given in recurrence
    (4.22), and define *T* ^′(*n*) as
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个实数上的Akra-Bazzi递归*T* (*n*)，如递归(4.22)中所示，并定义*T* ^′(*n*)为
- en: '![art](images/Art_P231.jpg)'
  id: totrans-471
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P231.jpg)'
- en: where *c* > 0 is constant. Prove that whatever the implicit initial conditions
    for *T* (*n*) might be, there exist initial conditions for *T* ^′(*n*) such that
    *T* ^′(*n*) = *cT* (*n*) for all *n* > 0\. Conclude that we can drop the asymptotics
    on a driving function in any Akra-Bazzi recurrence without affecting its asymptotic
    solution.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*c* > 0是常数。证明无论*T* (*n*)的隐式初始条件是什么，都存在*T* ^′(*n*)的初始条件，使得对所有*n* > 0，都有*T* ^′(*n*)
    = *cT* (*n*)。得出结论，我们可以在Akra-Bazzi递归中去掉驱动函数的渐近特性，而不影响其渐近解。
- en: '***4.7-2***'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.7-2***'
- en: Show that *f* (*n*) = *n*² satisfies the polynomial-growth condition but that
    *f* (*n*) = 2*^n* does not.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 证明*f* (*n*) = *n*²满足多项式增长条件，但*f* (*n*) = 2*^n*不满足。
- en: '***4.7-3***'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.7-3***'
- en: Let *f* (*n*) be a function that satisfies the polynomial-growth condition.
    Prove that *f* (*n*) is asymptotically positive, that is, there exists a constant
    *n*[0] ≥ 0 such that *f* (*n*) ≥ 0 for all *n* ≥ *n*[0].
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 设*f* (*n*)是满足多项式增长条件的函数。证明*f* (*n*)是渐近正的，即存在常数*n*[0] ≥ 0，使得对所有*n* ≥ *n*[0]，都有*f*
    (*n*) ≥ 0。
- en: ★ ***4.7-4***
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***4.7-4***
- en: Give an example of a function *f* (*n*) that does not satisfy the polynomial-growth
    condition but for which *f* (Θ(*n*)) = Θ(*f* (*n*)).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个不满足多项式增长条件但对于*f* (Θ(*n*)) = Θ(*f* (*n*))成立的函数*f* (*n*)的例子。
- en: '***4.7-5***'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '***4.7-5***'
- en: Use the Akra-Bazzi method to solve the following recurrences.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Akra-Bazzi方法解决以下递归。
- en: '***a.*** *T* (*n*) = *T* (*n*/2) + *T* (*n*/3) + *T* (*n*/6) + *n* lg *n*.'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** *T* (*n*) = *T* (*n*/2) + *T* (*n*/3) + *T* (*n*/6) + *n* lg *n*。'
- en: '***b.*** *T* (*n*) = 3*T* (*n*/3) + 8*T* (*n*/4) + *n*²/lg *n*.'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** *T* (*n*) = 3*T* (*n*/3) + 8*T* (*n*/4) + *n*²/lg *n*。'
- en: '***c.*** *T* (*n*) = (2/3)*T* (*n*/3) + (1/3)*T* (2*n*/3) + lg *n*.'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** *T* (*n*) = (2/3)*T* (*n*/3) + (1/3)*T* (2*n*/3) + lg *n*。'
- en: '***d.*** *T* (*n*) = (1/3)*T* (*n*/3) + 1/*n*.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** *T* (*n*) = (1/3)*T* (*n*/3) + 1/*n*。'
- en: '***e.*** *T* (*n*) = 3*T* (*n*/3) + 3*T* (2*n*/3) + *n*².'
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** *T* (*n*) = 3*T* (*n*/3) + 3*T* (2*n*/3) + *n*²。'
- en: ★ ***4.7-6***
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***4.7-6***
- en: Use the Akra-Bazzi method to prove the continuous master theorem.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Akra-Bazzi方法证明连续主定理。
- en: '**Problems**'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '***4-1     Recurrence examples***'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '***4-1     递归示例***'
- en: Give asymptotically tight upper and lower bounds for *T* (*n*) in each of the
    following algorithmic recurrences. Justify your answers.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 给出每个以下算法递归的渐近紧密上下界。证明你的答案。
- en: '***a.*** *T* (*n*) = 2*T* (*n*/2) + *n*³.'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** *T* (*n*) = 2*T* (*n*/2) + *n*³.'
- en: '***b.*** *T* (*n*) = *T* (8*n*/11) + *n*.'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** *T* (*n*) = *T* (8*n*/11) + *n*。'
- en: '***c.*** *T* (*n*) = 16*T* (*n*/4) + *n*².'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** *T* (*n*) = 16*T* (*n*/4) + *n*²。'
- en: '***d.*** *T* (*n*) = 4*T* (*n*/2) + *n*² lg *n*.'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** *T* (*n*) = 4*T* (*n*/2) + *n*² lg *n*。'
- en: '***e.*** *T* (*n*) = 8*T* (*n*/3) + *n*².'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** *T* (*n*) = 8*T* (*n*/3) + *n*²。'
- en: '***f.*** *T* (*n*) = 7*T* (*n*/2) + *n*² lg *n*.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '***f.*** *T* (*n*) = 7*T* (*n*/2) + *n*² lg *n*。'
- en: '***g.*** ![art](images/Art_P232.jpg).'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '***g.*** ![艺术](images/Art_P232.jpg)。'
- en: '***h.*** *T* (*n*) = *T* (*n* –2) + *n*².'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '***h.*** *T* (*n*) = *T* (*n* –2) + *n*²。'
- en: '***4-2     Parameter-passing costs***'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '***4-2     参数传递成本***'
- en: 'Throughout this book, we assume that parameter passing during procedure calls
    takes constant time, even if an *N*-element array is being passed. This assumption
    is valid in most systems because a pointer to the array is passed, not the array
    itself. This problem examines the implications of three parameter-passing strategies:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们假设在过程调用期间参数传递需要恒定时间，即使传递的是一个*N*元素的数组。这个假设在大多数系统中是有效的，因为传递的是数组的指针，而不是数组本身。这个问题考察了三种参数传递策略的影响：
- en: Arrays are passed by pointer. Time = Θ(1).
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组通过指针传递。时间 = Θ(1)。
- en: Arrays are passed by copying. Time = Θ(*N*), where *N* is the size of the array.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组通过复制传递。时间 = Θ(*N*)，其中*N*是数组的大小。
- en: Arrays are passed by copying only the subrange that might be accessed by the
    called procedure. Time = Θ(*n*) if the subarray contains *n* elements.
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 数组仅通过可能被调用过程访问的子范围进行复制。如果子数组包含*n*个元素，则时间 = Θ(*n*)。
- en: 'Consider the following three algorithms:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下三个算法：
- en: '***a.*** The recursive binary-search algorithm for finding a number in a sorted
    array (see Exercise 2.3-6).'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 用于在排序数组中查找数字的递归二分搜索算法（参见练习2.3-6）。'
- en: '***b.*** The MERGE-SORT procedure from [Section 2.3.1](chapter002.xhtml#Sec_2.3.1).'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 来自[第2.3.1节](chapter002.xhtml#Sec_2.3.1)的MERGE-SORT过程。'
- en: '***c.*** The MATRIX-MULTIPLY-RECURSIVE procedure from [Section 4.1](chapter004.xhtml#Sec_4.1).'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 来自[第4.1节](chapter004.xhtml#Sec_4.1)的MATRIX-MULTIPLY-RECURSIVE过程。'
- en: Give nine recurrences *T*[*a*1](*N, n*), *T*[*a*2](*N, n*), … , *T*[*c*3](*N,
    n*) for the worst-case running times of each of the three algorithms above when
    arrays and matrices are passed using each of the three parameter-passing strategies
    above. Solve your recurrences, giving tight asymptotic bounds.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 给出三个算法的最坏情况运行时间的九个递归*T*[*a*1](*N, n*)，*T*[*a*2](*N, n*)，…，*T*[*c*3](*N, n*)，当数组和矩阵使用上述三种参数传递策略时。解决你的递归，给出紧密的渐近界。
- en: '***4-3     Solving recurrences with a change of variables***'
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '***4-3     通过变量变换解递归***'
- en: Sometimes, a little algebraic manipulation can make an unknown recurrence similar
    to one you have seen before. Let’s solve the recurrence
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，一点代数操作可以使一个未知的递归类似于你以前见过的递归。让我们解决��归
- en: '![art](images/Art_P233.jpg)'
  id: totrans-511
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P233.jpg)'
- en: by using the change-of-variables method.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用变量变换方法。
- en: '***a.*** Define *m* = lg *n* and *S*(*m*) = *T* (2*^m*). Rewrite recurrence
    (4.25) in terms of *m* and *S*(*m*).'
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 定义 *m* = lg *n* 和 *S*(*m*) = *T* (2*^m*)。用 *m* 和 *S*(*m*) 重写递归式（4.25）。'
- en: '***b.*** Solve your recurrence for *S*(*m*).'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 解决你的递归式以得到 *S*(*m*)。'
- en: '***c.*** Use your solution for *S*(*m*) to conclude that *T* (*n*) = Θ(lg *n*
    lg lg *n*).'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 使用你对 *S*(*m*) 的解决方案得出 *T* (*n*) = Θ(lg *n* lg lg *n*)。'
- en: '***d.*** Sketch the recursion tree for recurrence (4.25), and use it to explain
    intuitively why the solution is *T* (*n*) = Θ(lg *n* lg lg *n*).'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 为递归式（4.25）绘制递归树，并用它直观地解释为什么解决方案是 *T* (*n*) = Θ(lg *n* lg lg *n*)。'
- en: 'Solve the following recurrences by changing variables:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 通过改变变量解决以下递归式：
- en: '***e.*** ![art](images/Art_P234.jpg).'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** ![art](images/Art_P234.jpg)。'
- en: '***f.*** ![art](images/Art_P235.jpg).'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '***f.*** ![art](images/Art_P235.jpg)。'
- en: '***4-4     More recurrence examples***'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '***4-4     更多递归例子***'
- en: Give asymptotically tight upper and lower bounds for *T* (*n*) in each of the
    following recurrences. Justify your answers.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 对于以下每个递归式，给出 *T* (*n*) 的渐近紧确上下界。解释你的答案。
- en: '***a.*** *T* (*n*) = 5*T* (*n*/3) + *n* lg *n*.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** *T* (*n*) = 5*T* (*n*/3) + *n* lg *n*。'
- en: '***b.*** *T* (*n*) = 3*T* (*n*/3) + *n*/lg *n*.'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** *T* (*n*) = 3*T* (*n*/3) + *n*/lg *n*。'
- en: '***c.*** ![art](images/Art_P236.jpg).'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** ![art](images/Art_P236.jpg)。'
- en: '***d.*** *T* (*n*) = 2*T* (*n*/2 –2) + *n*/2.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** *T* (*n*) = 2*T* (*n*/2 –2) + *n*/2。'
- en: '***e.*** *T* (*n*) = 2*T* (*n*/2) + *n*/lg *n*.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** *T* (*n*) = 2*T* (*n*/2) + *n*/lg *n*。'
- en: '***f.*** *T* (*n*) = *T* (*n*/2) + *T* (*n*/4) + *T* (*n*/8) + *n*.'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '***f.*** *T* (*n*) = *T* (*n*/2) + *T* (*n*/4) + *T* (*n*/8) + *n*。'
- en: '***g.*** *T* (*n*) = *T* (*n* – 1) + 1/*n*.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '***g.*** *T* (*n*) = *T* (*n* – 1) + 1/*n*。'
- en: '***h.*** *T* (*n*) = *T* (*n* – 1) + lg *n*.'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '***h.*** *T* (*n*) = *T* (*n* – 1) + lg *n*。'
- en: '***i.*** *T* (*n*) = *T* (*n* – 2) + 1/lg *n*.'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '***i.*** *T* (*n*) = *T* (*n* – 2) + 1/lg *n*。'
- en: '***j.*** ![art](images/Art_P237.jpg).'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: '***j.*** ![art](images/Art_P237.jpg)。'
- en: '***4-5     Fibonacci numbers***'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '***4-5     斐波那契数***'
- en: This problem develops properties of the Fibonacci numbers, which are defined
    by recurrence (3.31) on page 69\. We’ll explore the technique of generating functions
    to solve the Fibonacci recurrence. Define the ***generating function*** (or ***formal
    power series***) F as
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题探讨了斐波那契数的性质，它们由第69页的递归式（3.31）定义。我们将探索使用生成函数解决斐波那契递归的技术。将 ***生成函数***（或 ***形式幂级数***）*F*
    定义为
- en: '![art](images/Art_P238.jpg)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P238.jpg)'
- en: where *F[i]* is the *i*th Fibonacci number.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *F[i]* 是第 *i* 个斐波那契数。
- en: '***a.*** Show that F (*z*) = *z* + *z*F (*z*) + *z*²F (*z*).'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 证明 F (*z*) = *z* + *z*F (*z*) + *z*²F (*z*)。'
- en: '***b.*** Show that'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 证明'
- en: '![art](images/Art_P239.jpg)'
  id: totrans-538
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P239.jpg)'
- en: where *ϕ* is the golden ratio, and ![art](images/Art_P240.jpg) is its conjugate
    (see page 69).
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *ϕ* 是黄金比例，而 ![art](images/Art_P240.jpg) 是其共轭（见第69页）。
- en: '***c.*** Show that'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 证明'
- en: '![art](images/Art_P241.jpg)'
  id: totrans-541
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P241.jpg)'
- en: You may use without proof the generating-function version of equation (A.7)
    on page 1142, ![art](images/Art_P242.jpg). Because this equation involves a generating
    function, *x* is a formal variable, not a real-valued variable, so that you don’t
    have to worry about convergence of the summation or about the requirement in equation
    (A.7) that |*x*| < 1, which doesn’t make sense here.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在不证明的情况下使用第1142页方程（A.7）的生成函数版本，![art](images/Art_P242.jpg)。因为这个方程涉及生成函数，*x*
    是一个形式变量，不是一个实值变量，所以你不必担心求和的收敛性或方程（A.7）中要求 |*x*| < 1 的要求，在这里是没有意义的。
- en: '***d.*** Use part (c) to prove that ![art](images/Art_P243.jpg) for *i* > 0,
    rounded to the nearest integer. (*Hint:* Observe that ![art](images/Art_P244.jpg).)'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 使用部分（c）证明对于 *i* > 0，![art](images/Art_P243.jpg) 最接近的整数值。(*提示:* 观察
    ![art](images/Art_P244.jpg)。)'
- en: '***e.*** Prove that *F*[*i*+2] ≥ *ϕ^i* for *i* ≥ 0.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** 证明对于 *i* ≥ 0，*F*[*i*+2] ≥ *ϕ^i*。'
- en: '***4-6     Chip testing***'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: '***4-6     芯片测试***'
- en: 'Professor Diogenes has *n* supposedly identical integrated-circuit chips that
    in principle are capable of testing each other. The professor’s test jig accommodates
    two chips at a time. When the jig is loaded, each chip tests the other and reports
    whether it is good or bad. A good chip always reports accurately whether the other
    chip is good or bad, but the professor cannot trust the answer of a bad chip.
    Thus, the four possible outcomes of a test are as follows:'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: Diogenes 教授有 *n* 个据说相同的集成电路芯片，原则上能够相互测试。教授的测试夹具一次可容纳两个芯片。当夹具加载时，每个芯片都会测试另一个并报告其好坏。一个好的芯片总是准确报告另一个芯片是好还是坏，但教授不能相信一个坏芯片的答案。因此，测试的四种可能结果如下：
- en: '| Chip *A* says | Chip *B* says | Conclusion |'
  id: totrans-547
  prefs: []
  type: TYPE_TB
  zh: '| 芯片 *A* 说 | 芯片 *B* 说 | 结论 |'
- en: '| *B* is good | *A* is good | both are good, or both are bad |'
  id: totrans-548
  prefs: []
  type: TYPE_TB
  zh: '| *B* 是好的 | *A* 是好的 | 两者都好，或者两者都坏 |'
- en: '| *B* is good | *A* is bad | at least one is bad |'
  id: totrans-549
  prefs: []
  type: TYPE_TB
  zh: '| *B* 是好的 | *A* 是坏的 | 至少有一个是坏的 |'
- en: '| *B* is bad | *A* is good | at least one is bad |'
  id: totrans-550
  prefs: []
  type: TYPE_TB
  zh: '| *B* 是坏的 | *A* 是好的 | 至少有一个是坏的 |'
- en: '| *B* is bad | *A* is bad | at least one is bad |'
  id: totrans-551
  prefs: []
  type: TYPE_TB
  zh: '| *B* 是坏的 | *A* 是坏的 | 至少有一个是坏的 |'
- en: '***a.*** Show that if at least *n*/2 chips are bad, the professor cannot necessarily
    determine which chips are good using any strategy based on this kind of pairwise
    test. Assume that the bad chips can conspire to fool the professor.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 证明如果至少有 *n*/2 个芯片是坏的，教授不能通过任何基于这种两两测试的策略确定哪些芯片是好的。假设坏芯片可以合谋欺骗教授。'
- en: Now you will design an algorithm to identify which chips are good and which
    are bad, assuming that more than *n*/2 of the chips are good. First, you will
    determine how to identify one good chip.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你将设计一个算法来识别哪些芯片是好的，哪些是坏的，假设超过 *n*/2 的芯片是好的。首先，你将确定如何识别一个好的芯片。
- en: '***b.*** Show that ⌊*n*/2⌋ pairwise tests are sufficient to reduce the problem
    to one of nearly half the size. That is, show how to use ⌊*n*/2⌋ pairwise tests
    to obtain a set with at most ⌈*n*/2⌉ chips that still has the property that more
    than half of the chips are good.'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 证明 ⌊*n*/2⌋ 次两两测试足以将问题缩小到几乎一半的大小。也就是说，展示如何使用 ⌊*n*/2⌋ 次两两测试获得一个最多有 ⌈*n*/2⌉
    个芯片的集合，其中超过一半的芯片是好的。'
- en: '***c.*** Show how to apply the solution to part (b) recursively to identify
    one good chip. Give and solve the recurrence that describes the number of tests
    needed to identify one good chip.'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 展示如何将部分(b)的解递归应用于识别一个好的芯片。给出并解决描述识别一个好的芯片所需测试次数的递归关系。'
- en: You have now determined how to identify one good chip.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经确定了如何识别一个好的芯片。
- en: '***d.*** Show how to identify all the good chips with an additional Θ(*n*)
    pairwise tests.'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 展示如何通过额外的Θ(*n*)两两测试来识别所有好的芯片。'
- en: '***4-7     Monge arrays***'
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: '***4-7     蒙日数组***'
- en: An *m* × *n* array *A* of real numbers is a ***Monge array*** if for all *i*,
    *j*, *k*, and *l* such that 1 ≤ *i* < *k* ≤ *m* and 1 ≤ *j* < *l* ≤ *n*, we have
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对于所有满足1 ≤ *i* < *k* ≤ *m*和1 ≤ *j* < *l* ≤ *n*的*i*、*j*、*k*和*l*，我们有
- en: '*A*[*i*, *j*] + *A*[*k, l*] ≤ *A*[*i, l*] + *A*[*k*, *j*].'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '*A*[*i*, *j*] + *A*[*k, l*] ≤ *A*[*i, l*] + *A*[*k*, *j*]。'
- en: 'In other words, whenever we pick two rows and two columns of a Monge array
    and consider the four elements at the intersections of the rows and the columns,
    the sum of the upper-left and lower-right elements is less than or equal to the
    sum of the lower-left and upper-right elements. For example, the following array
    is Monge:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，每当我们选择一个蒙日数组的两行和两列，并考虑行和列的交点处的四个元素时，左上角和右下角元素的和小于或等于左下角和右上角元素的和。例如，以下数组是蒙日数组：
- en: '| 10 | 17 | 13 | 28 | 23 |'
  id: totrans-562
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 17 | 13 | 28 | 23 |'
- en: '| 17 | 22 | 16 | 29 | 23 |'
  id: totrans-563
  prefs: []
  type: TYPE_TB
  zh: '| 17 | 22 | 16 | 29 | 23 |'
- en: '| 24 | 28 | 22 | 34 | 24 |'
  id: totrans-564
  prefs: []
  type: TYPE_TB
  zh: '| 24 | 28 | 22 | 34 | 24 |'
- en: '| 11 | 13 | 6 | 17 | 7 |'
  id: totrans-565
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 13 | 6 | 17 | 7 |'
- en: '| 45 | 44 | 32 | 37 | 23 |'
  id: totrans-566
  prefs: []
  type: TYPE_TB
  zh: '| 45 | 44 | 32 | 37 | 23 |'
- en: '| 36 | 33 | 19 | 21 | 6 |'
  id: totrans-567
  prefs: []
  type: TYPE_TB
  zh: '| 36 | 33 | 19 | 21 | 6 |'
- en: '| 75 | 66 | 51 | 53 | 34 |'
  id: totrans-568
  prefs: []
  type: TYPE_TB
  zh: '| 75 | 66 | 51 | 53 | 34 |'
- en: '***a.*** Prove that an array is Monge if and only if for all *i* = 1, 2, …,
    *m* – 1 and *j* = 1, 2, …, *n* – 1, we have'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 证明一个数组是蒙日数组当且仅当对于所有*i* = 1, 2, …, *m* – 1和*j* = 1, 2, …, *n* – 1，我们有'
- en: '*A*[*i*, *j*] + *A*[*i* + 1, *j* + 1] ≤ *A*[*i*, *j* + 1] + *A*[*i* + 1, *j*].'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '*A*[*i*, *j*] + *A*[*i* + 1, *j* + 1] ≤ *A*[*i*, *j* + 1] + *A*[*i* + 1, *j*]。'
- en: (*Hint:* For the “if” part, use induction separately on rows and columns.)
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: （*提示：*对于“如果”部分，分别在行和列上使用归纳法。）
- en: '***b.*** The following array is not Monge. Change one element in order to make
    it Monge. (*Hint:* Use part (a).)'
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 以下数组不是蒙日数组。改变一个元素以使其成为蒙日数组。（*提示：*使用部分(a)。）'
- en: '| 37 | 23 | 22 | 32 |'
  id: totrans-573
  prefs: []
  type: TYPE_TB
  zh: '| 37 | 23 | 22 | 32 |'
- en: '| 21 | 6 | 7 | 10 |'
  id: totrans-574
  prefs: []
  type: TYPE_TB
  zh: '| 21 | 6 | 7 | 10 |'
- en: '| 53 | 34 | 30 | 31 |'
  id: totrans-575
  prefs: []
  type: TYPE_TB
  zh: '| 53 | 34 | 30 | 31 |'
- en: '| 32 | 13 | 9 | 6 |'
  id: totrans-576
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 13 | 9 | 6 |'
- en: '| 43 | 21 | 15 | 8 |'
  id: totrans-577
  prefs: []
  type: TYPE_TB
  zh: '| 43 | 21 | 15 | 8 |'
- en: '***c.*** Let *f* (*i*) be the index of the column containing the leftmost minimum
    element of row *i*. Prove that *f* (1) ≤ *f* (2) ≤ ⋯ ≤ *f* (*m*) for any *m* ×
    *n* Monge array.'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 让*f*(*i*)表示包含第*i*行最左最小元素的列的索引。证明对于任意*m* × *n*蒙日数组，*f*(1) ≤ *f*(2)
    ≤ ⋯ ≤ *f*(*m*)。'
- en: '***d.*** Here is a description of a divide-and-conquer algorithm that computes
    the leftmost minimum element in each row of an *m* × *n* Monge array *A*:'
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 这里描述了一个分治算法，用于计算*m* × *n*蒙日数组*A*中每行的最左最小元素：'
- en: Construct a submatrix *A*^′ of *A* consisting of the even-numbered rows of *A*.
    Recursively determine the leftmost minimum for each row of *A*^′. Then compute
    the leftmost minimum in the odd-numbered rows of *A*.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 构建由*A*的偶数行组成的子矩阵*A*^′。递归确定*A*^′的每行的最左最小值。然后计算*A*的奇数行的最左最小值。
- en: Explain how to compute the leftmost minimum in the odd-numbered rows of *A*
    (given that the leftmost minimum of the even-numbered rows is known) in *O*(*m*
    + *n*) time.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 解释如何在*O*(*m* + *n*)时间内计算*A*的奇数行的最左最小值（假设已知偶数行的最左最小值）。
- en: '***e.*** Write the recurrence for the running time of the algorithm in part
    (d). Show that its solution is *O*(*m* + *n* log *m*).'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** 写出部分(d)算法的运行时间的递归公式。证明其解为*O*(*m* + *n* log *m*)。'
- en: '**Chapter notes**'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节注释**'
- en: Divide-and-conquer as a technique for designing algorithms dates back at least
    to 1962 in an article by Karatsuba and Ofman [[242](bibliography001.xhtml#endnote_242)],
    but it might have been used well before then. According to Heideman, Johnson,
    and Burrus [[211](bibliography001.xhtml#endnote_211)], C. F. Gauss devised the
    first fast Fourier transform algorithm in 1805, and Gauss’s formulation breaks
    the problem into smaller subproblems whose solutions are combined.
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 分治作为一种设计算法的技术可以追溯至至少1962年Karatsuba和Ofman的一篇文章[[242](bibliography001.xhtml#endnote_242)]，但在那之前可能已经被使用。根据Heideman、Johnson和Burrus[[211](bibliography001.xhtml#endnote_211)]的说法，C.
    F. Gauss在1805年设计了第一个快速傅里叶变换算法，而高斯的公式将问题分解为更小的子问题，这些子问题的解决方案被合并。
- en: Strassen’s algorithm [[424](bibliography001.xhtml#endnote_424)] caused much
    excitement when it appeared in 1969\. Before then, few imagined the possibility
    of an algorithm asymptotically faster than the basic MATRIX-MULTIPLY procedure.
    Shortly thereafter, S. Winograd reduced the number of submatrix additions from
    18 to 15 while still using seven submatrix multiplications. This improvement,
    which Winograd apparently never published (and which is frequently miscited in
    the literature), may enhance the practicality of the method, but it does not affect
    its asymptotic performance. Probert [[368](bibliography001.xhtml#endnote_368)]
    described Winograd’s algorithm and showed that with seven multiplications, 15
    additions is the minimum possible.
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: Strassen算法[[424](bibliography001.xhtml#endnote_424)]在1969年出现时引起了很大的兴奋。在那之前，很少有人想象到比基本的矩阵乘法过程更快的算法是可能的。此后不久，S.
    Winograd将子矩阵相加的数量从18减少到15，同时仍然使用七次子矩阵乘法。这一改进，Winograd显然从未发表过（在文献中经常被错误引用），可能会增强该方法的实用性，但不会影响其渐近性能���Probert[[368](bibliography001.xhtml#endnote_368)]描述了Winograd的算法，并表明使用七次乘法，15次加法是可能的最小值。
- en: Strassen’s Θ(*n*^(lg 7)) = *O*(*n*^(2.81)) bound for matrix multiplication held
    until 1987, when Coppersmith and Winograd [[103](bibliography001.xhtml#endnote_103)]
    made a significant advance, improving the bound to *O*(*n*^(2.376)) time with
    a mathematically sophisticated but wildly impractical algorithm based on tensor
    products. It took approximately 25 years before the asymptotic upper bound was
    again improved. In 2012 Vassilevska Williams [[445](bibliography001.xhtml#endnote_445)]
    improved it to *O*(*n*^(2.37287)), and two years later Le Gall [[278](bibliography001.xhtml#endnote_278)]
    achieved *O*(*n*^(2.37286)), both of them using mathematically fascinating but
    impractical algorithms. The best lower bound to date is just the obvious Ω(*n*²)
    bound (obvious because any algorithm for matrix multiplication must fill in the
    *n*² elements of the product matrix).
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: Strassen的Θ(*n*^(lg 7)) = *O*(*n*^(2.81))矩阵乘法上限一直持续到1987年，当时Coppersmith和Winograd
    [[103](bibliography001.xhtml#endnote_103)]取得了重大进展，将上限改进为*O*(*n*^(2.376))时间，这是基于张量积的数学复杂但极不实用的算法。大约25年后，渐渐有人再次改进了渐近上限。2012年，Vassilevska
    Williams [[445](bibliography001.xhtml#endnote_445)]将其改进为*O*(*n*^(2.37287))，两年后Le
    Gall [[278](bibliography001.xhtml#endnote_278)]实现了*O*(*n*^(2.37286))，他们都使用了数学上引人入胜但不切实际的算法。迄今为止，最好的下限只是明显的Ω(*n*²)上限（明显是因为任何矩阵乘法算法都必须填充乘积矩阵的*n*²个元素）。
- en: The performance of MATRIX-MULTIPLY-RECURSIVE can be improved in practice by
    coarsening the leaves of the recursion. It also exhibits better cache behavior
    than MATRIX-MULTIPLY, although MATRIX-MULTIPLY can be improved by “tiling.” Leiserson
    et al. [[293](bibliography001.xhtml#endnote_293)] conducted a performance-engineering
    study of matrix multiplication in which a parallel and vectorized divide-and-conquer
    algorithm achieved the highest performance. Strassen’s algorithm can be practical
    for large dense matrices, although large matrices tend to be sparse, and sparse
    methods can be much faster. When using limited-precision floating-point values,
    Strassen’s algorithm produces larger numerical errors than the Θ(*n*³) algorithms
    do, although Higham [[215](bibliography001.xhtml#endnote_215)] demonstrated that
    Strassen’s algorithm is amply accurate for some applications.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，通过粗化递归的叶子节点可以改善MATRIX-MULTIPLY-RECURSIVE的性能。它还比MATRIX-MULTIPLY表现出更好的缓存行为，尽管MATRIX-MULTIPLY可以通过“瓦片化”来改进。Leiserson等人
    [[293](bibliography001.xhtml#endnote_293)]进行了矩阵乘法的性能工程研究，其中并行和矢量化的分治算法实现了最高性能。Strassen算法对于大型稠密矩阵可能是实用的，尽管大型矩阵往往是稀疏的，而稀疏方法可能更快。当使用有限精度浮点值时，Strassen算法产生的数值误差比Θ(*n*³)算法产生的要大，尽管Higham
    [[215](bibliography001.xhtml#endnote_215)]证明了Strassen算法对某些应用来说是足够准确的。
- en: Recurrences were studied as early as 1202 by Leonardo Bonacci [[66](bibliography001.xhtml#endnote_66)],
    also known as Fibonacci, for whom the Fibonacci numbers are named, although Indian
    mathematicians had discovered Fibonacci numbers centuries before. The French mathematician
    De Moivre [[108](bibliography001.xhtml#endnote_108)] introduced the method of
    generating functions with which he studied Fibonacci numbers (see Problem 4-5).
    Knuth [[259](bibliography001.xhtml#endnote_259)] and Liu [[302](bibliography001.xhtml#endnote_302)]
    are good resources for learning the method of generating functions.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 早在1202年，Leonardo Bonacci [[66](bibliography001.xhtml#endnote_66)]，也被称为斐波那契，就研究了递归，斐波那契数就是以他命名的，尽管印度数学家几个世纪前就已经发现了斐波那契数。法国数学家De
    Moivre [[108](bibliography001.xhtml#endnote_108)]引入了生成函数的方法，用这种方法研究了斐波那契数（见问题4-5）。Knuth
    [[259](bibliography001.xhtml#endnote_259)]和Liu [[302](bibliography001.xhtml#endnote_302)]是学习生成函数方法的好资源。
- en: Aho, Hopcroft, and Ullman [[5](bibliography001.xhtml#endnote_5), [6](bibliography001.xhtml#endnote_6)]
    offered one of the first general methods for solving recurrences arising from
    the analysis of divide-and-conquer algorithms. The master method was adapted from
    Bentley, Haken, and Saxe [[52](bibliography001.xhtml#endnote_52)]. The Akra-Bazzi
    method is due (unsurprisingly) to Akra and Bazzi [[13](bibliography001.xhtml#endnote_13)].
    Divide-and-conquer recurrences have been studied by many researchers, including
    Campbell [[79](bibliography001.xhtml#endnote_79)], Graham, Knuth, and Patashnik
    [[199](bibliography001.xhtml#endnote_199)], Kuszmaul and Leiserson [[274](bibliography001.xhtml#endnote_274)],
    Leighton [[287](bibliography001.xhtml#endnote_287)], Purdom and Brown [[371](bibliography001.xhtml#endnote_371)],
    Roura [[389](bibliography001.xhtml#endnote_389)], Verma [[447](bibliography001.xhtml#endnote_447)],
    and Yap [[462](bibliography001.xhtml#endnote_462)].
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: Aho、Hopcroft和Ullman [[5](bibliography001.xhtml#endnote_5), [6](bibliography001.xhtml#endnote_6)]
    提供了解决分治算法分析中产生的递归的第一种通用方法。主方法是从Bentley、Haken和Saxe [[52](bibliography001.xhtml#endnote_52)]那里改编而来的。Akra-Bazzi方法归功于Akra和Bazzi
    [[13](bibliography001.xhtml#endnote_13)]。分治递归已经被许多研究人员研究过，包括Campbell [[79](bibliography001.xhtml#endnote_79)]、Graham、Knuth和Patashnik
    [[199](bibliography001.xhtml#endnote_199)]、Kuszmaul和Leiserson [[274](bibliography001.xhtml#endnote_274)]、Leighton
    [[287](bibliography001.xhtml#endnote_287)]、Purdom和Brown [[371](bibliography001.xhtml#endnote_371)]、Roura
    [[389](bibliography001.xhtml#endnote_389)]、Verma [[447](bibliography001.xhtml#endnote_447)]和Yap
    [[462](bibliography001.xhtml#endnote_462)]。
- en: The issue of floors and ceilings in divide-and-conquer recurrences, including
    a theorem similar to Theorem 4.5, was studied by Leighton [[287](bibliography001.xhtml#endnote_287)].
    Leighton proposed a version of the polynomial-growth condition. Campbell [[79](bibliography001.xhtml#endnote_79)]
    removed several limitations in Leighton’s statement of it and showed that there
    were polynomially bounded functions that do not satisfy Leighton’s condition.
    Campbell also carefully studied many other technical issues, including the well-definedness
    of divide-and-conquer recurrences. Kuszmaul and Leiserson [[274](bibliography001.xhtml#endnote_274)]
    provided a proof of Theorem 4.5 that does not involve calculus or other higher
    math. Both Campbell and Leighton explored the perturbations of arguments beyond
    simple floors and ceilings.
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 关于分治递归中的向下取整和向上取整的问题，包括类似于定理4.5的定理，已经被Leighton研究过[[287](bibliography001.xhtml#endnote_287)]。Leighton提出了多项式增长条件的一个版本。Campbell[[79](bibliography001.xhtml#endnote_79)]消除了Leighton陈述中的几个限制，并展示了有多项式界限函数不满足Leighton的条件。Campbell还仔细研究了许多其他技术问题，包括分治递归的明确定义性。Kuszmaul和Leiserson[[274](bibliography001.xhtml#endnote_274)]提供了一个不涉及微积分或其他高等数学的定理4.5的证明。Campbell和Leighton都探讨了超出简单向下取整和向上取整的参数扰动。
- en: '[¹](#footnote_ref_1) This terminology does not mean that either *T* (*n*) or
    *f* (*n*) need be continuous, only that the domain of *T* (*n*) is the real numbers,
    as opposed to integers.'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: '[¹](#footnote_ref_1) 这个术语并不意味着*T*(*n*)或*f*(*n*)需要连续，只是*T*(*n*)的定义域是实数，而不是整数。'
