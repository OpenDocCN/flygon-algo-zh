- en: '[***Part VII    Selected Topics***](toc.xhtml#part-7)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[***第七部分    精选主题***](toc.xhtml#part-7)'
- en: '[**Introduction**](toc.xhtml#Rh1-151)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[**介绍**](toc.xhtml#Rh1-151)'
- en: This part contains a selection of algorithmic topics that extend and complement
    earlier material in this book. Some chapters introduce new models of computation
    such as circuits or parallel computers. Others cover specialized domains such
    as matrices or number theory. The last two chapters discuss some of the known
    limitations to the design of efficient algorithms and introduce techniques for
    coping with those limitations.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这部分包含了一些算法主题，扩展和补充了本书中较早的材料。一些章节介绍了新的计算模型，如电路或并行计算机。其他章节涵盖了专业领域，如矩阵或数论。最后两章讨论了设计高效算法的已知限制，并介绍了应对这些限制的技术。
- en: '[Chapter 26](chapter026.xhtml) presents an algorithmic model for parallel computing
    based on task-parallel computing, and more specifically, fork-join parallelism.
    The chapter introduces the basics of the model, showing how to quantify parallelism
    in terms of the measures of work and span. It then investigates several interesting
    fork-join algorithms, including algorithms for matrix multiplication and merge
    sorting.'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[第26章](chapter026.xhtml) 提出了一个基于任务并行计算的并行计算算法模型，更具体地说，是分叉-加入并行性。该章介绍了该模型的基础知识，展示了如何以工作量和跨度的度量来量化并行性。然后研究了几个有趣的分叉-加入算法，包括矩阵乘法和合并排序的算法。'
- en: An algorithm that receives its input over time, rather than having the entire
    input available at the start, is called an “online” algorithm. [Chapter 27](chapter027.xhtml)
    examines techniques used in online algorithms, starting with the “toy” problem
    of how long to wait for an elevator before taking the stairs. It then studies
    the “move-to-front” heuristic for maintaining a linked list and finishes with
    the online version of the caching problem we saw back in [Section 15.4](chapter015.xhtml#Sec_15.4).
    The analyses of these online algorithms are remarkable in that they prove that
    these algorithms, which do not know their future inputs, perform within a constant
    factor of optimal algorithms that know the future inputs.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接收输入的算法随时间推移，而不是在开始时拥有整个输入，被称为“在线”算法。[第27章](chapter027.xhtml) 研究了在线算法中使用的技术，从“玩具”问题开始，即在乘坐电梯前等待多长时间。然后研究了维护链表的“移至前端”启发式方法，并以我们在[第15.4节](chapter015.xhtml#Sec_15.4)中看到的缓存问题的在线版本结束。这些在线算法的分析令人瞩目，因为它们证明了这些算法，它们不知道未来的输入，执行与知道未来输入的最优算法相差一个常数因子。
- en: '[Chapter 28](chapter028.xhtml) studies efficient algorithms for operating on
    matrices. It presents two general methods—LU decomposition and LUP decomposition—for
    solving linear equations by Gaussian elimination in *O*(*n*³) time. It also shows
    that matrix inversion and matrix multiplication can be performed equally fast.
    The chapter concludes by showing how to compute a least-squares approximate solution
    when a set of linear equations has no exact solution.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第28章](chapter028.xhtml) 研究了在矩阵上操作的高效算法。它提出了两种通用方法——LU分解和LUP分解——通过高斯消元法在*O*(*n*³)时间内解线性方程。它还表明矩阵求逆和矩阵乘法可以同样快速地执行。该章最后展示了如何在一组线性方程没有精确解时计算最小二乘近似解。'
- en: '[Chapter 29](chapter029.xhtml) studies how to model problems as linear programs,
    where the goal is to maximize or minimize an objective, given limited resources
    and competing constraints. Linear programming arises in a variety of practical
    application areas. The chapter also addresses the concept of “duality” which,
    by establishing that a maximization problem and minimization problem have the
    same objective value, helps to show that solutions to each are optimal.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '[第29章](chapter029.xhtml) 研究了如何将问题建模为线性规划，目标是在有限资源和竞争约束的情况下最大化或最小化目标。线性规划在各种实际应用领域中出现。该章还涉及“对偶性”的概念，通过建立最大化问题和最小化问题具有相同目标值，有助于表明每个问题的解决方案都是最优的。'
- en: '[Chapter 30](chapter030.xhtml) studies operations on polynomials and shows
    how to use a well-known signal-processing technique—the fast Fourier transform
    (FFT)—to multiply two degree-*n* polynomials in *O*(*n* lg *n*) time. It also
    derives a parallel circuit to compute the FFT.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[第30章](chapter030.xhtml) 研究了多项式的运算，并展示了如何使用一种著名的信号处理技术——快速傅里叶变换（FFT）在*O*(*n*
    lg *n*)时间内相乘两个*n*次多项式。它还推导出一个并行电路来计算FFT。'
- en: '[Chapter 31](chapter031.xhtml) presents number-theoretic algorithms. After
    reviewing elementary number theory, it presents Euclid’s algorithm for computing
    greatest common divisors. Next, it studies algorithms for solving modular linear
    equations and for raising one number to a power modulo another number. Then, it
    explores an important application of number-theoretic algorithms: the RSA public-key
    cryptosystem. This cryptosystem can be used not only to encrypt messages so that
    an adversary cannot read them, but also to provide digital signatures. The chapter
    finishes with the Miller-Rabin randomized primality test, which enables finding
    large primes efficiently—an essential requirement for the RSA system.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[第31章](chapter031.xhtml) 展示了数论算法。在回顾基本数论之后，它介绍了欧几里德算法用于计算最大公约数。接下来，它研究了解决模线性方程和对一个数取模另一个数的幂的算法。然后，它探讨了数论算法的一个重要应用：RSA公钥加密系统。这个加密系统不仅可以用于加密消息，使对手无法��读，还可以提供数字签名。该章以米勒-拉宾随机素性测试结束，该测试能够高效地找到大素数——RSA系统的一个基本要求。'
- en: '[Chapter 32](chapter032.xhtml) studies the problem of finding all occurrences
    of a given pattern string in a given text string, a problem that arises frequently
    in text-editing programs. After examining the naive approach, the chapter presents
    an elegant approach due to Rabin and Karp. Then, after showing an efficient solution
    based on finite automata, the chapter presents the Knuth-Morris-Pratt algorithm,
    which modifies the automaton-based algorithm to save space by cleverly preprocessing
    the pattern. The chapter finishes by studying suffix arrays, which can not only
    find a pattern in a text string, but can do quite a bit more, such as finding
    the longest repeated substring in a text and finding the longest common substring
    appearing in two texts.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[第32章](chapter032.xhtml) 研究了在给定文本字符串中找到给定模式字符串的所有出现的问题，这个问题在文本编辑程序中经常出现。在检查了朴素方法之后，本章介绍了由拉宾和卡普提出的优雅方法。然后，在展示了基于有限自动机的高效解决方案之后，本章介绍了Knuth-Morris-Pratt算法，该算法修改了基于自动机的算法，通过巧妙地预处理模式来节省空间。本章最后研究了后缀数组，它不仅可以在文本字符串中找到模式，还可以做更多的事情，比如在文本中找到最长重复的子字符串，以及在两个文本中找到出现的最长公共子字符串。'
- en: '[Chapter 33](chapter033.xhtml) examines three algorithms within the expansive
    field of machine learning. Machine-learning algorithms are designed to take in
    vast amounts of data, devise hypotheses about patterns in the data, and test these
    hypotheses. The chapter starts with *k*-means clustering, which groups data elements
    into *k* classes based on how similar they are to each other. It then shows how
    to use the technique of multiplicative weights to make predictions accurately
    based on a set of “experts” of varying quality. Perhaps surprisingly, even without
    knowing which experts are reliable and which are not, you can predict almost as
    accurately as the most reliable expert. The chapter finishes with gradient descent,
    an optimization technique that finds a local minimum value for a function. Gradient
    descent has many applications, including finding parameter settings for many machine-learning
    models.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '[第33章](chapter033.xhtml) 探讨了机器学习领域中的三种算法。机器学习算法旨在接收大量数据，提出关于数据模式的假设，并测试这些假设。本章从*k*-means聚类开始，该算法根据数据元素之间的相似性将数据分组为*k*类。然后展示了如何使用乘法权重技术根据一组质量不同的“专家”准确预测。也许令人惊讶的是，即使不知道哪些专家可靠，哪些不可靠，你也可以几乎和最可靠的专家一样准确地预测。本章最后介绍了梯度下降，一种找到函数局部最小值的优化技术。梯度下降有许多应用，包括为许多机器学习模型找到参数设置。'
- en: '[Chapter 34](chapter034.xhtml) concerns NP-complete problems. Many interesting
    computational problems are NP-complete, but no polynomial-time algorithm is known
    for solving any of them. This chapter presents techniques for determining when
    a problem is NP-complete, using them to prove several classic problems NP-complete:
    determining whether a graph has a hamiltonian cycle (a cycle that includes every
    vertex), determining whether a boolean formula is satisfiable (whether there exists
    an assignment of boolean values to its variables that causes the formula to evaluate
    to TRUE), and determining whether a given set of numbers has a subset that adds
    up to a given target value. The chapter also proves that the famous traveling-salesperson
    problem (find a shortest route that starts and ends at the same location and visits
    each of a set of locations once) is NP-complete.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '[第34章](chapter034.xhtml) 关注NP完全问题。许多有趣的计算问题都是NP完全的，但目前尚不知道任何多项式时间算法来解决它们。本章介绍了确定问题是否为NP完全的技术，并使用这些技术证明了几个经典问题是NP完全的：确定图是否有哈密顿循环（包括每个顶点的循环），确定布尔公式是否可满足（是否存在一组布尔值的赋值使得公式求值为TRUE），以及确定给定数字集合是否有一个子集的和等于给定目标值。本章还证明了著名的旅行推销员问题（找到一条从同一位置出发并结束的最短路径，访问每个位置一次）是NP完全的。'
- en: '[Chapter 35](chapter035.xhtml) shows how to find approximate solutions to NP-complete
    problems efficiently by using approximation algorithms. For some NP-complete problems,
    approximate solutions that are near optimal are quite easy to produce, but for
    others even the best approximation algorithms known work progressively more poorly
    as the problem size increases. Then, there are some problems for which investing
    increasing amounts of computation time yields increasingly better approximate
    solutions. This chapter illustrates these possibilities with the vertex-cover
    problem (unweighted and weighted versions), an optimization version of 3-CNF satisfiability,
    the traveling-salesperson problem, the set-covering problem, and the subset-sum
    problem.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[第35章](chapter035.xhtml) 展示了如何通过使用近似算法有效地找到NP完全问题的近似解。对于一些NP完全问题，产生接近最优解的近似解相当容易，但对于其他问题，即使是已知的最佳近似算法随着问题规模的增加而逐渐变得更糟。然后，有一些问题，投入越来越多的计算时间会产生越来越好的近似解。本章通过顶点覆盖问题（无权重和有权重版本）、3-CNF可满足性的优化版本、旅行推销员问题、集合覆盖问题和子集和问题来说明这些可能性。'
