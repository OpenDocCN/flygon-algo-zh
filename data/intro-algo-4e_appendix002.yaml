- en: '[**B Sets, Etc.**](toc.xhtml#app-2)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[**B 集合等**](toc.xhtml#app-2)'
- en: Many chapters of this book touch on the elements of discrete mathematics. This
    appendix reviews the notations, definitions, and elementary properties of sets,
    relations, functions, graphs, and trees. If you are already well versed in this
    material, you can probably just skim this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的许多章节涉及离散数学的要素。本附录回顾了集合、关系、函数、图和树的符号、定义和基本性质。如果您已经熟悉这些材料，您可能只需浏览本章。
- en: '[**B.1 Sets**](toc.xhtml#Rh1-218)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[**B.1 集合**](toc.xhtml#Rh1-218)'
- en: A ***set*** is a collection of distinguishable objects, called its ***members***
    or ***elements***. If an object *x* is a member of a set *S*, we write *x* ∈ *S*
    (read “*x* is a member of *S*” or, more briefly, “*x* belongs to *S*”). If *x*
    is not a member of *S*, we write *x* ∉ *S*. To describe a set explicitly, write
    its members as a list inside braces. For example, to define a set *S* to contain
    precisely the numbers 1, 2, and 3, write *S* = {1, 2, 3}. Since 2 belongs to the
    set *S*, we can write 2 ∈ *S*, and since 4 is not a member, we can write 4 ∉ *S*.
    A set cannot contain the same object more than once,^([1](#footnote_1)) and its
    elements are not ordered. Two sets *A* and *B* are ***equal***, written *A* =
    *B*, if they contain the same elements. For example, {1, 2, 3, 1} = {1, 2, 3}
    = {3, 2, 1}.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一个***集合***是一组可区分的对象，称为其***成员***或***元素***。如果对象 *x* 是集合 *S* 的成员，我们写作 *x* ∈ *S*（读作“*x*
    是 *S* 的成员”或更简洁地说“*x* 属于 *S*”）。如果 *x* 不是 *S* 的成员，我们写作 *x* ∉ *S*。要明确描述一个集合，将其成员写成大括号内的列表。例如，要定义一个包含数字1、2和3的集合
    *S*，写作 *S* = {1, 2, 3}。由于2属于集合 *S*，我们可以写作 2 ∈ *S*，而由于4不是成员，我们可以写作 4 ∉ *S*。一个集合不能包含相同的对象超过一次，^([1](#footnote_1))
    并且其元素没有顺序。两个集合 *A* 和 *B* 是***相等***的，写作 *A* = *B*，如果它们包含相同的元素。例如，{1, 2, 3, 1} =
    {1, 2, 3} = {3, 2, 1}。
- en: 'We adopt special notations for frequently encountered sets:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们采用特殊符号表示经常遇到的集合：
- en: Ø denotes the ***empty set***, that is, the set containing no members.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ø 表示***空集***，即不包含任何成员的集合。
- en: ℤ denotes the set of ***integers***, that is, the set {… −2, −1, 0, 1, 2,…}.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ℤ 表示***整数集***，即集合{… −2, −1, 0, 1, 2,…}。
- en: ℝ denotes the set of ***real numbers***.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ℝ 表示***实数集***。
- en: ℕ denotes the set of ***natural numbers***, that is, the set {0, 1, 2,…}.^([2](#footnote_2))
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ℕ 表示***自然数集***，即集合{0, 1, 2,…}。^([2](#footnote_2))
- en: 'If all the elements of a set *A* are contained in a set *B*, that is, if *x*
    ∈ *A* implies *x* ∈ *B*, then we write *A* ⊆ *B* and say that *A* is a ***subset***
    of *B*. A set *A* is a ***proper subset*** of set *B*, written *A* ⊂ *B*, if *A*
    ⊆ *B* but *A* ≠ *B*. (Some authors use the symbol “⊂” to denote the ordinary subset
    relation, rather than the proper-subset relation.) Every set is a subset of itself:
    *A* ⊆ *A* for any set *A*. For two sets *A* and *B*, we have *A* = *B* if and
    only if *A* ⊆ *B* and *B* ⊆ *A*. The subset relation is transitive (see page 1159):
    for any three sets *A*, *B*, and *C*, if *A* ⊆ *B* and *B* ⊆ *C*, then *A* ⊆ *C*.
    The proper-subset relation is transitive as well. The empty set is a subset of
    all sets: for any set *A*, we have Ø ⊆ *A*.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果集合 *A* 的所有元素都包含在集合 *B* 中，即 *x* ∈ *A* 意味着 *x* ∈ *B*，那么我们写作 *A* ⊆ *B* 并说 *A*
    是 *B* 的***子集***。如果集合 *A* 是集合 *B* 的***真子集***，写作 *A* ⊂ *B*，如果 *A* ⊆ *B* 但 *A* ≠
    *B*。（一些作者使用符号“⊂”来表示普通的子集关系，而不是真子集关系。）每个集合都是其自身的子集：对于任何集合 *A*，都有 *A* ⊆ *A*。对于两个集合
    *A* 和 *B*，当且仅当 *A* ⊆ *B* 且 *B* ⊆ *A* 时，我们有 *A* = *B*。子集关系是传递的（见第1159页）：对于任意三个集合
    *A*、*B* 和 *C*，如果 *A* ⊆ *B* 且 *B* ⊆ *C*，那么 *A* ⊆ *C*。真子集关系也是传递的。空集是所有集合的子集：对于任何集合
    *A*，我们有 Ø ⊆ *A*。
- en: 'Sets can be specified in terms of other sets. Given a set *A*, a set *B* ⊆
    *A* can be defined by stating a property that distinguishes the elements of *B*.
    For example, one way to define the set of even integers is {*x* : *x* ∈ ℤ and
    *x*/2 is an integer}. The colon in this notation is read “such that.” (Some authors
    use a vertical bar in place of the colon.)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 集合可以根据其他集合来指定。给定一个集合 *A*，可以通过陈述区分 *B* 的元素的属性来定义一个 *B* ⊆ *A* 的集合。例如，定义偶数集合的一种方式是{*x*：*x*
    ∈ ℤ 且 *x*/2 是整数}。这种表示法中的冒号读作“这样”。（一些作者在冒号的位置使用竖线。）
- en: 'Given two sets *A* and *B*, ***set operations*** define new sets:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个集合 *A* 和 *B*，***集合运算***定义了新的集合：
- en: The ***intersection*** of sets *A* and *B* is the set
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合 *A* 和 *B* 的***交集***是集合
- en: '*A* ∩ *B* = {*x* : *x* ∈ *A* and *x* ∈ *B*}.'
  id: totrans-13
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*A* ∩ *B* = {*x*：*x* ∈ *A* 且 *x* ∈ *B*}。'
- en: The ***union*** of sets *A* and *B* is the set
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集合 *A* 和 *B* 的***并集***是集合
- en: '*A* ∪ *B* = {*x* : *x* ∈ *A* or *x* ∈ *B*}.'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*A* ∪ *B* = {*x*：*x* ∈ *A* 或 *x* ∈ *B*}。'
- en: The ***difference*** between two sets *A* and *B* is the set
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个集合 *A* 和 *B* 的***差集***是集合
- en: '*A* − *B* = {*x* : *x* ∈ *A* and *x* ∉ *B*}.'
  id: totrans-17
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*A* − *B* = {*x*：*x* ∈ *A* 且 *x* ∉ *B*}。'
- en: 'Set operations obey the following laws:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 集合运算遵循以下规律：
- en: '**Empty set laws:**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**空集律：**'
- en: '| *A* ∩ Ø | = | Ø, |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| *A* ∩ Ø | = | Ø, |'
- en: '| *A* ∪ Ø | = | *A.* |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| *A* ∪ Ø | = | *A.* |'
- en: '**Idempotency laws:**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**幂等律：**'
- en: '| *A* ∩ *A* | = | *A*, |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| *A* ∩ *A* | = | *A*, |'
- en: '| *A* ∪ *A* | = | *A.* |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| *A* ∪ *A* | = | *A.* |'
- en: '**Commutative laws:**'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**交换律：**'
- en: '| *A* ∩ *B* | = | *B* ∩ *A*, |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| *A* ∩ *B* | = | *B* ∩ *A*, |'
- en: '| *A* ∪ *B* | = | *B* ∪ *A*. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| *A* ∪ *B* | = | *B* ∪ *A*. |'
- en: '![art](images/Art_P1613.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1613.jpg)'
- en: '**Figure B.1** A Venn diagram illustrating the first of DeMorgan’s laws (B.2).
    Each of the sets *A*, *B*, and *C* is represented as a circle.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 B.1** 用维恩图说明了德摩根定律的第一个定律（B.2）。每个集合 *A*、*B* 和 *C* 都表示为一个圆。'
- en: '**Associative laws:**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**结合律：**'
- en: '| *A* ∩ (*B* ∩ *C*) | = | (*A* ∩ *B*) ∩ *C*, |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| *A* ∩ (*B* ∩ *C*) | = | (*A* ∩ *B*) ∩ *C*, |'
- en: '| *A* ∪ (*B* ∪ *C*) | = | (*A* ∪ *B*) ∪ *C.* |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| *A* ∪ (*B* ∪ *C*) | = | (*A* ∪ *B*) ∪ *C.* |'
- en: '**Distributive laws:**'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**分配律：**'
- en: '![art](images/Art_P1614.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1614.jpg)'
- en: '**Absorption laws:**'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**吸收律：**'
- en: '| *A* ∩ (*A* ∪ *B*) | = | *A*, |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| *A* ∩ (*A* ∪ *B*) | = | *A*, |'
- en: '| *A* ∪ (*A* ∩ *B*) | = | *A.* |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| *A* ∪ (*A* ∩ *B*) | = | *A.* |'
- en: '**DeMorgan’s laws:**'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**德摩根定律：**'
- en: '![art](images/Art_P1615.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1615.jpg)'
- en: '[Figure B.1](#Fig_B-1) illustrates the first of DeMorgan’s laws, using a ***Venn
    diagram***: a graphical picture in which sets are represented as regions of the
    plane.'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 B.1](#Fig_B-1) 用***维恩图***说明了德摩根定律的第一个定律：一个将集合表示为平面区域的图形图。'
- en: 'Often, all the sets under consideration are subsets of some larger set *U*
    called the ***universe***. For example, when considering various sets made up
    only of integers, the set ℤ of integers is an appropriate universe. Given a universe
    *U*, we define the ***complement*** of a set *A* as *Ā* = *U* − *A* = {*x* : *x*
    ∈ *U* and *x* ∉ *A*}. For any set *A* ⊆ *U*, we have the following laws:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '通常，所有考虑的集合都是某个称为***宇宙***的更大集合的子集。例如，当考虑仅由整数组成的各种集合时，整数集ℤ是一个合适的宇宙。给定一个宇宙*U*，我们将集合*A*的***补集***定义为*Ā*
    = *U* − *A* = {*x* : *x* ∈ *U*且*x* ∉ *A*}。对于任何*A* ⊆ *U*的集合，我们有以下定律：'
- en: '| ![art](images/Art_P1616.jpg) | = | *A*, |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| ![艺术](images/Art_P1616.jpg) | = | *A*, |'
- en: '| *A* ∩ *Ā* | = | Ø, |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| *A* ∩ *Ā* | = | Ø, |'
- en: '| *A* ∪ *Ā* | = | *U*. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| *A* ∪ *Ā* | = | *U*. |'
- en: An equivalent way to express DeMorgan’s laws (B.2) uses set complements. For
    any two sets *B, C* ⊆ *U*, we have
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 表达德摩根定律（B.2）的一个等价方式使用集合的补集。对于任意两个集合*B, C* ⊆ *U*，我们有
- en: '| *B* ∩ *C* | = | *B* ∪ *C*, |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| *B* ∩ *C* | = | *B* ∪ *C*, |'
- en: '| *B* ∪ *C* | = | *B* ∩ *C*. |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| *B* ∪ *C* | = | *B* ∩ *C*. |'
- en: Two sets *A* and *B* are ***disjoint*** if they have no elements in common,
    that is, if *A* ∩ *B* = Ø. A ***collection*** of sets *S*[1], *S*[2], … , either
    finite or infinite, is a set of sets, in which each member is a set *S[i]*. A
    collection S = {*S[i]*} of nonempty sets forms a ***partition*** of a set *S*
    if
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合*A*和*B*是***不相交***的，即如果*A* ∩ *B* = Ø，则它们没有共同元素。一组集合*S*[1]，*S*[2]，…，无论是有限的还是无限的，都是一组集合的集合，其中每个成员都是一个集合*S[i]*。如果*S*
    = {*S[i]*}是一组非空集合，则当
- en: the sets are ***pairwise disjoint***, that is, *S[i]*, *S[j]* ∈ S and *i* ≠
    *j* imply *S[i]* ∩ *S[j]* = Ø,
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些集合是***两两不相交***的，即*S[i]*，*S[j]* ∈ S且*i* ≠ *j*意味着*S[i]* ∩ *S[j]* = Ø，
- en: their union is *S*, that is,
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们的并集是*S*，即
- en: '![art](images/Art_P1617.jpg)'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1617.jpg)'
- en: In other words, S forms a partition of *S* if each element of *S* appears in
    exactly one set *S[i]* ∈ S.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，如果每个*S*的元素都只出现在*S[i]* ∈ S中的一个集合中，则*S*形成*S*的一个分区。
- en: The number of elements in a set is the ***cardinality*** (or ***size***) of
    the set, denoted |*S*|. Two sets have the same cardinality if their elements can
    be put into a one-to-one correspondence. The cardinality of the empty set is |Ø|
    = 0\. If the cardinality of a set is a natural number, the set is ***finite***,
    and otherwise, it is ***infinite***. An infinite set that can be put into a one-to-one
    correspondence with the natural numbers ℕ is ***countably infinite***, and otherwise,
    it is ***uncountable***. For example, the integers ℤ are countable, but the reals
    ℝ are uncountable.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一个集合中的元素数量称为集合的***基数***（或***大小***），表示为|*S*|。如果两个集合的元素可以一一对应，则它们具有相同的基数。空集的基数是|Ø|
    = 0。如果集合的基数是自然数，则集合是***有限的***，否则是***无限的***。一个可以与自然数ℕ一一对应的无限集被称为***可数无限的***，否则是***不可数的***。例如，整数集ℤ是可数的，但实数集ℝ是不可数的。
- en: For any two finite sets *A* and *B*, we have the identity
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意两个有限集合*A*和*B*，我们有等式
- en: '![art](images/Art_P1618.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1618.jpg)'
- en: from which we can conclude that
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由此我们可以得出结论
- en: '|*A* ∪ *B*| ≤ |*A*| + |*B*|.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '|*A* ∪ *B*| ≤ |*A*| + |*B*|.'
- en: If *A* and *B* are disjoint, then |*A* ∩ *B*| = 0 and thus |*A* ∪ *B*| = |*A*|
    + |*B*|. If *A* ⊆ *B*, then |*A*| ≤ |*B*|.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*A*和*B*是不相交的，则|*A* ∩ *B*| = 0，因此|*A* ∪ *B*| = |*A*| + |*B*|。如果*A* ⊆ *B*，则|*A*|
    ≤ |*B*|。
- en: A finite set of *n* elements is sometimes called an ***n-set***. A 1-set is
    called a ***singleton***. A subset of *k* elements of a set is sometimes called
    a ***k-subset***.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有*n*个元素的有限集有时被称为***n-集***。一个1-集被称为***单例集***。一个集合的*k*个元素的子集有时被称为***k-子集***。
- en: We denote the set of all subsets of a set *S*, including the empty set and *S*
    itself, by 2^(*S*), called the ***power set*** of *S*. For example, 2^({*a*,*b*})
    = {Ø, {*a*}, {*b*}, {*a, b*}}. The power set of a finite set *S* has cardinality
    2^(|*S*|) (see Exercise B.1-5).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用2^(*S*)表示一个集合*S*的所有子集，包括空集和*S*本身，称为*S*的***幂集***。例如，2^({*a*,*b*}) = {Ø, {*a*},
    {*b*}, {*a, b*}}。有限集合*S*的幂集的基数为2^(|*S*|)（见练习B.1-5）。
- en: We sometimes care about setlike structures in which the elements are ordered.
    An ***ordered pair*** of two elements *a* and *b* is denoted (*a*, *b*) and is
    defined formally as the set (*a*, *b*) = {*a,* {*a, b*}}. Thus, the ordered pair
    (*a*, *b*) is *not* the same as the ordered pair (*b*, *a*).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有时我们关心元素有序的类似集合。两个元素*a*和*b*的***有序对***表示为(*a*, *b*)，并且正式定义为集合(*a*, *b*) = {*a,*
    {*a, b*}}。因此，有序对(*a*, *b*)与有序对(*b*, *a*)不同。
- en: The ***Cartesian product*** of two sets *A* and *B*, denoted *A* × *B*, is the
    set of all ordered pairs such that the first element of the pair is an element
    of *A* and the second is an element of *B*. More formally,
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合*A*和*B*的***笛卡尔积***，表示为*A* × *B*，是所有有序对的集合，使得对的第一个元素是*A*的元素，第二个元素是*B*的元素。更正式地说，
- en: '*A* × *B* = {(*a*, *b*) : *a* ∈ *A* and *b* ∈ *B*}.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*A* × *B* = {(*a*, *b*) : *a* ∈ *A* and *b* ∈ *B*}.'
- en: For example, {*a, b*}×{*a, b, c*} = {(*a*, *a*), (*a, b*), (*a, c*), (*b, a*),
    (*b, b*), (*b, c*)}. When *A* and *B* are finite sets, the cardinality of their
    Cartesian product is
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，{*a, b*}×{*a, b, c*} = {(*a*, *a*), (*a, b*), (*a, c*), (*b, a*), (*b, b*),
    (*b, c*)}。当*A*和*B*是有限集合时，它们的笛卡尔积的基数是
- en: '![art](images/Art_P1619.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1619.jpg)'
- en: The Cartesian product of *n* sets *A*[1], *A*[2], … , *A[n]* is the set of ***n-tuples***
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*个集合*A*[1]，*A*[2]，…，*A[n]*的笛卡尔积是***n-元组***的集合'
- en: '*A*[1] × *A*[2] × … × *A[n]* = {(*a*[1], *a*[2], … , *a[n]*) : *a[i]* ∈ *A[i]*
    for *i* = 1, 2, … , *n*},'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*A*[1] × *A*[2] × … × *A[n]* = {(*a*[1], *a*[2], … , *a[n]*) : *a[i]* ∈ *A[i]*
    for *i* = 1, 2, … , *n*},'
- en: whose cardinality is
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 其基数为
- en: '|*A*[1] × *A*[2] × … × *A[n]*| = |*A*[1]| · |*A*[2]| · |*A[n]*|'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '|*A*[1] × *A*[2] × … × *A[n]*| = |*A*[1]| · |*A*[2]| · |*A[n]*|'
- en: if all sets *A[i]* are finite. We denote an *n*-fold Cartesian product over
    a single set *A* by the set
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有集合*A[i]*都是有限的。我们用集合来表示单个集合*A*上的*n*重笛卡尔积
- en: '![art](images/Art_P1620.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1620.jpg)'
- en: whose cardinality is |*A^n*| = |*A*|*^n* if *A* is finite. We can also view
    an *n*-tuple as a finite sequence of length *n* (see page 1162).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*A*是有限的，则其基数为|*A^n*| = |*A*|*^n*。我们也可以将*n*-元组视为长度为*n*的有限序列（见第1162页）。
- en: 'Intervals are continuous sets of real numbers. We denote them with parentheses
    and/or brackets. Given real numbers *a* and *b*, the ***closed interval*** [*a,
    b*] is the set {*x* ∈ ℝ : *a* ≤ *x* ≤ *b*} of reals between *a* and *b*, including
    both *a* and *b*. (If *a* > *b*, this definition implies that [*a, b*] = Ø.) The
    ***open interval*** (*a*, *b*) = {*x* ∈ ℝ : *a* < *x* < *b*} omits both of the
    endpoints from the set. There are two ***half-open intervals*** [*a, b*) = {*x*
    ∈ ℝ : *a* ≤ *x* < *b*} and (*a*, *b*] = {*x* ∈ ℝ : *a* < *x* ≤ *b*}, each of which
    excludes one endpoint.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 区间是实数的连续集合。我们用括号和/或方括号表示它们。给定实数*a*和*b*，***闭区间***[*a, b*]是集合{*x* ∈ ℝ：*a* ≤ *x*
    ≤ *b*}，包括*a*和*b*之间的所有实数（如果*a* > *b*，这个定义意味着[*a, b*] = Ø）。***开区间***(*a*, *b*) =
    {*x* ∈ ℝ：*a* < *x* < *b*}排除了集合中的两个端点。有两个***半开区间***[*a, b*) = {*x* ∈ ℝ：*a* ≤ *x*
    < *b*}和(*a*, *b*] = {*x* ∈ ℝ：*a* < *x* ≤ *b*}，每个都排除一个端点。
- en: Intervals can also be defined on the integers by replacing ℝ in the these definitions
    by ℤ. Whether the interval is defined over the reals or integers can usually be
    inferred from context.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 区间也可以通过用ℤ替换这些定义中的ℝ来定义整数。区间是在实数或整数上定义的，通常可以从上下文中推断出来。
- en: '**Exercises**'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***B.1-1***'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.1-1***'
- en: Draw Venn diagrams that illustrate the first of the distributive laws (B.1).
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制说明第一个分配律（B.1）的维恩图。
- en: '***B.1-2***'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.1-2***'
- en: 'Prove the generalization of DeMorgan’s laws to any finite collection of sets:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 证明DeMorgan定律对任意有限集合的一般化：
- en: '| *A*[1] ∩ *A*[2] ∩ … ∩ *A[n]* | = | *A*[1] ∪ *A*[2] ∪ … ∪ *A[*n*]*, |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| *A*[1] ∩ *A*[2] ∩ … ∩ *A[n]* | = | *A*[1] ∪ *A*[2] ∪ … ∪ *A[*n*]*, |'
- en: '| *A*[1] ∪ *A*[2] ∪ … ∪ *A[n]* | = | *A*[1] ∩ *A*[2] ∩ … ∩ *A[*n*].* |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| *A*[1] ∪ *A*[2] ∪ … ∪ *A[n]* | = | *A*[1] ∩ *A*[2] ∩ … ∩ *A[*n*].* |'
- en: ★ ***B.1-3***
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***B.1-3***
- en: 'Prove the generalization of equation (B.3), which is called the ***principle
    of inclusion and exclusion***:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 证明方程（B.3）的一般化，这被称为***包含与排斥原理***：
- en: '| &#124;*A*[1] ∪ *A*[2] ∪ … ∪ *A[n]*&#124; = |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| &#124;*A*[1] ∪ *A*[2] ∪ … ∪ *A[n]*&#124; = |'
- en: '|  | &#124;*A*[1]&#124; + &#124;*A*[2]&#124; + … + &#124;*A[n]*&#124; |  |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|  | &#124;*A*[1]&#124; + &#124;*A*[2]&#124; + … + &#124;*A[n]*&#124; |  |'
- en: '|  | − &#124;*A*[1] ∩ *A*[2]&#124; − &#124;*A*[1] ∩ *A*[3]&#124; − … | (all
    pairs) |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|  | − &#124;*A*[1] ∩ *A*[2]&#124; − &#124;*A*[1] ∩ *A*[3]&#124; − … | （所有对）
    |'
- en: '|  | + &#124;*A*[1] ∩ *A*[2] ∩ *A*[3]&#124; + … | (all triples) |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '|  | + &#124;*A*[1] ∩ *A*[2] ∩ *A*[3]&#124; + … | （所有三元组） |'
- en: '|  | ⋮ |  |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '|  | ⋮ |  |'
- en: '|  | + (−1)^(*n*−1) &#124;*A*[1] ∩ *A*[2] ∩ … ∩ *A[n]*&#124;. |  |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '|  | + (−1)^(*n*−1) &#124;*A*[1] ∩ *A*[2] ∩ … ∩ *A[n]*&#124;. |  |'
- en: '***B.1-4***'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.1-4***'
- en: Show that the set of odd natural numbers is countable.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 展示奇自然数集是可数的。
- en: '***B.1-5***'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.1-5***'
- en: Show that for any finite set *S*, the power set 2^(*S*) has 2^(|*S*|) elements
    (that is, there are 2^(|*S*|) distinct subsets of *S*).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 展示对于任意有限集合*S*，幂集2^(*S*)有2^(|*S*|)个元素（即，*S*的子集有2^(|*S|)个不同的子集）。
- en: '***B.1-6***'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.1-6***'
- en: Give an inductive definition for an *n*-tuple by extending the set-theoretic
    definition for an ordered pair.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过扩展有序对的集合论定义，为*n*-元组给出归纳定义。
- en: '[**B.2 Relations**](toc.xhtml#Rh1-219)'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '[**B.2 关系**](toc.xhtml#Rh1-219)'
- en: 'A ***binary relation*** *R* on two sets *A* and *B* is a subset of the Cartesian
    product *A*×*B*. If (*a*, *b*) ∈ *R*, we sometimes write *a R b*. When we say
    that *R* is a binary relation on a set *A*, we mean that *R* is a subset of *A*
    × *A*. For example, the “less than” relation on the natural numbers is the set
    {(*a*, *b*) : *a, b* ∈ ℕ and *a* < *b*}. An *n*-ary relation on sets *A*[1], *A*[2],
    … , *A[n]* is a subset of *A*[1] × *A*[2] × … × *A[n]*.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 两个集合*A*和*B*上的***二元关系*** *R* 是集合*A*×*B*的子集。如果(*a*, *b*) ∈ *R*，我们有时写作*a R b*。当我们说*R*是集合*A*上的二元关系时，我们指的是*R*是*A*
    × *A*的子集。例如，自然数上的“小于”关系是集合{(*a*, *b*)：*a, b* ∈ ℕ且*a* < *b*}。对于��合*A*[1]，*A*[2]，…，*A[n]*的*n*元关系是集合*A*[1]
    × *A*[2] × … × *A[n]*的子集。
- en: A binary relation *R* ⊆ *A* × *A* is ***reflexive*** if
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 二元关系 *R* ⊆ *A* × *A* 如果是***自反的***，则
- en: '*a R a*'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*a R a*'
- en: for all *a* ∈ *A*. For example, “=” and “≤” are reflexive relations on ℕ, but
    “<” is not. The relation *R* is ***symmetric*** if
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有*a* ∈ *A*。例如，“=”和“≤”是自然数上的自反关系，但“<”不是。关系*R*是***对称的***，如果
- en: '*a R b* implies *b R a*'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*a R b* 意味着 *b R a*'
- en: for all *a, b* ∈ *A*. For example, “=” is symmetric, but “<” and “≤” are not.
    The relation *R* is ***transitive*** if
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有*a, b* ∈ *A*。例如，“=”是对称的，但“<”和“≤”不是。关系*R*是***传递的***，如果
- en: '*a R b* and *b R c* imply *a R c*'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '*a R b* 和 *b R c* 意味着 *a R c*'
- en: 'for all *a, b, c* ∈ *A*. For example, the relations “<,” “≤,” and “=” are transitive,
    but the relation *R* = {(*a*, *b*) : *a, b* ∈ ℕ and *a* = *b* − 1} is not, since
    3 *R* 4 and 4 *R* 5 do not imply 3 *R* 5.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有*a, b, c* ∈ *A*。例如，“<”，“≤”和“=”是传递的，但关系*R* = {(*a*, *b*)：*a, b* ∈ ℕ且*a* =
    *b* − 1}不是，因为3 *R* 4和4 *R* 5并不意味着3 *R* 5。
- en: 'A relation that is reflexive, symmetric, and transitive is an ***equivalence
    relation***. For example, “=” is an equivalence relation on the natural numbers,
    but “<” is not. If *R* is an equivalence relation on a set *A*, then for *a* ∈
    *A*, the ***equivalence class*** of *a* is the set [*a*] = {*b* ∈ *A* : *a R b*},
    that is, the set of all elements equivalent to *a*. For example, if we define
    *R* = {(*a*, *b*) : *a, b* ∈ ℕ and *a* + *b* is an even number}, then *R* is an
    equivalence relation, since *a* + *a* is even (reflexive), *a* + *b* is even implies
    *b* + *a* is even (symmetric), and *a* + *b* is even and *b* + *c* is even imply
    *a* + *c* is even (transitive). The equivalence class of 4 is [4] = {0, 2, 4,
    6,…}, and the equivalence class of 3 is [3] = {1, 3, 5, 7,…}. A basic theorem
    of equivalence classes is the following.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个自反、对称和传递的关系是一个***等价关系***。例如，“=”是自然数上的等价关系，但“<”不是。如果*R*是集合*A*上的等价关系，那么对于*a*
    ∈ *A*，*a*的***等价类***是集合[*a*] = {*b* ∈ *A*：*a R b*}，即所有等价于*a*的元素的集合。例如，如果我们定义*R*
    = {(*a*, *b*)：*a, b* ∈ ℕ且*a* + *b*是偶数}，那么*R*是一个等价关系，因为*a* + *a*是偶数（自反），*a* + *b*是偶数意味着*b*
    + *a*是偶数（对称），*a* + *b*是偶数且*b* + *c*是偶数意味着*a* + *c*是偶数（传递）。4的等价类是[4] = {0, 2, 4,
    6,…}，3的等价类是[3] = {1, 3, 5, 7,…}。等价类的一个基本定理如下。
- en: '***Theorem B.1 (An equivalence relation is the same as a partition)***'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 B.1（等价关系等同于划分）***'
- en: The equivalence classes of any equivalence relation *R* on a set *A* form a
    partition of *A*, and any partition of *A* determines an equivalence relation
    on *A* for which the sets in the partition are the equivalence classes.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 集合*A*上的任何等价关系*R*的等价类形成了*A*的一个划分，并且*A*的任何划分确定了一个等价关系*R*，其中划分中的集合是等价类。
- en: '***Proof***   For the first part of the proof, we must show that the equivalence
    classes of *R* are nonempty, pairwise-disjoint sets whose union is *A*. Because
    *R* is reflexive, *a* ∈ [*a*], and so the equivalence classes are nonempty. Moreover,
    since every element *a* ∈ *A* belongs to the equivalence class [*a*], the union
    of the equivalence classes is *A*. It remains to show that the equivalence classes
    are pairwise disjoint, that is, if two equivalence classes [*a*] and [*b*] have
    an element *c* in common, then they are in fact the same set. Suppose that *a
    R c* and *b R c*. Symmetry gives that *c R b* and, by transitivity, *a R b*. Thus,
    we have *x R a* for any arbitrary element *x* ∈ [*a*] and, by transitivity, *x
    R b*, and thus [*a*] ⊆ [*b*]. Similarly, [*b*] ⊆ [*a*], and thus [*a*] = [*b*].'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   证明的第一部分，我们必须证明*R*的等价类是非空的、两两不相交的集合，它们的并集是*A*。因为*R*是自反的，*a* ∈ [*a*]，所以等价类是非空的。此外，因为每个元素*a*
    ∈ *A*属于等价类[*a*]，等价类的并集是*A*。剩下的是要证明等价类是两两不相交的，即如果两个等价类[*a*]和[*b*]有一个共同元素*c*，那么它们实际上是相同的集合。假设*a
    R c*和*b R c*。对称性给出*c R b*，通过传递性，*a R b*。因此，对于任意任意元素*x* ∈ [*a*]，我们有*x R a*，通过传递性，*x
    R b*，因此[*a*] ⊆ [*b*]。类似地，[*b*] ⊆ [*a*]，因此[*a*] = [*b*]。'
- en: 'For the second part of the proof, let A = {*A[i]*} be a partition of *A*, and
    define *R* = {(*a*, *b*) : there exists *i* such that *a* ∈ *A[i]* and *b* ∈ *A[i]*}.
    We claim that *R* is an equivalence relation on *A*. Reflexivity holds, since
    *a* ∈ *A[i]* implies *a R a*. Symmetry holds, because if *a R b*, then *a* and
    *b* belong to the same set *A[i]*, and hence *b R a*. If *a R b* and *b R c*,
    then all three elements are in the same set *A[i]*, and thus *a R c* and transitivity
    holds. To see that the sets in the partition are the equivalence classes of *R*,
    observe that if *a* ∈ *A[i]*, then *x* ∈ [*a*] implies *x* ∈ *A[i]*, and *x* ∈
    *A[i]* implies *x* ∈ [*a*].'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 证明的第二部分，令A = {*A[i]*}为*A*的一个划分，并定义*R* = {(*a*, *b*)：存在*i*使得*a* ∈ *A[i]*且*b*
    ∈ *A[i]*}。我们声称*R*是*A*上的一个等价关系。自反性成立，因为*a* ∈ *A[i]*意味着*a R a*。对称性成立，因为如果*a R b*，那么*a*和*b*属于同一集合*A[i]*，因此*b
    R a*。如果*a R b*和*b R c*，那么所有三个元素都在同一集合*A[i]*中，因此*a R c*，传递性成立。要看到划分中的集合��*R*的等价类，观察如果*a*
    ∈ *A[i]*，那么*x* ∈ [*a*]意味着*x* ∈ *A[i]*，而*x* ∈ *A[i]*意味着*x* ∈ [*a*]。
- en: ▪
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: A binary relation *R* on a set *A* is ***antisymmetric*** if
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 集合*A*上的二元关系*R*如果***反对称***，则为反对称关系。
- en: '*a R b* and *b R a* imply *a* = *b*.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '*a R b*和*b R a*意味着*a* = *b*。'
- en: For example, the “≤” relation on the natural numbers is antisymmetric, since
    *a* ≤ *b* and *b* ≤ *a* imply *a* = *b*. A relation that is reflexive, antisymmetric,
    and transitive is a ***partial order***, and we call a set on which a partial
    order is defined a ***partially ordered set***. For example, the relation “is
    a descendant of” is a partial order on the set of all people (if we view individuals
    as being their own descendants).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，自然数上的“≤”关系是反对称的，因为*a* ≤ *b*和*b* ≤ *a*意味着*a* = *b*。一个既是自反又是反对称和传递的关系是***偏序***，我们称定义了偏序的集合为***部分有序集***。例如，“是某人的后代”关系是所有人集合上的偏序（如果我们将个体视为自己的后代）。
- en: In a partially ordered set *A*, there may be no single “maximum” element *a*
    such that *b R a* for all *b* ∈ *A*. Instead, the set may contain several ***maximal***
    elements *a* such that for no *b* ∈ *A*, where *b* ≠ *a*, is it the case that
    *a R b*. For example, a collection of different-sized boxes may contain several
    maximal boxes that don’t fit inside any other box, yet it has no single “maximum”
    box into which any other box will fit.^([3](#footnote_3))
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在部分有序集合*A*中，可能没有单个“最大”元素*a*，使得对于所有*b* ∈ *A*，都有*b R a*。相反，集合可能包含几个***极大***元素*a*，使得对于没有*b*
    ∈ *A*，其中*b* ≠ *a*，都不满足*a R b*。例如，不同大小的盒子集合可能包含几个最大的盒子，这些盒子无法放入任何其他盒子中，但没有单个“最大”盒子可以容纳任何其他盒子。^([3](#footnote_3))
- en: A relation *R* on a set *A* is a ***total relation*** if for all *a, b* ∈ *A*,
    we have *a R b* or *b R a* (or both), that is, if every pairing of elements of
    *A* is related by *R*. A partial order that is also a total relation is a ***total
    order*** or ***linear order***. For example, the relation “≤” is a total order
    on the natural numbers, but the “is a descendant of” relation is not a total order
    on the set of all people, since there are individuals neither of whom is descended
    from the other. A total relation that is transitive, but not necessarily either
    symmetric or antisymmetric, is a ***total preorder***.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 集合*A*上的关系*R*如果对于所有*a, b* ∈ *A*，我们有*a R b*或*b R a*（或两者都有），即*A*中的每对元素都由*R*相关联，则为***全关系***。既是偏序又是全关系的关系为***全序***或***线性序***。例如，“≤”关系是自然数上的全序，但“是某人的后代”关系不是所有人集合上的全序，因为有些个体彼此之间没有后代关系。一个传递的全关系，但不一定对称或反对称的关系为***全预序***。
- en: '**Exercises**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***B.2-1***'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.2-1***'
- en: Prove that the subset relation “⊆” on all subsets of ℤ is a partial order but
    not a total order.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 证明整数的所有子集上的子集关系“⊆”是一个偏序但不是全序。
- en: '***B.2-2***'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.2-2***'
- en: Show that for any positive integer *n*, the relation “equivalent modulo *n*”
    is an equivalence relation on the integers. (We say that *a* = *b* (mod *n*) if
    there exists an integer *q* such that *a* − *b* = *qn*.) Into what equivalence
    classes does this relation partition the integers?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 证明对于任意正整数*n*，关系“模*n*等价”是整数上的等价关系。（我们说*a* = *b* (mod *n*)，如果存在整数*q*使得*a* − *b*
    = *qn*。）这个关系将整数划分为哪些等价类？
- en: '***B.2-3***'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.2-3***'
- en: Give examples of relations that are
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一些既是
- en: '***a.*** reflexive and symmetric but not transitive,'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 自反和对称但不传递，'
- en: '***b.*** reflexive and transitive but not symmetric,'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 自反和传递但不对称，'
- en: '***c.*** symmetric and transitive but not reflexive.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 对称和传递但不自反。'
- en: '***B.2-4***'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.2-4***'
- en: Let *S* be a finite set, and let *R* be an equivalence relation on *S* × *S*.
    Show that if in addition *R* is antisymmetric, then the equivalence classes of
    *S* with respect to *R* are singletons.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 设*S*是一个有限集，*R*是*S* × *S*上的等价关系。证明如果此外*R*是反对称的，那么关于*R*的*S*的等价类是单元素集。
- en: '***B.2-5***'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.2-5***'
- en: Professor Narcissus claims that if a relation *R* is symmetric and transitive,
    then it is also reflexive. He offers the following proof. By symmetry, *a R b*
    implies *b R a*. Transitivity, therefore, implies *a R a*. Is the professor correct?
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 纳西索斯教授声称如果一个关系*R*是对称的和传递的，那么它也是自反的。他提供以下证明。根据对称性，*a R b*意味着*b R a*。因此，传递性意味着*a
    R a*。教授正确吗？
- en: '[**B.3 Functions**](toc.xhtml#Rh1-220)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[**B.3 函数**](toc.xhtml#Rh1-220)'
- en: 'Given two sets *A* and *B*, a ***function*** *f* is a binary relation on *A*
    and *B* such that for all *a* ∈ *A*, there exists precisely one *b* ∈ *B* such
    that (*a*, *b*) ∈ *f*. The set *A* is called the ***domain*** of *f*, and the
    set *B* is called the ***codomain*** of *f*. We sometimes write *f* : *A* → *B*,
    and if (*a*, *b*) ∈ *f*, we write *b* = *f* (*a*), since the choice of *a* uniquely
    determines *b*.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '给定两个集合*A*和*B*，一个***函数*** *f*是*A*和*B*上的二元关系，对于所有*a* ∈ *A*，存在唯一的*b* ∈ *B*使得(*a*,
    *b*) ∈ *f*。集合*A*称为*f*的***定义域***，集合*B*称为*f*的***陪域***。我们有时写*f* : *A* → *B*，如果(*a*,
    *b*) ∈ *f*，我们写*b* = *f* (*a*)，因为选择*a*唯一确定*b*。'
- en: Intuitively, the function *f* assigns an element of *B* to each element of *A*.
    No element of *A* is assigned two different elements of *B*, but the same element
    of *B* can be assigned to two different elements of *A*. For example, the binary
    relation
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地说，函数*f*为每个*A*的元素分配一个*B*的元素。没有*A*的元素被分配两个不同的*B*的元素，但是同一个*B*的元素可以被分配给两个不同的*A*的元素。例如，二元关系
- en: '*f* = {(*a*, *b*) : *a, b* ∈ ℕ and *b* = *a* mod 2}'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '*f* = {(*a*, *b*) : *a, b* ∈ ℕ and *b* = *a* mod 2}'
- en: 'is a function *f* : → {0, 1}, since for each natural number *a*, there is exactly
    one value *b* in {0, 1} such that *b* = *a* mod 2\. For this example, 0 = *f*
    (0), 1 = *f* (1), 0 = *f* (2), 1 = *f* (3), etc. In contrast, the binary relation'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '是一个函数*f* : → {0, 1}，因为对于每个自然数*a*，存在一个值*b*在{0, 1}中，使得*b* = *a* mod 2。例如，0 =
    *f* (0), 1 = *f* (1), 0 = *f* (2), 1 = *f* (3)，等等。相比之下，二元关系'
- en: '*g* = {(*a*, *b*) : *a, b* ∈ ℕ and *a* + *b* is even}'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*g* = {(*a*, *b*) : *a, b* ∈ ℕ and *a* + *b* is even}'
- en: is not a function, since (1, 3) and (1, 5) are both in *g*, and thus for the
    choice *a* = 1, there is not precisely one *b* such that (*a*, *b*) ∈ *g*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 不是一个函数，因为(1, 3)和(1, 5)都在*g*中，因此对于选择*a* = 1，没有确切的一个*b*使得(*a*, *b*) ∈ *g*。
- en: 'Given a function *f* : *A* → *B*, if *b* = *f* (*a*), we say that *a* is the
    ***argument*** of *f* and that *b* is the ***value*** of *f* at *a*. We can define
    a function by stating its value for every element of its domain. For example,
    we might define *f* (*n*) = 2*n* for *n* ∈ ℕ, which means *f* = {(*n*, 2*n*) :
    *n* ∈ ℕ}. Two functions *f* and *g* are ***equal*** if they have the same domain
    and codomain and if *f* (*a*) = *g*(*a*) for all *a* in the domain.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '给定一个函数*f* : *A* → *B*，如果*b* = *f* (*a*)，我们说*a*是*f*的***自变量***，*b*是*f*在*a*处的***值***。我们可以通过为其定义域中的每个元素陈述其值来定义一个函数。例如，我们可以定义*f*
    (*n*) = 2*n*，其中*n* ∈ ℕ，这意味着*f* = {(*n*, 2*n*) : *n* ∈ ℕ}。如果两个函数*f*和*g*相等，那么它们具有相同的定义域和值域，并且对于定义域中的所有*a*，*f*
    (*a*) = *g*(*a*)。'
- en: 'A ***finite sequence*** of length *n* is a function *f* whose domain is the
    set of *n* integers {0, 1, … , *n* − 1}. We often denote a finite sequence by
    listing its values in angle brackets: 〈*f* (0), *f* (1), … , *f* (*n*−1)〉. An
    ***infinite sequence*** is a function whose domain is the set ℕ of natural numbers.
    For example, the Fibonacci sequence, defined by recurrence (3.31), is the infinite
    sequence 〈0, 1, 1, 2, 3, 5, 8, 13, 21,…〉.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 长度为*n*的***有限序列***是一个函数*f*，其定义域是{n}中的*n*个整数{0, 1, … , *n* − 1}。我们通常通过在尖括号中列出其值来表示有限序列：〈*f*
    (0), *f* (1), … , *f* (*n*−1)〉。一个***无限序列***是一个函数，其定义域是自然数集ℕ。例如，由递推式(3.31)定义的斐波那契序列是无限序列〈0,
    1, 1, 2, 3, 5, 8, 13, 21,…〉。
- en: 'When the domain of a function *f* is a Cartesian product, we often omit the
    extra parentheses surrounding the argument of *f*. For example, if we have a function
    *f* : *A*[1] × *A*[2] × … *A*[*n*] → *B*, we write *b* = *f* (*a*[1], *a*[2],
    … *a[n]*) instead of writing *b* = *f* ((*a*[1], *a*[2], … *a[n]*)). We also call
    each *a[i]* an ***argument*** to the function *f*, though technically *f* has
    just a single argument, which is the *n*-tuple (*a*[1], *a*[2], … *a*[*n*]).'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '当函数*f*的定义域是一个笛卡尔积时，我们经常省略围绕*f*的参数的额外括号。例如，如果我们有一个函数*f* : *A*[1] × *A*[2] ×
    … *A*[*n*] → *B*，我们写*b* = *f* (*a*[1], *a*[2], … *a[n]*)而不是写*b* = *f* ((*a*[1],
    *a*[2], … *a[n]*)。我们也称每个*a[i]*为函数*f*的***自变量***，尽管严格来说*f*只有一个自变量，即*n*-元组(*a*[1],
    *a*[2], … *a*[*n*])。'
- en: 'If *f* : *A* → *B* is a function and *b* = *f* (*a*), then we sometimes say
    that *b* is the ***image*** of *a* under *f*. The image of a set *A*′ ⊆ *A* under
    *f* is defined by'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '如果*f* : *A* → *B*是一个函数，*b* = *f* (*a*)，那么我们有时说*b*是*a*在*f*下的***象***。在*f*下集合*A*′的象由以下定义'
- en: '*f* (*A*′) = {*b* ∈ *B* : *b* = *f* (*a*) for some *a* ∈ *A*′}.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '*f* (*A*′) = {*b* ∈ *B* : *b* = *f* (*a*) for some *a* ∈ *A*′}.'
- en: 'The ***range*** of *f* is the image of its domain, that is, *f* (*A*). For
    example, the range of the function *f* : ℕ → ℕ defined by *f* (*n*) = 2*n* is
    *f*(ℕ) = {*m* : *m* = 2*n* for some *n* ∈ ℕ}, in other words, the set of nonnegative
    even integers.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '*f*的***值域***是其定义域的像，即*f* (*A*)。例如，函数*f* : ℕ → ℕ定义为*f* (*n*) = 2*n*的值域是*f*(ℕ)
    = {*m* : *m* = 2*n*，其中*n* ∈ ℕ}，换句话说，非负偶数的集合。'
- en: 'A function is a ***surjection*** if its range is its codomain. For example,
    the function *f* (*n*) = ⌊*n*/2⌋ is a surjective function from ℕ to ℕ, since every
    element in ℕ appears as the value of *f* for some argument. In contrast, the function
    *f* (*n*) = 2*n* is not a surjective function from ℕ to ℕ, since no argument to
    *f* can produce any odd natural number as a value. The function *f* (*n*) = 2*n*
    is, however, a surjective function from the natural numbers to the even numbers.
    A surjection *f* : *A* → *B* is sometimes described as mapping *A **onto** B*.
    When we say that *f* is onto, we mean that it is surjective.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个函数是***满射***，那么它的值域就是它的余域。例如，函数*f*(*n*) = ⌊*n*/2⌋是从自然数到自然数的满射函数，因为自然数中的每个元素都会作为*f*的某个参数的值出现。相比之下，函数*f*(*n*)
    = 2*n*不是从自然数到自然数的满射函数，因为没有任何参数可以产生任何奇数自然数作为值。然而，函数*f*(*n*) = 2*n*是从自然数到偶数的满射函数。一个从*A*到*B*的满射*f*有时被描述为将*A*
    **映射到** B*。当我们说*f*是映射到时，我们的意思是它是满射的。
- en: 'A function *f* : *A* → *B* is an ***injection*** if distinct arguments to *f*
    produce distinct values, that is, if *a* ≠ *a*′ implies *f* (*a*) ≠ *f* (*a*′).
    For example, the function *f* (*n*) = 2*n* is an injective function from ℕ to
    ℕ, since each even number *b* is the image under *f* of at most one element of
    the domain, namely *b*/2\. The function *f* (*n*) = ⌊*n*/2⌋ is not injective,
    since the value 1 is produced by two arguments: *f* (2) = 1 and *f* (3) = 1\.
    An injection is sometimes called a ***one-to-one*** function.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*f*：*A* → *B*是一个***单射***，那么*f*的不同参数产生不同的值，也就是说，如果*a* ≠ *a*′，则*f*(*a*) ≠ *f*(*a*′)。例如，函数*f*(*n*)
    = 2*n*是从自然数到自然数的单射函数，因为每个偶数*b*最多是域中一个元素的图像，即*b*/2。函数*f*(*n*) = ⌊*n*/2⌋不是单射的，因为值1由两个参数产生：*f*(2)
    = 1和*f*(3) = 1。单射有时被称为***一一***函数。
- en: 'A function *f* : *A* → *B* is a ***bijection*** if it is injective and surjective.
    For example, the function *f* (*n*) = (−1)*^n*⌈*n*/2⌉ is a bijection from ℕ to
    ℤ:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 函数*f*：*A* → *B*是一个***双射***，如果它是单射和满射的。例如，函数*f*(*n*) = (−1)*^n*⌈*n*/2⌉是从自然数到整数的双射：
- en: '| 0 | → | 0, |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 0 | → | 0, |'
- en: '| 1 | → | −1, |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| 1 | → | −1, |'
- en: '| 2 | → | 1, |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| 2 | → | 1, |'
- en: '| 3 | → | −2, |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 3 | → | −2, |'
- en: '| 4 | → | 2, |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 4 | → | 2, |'
- en: '|  | ⋮ |  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|  | ⋮ |  |'
- en: The function is injective, since no element of ℤ is the image of more than one
    element of ℕ. It is surjective, since every element of ℤ appears as the image
    of some element of ℕ. Hence, the function is bijective. A bijection is sometimes
    called a ***one-to-one correspondence***, since it pairs elements in the domain
    and codomain. A bijection from a set *A* to itself is sometimes called a ***permutation***.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 该函数是单射的，因为ℤ中的任何元素都不是自然数的多个元素的图像。它是满射的，因为ℤ中的每个元素都会作为某个自然数的图像出现。因此，该函数是双射的。双射有时被称为***一一对应***，因为它将定义域和余域中的元素配对。从集合*A*到自身的双射有时被称为***置换***。
- en: When a function *f* is bijective, we define its ***inverse*** *f*^(−1) as
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个函数*f*是双射时，我们将其***逆*** *f*^(−1)定义为
- en: '*f* ^(−1)(*b*) = *a* if and only if *f* (*a*) = *b*.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '*f* ^(−1)(*b*) = *a*当且仅当*f*(*a*) = *b*。'
- en: For example, the inverse of the function *f* (*n*) = (−1)*^n*⌈*n*/2⌉ is
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，函数*f*(*n*) = (−1)*^n*⌈*n*/2⌉的逆函数是
- en: '![art](images/Art_P1621.jpg)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1621.jpg)'
- en: '**Exercises**'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***B.3-1***'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.3-1***'
- en: 'Let *A* and *B* be finite sets, and let *f* : *A* → *B* be a function. Show
    the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 设*A*和*B*是有限集，*f*：*A* → *B*是一个函数。证明以下结论：
- en: '***a.*** If *f* is injective, then |*A*| ≤ |*B*|.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 如果*f*是单射的，那么|*A*| ≤ |*B*|。'
- en: '***b.*** If *f* is surjective, then |*A*| ≥ |*B*|.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 如果*f*是满射的，那么|*A*| ≥ |*B*|。'
- en: '***B.3-2***'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.3-2***'
- en: Is the function *f* (*x*) = *x* + 1 bijective when the domain and the codomain
    are the set ℕ? Is it bijective when the domain and the codomain are the set ℤ?
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 当定义域和余域是集合ℕ时，函数*f*(*x*) = *x* + 1是双射的吗？当定义域和余域是集合ℤ时，它是双射的吗？
- en: '***B.3-3***'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.3-3***'
- en: Give a natural definition for the inverse of a binary relation such that if
    a relation is in fact a bijective function, its relational inverse is its functional
    inverse.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个关于二元关系的逆的自然定义，使得如果一个关系实际上是一个双射函数，那么它的关系逆就是它的函数逆。
- en: ★ ***B.3-4***
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***B.3-4***
- en: Give a bijection from ℤ to ℤ × ℤ.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个从整数到整数×整数的双射。
- en: '[**B.4 Graphs**](toc.xhtml#Rh1-221)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '[**B.4 图**](toc.xhtml#Rh1-221)'
- en: 'This section presents two kinds of graphs: directed and undirected. Certain
    definitions in the literature differ from those given here, but for the most part,
    the differences are slight. [Section 20.1](chapter020.xhtml#Sec_20.1) shows how
    to represent graphs in computer memory.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了两种图：有向图和无向图。文献中的某些定义与此处给出的定义有所不同，但大部分差异很小。[第20.1节](chapter020.xhtml#Sec_20.1)展示了如何在计算机内存中表示图形。
- en: 'A ***directed graph*** (or ***digraph***) *G* is a pair (*V*, *E*), where *V*
    is a finite set and *E* is a binary relation on *V*. The set *V* is called the
    ***vertex set*** of *G*, and its elements are called ***vertices*** (singular:
    ***vertex***). The set *E* is called the ***edge set*** of *G*, and its elements
    are called ***edges***. [Figure B.2(a)](#Fig_B-2) is a pictorial representation
    of a directed graph on the vertex set {1, 2, 3, 4, 5, 6}. Vertices are represented
    by circles in the figure, and edges are represented by arrows. ***Self-loops***—edges
    from a vertex to itself—are possible.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 一个***有向图***（或***有向图***）*G*是一个二元组（*V*，*E*），其中*V*是一个有限集，*E*是*V*上的二元关系。集合*V*被称为*G*的***顶点集***，其元素被称为***顶点***（单数：***顶点***）。集合*E*被称为*G*的***边集***，其元素被称为***边***。[图B.2(a)](#Fig_B-2)是在顶点集{1,
    2, 3, 4, 5, 6}上的有向图的图示表示。图中的圆表示顶点，箭头表示边。***自环***—从一个顶点到自身的边是可能的。
- en: In an ***undirected graph*** *G* = (*V*, *E*), the edge set *E* consists of
    *unordered* pairs of vertices, rather than ordered pairs. That is, an edge is
    a set {*u, v*}, where *u, v* ∈ *V* and *u* ≠ *v*. By convention, we use the notation
    (*u*, *v*) for an edge, rather than the set notation {*u, v*}, and we consider
    (*u*, *v*) and (*v*, *u*) to be the same edge. In an undirected graph, self-loops
    are forbidden, so that every edge consists of two distinct vertices. [Figure B.2(b)](#Fig_B-2)
    shows an undirected graph on the vertex set {1, 2, 3, 4, 5, 6}.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个***无向图*** *G* = (*V*, *E*) 中，边集 *E* 由顶点的*无序*对组成，而不是有序对。也就是说，一条边是一个集合{*u,
    v*}，其中 *u, v* ∈ *V* 且 *u* ≠ *v*。按照惯例，我们使用符号(*u*, *v*)表示一条边，而不是集合符号{*u, v*}，并且我们认为(*u*,
    *v*) 和 (*v*, *u*) 是相同的边。在无向图中，自环是被禁止的，因此每条边由两个不同的顶点组成。[图 B.2(b)](#Fig_B-2)展示了一个顶点集合为{1,
    2, 3, 4, 5, 6}的无向图。
- en: '![art](images/Art_P1622.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1622.jpg)'
- en: '**Figure B.2** Directed and undirected graphs. **(a)** A directed graph *G*
    = (*V*, *E*), where *V* = {1, 2, 3, 4, 5, 6} and *E* = {(1, 2), (2, 2), (2, 4),
    (2, 5), (4, 1), (4, 5), (5, 4), (6, 3)}. The edge (2, 2) is a self-loop. **(b)**
    An undirected graph *G* = (*V*, *E*), where *V* = {1, 2, 3, 4, 5, 6} and *E* =
    {(1, 2), (1, 5), (2, 5), (3, 6)}. The vertex 4 is isolated. **(c)** The subgraph
    of the graph in part (a) induced by the vertex set {1, 2, 3, 6}.'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 B.2** 有向图和无向图。**(a)** 一个有向图 *G* = (*V*, *E*)，其中 *V* = {1, 2, 3, 4, 5, 6}，*E*
    = {(1, 2), (2, 2), (2, 4), (2, 5), (4, 1), (4, 5), (5, 4), (6, 3)}。边 (2, 2) 是一个自环。**(b)**
    一个无向图 *G* = (*V*, *E*)，其中 *V* = {1, 2, 3, 4, 5, 6}，*E* = {(1, 2), (1, 5), (2,
    5), (3, 6)}。顶点 4 是孤立的。**(c)** 由顶点集合{1, 2, 3, 6}诱导的图的子图。'
- en: Many definitions for directed and undirected graphs are the same, although certain
    terms have slightly different meanings in the two contexts. If (*u*, *v*) is an
    edge in a directed graph *G* = (*V*, *E*), we say that (*u*, *v*) is ***incident
    from*** or ***leaves*** vertex *u* and is ***incident to*** or ***enters*** vertex
    *v*. For example, the edges leaving vertex 2 in [Figure B.2(a)](#Fig_B-2) are
    (2, 2), (2, 4), and (2, 5). The edges entering vertex 2 are (1, 2) and (2, 2).
    If (*u*, *v*) is an edge in an undirected graph *G* = (*V*, *E*), we say that
    (*u*, *v*) is ***incident on*** vertices *u* and *v*. In [Figure B.2(b)](#Fig_B-2),
    the edges incident on vertex 2 are (1, 2) and (2, 5).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 许多有向图和无向图的定义是相同的，尽管在两种情境下某些术语的含义略有不同。如果在有向图 *G* = (*V*, *E*) 中(*u*, *v*)是一条边，我们说(*u*,
    *v*) ***从*** 顶点 *u* ***出发*** 或 ***离开***，并且 ***进入*** 顶点 *v*。例如，在[图 B.2(a)](#Fig_B-2)中，离开顶点
    2 的边是 (2, 2), (2, 4), 和 (2, 5)。进入顶点 2 的边是 (1, 2) 和 (2, 2)。如果在无向图 *G* = (*V*, *E*)
    中(*u*, *v*)是一条边，我们说(*u*, *v*) ***关联*** 于顶点 *u* 和 *v*。在[图 B.2(b)](#Fig_B-2)中，关联于顶点
    2 的边是 (1, 2) 和 (2, 5)。
- en: If (*u*, *v*) is an edge in a graph *G* = (*V*, *E*), we say that vertex *v*
    is ***adjacent*** to vertex *u*. When the graph is undirected, the adjacency relation
    is symmetric. When the graph is directed, the adjacency relation is not necessarily
    symmetric. If *v* is adjacent to *u* in a directed graph, we can write *u* → *v*.
    In parts (a) and (b) of [Figure B.2](#Fig_B-2), vertex 2 is adjacent to vertex
    1, since the edge (1, 2) belongs to both graphs. Vertex 1 is *not* adjacent to
    vertex 2 in [Figure B.2(a)](#Fig_B-2), since the edge (2, 1) is absent.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在图 *G* = (*V*, *E*) 中(*u*, *v*)是一条边，我们说顶点 *v* ***相邻*** 于顶点 *u*。当图是无向的时，相邻关系是对称的。当图是有向的时，相邻关系不一定是对称的。如果在有向图中
    *v* 是 *u* 的邻接点，我们可以写成 *u* → *v*。在[图 B.2](#Fig_B-2)的(a)和(b)部分中，顶点 2 是顶点 1 的邻接点，因为边
    (1, 2) 属于两个图。在[图 B.2(a)](#Fig_B-2)中，顶点 1 *不* 是顶点 2 的邻接点，因为边 (2, 1) 不存在。
- en: The ***degree*** of a vertex in an undirected graph is the number of edges incident
    on it. For example, vertex 2 in [Figure B.2(b)](#Fig_B-2) has degree 2\. A vertex
    whose degree is 0, such as vertex 4 in [Figure B.2(b)](#Fig_B-2), is ***isolated***.
    In a directed graph, the ***out-degree*** of a vertex is the number of edges leaving
    it, and the ***in-degree*** of a vertex is the number of edges entering it. The
    ***degree*** of a vertex in a directed graph is its in-degree plus its out-degree.
    Vertex 2 in [Figure B.2(a)](#Fig_B-2) has in-degree 2, out-degree 3, and degree
    5.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在无向图中，顶点的***度***是与之关联的边的数量。例如，在[图 B.2(b)](#Fig_B-2)中，顶点 2 的度为 2。一个度为 0 的顶点，比如[图
    B.2(b)](#Fig_B-2)中的顶点 4，是***孤立*** 的。在有向图中，顶点的***出度*** 是离开它的边的数量，顶点的***入度*** 是进入它的边的数量。顶点在有向图中的***度***
    是它的入度加上出度。在[图 B.2(a)](#Fig_B-2)中，顶点 2 的入度为 2，出度为 3，度为 5。
- en: A ***path*** of ***length*** *k* from a vertex *u* to a vertex *u*′ in a graph
    *G* = (*V*, *E*) is a sequence 〈*v*[0], *v*[1], *v*[2], … , *v[k]*〉 of vertices
    such that *u* = *v*[0], *u*′ = *v[k]*, and (*v*[*i*−1], *v[i]*) ∈ *E* for *i*
    = 1, 2, … , *k*. The length of the path is the number of edges in the path, which
    is 1 less than the number of vertices in the path. The path ***contains*** the
    vertices *v*[0], *v*[1], … , *v[k]* and the edges (*v*[0], *v*[1]), (*v*[1], *v*[2]),
    … , (*v*[*k*−1], *v[k]*). (There is always a 0-length path from *u* to *u*.) If
    there is a path *p* from *u* to *u*′, we say that *u*′ is ***reachable*** from
    *u* via *p*, which we can write as ![art](images/Art_P1623.jpg). A path is ***simple***^([4](#footnote_4))
    if all vertices in the path are distinct. In [Figure B.2(a)](#Fig_B-2), the path
    〈1, 2, 5, 4〉 is a simple path of length 3\. The path 〈2, 5, 4, 5〉 is not simple.
    A ***subpath*** of path *p* = 〈*v*[0], *v*[1], … , *v[k]*〉 is a contiguous subsequence
    of its vertices. That is, for any 0 ≤ *i* ≤ *j* ≤ *k*, the subsequence of vertices
    〈*v[i]*, *v*[*i*+1], … , *v[j]*〉 is a subpath of *p*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 从图*G* = (*V*, *E*)中的顶点*u*到顶点*u*′的***长度***为*k*的***路径***是一个顶点序列〈*v*[0], *v*[1],
    *v*[2], … , *v[k]*〉，使得*u* = *v*[0]，*u*′ = *v[k]*，且(*v*[*i*−1], *v[i]*) ∈ *E*对于*i*
    = 1, 2, … , *k*。路径的长度是路径中边的数量，比路径中顶点的数量少1。路径***包含***顶点*v*[0], *v*[1], … , *v[k]*和边(*v*[0],
    *v*[1])，(*v*[1], *v*[2])，… , (*v*[*k*��1], *v[k]*)。从*u*到*u*′存在路径*p*时，我们说*u*′可以通过*p*从*u*到达，可以写为![art](images/Art_P1623.jpg)。如果路径中的所有顶点都是不同的，则路径是***简单***的^([4](#footnote_4))。在[图
    B.2(a)](#Fig_B-2)中，路径〈1, 2, 5, 4〉是长度为3的简单路径。路径〈2, 5, 4, 5〉不是简单的。路径*p* = 〈*v*[0],
    *v*[1], … , *v[k]*〉的***子路径***是其顶点的连续子序列。也就是说，对于任意0 ≤ *i* ≤ *j* ≤ *k*，顶点子序列〈*v[i]*,
    *v*[*i*+1], … , *v[j]*〉是路径*p*的子路径。
- en: In a directed graph, a path 〈*v*[0], *v*[1], … , *v[k]*〉 forms a ***cycle***
    if *v*[0] = *v[k]* and the path contains at least one edge. The cycle is ***simple***
    if, in addition, *v*[1], *v*[2], … , *v[k]* are distinct. A cycle consisting of
    *k* vertices has ***length*** *k*. A self-loop is a cycle of length 1\. Two paths
    〈*v*[0], *v*[1], *v*[2], … , *v*[*k*−1], *v*[0]〉 and ![art](images/Art_P1623a.jpg)
    form the same cycle if there exists an integer *j* such that ![art](images/Art_P1623b.jpg)
    for *i* = 0, 1, … , *k*−1\. In [Figure B.2(a)](#Fig_B-2), the path 〈1,2,4,1〉 forms
    the same cycle as the paths 〈2, 4, 1, 2〉 and 〈4, 1, 2, 4〉. This cycle is simple,
    but the cycle 〈1, 2, 4, 5, 4, 1〉 is not. The cycle 〈2, 2〉 formed by the edge (2,
    2) is a self-loop. A directed graph with no self-loops is ***simple***. In an
    undirected graph, a path 〈*v*[0], *v*[1], …, *v*[*k*]〉 forms a ***cycle*** if
    *k* > 0, *v*[0] = *v[k]*, and all edges on the path are distinct. The cycle is
    ***simple*** if *v*[1], *v*[2], … , *v[k]* are distinct. For example, in [Figure
    B.2(b)](#Fig_B-2), the path 〈1, 2, 5, 1〉 is a simple cycle. A graph with no simple
    cycles is ***acyclic***.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在有向图中，路径〈*v*[0], *v*[1], … , *v[k]*〉形成一个***循环***，如果*v*[0] = *v[k]*且路径至少包含一条边。如果此外*v*[1],
    *v*[2], … , *v[k]*是不同的，则循环是***简单***的。由*k*个顶点组成的循环的***长度***为*k*。自环是长度为1的循环。两条路径〈*v*[0],
    *v*[1], *v*[2], … , *v*[*k*−1], *v*[0]〉和![art](images/Art_P1623a.jpg)形成相同的循环，如果存在整数*j*使得![art](images/Art_P1623b.jpg)对于*i*
    = 0, 1, … , *k*−1。在[图 B.2(a)](#Fig_B-2)中，路径〈1,2,4,1〉与路径〈2, 4, 1, 2〉和〈4, 1, 2,
    4〉形成相同的循环。这个循环是简单的，但循环〈1, 2, 4, 5, 4, 1〉不是。由边(2, 2)形成的循环〈2, 2〉是自环。没有自环的有向图是***简单***的。在无向图中，路径〈*v*[0],
    *v*[1], …, *v*[*k*]〉形成一个***循环***，如果*k* > 0，*v*[0] = *v[k]*，并且路径上的所有边都是不同的。如果*v*[1],
    *v*[2], … , *v[k]*是不同的，则循环是***简单***的。例如，在[图 B.2(b)](#Fig_B-2)中，路径〈1, 2, 5, 1〉是一个简单循环。没有简单循环的图是***无环***的。
- en: 'An undirected graph is ***connected*** if every vertex is reachable from all
    other vertices. The ***connected components*** of an undirected graph are the
    equivalence classes of vertices under the “is reachable from” relation. The graph
    shown in [Figure B.2(b)](#Fig_B-2) has three connected components: {1, 2, 5},
    {3, 6}, and {4}. Every vertex in the connected component {1, 2, 5} is reachable
    from every other vertex in {1, 2, 5}. An undirected graph is connected if it has
    exactly one connected component. The edges of a connected component are those
    that are incident on only the vertices of the component. In other words, edge
    (*u*, *v*) is an edge of a connected component only if both *u* and *v* are vertices
    of the component.'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无向图是***连通***的，如果每个顶点都可以从其他所有顶点到达。无向图的***连通分量***是在“可从”关系下的顶点等价类。在[图 B.2(b)](#Fig_B-2)中展示的图有三个连通分量：{1,
    2, 5}，{3, 6}和{4}。在连通分量{1, 2, 5}中的每个顶点都可以从{1, 2, 5}中的任何其他顶点到达。一个无向图只有一个连通分量时才是连通的。连通分量的边是仅与该分量中的顶点相关的边。换句话说，边(*u*,
    *v*)只有当*u*和*v*都是该分量中的顶点时才是该分量的边。
- en: 'A directed graph is ***strongly connected*** if every two vertices are reachable
    from each other. The ***strongly connected components*** of a directed graph are
    the equivalence classes of vertices under the “are mutually reachable” relation.
    A directed graph is strongly connected if it has only one strongly connected component.
    The graph in [Figure B.2(a)](#Fig_B-2) has three strongly connected components:
    {1, 2, 4, 5}, {3}, and {6}. All pairs of vertices in {1, 2, 4, 5} are mutually
    reachable. The vertices {3, 6} do not form a strongly connected component, since
    vertex 6 cannot be reached from vertex 3.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有向图是***强连通***的，如果每两个顶点都可以互相到达。有向图的***强连通分量***是在“互相可达”关系下的顶点等价类。一个有向图只有一个强连通分量时才是强连通的。[图
    B.2(a)](#Fig_B-2)中的图有三个强连通分量：{1, 2, 4, 5}，{3}和{6}。在{1, 2, 4, 5}中的所有顶点都是互相可达的。顶点{3,
    6}不构成一个强连通分量，因为顶点6无法从顶点3到达。
- en: 'Two graphs *G* = (*V*, *E*) and *G*′ = (*V*′, *E*′) are ***isomorphic*** if
    there exists a bijection *f* : *V* → *V*′ such that (*u*, *v*) ∈ *E* if and only
    if (*f* (*u*), *f* (*v*)) ∈ *E*′. In other words, *G* and *G*′ are isomorphic
    if the vertices of *G* can be relabeled to be vertices of *G*′, maintaining the
    corresponding edges in *G* and *G*′. [Figure B.3(a)](#Fig_B-3) shows a pair of
    isomorphic graphs *G* and *G*′ with respective vertex sets *V* = {1, 2, 3, 4,
    5, 6} and *V*′ = {*u, v, w, x, y, z*}. The mapping from *V* to *V*′ given by *f*
    (1) = *u, f* (2) = *v, f* (3) = *w, f* (4) = *x, f* (5) = *y, f* (6) = *z* provides
    the required bijective function. The graphs in [Figure B.3(b)](#Fig_B-3) are not
    isomorphic. Although both graphs have 5 vertices and 7 edges, the top graph has
    a vertex of degree 4 and the bottom graph does not.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '如果存在一个双射*f* : *V* → *V*′，使得当且仅当(*u*, *v*) ∈ *E*时(*f*(*u*), *f*(*v*)) ∈ *E*′，则两个图*G*
    = (*V*, *E*)和*G*′ = (*V*′, *E*′)是***同构***的。换句话说，如果*G*的顶点可以重新标记为*G*′的顶点，保持*G*和*G*′中对应的边，则*G*和*G*′是同构的。
    [图B.3(a)](#Fig_B-3)展示了一对同构图*G*和*G*′，它们的顶点集分别为*V* = {1, 2, 3, 4, 5, 6}和*V*′ = {*u,
    v, w, x, y, z*}。从*V*到*V*′的映射由*f*(1) = *u, f*(2) = *v, f*(3) = *w, f*(4) = *x,
    f*(5) = *y, f*(6) = *z*给出所需的双射函数。 [图B.3(b)](#Fig_B-3)中的两个图不是同构的。尽管两个图都有5个顶点和7条边，但顶部图有一个度为4的顶点，而底部图没有。'
- en: We say that a graph *G*′ = (*V*′, *E*′) is a ***subgraph*** of *G* = (*V*, *E*)
    if *V*′ ⊆ *V* and *E*′ ⊆ *E*. Given a set *V*′ ⊆ *V*, the subgraph of *G **induced***
    by *V*′ is the graph *G*′ = (*V*′, *E*′), where
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说图*G*′ = (*V*′, *E*′)是图*G* = (*V*, *E*)的一个***子图***，如果*V*′ ⊆ *V*且*E*′ ⊆ *E*。给定一个集合*V*′
    ⊆ *V*，由*V*′诱导的*G*的子图是图*G*′ = (*V*′, *E*′)，其中
- en: '*E*′ = {(*u*, *v*) ∈ *E* : *u, v* ∈ *V*′}.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*E*′ = {(*u*, *v*) ∈ *E* : *u, v* ∈ *V*′}。'
- en: The subgraph induced by the vertex set {1, 2, 3, 6} in [Figure B.2(a)](#Fig_B-2)
    appears in [Figure B.2(c)](#Fig_B-2) and has the edge set {(1, 2), (2, 2), (6,
    3)}.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图B.2(a)](#Fig_B-2)中由顶点集{1, 2, 3, 6}诱导的子图出现在[图B.2(c)](#Fig_B-2)中，并且具有边集{(1,
    2), (2, 2), (6, 3)}。
- en: Given an undirected graph *G* = (*V*, *E*), the ***directed version*** of *G*
    is the directed graph *G*′ = (*V*, *E*′), where (*u*, *v*) ∈ *E*′ if and only
    if (*u*, *v*) ∈ *E*. That is, each undirected edge (*u*, *v*) in *G* turns into
    two directed edges, (*u*, *v*) and (*v*, *u*), in the directed version. Given
    a directed graph *G* = (*V*, *E*), the ***undirected version*** of *G* is the
    undirected graph *G*′ = (*V*, *E*′), where (*u*, *v*) ∈ *E*′ if and only if *u*
    ≠ *v* and *E* contains at least one of the edges (*u*, *v*) and (*v*, *u*). That
    is, the undirected version contains the edges of *G* “with their directions removed”
    and with self-loops eliminated. (Since (*u*, *v*) and (*v*, *u*) are the same
    edge in an undirected graph, the undirected version of a directed graph contains
    it only once, even if the directed graph contains both edges (*u*, *v*) and (*v*,
    *u*).) In a directed graph *G* = (*V*, *E*), a ***neighbor*** of a vertex *u*
    is any vertex that is adjacent to *u* in the undirected version of *G*. That is,
    *v* is a neighbor of *u* if *u* ≠ *v* and either (*u*, *v*) ∈ *E* or (*v*, *u*)
    ∈ *E*. In an undirected graph, *u* and *v* are neighbors if they are adjacent.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个无向图*G* = (*V*, *E*), *G*的***有向版本***是有向图*G*′ = (*V*, *E*′), 其中当且仅当(*u*, *v*)
    ∈ *E*时(*u*, *v*) ∈ *E*′。也就是说，*G*中的每条无向边(*u*, *v*)在有向版本中变成两条有向边(*u*, *v*)和(*v*,
    *u*)。给定一个有向图*G* = (*V*, *E*), *G*的***无向版本***是无向图*G*′ = (*V*, *E*′), 其中当且仅当*u*
    ≠ *v*且*E*至少包含边(*u*, *v*)和(*v*, *u*)中的一条时(*u*, *v*) ∈ *E*′。也就是说，无向版本包含了*G*中的边“去除方向”并消除自环。
    (由于在无向图中(*u*, *v*)和(*v*, *u*)是同一条边，有向图的无向版本只包含一次，即使有向图包含边(*u*, *v*)和(*v*, *u*)两条。)
    在有向图*G* = (*V*, *E*)中，顶点*u*的一个***邻居***是在*G*的无向版本中与*u*相邻的任意顶点。也就是说，如果*u* ≠ *v*且(*u*,
    *v*) ∈ *E*或(*v*, *u*) ∈ *E*，则*v*是*u*的邻居。在无向图中，如果两个顶点*u*和*v*相邻，则它们是邻居。
- en: '![art](images/Art_P1624.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1624.jpg)'
- en: '**Figure B.3 (a)** A pair of isomorphic graphs. The vertices of the top graph
    are mapped to the vertices of the bottom graph by *f* (1) = *u, f* (2) = *v, f*
    (3) = *w, f* (4) = *x, f* (5) = *y, f* (6) = *z*. **(b)** Two graphs that are
    not isomorphic. The top graph has a vertex of degree 4, and the bottom graph does
    not.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**图B.3 (a)** 一对同构图。顶部图的顶点通过*f*(1) = *u, f*(2) = *v, f*(3) = *w, f*(4) = *x,
    f*(5) = *y, f*(6) = *z*映射到底部图的顶点。 **(b)** 两个不同构的图。顶部图有一个度为4的顶点，底部图没有。'
- en: Several kinds of graphs have special names. A ***complete graph*** is an undirected
    graph in which every pair of vertices is adjacent. An undirected graph *G* = (*V*,
    *E*) is ***bipartite*** if *V* can be partitioned into two sets *V*[1] and *V*[2]
    such that (*u*, *v*) ∈ *E* implies either *u* ∈ *V*[1] and *v* ∈ *V*[2] or *u*
    ∈ *V*[2] and *v* ∈ *V*[1]. That is, all edges go between the two sets *V*[1] and
    *V*[2]. An acyclic, undirected graph is a ***forest***, and a connected, acyclic,
    undirected graph is a ***(free) tree*** (see [Section B.5](appendix002.xhtml#Sec_B.5)).
    We often take the first letters of “directed acyclic graph” and call such a graph
    a ***dag***.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 几种图有特殊的名称。一个***完全图***是一个无向图，其中每对顶点都是相邻的。一个无向图*G* = (*V*, *E*)是***二分图***，如果*V*可以被划分为两个集合*V*[1]和*V*[2]，使得(*u*,
    *v*) ∈ *E*意味着*u* ∈ *V*[1]且*v* ∈ *V*[2]或*u* ∈ *V*[2]且*v* ∈ *V*[1]。也就是说，所有的边都在*V*[1]和*V*[2]之间。一个无环的无向图是一个***森林***，一个连通的无环的无向图是��个***(自由)树***
    (参见[第B.5节](appendix002.xhtml#Sec_B.5))。我们经常取“有向无环图”的首字母，并称这样的图为***dag***。
- en: There are two variants of graphs that you may occasionally encounter. A ***multigraph***
    is like an undirected graph, but it can have both multiple edges between vertices
    (such as two distinct edges (*u*, *v*) and (*u*, *v*)) and self-loops. A ***hypergraph***
    is like an undirected graph, but each ***hyperedge***, rather than connecting
    two vertices, connects an arbitrary subset of vertices. Many algorithms written
    for ordinary directed and undirected graphs can be adapted to run on these graphlike
    structures.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能偶尔会遇到两种变体的图。一个***多重图***类似于无向图，但它可以在顶点之间有多条边（例如两条不同的边(*u*, *v*)和(*u*, *v*)）和自环。一个***超图***类似于无向图，但每个***超边***连接的是顶点的任意子集。许多为普通有向和无向图编写的算法可以适应在这些类似图结构上运行。
- en: The ***contraction*** of an undirected graph *G* = (*V*, *E*) by an edge *e*
    = (*u*, *v*) is a graph *G*′ = (*V*′, *E*′), where *V*′ = *V* − {*u, v*} ∪ {*x*}
    and *x* is a new vertex. The set of edges *E*′ is formed from *E* by deleting
    the edge (*u*, *v*) and, for each vertex *w* adjacent to *u* or *v*, deleting
    whichever of (*u*, *w*) and (*v*, *w*) belongs to *E* and adding the new edge
    (*x*, *w*). In effect, *u* and *v* are “contracted” into a single vertex.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 通过边 *e* = (*u*, *v*) 对无向图 *G* = (*V*, *E*) 进行***收缩***，得到一个图 *G*′ = (*V*′, *E*′)，其中
    *V*′ = *V* − {*u, v*} ∪ {*x*}，*x*是一个新顶点。边集 *E*′由 *E* 删除边(*u*, *v*)并且对于与 *u* 或
    *v* 相邻的每个顶点 *w*，删除(*u*, *w*)和(*v*, *w*)中属于 *E* 的边，添加新边(*x*, *w*)。实际上，*u* 和 *v*
    被“收缩”成一个单个顶点。
- en: '**Exercises**'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***B.4-1***'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.4-1***'
- en: 'Attendees of a faculty party shake hands to greet each other, with every pair
    of professors shaking hands one time. Each professor remembers the number of times
    he or she shook hands. At the end of the party, the department head asks the professors
    for their totals and adds them all up. Show that the result is even by proving
    the ***handshaking lemma***: if *G* = (*V*, *E*) is an undirected graph, then'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 参加学院聚会的与会者互相握手致意，每对教授握手一次。每位教授记住自己握手的��数。聚会结束时，系主任要求教授们报告他们的总数并将它们相加。通过证明***握手引理***：如果
    *G* = (*V*, *E*) 是一个无向图，则
- en: '![art](images/Art_P1625.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1625.jpg)'
- en: '***B.4-2***'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.4-2***'
- en: Show that if a directed or undirected graph contains a path between two vertices
    *u* and *v*, then it contains a simple path between *u* and *v*. Show that if
    a directed graph contains a cycle, then it contains a simple cycle.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 证明如果一个有向或无向图包含顶点 *u* 和 *v* 之间的路径，则它包含顶点 *u* 和 *v* 之间的简单路径。证明如果一个有向图包含一个环，则它包含一个简单环。
- en: '***B.4-3***'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.4-3***'
- en: Show that any connected, undirected graph *G* = (*V*, *E*) satisfies |*E*| ≥
    |*V* | − 1.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 证明任何连通的无向图 *G* = (*V*, *E*) 满足 |*E*| ≥ |*V* | − 1。
- en: '***B.4-4***'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.4-4***'
- en: Verify that in an undirected graph, the “is reachable from” relation is an equivalence
    relation on the vertices of the graph. Which of the three properties of an equivalence
    relation hold in general for the “is reachable from” relation on the vertices
    of a directed graph?
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 验证在无向图中，“可达自”关系是图的顶点上的等价关系。在一般情况下，哪三个等价关系属性适用于有向图的顶点上的“可达自”关系？
- en: '***B.4-5***'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.4-5***'
- en: What is the undirected version of the directed graph in [Figure B.2(a)](#Fig_B-2)?
    What is the directed version of the undirected graph in [Figure B.2(b)](#Fig_B-2)?
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '[图B.2(a)](#Fig_B-2)中的有向图的无向版本是什么？[图B.2(b)](#Fig_B-2)中的无向图的有向版本是什么？'
- en: '***B.4-6***'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.4-6***'
- en: Show how a bipartite graph can represent a hypergraph by letting incidence in
    the hypergraph correspond to adjacency in the bipartite graph. (*Hint:* Let one
    set of vertices in the bipartite graph correspond to vertices of the hypergraph,
    and let the other set of vertices of the bipartite graph correspond to hyperedges.)
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过让超图中的关联对应于双分图中的邻接，展示双分图如何表示超图。（*提示：*让双分图中的一个顶点集对应于超图的顶点，让双分图的另一个顶点集对应于超边。）
- en: '[**B.5 Trees**](toc.xhtml#Rh1-222)'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '[**B.5 树**](toc.xhtml#Rh1-222)'
- en: As with graphs, there are many related, but slightly different, notions of trees.
    This section presents definitions and mathematical properties of several kinds
    of trees. [Sections 10.3](chapter010.xhtml#Sec_10.3) and [20.1](chapter020.xhtml#Sec_20.1)
    describe how to represent trees in computer memory.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 与图类似，树有许多相关但略有不同的概念。本节介绍了几种树的定义和数学性质。[第10.3节](chapter010.xhtml#Sec_10.3)和[第20.1节](chapter020.xhtml#Sec_20.1)描述了如何在计算机内存中表示树。
- en: '**B.5.1 Free trees**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**B.5.1 自由树**'
- en: As defined in [Section B.4](appendix002.xhtml#Sec_B.4), a ***free tree*** is
    a connected, acyclic, undirected graph. We often omit the adjective “free” when
    we say that a graph is a tree. If an undirected graph is acyclic but possibly
    disconnected, it is a ***forest***. Many algorithms that work for trees also work
    for forests. [Figure B.4(a)](#Fig_B-4) shows a free tree, and [Figure B.4(b)](#Fig_B-4)
    shows a forest. The forest in [Figure B.4(b)](#Fig_B-4) is not a tree because
    it is not connected. The graph in [Figure B.4(c)](#Fig_B-4) is connected but neither
    a tree nor a forest, because it contains a cycle.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第B.4节](appendix002.xhtml#Sec_B.4)中定义的，***自由树***是一个连通的、无环的、无向图。当我们说一个图是树时，通常会省略形容词“自由”。如果一个无向图是无环的但可能是不连通的，则是一个***森林***。许多适用于树的算法也适用于森林。[图B.4(a)](#Fig_B-4)展示了一个自由树，[图B.4(b)](#Fig_B-4)展示了一个森林。[图B.4(b)](#Fig_B-4)中的森林不是树，因为它不是连通的。[图B.4(c)](#Fig_B-4)中的图是连通的，但既不是树也不是森林，因为它包含一个环。
- en: The following theorem captures many important facts about free trees.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定理概括了关于自由树的许多重要事实。
- en: '***Theorem B.2 (Properties of free trees)***'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理B.2（自由树的性质）***'
- en: '![art](images/Art_P1626.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1626.jpg)'
- en: '**Figure B.4 (a)** A free tree. **(b)** A forest. **(c)** A graph that contains
    a cycle and is therefore neither a tree nor a forest.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '**图B.4 (a)** 一个自由树。**(b)** 一个森林。**(c)** 一个包含环的图，因此既不是树也不是森林。'
- en: Let *G* = (*V*, *E*) be an undirected graph. The following statements are equivalent.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 设 *G* = (*V*, *E*) 是一个无向图。以下陈述是等价的。
- en: '*G* is a free tree.'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*G* 是一个自由树。'
- en: Any two vertices in *G* are connected by a unique simple path.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*G*中任意两个顶点由唯一的简单路径连接。'
- en: '*G* is connected, but if any edge is removed from *E*, the resulting graph
    is disconnected.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*G*是连通的，但如果从*E*中移除任意边，则得到的图将是不连通的。'
- en: '*G* is connected, and |*E*| = |*V* | − 1.'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*G*是连通的，且|*E*| = |*V* | − 1。'
- en: '*G* is acyclic, and |*E*| = |*V* | − 1.'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*G*是无环的，且|*E*| = |*V* | − 1。'
- en: '*G* is acyclic, but if any edge is added to *E*, the resulting graph contains
    a cycle.'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*G*是无环的，但如果向*E*中添加任意边，则得到的图将包含一个环。'
- en: '![art](images/Art_P1627.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1627.jpg)'
- en: '**Figure B.5** A step in the proof of Theorem B.2: if (1) *G* is a free tree,
    then (2) any two vertices in *G* are connected by a unique simple path. Assume
    for the sake of contradiction that vertices *u* and *v* are connected by two distinct
    simple paths. These paths first diverge at vertex *w*, and they first reconverge
    at vertex *z*. The path *p*′ concatenated with the reverse of the path *p*″ forms
    a cycle, which yields the contradiction.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 B.5** 定理 B.2 证明的一步：如果(1) *G*是一棵自由树，则(2) *G*中的任意两个顶点由唯一的简单路径连接。假设为了推导矛盾，顶点*u*和*v*由两条不同的简单路径连接。这些���径在顶点*w*处首次分歧，并在顶点*z*处首次重新汇合。路径*p*′与路径*p*″的逆序连接形成一个环，导致矛盾。'
- en: '***Proof***   (1) ⇒ (2): Since a tree is connected, any two vertices in *G*
    are connected by at least one simple path. Suppose for the sake of contradiction
    that vertices *u* and *v* are connected by two distinct simple paths as shown
    in [Figure B.5](#Fig_B-5). Let *w* be the vertex at which the paths first diverge.
    That is, if we call the paths *p*[1] and *p*[2], then *w* is the first vertex
    on both *p*[1] and *p*[2] whose successor on *p*[1] is *x* and whose successor
    on *p*[2] is *y*, where *x* ≠ *y*. Let *z* be the first vertex at which the paths
    reconverge, that is, *z* is the first vertex following *w* on *p*[1] that is also
    on *p*[2]. Let *p*′ = *w* → *x* ⇝ *z* be the subpath of *p*[1] from *w* through
    *x* to *z*, so that ![art](images/Art_P1628.jpg), and let *p*″ = *w* → *y* ⇝ *z*
    be the subpath of *p*[2] from *w* through *y* to *z*, so that ![art](images/Art_P1630.jpg).
    Paths *p*′ and *p*″ share no vertices except their endpoints. Then, as [Figure
    B.5](#Fig_B-5) shows, the path obtained by concatenating *p*′ and the reverse
    of *p*″ is a cycle, which contradicts our assumption that *G* is a tree. Thus,
    if *G* is a tree, there can be at most one simple path between two vertices.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   (1) ⇒ (2): 由于树是连通的，*G*中的任意两个顶点至少由一条简单路径连接。假设为了推导矛盾，顶点*u*和*v*由图中两条不同的简单路径连接，如[图
    B.5](#Fig_B-5)所示。让*w*是路径首次分歧的顶点。也就是说，如果我们将路径称为*p*[1]和*p*[2]，那么*w*是*p*[1]和*p*[2]上第一个后继分别为*x*和*y*（其中*x*
    ≠ *y*）的顶点。让*z*是路径首次重新汇合的顶点，也就是说，*z*是在*p*[1]上的*w*之后也在*p*[2]上的第一个顶点。让*p*′ = *w*
    → *x* ⇝ *z*是*p*[1]中从*w*经*x*到*z*的子路径，使得 ![art](images/Art_P1628.jpg)，让*p*″ = *w*
    → *y* ⇝ *z*是*p*[2]中从*w*经*y*到*z*的子路径，使得 ![art](images/Art_P1630.jpg)。路径*p*′和*p*″除了它们的端点外没有共同的顶点。然后，如[图
    B.5](#Fig_B-5)所示，将*p*′与*p*″的逆序连接起来形成一个环，这与我们假设的*G*是树相矛盾。因此，如果*G*是树，则两个顶点之间最多只能有一条简单路径。'
- en: '(2) ⇒ (3): If any two vertices in *G* are connected by a unique simple path,
    then *G* is connected. Let (*u*, *v*) be any edge in *E*. This edge is a path
    from *u* to *v*, and so it must be the unique path from *u* to *v*. If (*u*, *v*)
    were to be removed from *G*, there would be no path from *u* to *v*, and *G* would
    be disconnected.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '(2) ⇒ (3): 如果*G*中任意两个顶点由唯一的简单路径连接，则*G*是连通的。设(*u*, *v*)是*E*中的任意边。这条边是从*u*到*v*的路径，因此它必须是从*u*到*v*的唯一路径。如果将(*u*,
    *v*)从*G*中移除，那么从*u*到*v*就没有路径，*G*将是不连通的。'
- en: '(3) ⇒ (4): By assumption, the graph *G* is connected, so Exercise B.4-3 gives
    that |*E*| ≥ |*V*| − 1\. We prove |*E*| ≤ |*V*| − 1 by induction on |*V*|. The
    base cases are when |*V*| = 1 or |*V*| = 2, and in either case, |*E*| = |*V*|
    − 1\. For the inductive step, suppose that |*V*| ≥ 3 for graph *G* and that any
    graph *G*′ = (*V*′, *E*′), where |*V*′| < |*V*|, that satisfies (3) also satisfies
    |*E*′| ≤ |*V*′| − 1\. Removing an arbitrary edge from *G* separates the graph
    into *k* ≥ 2 connected components (actually *k* = 2). Each component satisfies
    (3), or else *G* would not satisfy (3). Consider each connected component *V[i]*,
    with edge set *E[i]*, as a separate free tree. Then, because each connected component
    has fewer than |*V*| vertices, the inductive hypothesis implies that |*E[i]*|
    ≤ |*V[i]*| − 1\. Thus, the number of edges in all *k* connected components combined
    is at most |*V*| − *k* ≤ |*V*| − 2\. Adding in the removed edge yields |*E*| ≤
    |*V*| − 1.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '(3) ⇒ (4): 根据假设，图*G*是连通的，因此练习 B.4-3 表明 |*E*| ≥ |*V*| − 1\. 我们通过对|*V*|进行归纳证明
    |*E*| ≤ |*V*| − 1。基本情况是当|*V*| = 1或|*V*| = 2时，在任一情况下，|*E*| = |*V*| − 1\. 对于归纳步骤，假设对于图*G*，|*V*|
    ≥ 3，以及满足(3)的任何图*G*′ = (*V*′, *E*′)，其中|*V*′| < |*V*|，也满足|*E*′| ≤ |*V*′| − 1\. 从*G*中移除任意边将图分成*k*
    ≥ 2个连通分量（实际上*k* = 2）。每个分量都满足(3)，否则*G*就不会满足(3)。将每个连通分量*V[i]*及其边集*E[i]*视为单独的自由树。然后，因为每个连通分量的顶点数少于|*V*|，归纳假设意味着
    |*E[i]*| ≤ |*V[i]*| − 1\. 因此，所有*k*个连通分量中的边数最多为|*V*| − *k* ≤ |*V*| − 2\. 加入移除的边后，得到
    |*E*| ≤ |*V*| − 1。'
- en: '(4) ⇒ (5): Suppose that *G* is connected and that |*E*| = |*V*| − 1\. We must
    show that *G* is acyclic. Suppose that *G* has a cycle containing *k* vertices
    *v*[1], *v*[2], … , *v[k]*, and without loss of generality assume that this cycle
    is simple. Let *G[k]* = (*V[k], E[k]*) be the subgraph of *G* consisting of the
    cycle, so that |*V[k]*| = |*E[k]*| = *k*. If *k* < |*V*|, then because *G* is
    connected, there must be a vertex *v*[*k*+1]∈ *V* − *V[k]* that is adjacent to
    some vertex *v[i]* ∈ *V[k]*. Define *G*[*k*+1] = (*V*[*k*+1], *E*[*k*+1]) to be
    the subgraph of *G* with *V*[*k*+1] = *V[k]* ∪ {*v*[*k*+1]} and *E*[*k*+1] = *E[k]*
    ∪ {(*v*[*i*], *v*[*k*+1])}. Note that |*V*[*k*+1]| = |*E*[*k*+1]| = *k* + 1\.
    If *k* + 1 < |*V*|, then continue, defining *G*[*k*+2] in the same manner, and
    so forth, until we obtain *G[n]* = (*V[n], E[n]*), where *n* = |*V*|, *V[n]* =
    *V*, and |*E[n]*| = |*V[n]*| = |*V*|. Since *G[n]* is a subgraph of *G*, we have
    *E[n]* ⊆ *E*, and hence |*E*| ≥ |*E[n]*| = |*V[n]*| = |*V*|, which contradicts
    the assumption that |*E*| = |*V*| − 1\. Thus, *G* is acyclic.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '(4) ⇒ (5): 假设*G*是连通的，并且|*E*| = |*V*| − 1\. 我们必须证明*G*是无环的。假设*G*有一个包含*k*个顶点*v*[1]，*v*[2]，…，*v[k]*的环，且不失一般性地假设这个环是简单的。设*G[k]*
    = (*V[k], E[k]*)是由环组成的*G*的子图，使得|*V[k]*| = |*E[k]*| = *k*。如果*k* < |*V*|，那么因为*G*是连通的，必然存在一个顶点*v*[*k*+1]∈
    *V* − *V[k]*，它与某个顶点*v[i]* ∈ *V[k]*相邻。定义*G*[*k*+1] = (*V*[*k*+1], *E*[*k*+1])为*G*的子图，其中*V*[*k*+1]
    = *V[k]* ∪ {*v*[*k*+1]}，*E*[*k*+1] = *E[k]* ∪ {(*v*[*i*], *v*[*k*+1])}。注意到|*V*[*k*+1]|
    = |*E*[*k*+1]| = *k* + 1\. 如果*k* + 1 < |*V*|，则继续，以相同方式定义*G*[*k*+2]，依此类推，直到得到*G[n]*
    = (*V[n], E[n]*)，其中*n* = |*V*|，*V[n]* = *V*，且|*E[n]*| = |*V[n]*| = |*V*|。由于*G[n]*是*G*的子图，我们有*E[n]*
    ⊆ *E*，因此|*E*| ≥ |*E[n]*| = |*V[n]*| = |*V*|，这与假设|*E*| = |*V*| − 1相矛盾。因此，*G*是无环的。'
- en: '(5) ⇒ (6): Suppose that *G* is acyclic and that |*E*| = |*V*| − 1\. Let *k*
    be the number of connected components of *G*. Each connected component is a free
    tree by definition, and since (1) implies (5), the sum of all edges in all connected
    components of *G* is |*V*| − *k*. Consequently, *k* must equal 1, and *G* is in
    fact a tree. Since (1) implies (2), any two vertices in *G* are connected by a
    unique simple path. Thus, adding any edge to *G* creates a cycle.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '(5) ⇒ (6): 假设*G*是无环的，并且|*E*| = |*V*| − 1\. 设*k*是*G*的连通分量的数量。每个连通分量根据定义都是一棵自由树，由于(1)蕴含(5)，*G*的所有连通分量中所有边的总和为|*V*|
    − *k*。因此，*k*必须等于1，*G*实际上是一棵树。由于(1)蕴含(2)，*G*中任意两个顶点都由唯一的简单路径连接。因此，向*G*添加任何边都会形成一个环。'
- en: '(6) ⇒ (1): Suppose that *G* is acyclic but that adding any edge to *E* creates
    a cycle. We must show that *G* is connected. Let *u* and *v* be arbitrary vertices
    in *G*. If *u* and *v* are not already adjacent, adding the edge (*u*, *v*) creates
    a cycle in which all edges but (*u*, *v*) belong to *G*. Thus, the cycle minus
    edge (*u*, *v*) must contain a path from *u* to *v*, and since *u* and *v* were
    chosen arbitrarily, *G* is connected.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '(6) ⇒ (1): 假设*G*是无环的，但添加任何边到*E*都会形成一个环。我们必须证明*G*是连通的。设*u*和*v*是*G*中任意的顶点。如果*u*和*v*不是相邻的，添加边(*u*,
    *v*)会形成一个包含所有边但不包含(*u*, *v*)的环，因此，环减去边(*u*, *v*)必然包含从*u*到*v*的路径，由于*u*和*v*是任意选择的，*G*是连通的。'
- en: ▪
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**B.5.2 Rooted and ordered trees**'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '**B.5.2 根树和有序树**'
- en: A ***rooted tree*** is a free tree in which one of the vertices is distinguished
    from the others. We call the distinguished vertex the ***root*** of the tree.
    We often refer to a vertex of a rooted tree as a ***node***^([5](#footnote_5))
    of the tree. [Figure B.6(a)](#Fig_B-6) shows a rooted tree on a set of 12 nodes
    with root 7.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 一个***根树***是一棵自由树，其中一个顶点与其他顶点有所区别。我们称这个特殊的顶点为树的***根***。我们经常将根树的顶点称为树的***节点***^([5](#footnote_5))。[图B.6(a)](#Fig_B-6)展示了一个包含12个节点且根为7的根树。
- en: '![art](images/Art_P1631.jpg)'
  id: totrans-231
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1631.jpg)'
- en: '**Figure B.6** Rooted and ordered trees. **(a)** A rooted tree with height
    4\. The tree is drawn in a standard way: the root (node 7) is at the top, its
    children (nodes with depth 1) are beneath it, their children (nodes with depth
    2) are beneath them, and so forth. If the tree is ordered, the relative left-to-right
    order of the children of a node matters; otherwise, it doesn’t. **(b)** Another
    rooted tree. As a rooted tree, it is identical to the tree in (a), but as an ordered
    tree it is different, since the children of node 3 appear in a different order.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '**图B.6** 根树和有序树。**(a)** 高度为4的根树。树以标准方式绘制：根（节点7）在顶部，其子节点（深度为1的节点）在其下方，它们的子节点（深度为2的节点）在它们下方，依此类推。如果树是有序的，节点的子节点的相对左右顺序很重要；否则，不重要。**(b)**
    另一棵根树。作为根树，它与(a)中的树相同，但作为有序树，它不同，因为节点3的子节点以不同的顺序出现。'
- en: Consider a node *x* in a rooted tree *T* with root *r*. We call any node *y*
    on the unique simple path from *r* to *x* an ***ancestor*** of *x*. If *y* is
    an ancestor of *x*, then *x* is a ***descendant*** of *y*. (Every node is both
    an ancestor and a descendant of itself.) If *y* is an ancestor of *x* and *x*
    ≠ *y*, then *y* is a ***proper ancestor*** of *x* and *x* is a ***proper descendant***
    of *y*. The ***subtree rooted at x*** is the tree induced by descendants of *x*,
    rooted at *x*. For example, the subtree rooted at node 8 in [Figure B.6(a)](#Fig_B-6)
    contains nodes 8, 6, 5, and 9.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑根为*r*的树*T*中的节点*x*。我们称从*r*到*x*的唯一简单路径上的任何节点*y*为*x*的***祖先节点***。如果*y*是*x*的祖先节点，则*x*是*y*的***后代节点***。（每个节点既是祖先也是后代自己。）如果*y*是*x*的祖先节点且*x*
    ≠ *y*，则*y*是*x*的***真祖先节点***，*x*是*y*的***真后代节点***。以*x*为根的***子树***是由*x*的后代节点组成的树，以*x*为根。例如，[图B.6(a)](#Fig_B-6)中以节点8为根的子树包含节点8、6、5和9。
- en: If the last edge on the simple path from the root *r* of a tree *T* to a node
    *x* is (*y*, *x*), then *y* is the ***parent*** of *x*, and *x* is a ***child***
    of *y*. The root is the only node in *T* with no parent. If two nodes have the
    same parent, they are ***siblings***. A node with no children is a ***leaf***
    or ***external node***. A nonleaf node is an ***internal node***.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从树*T*的根*r*到节点*x*的简单路径上的最后一条边是(*y*, *x*)，那么*y*是*x*的***父节点***，*x*是*y*的***子节点***。根是*T*中唯一没有父节点的节点。如果两个节点有相同的父节点，它们是***兄弟节点***。没有子节点的节点是***叶子节点***或***外部节点***。非叶子节点是***内部节点***。
- en: The number of children of a node *x* in a rooted tree *T* is the ***degree***
    of *x*.^([6](#footnote_6)) The length of the simple path from the root *r* to
    a node *x* is the ***depth*** of *x* in *T*. A ***level*** of a tree consists
    of all nodes at the same depth. The ***height*** of a node in a tree is the number
    of edges on the longest simple downward path from the node to a leaf, and the
    height of a tree is the height of its root. The height of a tree is also equal
    to the largest depth of any node in the tree.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在根树*T*中，节点*x*的子节点数称为*x*的***度***。从根*r*到节点*x*的简单路径的长度称为*x*在*T*中的***深度***。树的一个***层***包括所有深度相同的节点。树中节点的高度是从节点到叶子的最长简单向下路径上的边数，树的高度是其根的高度。树的高度也等于树中任何节点的最大深度。
- en: An ***ordered tree*** is a rooted tree in which the children of each node are
    ordered. That is, if a node has *k* children, then there is a first child, a second
    child, and so on, up to and including a *k*th child. The two trees in [Figure
    B.6](#Fig_B-6) are different when considered to be ordered trees, but the same
    when considered to be just rooted trees.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 一个***有序树***是一个根树，其中每个节点的子节点是有序的。也就是说，如果一个节点有*k*个子节点，则有第一个子节点，第二个子节点，依此类推，直到第*k*个子节点。在考虑为有序树时，[图
    B.6](#Fig_B-6)中的两棵树是不同的，但在考虑为根树时是相同的。
- en: '**B.5.3 Binary and positional trees**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**B.5.3 二叉树和位置树**'
- en: We define binary trees recursively. A ***binary tree*** *T* is a structure defined
    on a finite set of nodes that either
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们递归地定义二叉树。一个***二叉树*** *T* 是在一个有限节点集上定义的结构，它要么
- en: contains no nodes, or
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不包含任何节点，或
- en: 'is composed of three disjoint sets of nodes: a ***root*** node, a binary tree
    called its ***left subtree***, and a binary tree called its ***right subtree***.'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由三个不相交的节点集合组成：一个***根***节点，一个称为***左子树***的二叉树，和一个称为***右子树***的二叉树。
- en: The binary tree that contains no nodes is called the ***empty tree*** or ***null
    tree***, sometimes denoted NIL. If the left subtree is nonempty, its root is called
    the ***left child*** of the root of the entire tree. Likewise, the root of a nonnull
    right subtree is the ***right child*** of the root of the entire tree. If a subtree
    is the null tree NIL, we say that the child is ***absent*** or ***missing***.
    [Figure B.7(a)](#Fig_B-7) shows a binary tree.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 不包含任何节点的二叉树称为***空树***或***空树***，有时表示为NIL。如果左子树非空，则其根称为整个树的***左子节点***。同样，非空右子树的根是整个树的***右子节点***。如果子树是空树NIL，则称该子节点***缺失***或***丢失***。[图
    B.7(a)](#Fig_B-7)展示了一个二叉树。
- en: A binary tree is not simply an ordered tree in which each node has degree at
    most 2\. For example, in a binary tree, if a node has just one child, the position
    of the child—whether it is the ***left child*** or the ***right child***—matters.
    In an ordered tree, there is no distinguishing a sole child as being either left
    or right. [Figure B.7(b)](#Fig_B-7) shows a binary tree that differs from the
    tree in [Figure B.7(a)](#Fig_B-7) because of the position of one node. Considered
    as ordered trees, however, the two trees are identical.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 二叉树不仅仅是每个节点最多有两个子节点的有序树。例如，在二叉树中，如果一个节点只有一个子节点，则子节点的位置——是***左子节点***还是***右子节点***——很重要。在有序树中，无法区分唯一子节点是左子节点还是右子节点。[图
    B.7(b)](#Fig_B-7)展示了一个与[图 B.7(a)](#Fig_B-7)中的树不同的二叉树，因为一个节点的位置不同。然而，从有序树的角度来看，这两棵树是相同的。
- en: 'One way to represent the positioning information in a binary tree is by the
    internal nodes of an ordered tree, as shown in [Figure B.7(c)](#Fig_B-7). The
    idea is to replace each missing child in the binary tree with a node having no
    children. These leaf nodes are drawn as squares in the figure. The tree that results
    is a ***full binary tree***: each node is either a leaf or has degree exactly
    2\. No nodes have degree 1\. Consequently, the order of the children of a node
    preserves the position information.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 表示二叉树中的定位信息的一种方法是通过有序树的内部节点，如[图 B.7(c)](#Fig_B-7)所示。这个想法是用没有子节点的节点替换二叉树中的每个缺失子节点。这些叶节点在图中显示为方块。结果得到的树是一个***完全二叉树***：每个节点要么是叶子，要么恰好有2个子节点。没有节点的度为1。因此，节点的子节点顺序保留了位置信息。
- en: '![art](images/Art_P1632.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1632.jpg)'
- en: '**Figure B.7** Binary trees. **(a)** A binary tree drawn in a standard way.
    The left child of a node is drawn beneath the node and to the left. The right
    child is drawn beneath and to the right. **(b)** A binary tree different from
    the one in (a). In (a), the left child of node 7 is 5 and the right child is absent.
    In (b), the left child of node 7 is absent and the right child is 5\. As ordered
    trees, these trees are the same, but as binary trees, they are distinct. **(c)**
    The binary tree in (a) represented by the internal nodes of a full binary tree:
    an ordered tree in which each internal node has degree 2\. The leaves in the tree
    are shown as squares.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 B.7** 二叉树。**(a)** 以标准方式绘制的二叉树。节点的左子节点绘制在节点下方且向左。右子节点绘制在节点下方且向右。**(b)**
    与(a)中不同的二叉树。在(a)中，节点7的左子节点是5，右子节点不存在。在(b)中，节点7的左子节点不存在，右子节点是5。作为有序树，这些树是相同的，但作为二叉树，它们是不同的。**(c)**
    (a)中的二叉树由完全二叉树的内部节点表示：一棵有序树，其中每个内部节点的度为2。树中的叶子节点显示为方块。'
- en: The positioning information that distinguishes binary trees from ordered trees
    extends to trees with more than two children per node. In a ***positional tree***,
    the children of a node are labeled with distinct positive integers. The *i*th
    child of a node is ***absent*** if no child is labeled with integer *i*. A ***k-ary***
    tree is a positional tree in which for every node, all children with labels greater
    than *k* are missing. Thus, a binary tree is a *k*-ary tree with *k* = 2.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 将二叉树与有序树区分开的定位信息扩展到每个节点有两个以上子节点的树。在一个***位置树***中，节点的子节点用不同的正整数���记。如果没有用整数*i*标记的子节点，则第*i*个子节点***缺失***。一个***k叉***树是一个位置树，对于每个节点，所有标记大于*k*的子节点都缺失。因此，二叉树是一个*k*
    = 2的*k*叉树。
- en: A ***complete k-ary tree*** is a *k*-ary tree in which all leaves have the same
    depth and all internal nodes have degree *k*. [Figure B.8](#Fig_B-8) shows a complete
    binary tree of height 3\. How many leaves does a complete *k*-ary tree of height
    *h* have? The root has *k* children at depth 1, each of which has *k* children
    at depth 2, etc. Thus, the number of nodes at depth *d* is *k^d*. In a complete
    *k*-ary tree with height *h*, the leaves are at depth *h*, so that there are *k^h*
    leaves. Consequently, the height of a complete *k*-ary tree with *n* leaves is
    log[*k*]*n*. A complete *k*-ary tree of height *h* has
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '***完全k元树***是一个*k*元树，其中所有叶子具有相同的深度，所有内部节点的度为*k*。[图B.8](#Fig_B-8)展示了高度为3的完全二叉树。高度为*h*的完全*k*元树有多少叶子？根节点在深度1处有*k*个子节点，每个子节点在深度2处有*k*个子节点，依此类推。因此，在深度*d*处的节点数为*k^d*。在高度为*h*的完全*k*元树中，叶子在深度*h*处，因此有*k^h*个叶子。因此，具有*n*个叶子的完全*k*元树的高度为log[*k*]*n*。高度为*h*的完全*k*元树有'
- en: '![art](images/Art_P1633.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1633.jpg)'
- en: internal nodes. Thus, a complete binary tree has 2^(*h*) − 1 internal nodes.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 内部节点。因此，完全二叉树有2^(*h*) − 1个内部节点。
- en: '![art](images/Art_P1634.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1634.jpg)'
- en: '**Figure B.8** A complete binary tree of height 3 with 8 leaves and 7 internal
    nodes.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '**图B.8** 高度为3且有8个叶子和7个内部节点的完全二叉树。'
- en: '**Exercises**'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***B.5-1***'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.5-1***'
- en: Draw all the free trees composed of the three vertices *x*, *y*, and *z*. Draw
    all the rooted trees with nodes *x*, *y*, and *z* with *x* as the root. Draw all
    the ordered trees with nodes *x*, *y*, and *z* with *x* as the root. Draw all
    the binary trees with nodes *x*, *y*, and *z* with *x* as the root.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制由三个顶点*x*、*y*和*z*组成的所有自由树。绘制具有节点*x*、*y*和*z*且*x*为根的所有根树。绘制具有节点*x*、*y*和*z*且*x*为根的所有有序树。绘制具有节点*x*、*y*和*z*且*x*为根的所有二叉树。
- en: '***B.5-2***'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.5-2***'
- en: Let *G* = (*V*, *E*) be a directed acyclic graph in which there is a vertex
    *v*[0] ∈ *V* such that there exists a unique path from *v*[0] to every vertex
    *v* ∈ *V*. Prove that the undirected version of *G* forms a tree.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 设*G* = (*V*, *E*)是一个有向无环图，其中存在���个顶点*v*[0] ∈ *V*，使得从*v*[0]到每个顶点*v* ∈ *V*都存在一条唯一路径。证明*G*的无向版本形成一棵树。
- en: '***B.5-3***'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.5-3***'
- en: Show by induction that the number of degree-2 nodes in any nonempty binary tree
    is one less than the number of leaves. Conclude that the number of internal nodes
    in a full binary tree is one less than the number of leaves.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 通过归纳法证明任何非空二叉树中度为2的节点数比叶子数少一个。得出结论，完全二叉树中内部节点数比叶子数少一个。
- en: '***B.5-4***'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.5-4***'
- en: Prove that for any integer *k* ≥ 1, there is a full binary tree with *k* leaves.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 证明对于任何整数*k* ≥ 1，都存在具有*k*个叶子的完全二叉树。
- en: '***B.5-5***'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '***B.5-5***'
- en: Use induction to show that a nonempty binary tree with *n* nodes has height
    at least ⌊lg *n*⌋.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 使用归纳法证明，具有*n*个节点的非空二叉树的高度至少为⌊lg *n*⌋。
- en: ★ ***B.5-6***
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***B.5-6***
- en: The ***internal path length*** of a full binary tree is the sum, taken over
    all internal nodes of the tree, of the depth of each node. Likewise, the ***external
    path length*** is the sum, taken over all leaves of the tree, of the depth of
    each leaf. Consider a full binary tree with *n* internal nodes, internal path
    length *i*, and external path length *e*. Prove that *e* = *i* + 2*n*.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 完全二叉树的***内部路径长度***是树的所有内部节点的深度之和。同样，***外部路径长度***是树的所有叶子的深度之和。考虑具有*n*个内部节点、内部路径长度*i*和外部路径长度*e*的完全二叉树。证明*e*
    = *i* + 2*n*。
- en: ★ ***B.5-7***
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***B.5-7***
- en: 'Associate a “weight” *w*(*x*) = 2^(−*d*) with each leaf *x* of depth *d* in
    a binary tree *T*, and let *L* be the set of leaves of *T*. Prove the ***Kraft
    inequality***: Σ[*x*∈*L*] *w*(*x*) ≤ 1.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 将二叉树*T*中深度为*d*的每个叶子*x*关联一个“权重”*w*(*x*) = 2^(−*d*)，并让*L*为*T*的叶子集。证明***Kraft不等式***：Σ[*x*∈*L*] *w*(*x*)
    ≤ 1。
- en: ★ ***B.5-8***
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***B.5-8***
- en: Show that if *L* ≥ 2, then every binary tree with *L* leaves contains a subtree
    having between *L*/3 and 2*L*/3 leaves, inclusive.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 证明如果*L* ≥ 2，则每个具有*L*个叶子的二叉树包含具有*L*/3到2*L*/3个叶子的子树，包括边界值。
- en: '**Problems**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '***B-1 Graph coloring***'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '***B-1 图着色***'
- en: 'A ***k-coloring*** of undirected graph *G* = (*V*, *E*) is a function *c* :
    *V* → {1, 2, … , *k*} such that *c*(*u*) ≠ *c*(*v*) for every edge (*u*, *v*)
    ∈ *E*. In other words, the numbers 1, 2, … , *k* represent the *k* colors, and
    adjacent vertices must have different colors.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 无向图*G* = (*V*, *E*)的***k着色***是一个函数*c*：*V* → {1, 2, … , *k*}，使得对于每条边(*u*, *v*)
    ∈ *E*，*c*(*u*) ≠ *c*(*v*)。换句话说，数字1, 2, … , *k*代表*k*种颜色，相邻的顶点必须具有不同的颜色。
- en: '***a.*** Show that any tree is 2-colorable.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 证明任何树都是2可着色的。'
- en: '***b.*** Show that the following are equivalent:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 证明以下内容是等价的：'
- en: '*G* is bipartite.'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*G*是二分图。'
- en: '*G* is 2-colorable.'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*G*是2可着色的。'
- en: '*G* has no cycles of odd length.'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*G*没有奇数长度的循环。'
- en: '***c.*** Let *d* be the maximum degree of any vertex in a graph *G*. Prove
    that *G* can be colored with *d* + 1 colors.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 设*G*中任意顶点的最大度数为*d*。证明*G*可以用*d* + 1种颜色着色。'
- en: '***d.*** Show that if *G* has *O*(|*V*|) edges, then *G* can be colored with
    ![art](images/Art_P1635.jpg) colors.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 证明如果*G*有*O*(|*V*|)条边，则*G*可以用![art](images/Art_P1635.jpg)种颜色着色。'
- en: '***B-2 Friendly graphs***'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '***B-2 友好图***'
- en: Reword each of the following statements as a theorem about undirected graphs,
    and then prove it. Assume that friendship is symmetric but not reflexive.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下每个陈述重新表述为关于无向图的定理，然后证明它。假设友谊是对称的但不是自反的。
- en: '***a.*** Any group of at least two people contains at least two people with
    the same number of friends in the group.'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 任何至少有两个人的群体中至少有两个人在群体中有相同数量的朋友。'
- en: '***b.*** Every group of six people contains either at least three mutual friends
    or at least three mutual strangers.'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 每个六人组中要么至少有三个相互朋友，要么至少有三个相互陌生人。'
- en: '***c.*** Any group of people can be partitioned into two subgroups such that
    at least half the friends of each person belong to the subgroup of which that
    person is *not* a member.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 任何一组人都可以被划分为两个子组，使得每个人的至少一半朋友属于该人*不*是成员的子组。'
- en: '***d.*** If everyone in a group is the friend of at least half the people in
    the group, then the group can be seated around a table in such a way that everyone
    is seated between two friends.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 如果一个群体中的每个人至少是群体中一半人的朋友，则可以使群体围坐在桌子周围，以便每个人坐在两个朋友之间。'
- en: '***B-3 Bisecting trees***'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '***B-3 二等分树***'
- en: Many divide-and-conquer algorithms that operate on graphs require that the graph
    be bisected into two nearly equal-sized subgraphs, which are induced by a partition
    of the vertices. This problem investigates bisections of trees formed by removing
    a small number of edges. We require that whenever two vertices end up in the same
    subtree after removing edges, then they must belong to the same partition.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 许多在图上操作的分治算法要求将图二等分为两个大小几乎相等的子图，这些子图由顶点的一个划分诱导而成。这个问题研究了通过移除少量边形成的树的二等分。我们要求无论在移除边后两个顶点最终位于同一子树中，它们必须属于同一划分。
- en: '***a.*** Show that the vertices of any *n*-vertex binary tree can be partitioned
    into two sets *A* and *B*, such that |*A*| ≤ 3*n*/4 and |*B*| ≤ 3*n*/4, by removing
    a single edge.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 证明任何*n*个顶点的二叉树的顶点可以通过移除一条边划分为两个集合*A*和*B*，使得|*A*| ≤ 3*n*/4，|*B*| ≤
    3*n*/4。'
- en: '***b.*** Show that the constant 3/4 in part (a) is optimal in the worst case
    by giving an example of a simple binary tree whose most evenly balanced partition
    upon removal of a single edge has |*A*| = 3*n*/4.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 通过给出一个简单二叉树的例子，证明部分(a)中的常数3/4在最坏情况下是最优的，即在移除一条边后，最平衡的划分具有|*A*| = 3*n*/4。'
- en: '***c.*** Show that by removing at most *O*(lg *n*) edges, we can partition
    the vertices of any *n*-vertex binary tree into two sets *A* and *B* such that
    |*A*| = ⌊*n*/2⌋ and |*B*| = ⌈*n*/2⌉.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 证明通过移除最多*O*(lg *n*)条边，我们可以将任何*n*个顶点的二叉树划分为两个集合*A*和*B*，使得|*A*| = ⌊*n*/2⌋，|*B*|
    = ⌈*n*/2⌉。'
- en: '**Appendix notes**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**附录注释**'
- en: G. Boole pioneered the development of symbolic logic, and he introduced many
    of the basic set notations in a book published in 1854\. Modern set theory was
    created by G. Cantor during the period 1874–1895\. Cantor focused primarily on
    sets of infinite cardinality. The term “function” is attributed to G. W. Leibniz,
    who used it to refer to several kinds of mathematical formulas. His limited definition
    has been generalized many times. Graph theory originated in 1736, when L. Euler
    proved that it was impossible to cross each of the seven bridges in the city of
    Königsberg exactly once and return to the starting point.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: G. 布尔开创了符号逻辑的发展，并在1854年出版的一本书中引入了许多基本集合符号。现代集合论是由G. 康托在1874年至1895年期间创立的。康托主要关注无限基数的集合。术语“函数”归因于G.
    W. 莱布尼茨，他用它来指代几种数学公式。他有限的定义已经被广义化多次。图论起源于1736年，当时L. 欧拉证明了在康斯堡市穿过每座桥仅一次并返回起点是不可能的。
- en: The book by Harary [[208](bibliography001.xhtml#endnote_208)] provides a useful
    compendium of many definitions and results from graph theory.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: Harary的书[[208](bibliography001.xhtml#endnote_208)]提供了图论中许多定义和结果的有用汇编。
- en: '[¹](#footnote_ref_1) A variation of a set, which can contain the same object
    more than once, is called a ***multiset***.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[¹](#footnote_ref_1) 一个集合的变体，可以包含相同的对象多次，被称为***多重集***。'
- en: '[²](#footnote_ref_2) Some authors start the natural numbers with 1 instead
    of 0\. The modern trend seems to be to start with 0.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[²](#footnote_ref_2) 一些作者从1开始而不是从0开始自然数。现代趋势似乎是从0开始。'
- en: '[³](#footnote_ref_3) To be precise, in order for the “fit inside” relation
    to be a partial order, we need to view a box as fitting inside itself.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[³](#footnote_ref_3) 要精确，为了使“适合内部”关系成为偏序，我们需要将一个盒子视为适合于自身。'
- en: '[⁴](#footnote_ref_4) Some authors refer to what we call a path as a “walk”
    and to what we call a simple path as just a “path.”'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[⁴](#footnote_ref_4) 一些作者将我们称为路径的东西称为“步行”，将我们称为简单路径的东西称为“路径”。'
- en: '[⁵](#footnote_ref_5) The term “node” is often used in the graph theory literature
    as a synonym for “vertex.” We reserve the term “node” to mean a vertex of a rooted
    tree.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[⁵](#footnote_ref_5) “节点”一词在图论文献中经常被用作“顶点”的同义词。我们将术语“节点”保留为根树的顶点的意思。'
- en: '[⁶](#footnote_ref_6) The degree of a node depends on whether we consider *T*
    to be a rooted tree or a free tree. The degree of a vertex in a free tree is,
    as in any undirected graph, the number of adjacent vertices. In a rooted tree,
    however, the degree is the number of children—the parent of a node does not count
    toward its degree.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[⁶](#footnote_ref_6) 一个节点的度取决于我们将*T*视为根树还是自由树。在自由树中，一个顶点的度，就像在任何无向图中一样，是相邻顶点的数量。然而，在根树中，度是子节点的数量——节点的父节点不计入其度。'
