- en: '[**10        Elementary Data Structures**](toc.xhtml#chap-10)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[**10        基本数据结构**](toc.xhtml#chap-10)'
- en: 'In this chapter, we examine the representation of dynamic sets by simple data
    structures that use pointers. Although you can construct many complex data structures
    using pointers, we present only the rudimentary ones: arrays, matrices, stacks,
    queues, linked lists, and rooted trees.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过使用指针的简单数据结构来检查动态集合的表示。虽然你可以使用指针构建许多复杂的数据结构，但我们只介绍基本的数据结构：数组、矩阵、栈、队列、链表和根树。
- en: '[**10.1    Simple array-based data structures: arrays, matrices, stacks, queues**](toc.xhtml#Rh1-57)'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[**10.1    基于简单数组的数据结构：数组、矩阵、栈��队列**](toc.xhtml#Rh1-57)'
- en: '**10.1.1    Arrays**'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.1.1    数组**'
- en: We assume that, as in most programming languages, an array is stored as a contiguous
    sequence of bytes in memory. If the first element of an array has index *s* (for
    example, in an array with 1-origin indexing, *s* = 1), the array starts at memory
    address *a*, and each array element occupies *b* bytes, then the *i*th element
    occupies bytes *a* + *b*(*i* – *s*) through *a* + *b*(*i* – *s* + 1) – 1\. Since
    most of the arrays in this book are indexed starting at 1, and a few starting
    at 0, we can simplify these formulas a little. When *s* = 1, the *i*th element
    occupies bytes *a* + *b*(*i* – 1) through *a* + *bi* – 1, and when *s* = 0, the
    *i*th element occupies bytes *a* + *bi* through *a* + *b*(*i* + 1) – 1\. Assuming
    that the computer can access all memory locations in the same amount of time (as
    in the RAM model described in [Section 2.2](chapter002.xhtml#Sec_2.2)), it takes
    constant time to access any array element, regardless of the index.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设，与大多数编程语言一样，数组在内存中作为连续的字节序列存储。如果数组的第一个元素具有索引 *s*（例如，在具有 1 起始索引的数组中，*s* =
    1），数组从内存地址 *a* 开始，每个数组元素占据 *b* 字节，则第 *i* 个元素占据字节 *a* + *b*(*i* – *s*) 到 *a* +
    *b*(*i* – *s* + 1) – 1。由于本书中的大多数数组从 1 开始索引，少数从 0 开始索引，我们可以稍微简化这些公式。当 *s* = 1 时，第
    *i* 个元素占据字节 *a* + *b*(*i* – 1) 到 *a* + *bi* – 1，当 *s* = 0 时，第 *i* 个元素占据字节 *a*
    + *bi* 到 *a* + *b*(*i* + 1) – 1。假设计算机可以在相同的时间内访问所有内存位置（如 [第 2.2 节](chapter002.xhtml#Sec_2.2)
    中描述的 RAM 模型），无论索引如何，访问任何数组元素都需要恒定时间。
- en: Most programming languages require each element of a particular array to be
    the same size. If the elements of a given array might occupy different numbers
    of bytes, then the above formulas fail to apply, since the element size *b* is
    not a constant. In such cases, the array elements are usually objects of varying
    sizes, and what actually appears in each array element is a pointer to the object.
    The number of bytes occupied by a pointer is typically the same, no matter what
    the pointer references, so that to access an object in an array, the above formulas
    give the address of the pointer to the object and then the pointer must be followed
    to access the object itself.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数编程语言要求特定数组的每个元素大小相同。如果给定数组的元素可能占用不同数量的字节，则上述公式不适用，因为元素大小 *b* 不是常数。在这种情况下，数组元素通常是大小不同的对象，每个数组元素实际上是指向对象的指针。指针占用的字节数通常是相同的，无论指针引用什么，因此要访问数组中的对象，上述公式给出对象指针的地址，然后必须跟随指针以访问对象本身。
- en: '![art](images/Art_P365.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P365.jpg)'
- en: '**Figure 10.1** Four ways to store the 2 × 3 matrix *M* from equation (10.1).
    **(a)** In row-major order, in a single array. **(b)** In column-major order,
    in a single array. **(c)** In row-major order, with one array per row (tan) and
    a single array (blue) of pointers to the row arrays. **(d)** In column-major order,
    with one array per column (tan) and a single array (blue) of pointers to the column
    arrays.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.1** 存储方程（10.1）中的 2 × 3 矩阵 *M* 的四种方法。 **(a)** 按行主序在单个数组中。 **(b)** 按列主序在单个数组中。
    **(c)** 按行主序，每行一个数组（棕色），一个指向行数组的指针数组（蓝色）。 **(d)** 按列主序，每列一个数组（棕色），一个指向列数组的指针数组（蓝色）。'
- en: '**10.1.2    Matrices**'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.1.2    矩阵**'
- en: We typically represent a matrix or two-dimensional array by one or more one-dimensional
    arrays. The two most common ways to store a matrix are row-major and column-major
    order. Let’s consider an *m* × *n* matrix—a matrix with *m* rows and *n* columns.
    In ***row-major order***, the matrix is stored row by row, and in ***column-major
    order***, the matrix is stored column by column. For example, consider the 2 ×
    3 matrix
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常通过一个或多个一维数组来表示矩阵或二维数组。存储矩阵的两种最常见方式是按行主序和按列主序。让我们考虑一个 *m* × *n* 矩阵，即具有 *m*
    行和 *n* 列的矩阵。在***按行主序***中，矩阵按行存储，而在***按列主序***中，矩阵按列存储。例如，考虑 2 × 3 矩阵
- en: '![art](images/Art_P366.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P366.jpg)'
- en: Row-major order stores the two rows 1 2 3 and 4 5 6, whereas column-major order
    stores the three columns 1 4; 2 5; and 3 6.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 按行主序存储两行 1 2 3 和 4 5 6，而按列主序存储三列 1 4；2 5；和 3 6。
- en: 'Parts (a) and (b) of [Figure 10.1](chapter010.xhtml#Fig_10-1) show how to store
    this matrix using a single one-dimensional array. It’s stored in row-major order
    in part (a) and in column-major order in part (b). If the rows, columns, and the
    single array all are indexed starting at *s*, then *M* [*i*, *j*]—the element
    in row *i* and column *j*—is at array index *s* + (*n*(*i* – *s*)) + (*j* – *s*)
    with row-major order and *s* + (*m*(*j* – *s*)) + (*i* – *s*) with column-major
    order. When *s* = 1, the single-array indices are *n*(*i* – 1) + *j* with row-major
    order and *i* + *m*(*j* – 1) with column-major order. When *s* = 0, the single-array
    indices are simpler: *ni* + *j* with row-major order and *i* + *mj* with column-major
    order. For the example matrix *M* with 1-origin indexing, element *M* [2, 1] is
    stored at index 3(2 – 1) + 1 = 4 in the single array using row-major order and
    at index 2 + 2(1 – 1) = 2 using column-major order.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10.1](chapter010.xhtml#Fig_10-1)的(a)和(b)部分展示了如何使用单一一维数组存储此矩阵。在(a)部分中以行主序存储，在(b)部分中以列主序存储。如果行、列和单一数组都从*s*开始索引，那么*M*
    [*i*, *j*]—第*i*行和第*j*列的元素—在行主序中的数组索引为*s* + (*n*(*i* – *s*)) + (*j* – *s*)，在列主序中为*s*
    + (*m*(*j* – *s*)) + (*i* – *s*)。当*s* = 1时，单一数组索引为*n*(*i* – 1) + *j*，行主序为*i* +
    *m*(*j* – 1)。当*s* = 0时，单一数组索引更简单：*ni* + *j*，行主序为*i* + *mj*。对于具有1起始索引的示例矩阵*M*，元素*M*
    [2, 1]在单一数组中以行主序存储在索引3(2 – 1) + 1 = 4处，在列主序中以索引2 + 2(1 – 1) = 2处。'
- en: Parts (c) and (d) of [Figure 10.1](chapter010.xhtml#Fig_10-1) show multiple-array
    strategies for storing the example matrix. In part (c), each row is stored in
    its own array of length *n*, shown in tan. Another array, with *m* elements, shown
    in blue, points to the *m* row arrays. If we call the blue array *A*, then *A*[*i*]
    points to the array storing the entries for row *i* of *M*, and array element
    *A*[*i*] [*j*] stores matrix element *M* [*i*, *j*]. Part (d) shows the column-major
    version of the multiple-array representation, with *n* arrays, each of length
    *m*, representing the *n* columns. Matrix element *M* [*i*, *j*] is stored in
    array element *A*[*j*] [*i*].
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10.1](chapter010.xhtml#Fig_10-1)的(c)和(d)部分展示了存储示例矩阵的多数组策略。在(c)部分，每行都存储在其自己的长度为*n*的数组中，显示为棕色。另一个具有*m*个元素的数组，显示为蓝色，指向*m*行数组。如果我们称蓝色数组为*A*，那么*A*[*i*]指向存储*M*第*i*行条目的数组，并且数组元素*A*[*i*]
    [*j*]存储矩阵元素*M* [*i*, *j*]。部分(d)显示了多数组表示的列主版本，其中有*n*个长度为*m*的数组，表示*n*列。矩阵元素*M* [*i*,
    *j*]存储在数组元素*A*[*j*] [*i*]中。'
- en: Single-array representations are typically more efficient on modern machines
    than multiple-array representations. But multiple-array representations can sometimes
    be more flexible, for example, allowing for “ragged arrays,” in which the rows
    in the row-major version may have different lengths, or symmetrically for the
    column-major version, where columns may have different lengths.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 单数组表示通常在现代计算机上比多数组表示更有效。但是多数组表示有时更灵活，例如允许“不规则数组”，其中行在行主版本中可能具有不同长度，或者对称地在列主版本中，其中列可能具有不同长度。
- en: Occasionally, other schemes are used to store matrices. In the ***block representation***,
    the matrix is divided into blocks, and each block is stored contiguously. For
    example, a 4 × 4 matrix that is divided into 2 × 2 blocks, such as
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，还会使用其他方案来存储矩阵。在***块表示***中，矩阵被分成块，并且每个块都是连续存储的。例如，将4×4矩阵分成2×2块，如下所示
- en: '![art](images/Art_P367.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P367.jpg)'
- en: might be stored in a single array in the order 〈1, 2, 5, 6, 3, 4, 7, 8, 9, 10,
    13, 14, 11, 12, 15, 16〉.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 可以按顺序将其存储在单个数组中〈1, 2, 5, 6, 3, 4, 7, 8, 9, 10, 13, 14, 11, 12, 15, 16〉。
- en: '**10.1.3    Stacks and queues**'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**10.1.3    栈和队列**'
- en: 'Stacks and queues are dynamic sets in which the element removed from the set
    by the DELETE operation is prespecified. In a ***stack***, the element deleted
    from the set is the one most recently inserted: the stack implements a ***last-in*,
    *first-out***, or ***LIFO***, policy. Similarly, in a ***queue***, the element
    deleted is always the one that has been in the set for the longest time: the queue
    implements a ***first-in, first-out***, or ***FIFO***, policy. There are several
    efficient ways to implement stacks and queues on a computer. Here, you will see
    how to use an array with attributes to store them.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 栈和队列是动态集合，其中通过DELETE操作从集合中删除的元素是预先指定的。在***栈***中，从集合中删除的元素是最近插入的元素：栈实现***后进先出***或***LIFO***策略。同样，在***队列***中，删除的元素始终是在集合中存在时间最长的元素：队列实现***先进先出***或***FIFO***策略。在计算机上有几种有效的方法来���现栈和队列。在这里，您将看到如何使用带有属性的数组来存储它们。
- en: '**Stacks**'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈**'
- en: The INSERT operation on a stack is often called PUSH, and the DELETE operation,
    which does not take an element argument, is often called POP. These names are
    allusions to physical stacks, such as the spring-loaded stacks of plates used
    in cafeterias. The order in which plates are popped from the stack is the reverse
    of the order in which they were pushed onto the stack, since only the top plate
    is accessible.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 栈上的INSERT操作通常称为PUSH，而不带元素参数的DELETE操作通常称为POP。这些名称是对物理栈的暗示，例如在自助餐厅中使用的弹簧加载的盘子堆栈。从栈中弹出盘子的顺序与将其推入栈的顺序相反，因为只有顶部盘子是可访问的。
- en: '[Figure 10.2](chapter010.xhtml#Fig_10-2) shows how to implement a stack of
    at most *n* elements with an array *S*[1 : *n*]. The stack has attributes *S.top*,
    indexing the most recently inserted element, and *S.size*, equaling the size *n*
    of the array. The stack consists of elements *S*[1 : *S.top*], where *S*[1] is
    the element at the bottom of the stack and *S*[*S.top*] is the element at the
    top.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[图10.2](chapter010.xhtml#Fig_10-2)展示了如何使用数组*S*[1 : *n*]实现最多包含*n*个元素的栈。栈具有属性*S.top*，用于索引最近插入的元素，以及*S.size*，等于数组的大小*n*。栈由元素*S*[1
    : *S.top*]组成，其中*S*[1]是栈底的元素，*S*[*S.top*]是栈顶的元素。'
- en: '![art](images/Art_P368.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P368.jpg)'
- en: '**Figure 10.2** An array implementation of a stack *S*. Stack elements appear
    only in the tan positions. **(a)** Stack *S* has 4 elements. The top element is
    9\. **(b)** Stack *S* after the calls PUSH(*S*, 17) and PUSH(*S*, 3). **(c)**
    Stack *S* after the call POP(*S*) has returned the element 3, which is the one
    most recently pushed. Although element 3 still appears in the array, it is no
    longer in the stack. The top is element 17.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.2** 一个栈 *S* 的数组实现。栈元素仅出现在棕色位置。**(a)** 栈 *S* 有 4 个元素。顶部元素是 9。**(b)**
    在调用 PUSH(*S*, 17) 和 PUSH(*S*, 3) 后的栈 *S*。**(c)** 在调用 POP(*S*) 返回元素 3 后，这是最近推入的元素。尽管元素
    3 仍然出现在数组中，但它不再在栈中。顶部是元素 17。'
- en: When *S.top* = 0, the stack contains no elements and is ***empty***. We can
    test whether the stack is empty with the query operation STACK-EMPTY. Upon an
    attempt to pop an empty stack, the stack ***underflows***, which is normally an
    error. If *S.top* exceeds *S.size*, the stack ***overflows***.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *S.top* = 0 时，栈中不包含任何元素，是***空的***。我们可以使用查询操作 STACK-EMPTY 来测试栈是否为空。尝试从空栈中弹出时，栈会***下溢***，通常是一个错误。如果
    *S.top* 超过 *S.size*，栈会***上溢***。
- en: The procedures STACK-EMPTY, PUSH, and POP implement each of the stack operations
    with just a few lines of code. [Figure 10.2](chapter010.xhtml#Fig_10-2) shows
    the effects of the modifying operations PUSH and POP. Each of the three stack
    operations takes *O*(1) time.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: STACK-EMPTY、PUSH 和 POP 这三个栈操作的实现仅需几行代码。[图 10.2](chapter010.xhtml#Fig_10-2) 展示了修改操作
    PUSH 和 POP 的效果。这三个栈操作每个都需要 *O*(1) 时间。
- en: STACK-EMPTY(*S*)
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: STACK-EMPTY(*S*)
- en: '| 1 | **if** *S.top* == 0 |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **如果** *S.top* == 0 |'
- en: '| 2 | **return** TRUE |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **返回** TRUE |'
- en: '| 3 | **else return** FALSE |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **否则返回** FALSE |'
- en: PUSH(*S*, *x*)
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: PUSH(*S*, *x*)
- en: '| 1 | **if** *S.top* == *S.size* |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **如果** *S.top* == *S.size* |'
- en: '| 2 | **error** “overflow” |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **错误** “上溢” |'
- en: '| 3 | **else** *S.top* = *S.top* + 1 |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **否则** *S.top* = *S.top* + 1 |'
- en: '| 4 | *S*[*S.top*] = *x* |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *S*[*S.top*] = *x* |'
- en: POP(*S*)
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: POP(*S*)
- en: '| 1 | **if** STACK-EMPTY(*S*) |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **如果** STACK-EMPTY(*S*) |'
- en: '| 2 | **error** “underflow” |'
  id: totrans-38
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **错��** “下溢” |'
- en: '| 3 | **else** *S.top* = *S.top* – 1 |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **否则** *S.top* = *S.top* – 1 |'
- en: '| 4 | **return** *S*[*S.top* + 1] |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **返回** *S*[*S.top* + 1] |'
- en: '![art](images/Art_P369.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P369.jpg)'
- en: '**Figure 10.3** A queue implemented using an array *Q*[1 : 12]. Queue elements
    appear only in the tan positions. **(a)** The queue has 5 elements, in locations
    *Q*[7 : 11]. **(b)** The configuration of the queue after the calls ENQUEUE(*Q*,
    17), ENQUEUE(*Q*, 3), and ENQUEUE(*Q*, 5). **(c)** The configuration of the queue
    after the call DEQUEUE(*Q*) returns the key value 15 formerly at the head of the
    queue. The new head has key 6.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.3** 使用数组 *Q*[1 : 12] 实现的队列。队列元素仅出现在棕色位置。**(a)** 队列有 5 个元素，位于位置 *Q*[7
    : 11]。**(b)** 在调用 ENQUEUE(*Q*, 17)、ENQUEUE(*Q*, 3) 和 ENQUEUE(*Q*, 5) 后的队列配置。**(c)**
    在调用 DEQUEUE(*Q*) 返回原先在队列头部的键值 15 后的队列配置。新的头部键值为 6。'
- en: '**Queues**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**队列**'
- en: We call the INSERT operation on a queue ENQUEUE, and we call the DELETE operation
    DEQUEUE. Like the stack operation POP, DEQUEUE takes no element argument. The
    FIFO property of a queue causes it to operate like a line of customers waiting
    for service. The queue has a ***head*** and a ***tail***. When an element is enqueued,
    it takes its place at the tail of the queue, just as a newly arriving customer
    takes a place at the end of the line. The element dequeued is always the one at
    the head of the queue, like the customer at the head of the line, who has waited
    the longest.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将队列上的 INSERT 操作称为 ENQUEUE，将 DELETE 操作称为 DEQUEUE。与栈操作 POP 类似，DEQUEUE 不需要元素参数。队列的
    FIFO 特性使其像等待服务的顾客队列一样运作。队列有一个***头部***和一个***尾部***。当一个元素入队时，它会占据队列尾部的位置，就像新到达的顾客会排在队伍的最后。出队的元素总是队列头部的元素，就像队伍中等待时间最长的顾客一样。
- en: '[Figure 10.3](chapter010.xhtml#Fig_10-3) shows one way to implement a queue
    of at most *n* – 1 elements using an array *Q*[1 : *n*], with the attribute *Q.size*
    equaling the size *n* of the array. The queue has an attribute *Q.head* that indexes,
    or points to, its head. The attribute *Q.tail* indexes the next location at which
    a newly arriving element will be inserted into the queue. The elements in the
    queue reside in locations *Q.head*, *Q.head* + 1, … , *Q.tail* – 1, where we “wrap
    around” in the sense that location 1 immediately follows location *n* in a circular
    order. When *Q.head* = *Q.tail*, the queue is empty. Initially, we have *Q.head*
    = *Q.tail* = 1\. An attempt to dequeue an element from an empty queue causes the
    queue to underflow. When *Q.head* = *Q.tail* + 1 or both *Q.head* = 1 and *Q.tail*
    = *Q.size*, the queue is full, and an attempt to enqueue an element causes the
    queue to overflow.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.3](chapter010.xhtml#Fig_10-3) 展示了使用数组 *Q*[1 : *n*] 实现最多 *n* – 1 个元素的队列的一种方法，其中属性
    *Q.size* 等于数组的大小 *n*。队列有一个属性 *Q.head* 用于索引或指向其头部。属性 *Q.tail* 索引下一个位置，新到达的元素将插入队列中。队列中的元素位于位置
    *Q.head*、*Q.head* + 1，…，*Q.tail* – 1，我们在循环顺序中“环绕”，即位置 1 紧随位置 *n*。当 *Q.head* =
    *Q.tail* 时，队列为空。最初，我们有 *Q.head* = *Q.tail* = 1。尝试从空队列中出队元素会导致队列下溢。当 *Q.head* =
    *Q.tail* + 1 或者 *Q.head* = 1 且 *Q.tail* = *Q.size* 时，队列已满，尝试入队元素会导致队列上溢。'
- en: In the procedures ENQUEUE and DEQUEUE, we have omitted the error checking for
    underflow and overflow. (Exercise 10.1-5 asks you to supply these checks.) [Figure
    10.3](chapter010.xhtml#Fig_10-3) shows the effects of the ENQUEUE and DEQUEUE
    operations. Each operation takes *O*(1) time.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 ENQUEUE 和 DEQUEUE 过程中，我们省略了下溢和上溢的错误检查。（练习 10.1-5 要求您提供这些检查。）[图 10.3](chapter010.xhtml#Fig_10-3)
    展示了 ENQUEUE 和 DEQUEUE 操作的效果。每个操作都需要 *O*(1) 时间。
- en: ENQUEUE(*Q*, *x*)
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: ENQUEUE(*Q*, *x*)
- en: '| 1 | *Q*[*Q.tail*] = *x* |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *Q*[*Q.tail*] = *x* |'
- en: '| 2 | **if** *Q.tail* == *Q.size* |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **如果** *Q.tail* == *Q.size* |'
- en: '| 3 | *Q.tail* = 1 |'
  id: totrans-50
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *Q.tail* = 1 |'
- en: '| 4 | **else** *Q.tail* = *Q.tail* + 1 |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **否则** *Q.tail* = *Q.tail* + 1 |'
- en: DEQUEUE(*Q*)
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: DEQUEUE(*Q*)
- en: '| 1 | *x* = *Q*[*Q.head*] |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *x* = *Q*[*Q.head*] |'
- en: '| 2 | **if** *Q.head* == *Q.size* |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **如果** *Q.head* == *Q.size* |'
- en: '| 3 | *Q.head* = 1 |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *Q.head* = 1 |'
- en: '| 4 | **else** *Q.head* = *Q.head* + 1 |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **否则** *Q.head* = *Q.head* + 1 |'
- en: '| 5 | **return** *x* |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **返回** *x* |'
- en: '**Exercises**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***10.1-1***'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.1-1***'
- en: Consider an *m* × *n* matrix in row-major order, where both *m* and *n* are
    powers of 2 and rows and columns are indexed from 0\. We can represent a row index
    *i* in binary by the lg *m* bits 〈*i*[lg *m* – 1], *i*[lg *m* – 2], … , *i*[0]〉
    and a column index *j* in binary by the lg *n* bits 〈*j*[lg *n* – 1], *j*[lg *n*
    – 2], … , *j*[0]〉. Suppose that this matrix is a 2 × 2 block matrix, where each
    block has *m*/2 rows and *n*/2 columns, and it is to be represented by a single
    array with 0-origin indexing. Show how to construct the binary representation
    of the (lg *m* + lg *n*)-bit index into the single array from the binary representations
    of *i* and *j*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个*m* × *n*矩阵按行主序排列，其中*m*和*n*都是2的幂，行和列从0开始索引。我们可以用二进制表示一个行索引*i*，通过lg *m*位
    〈*i*[lg *m* – 1], *i*[lg *m* – 2], … , *i*[0]〉，以及用二进制表示一个列索引*j*，通过lg *n*位 〈*j*[lg
    *n* – 1], *j*[lg *n* – 2], … , *j*[0]〉。假设这个矩阵是一个2 × 2的块矩阵，每个块有*m*/2行和*n*/2列，并且要用一个单一数组表示，索引从0开始。展示如何从*i*和*j*的二进制表示构造出(lg
    *m* + lg *n*)位索引到单一数组的二进制表示。
- en: '***10.1-2***'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.1-2***'
- en: 'Using [Figure 10.2](chapter010.xhtml#Fig_10-2) as a model, illustrate the result
    of each operation in the sequence PUSH(*S*, 4), PUSH(*S*, 1), PUSH(*S*, 3), POP(*S*),
    PUSH(*S*, 8), and POP(*S*) on an initially empty stack *S* stored in array *S*[1
    : 6]'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '使用[图10.2](chapter010.xhtml#Fig_10-2)作为模型，说明在初始为空的数组*S*[1 : 6]中存储的栈*S*上的每个操作序列PUSH(*S*,
    4)，PUSH(*S*, 1)，PUSH(*S*, 3)，POP(*S*)，PUSH(*S*, 8)和POP(*S*)的结果。'
- en: '***10.1-3***'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.1-3***'
- en: 'Explain how to implement two stacks in one array *A*[1 : *n*] in such a way
    that neither stack overflows unless the total number of elements in both stacks
    together is *n*. The PUSH and POP operations should run in *O*(1) time.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '解释如何在一个数组*A*[1 : *n*]中实现两个栈，使得两个栈的元素总数不超过*n*。PUSH和POP操作应该在*O*(1)时间内完成。'
- en: '***10.1-4***'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.1-4***'
- en: 'Using [Figure 10.3](chapter010.xhtml#Fig_10-3) as a model, illustrate the result
    of each operation in the sequence ENQUEUE(*Q*, 4), ENQUEUE(*Q*, 1), ENQUEUE(*Q*,
    3), DEQUEUE(*Q*), ENQUEUE(*Q*, 8), and DEQUEUE(*Q*) on an initially empty queue
    *Q* stored in array *Q*[1 : 6].'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '使用[图10.3](chapter010.xhtml#Fig_10-3)作为模型，说明在初始为空的数组*Q*[1 : 6]中存储的队列*Q*上的每个操作序列ENQUEUE(*Q*,
    4)，ENQUEUE(*Q*, 1)，ENQUEUE(*Q*, 3)，DEQUEUE(*Q*)，ENQUEUE(*Q*, 8)和DEQUEUE(*Q*)的结果。'
- en: '***10.1-5***'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.1-5***'
- en: Rewrite ENQUEUE and DEQUEUE to detect underflow and overflow of a queue.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重写ENQUEUE和DEQUEUE以检测队列的下溢和上溢。
- en: '***10.1-6***'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.1-6***'
- en: Whereas a stack allows insertion and deletion of elements at only one end, and
    a queue allows insertion at one end and deletion at the other end, a ***deque***
    (double-ended queue, pronounced like “deck”) allows insertion and deletion at
    both ends. Write four *O*(1)-time procedures to insert elements into and delete
    elements from both ends of a deque implemented by an array.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 而栈只允许在一个端口插入和删除元素，队列允许在一个端口插入和在另一个端口删除元素，一个***双端队列***（double-ended queue，发音类似于“deck”）允许在两端插入和删除元素。编写四个*O*(1)时间的过程，用于在数组中实现一个双端队列中插入和删除元素。
- en: '***10.1-7***'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.1-7***'
- en: Show how to implement a queue using two stacks. Analyze the running time of
    the queue operations.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何使用两个栈实现一个队列。分析队列操作的运行时间。
- en: '***10.1-8***'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.1-8***'
- en: Show how to implement a stack using two queues. Analyze the running time of
    the stack operations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何使用两个队列实现一个栈。分析栈操作的运行时间。
- en: '[**10.2    Linked lists**](toc.xhtml#Rh1-58)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[**10.2    链表**](toc.xhtml#Rh1-58)'
- en: A ***linked list*** is a data structure in which the objects are arranged in
    a linear order. Unlike an array, however, in which the linear order is determined
    by the array indices, the order in a linked list is determined by a pointer in
    each object. Since the elements of linked lists often contain keys that can be
    searched for, linked lists are sometimes called ***search lists***. Linked lists
    provide a simple, flexible representation for dynamic sets, supporting (though
    not necessarily efficiently) all the operations listed on page 250.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 一个***链表***是一种数据结构，其中对象按线性顺序排列。然而，与数组不同，数组索引确定了线性顺序，链表中的顺序由每个对象中的指针确定。由于链表的元素通常包含可搜索的键，因此有时称为***搜索列表***。链表为动态集合提供了简单、灵活的表示，支持（尽管不一定高效地）250页上列出的所有操作。
- en: 'As shown in [Figure 10.4](chapter010.xhtml#Fig_10-4), each element of a ***doubly
    linked list*** *L* is an object with an attribute *key* and two pointer attributes:
    *next* and *prev*. The object may also contain other satellite data. Given an
    element *x* in the list, *x.next* points to its successor in the linked list,
    and *x.prev* points to its predecessor. If *x.prev* = NIL, the element *x* has
    no predecessor and is therefore the first element, or ***head***, of the list.
    If *x.next* = NIL, the element *x* has no successor and is therefore the last
    element, or ***tail***, of the list. An attribute *L.head* points to the first
    element of the list. If *L.head* = NIL, the list is empty.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图10.4](chapter010.xhtml#Fig_10-4)所示，***双向链表*** *L*的每个元素都是一个带有属性*key*和两个指针属性*next*和*prev*的对象。对象还可以包含其他卫星数据。给定列表中的元素*x*，*x.next*指向链表中的后继，*x.prev*指向前驱。如果*x.prev*
    = NIL，则元素*x*没有前驱，因此是列表的第一个元素，或***头部***。如果*x.next* = NIL，则元素*x*没有后继，因此是列表的最后一个元素，或***尾部***。属性*L.head*指向列表的第一个元素。如果*L.head*
    = NIL，则列表为空。
- en: '![art](images/Art_P370.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P370.jpg)'
- en: '**Figure 10.4 (a)** A doubly linked list *L* representing the dynamic set {1,
    4, 9, 16}. Each element in the list is an object with attributes for the key and
    pointers (shown by arrows) to the next and previous objects. The *next* attribute
    of the tail and the *prev* attribute of the head are NIL, indicated by a diagonal
    slash. The attribute *L.head* points to the head. **(b)** Following the execution
    of LIST-PREPEND(*L*, *x*), where *x.key* = 25, the linked list has an object with
    key 25 as the new head. This new object points to the old head with key 9\. **(c)**
    The result of calling LIST-INSERT(*x*, *y*), where *x.key* = 36 and *y* points
    to the object with key 9\. **(d)** The result of the subsequent call LIST-DELETE(*L*,
    *x*), where *x* points to the object with key 4.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.4 (a)** 代表动态集合{1, 4, 9, 16}的双向链接列表*L*。列表中的每个元素都是一个具有键和指向下一个和上一个对象的指针（由箭头表示）的对象。尾部的*next*属性和头部的*prev*属性都是NIL，用斜线表示。属性*L.head*指向头部。**(b)**
    在执行LIST-PREPEND(*L*, *x*)后，其中*x.key* = 25，链表中有一个键为25的新头部对象。这个新对象指向键为9的旧头部。**(c)**
    调用LIST-INSERT(*x*, *y*)的结果，其中*x.key* = 36，*y*指向键为9的对象。**(d)** 调用LIST-DELETE(*L*,
    *x*)后的结果，其中*x*指向键为4的对象。'
- en: A list may have one of several forms. It may be either singly linked or doubly
    linked, it may be sorted or not, and it may be circular or not. If a list is ***singly
    linked***, each element has a *next* pointer but not a *prev* pointer. If a list
    is ***sorted***, the linear order of the list corresponds to the linear order
    of keys stored in elements of the list. The minimum element is then the head of
    the list, and the maximum element is the tail. If the list is ***unsorted***,
    the elements can appear in any order. In a ***circular list***, the *prev* pointer
    of the head of the list points to the tail, and the *next* pointer of the tail
    of the list points to the head. You can think of a circular list as a ring of
    elements. In the remainder of this section, we assume that the lists we are working
    with are unsorted and doubly linked.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 一个列表可能有几种形式。它可以是单向链接的，也可以是双向链接的，可以是排序的，也可以是非排序的，还可以是循环的或非循环的。如果列表是***单向链接***的，每个元素都有一个*next*指针，但没有*prev*指针。如果列表是***排序的***，列表的线性顺序对应于列表中元素存储的键的线性顺序。最小元素是列表的头部，最大元素是尾部。如果列表是***非排序的***，元素可以以任何顺序出现。在***循环列表***中，列表头部的*prev*指针指向尾部，列表尾部的*next*指针指向头部。你可以将循环列表看作是一圈元素。在本节的其余部分，我们假设我们正在处理的列表是非排序的、双向链接的。
- en: '**Searching a linked list**'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '**搜索链表**'
- en: The procedure LIST-SEARCH(*L*, *k*) finds the first element with key *k* in
    list *L* by a simple linear search, returning a pointer to this element. If no
    object with key *k* appears in the list, then the procedure returns NIL. For the
    linked list in [Figure 10.4(a)](chapter010.xhtml#Fig_10-4), the call LIST-SEARCH(*L*,
    4) returns a pointer to the third element, and the call LIST-SEARCH(*L*, 7) returns
    NIL. To search a list of *n* objects, the LIST-SEARCH procedure takes Θ(*n*) time
    in the worst case, since it may have to search the entire list.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: LIST-SEARCH(*L*, *k*)过程通过简单的线性搜索在列表*L*中找到具有键*k*的第一个元素，并返回指向该元素的指针。如果列表中没有键*k*的对象，则该过程返回NIL。对于[图10.4(a)](chapter010.xhtml#Fig_10-4)中的链表，调用LIST-SEARCH(*L*,
    4)返回指向第三个元素的指针，调用LIST-SEARCH(*L*, 7)返回NIL。要搜索包含*n*个对象的列表，LIST-SEARCH过程在最坏情况下需要Θ(*n*)时间，因为��可能需要搜索整个列表。
- en: LIST-SEARCH(*L*, *k*)
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: LIST-SEARCH(*L*, *k*)
- en: '| 1 | *x* = *L.head* |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *x* = *L.head* |'
- en: '| 2 | **while** *x* ≠ NIL and *x.key* ≠ *k* |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **while** *x* ≠ NIL and *x.key* ≠ *k* |'
- en: '| 3 | *x* = *x.next* |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *x* = *x.next* |'
- en: '| 4 | **return** *x* |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **return** *x* |'
- en: '**Inserting into a linked list**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**向链表中插入**'
- en: Given an element *x* whose *key* attribute has already been set, the LIST-PREPEND
    procedure adds *x* to the front of the linked list, as shown in [Figure 10.4(b)](chapter010.xhtml#Fig_10-4).
    (Recall that our attribute notation can cascade, so that *L.head.prev* denotes
    the *prev* attribute of the object that *L.head* points to.) The running time
    for LIST-PREPEND on a list of *n* elements is *O*(1).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个已经设置了*key*属性的元素*x*，LIST-PREPEND过程将*x*添加到链表的前面，如[图10.4(b)](chapter010.xhtml#Fig_10-4)所示。
    （回想一下，我们的属性表示法可以级联，因此*L.head.prev*表示*L.head*指向的对象的*prev*属性。）在包含*n*个元素的列表上，LIST-PREPEND的运行时间为*O*(1)。
- en: LIST-PREPEND(*L*, *x*)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: LIST-PREPEND(*L*, *x*)
- en: '| 1 | *x.next* = *L.head* |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *x.next* = *L.head* |'
- en: '| 2 | *x.prev* = NIL |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *x.prev* = NIL |'
- en: '| 3 | **if** *L.head* ≠ NIL |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **if** *L.head* ≠ NIL |'
- en: '| 4 | *L.head.prev* = *x* |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *L.head.prev* = *x* |'
- en: '| 5 | *L.head* = *x* |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 5 | *L.head* = *x* |'
- en: You can insert anywhere within a linked list. As [Figure 10.4(c)](chapter010.xhtml#Fig_10-4)
    shows, if you have a pointer *y* to an object in the list, the LIST-INSERT procedure
    on the facing page “splices” a new element *x* into the list, immediately following
    *y*, in *O*(1) time. Since LIST-INSERT never references the list object *L*, it
    is not supplied as a parameter.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在链表中可以随意插入元素。如[图10.4(c)](chapter010.xhtml#Fig_10-4)所示，如果你有一个指向列表中对象的指针*y*，则在面对页面上的LIST-INSERT过程会在*O*(1)时间内将一个新元素*x*“拼接”到列表中，紧随*y*之后。由于LIST-INSERT从不引用列表对象*L*，因此不需要将其作为参数提供。
- en: LIST-INSERT(*x*, *y*)
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: LIST-INSERT(*x*, *y*)
- en: '| 1 | *x.next* = *y.next* |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *x.next* = *y.next* |'
- en: '| 2 | *x.prev* = *y* |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *x.prev* = *y* |'
- en: '| 3 | **if** *y.next* ≠ NIL |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **if** *y.next* ≠ NIL |'
- en: '| 4 | *y.next.prev* = *x* |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *y.next.prev* = *x* |'
- en: '| 5 | *y.next* = *x* |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 5 | *y.next* = *x* |'
- en: '**Deleting from a linked list**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**从链表中删除**'
- en: The procedure LIST-DELETE removes an element *x* from a linked list *L*. It
    must be given a pointer to *x*, and it then “‘splices” *x* out of the list by
    updating pointers. To delete an element with a given key, first call LIST-SEARCH
    to retrieve a pointer to the element. [Figure 10.4(d)](chapter010.xhtml#Fig_10-4)
    shows how an element is deleted from a linked list. LIST-DELETE runs in *O*(1)
    time, but to delete an element with a given key, the call to LIST-SEARCH makes
    the worst-case running time be Θ(*n*).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 过程LIST-DELETE从链表*L*中移除元素*x*。它必须给出指向*x*的指针，然后通过更新指针“剪接”*x*出列表。要删除具有给定键的元素，首先调用LIST-SEARCH检索指向元素的指针。[图10.4(d)](chapter010.xhtml#Fig_10-4)展示了如何从链表中删除一个元素。LIST-DELETE在*O*(1)时间内运行，但要删除具有给定键的元素，调用LIST-SEARCH使得最坏情况运行时间为Θ(*n*)。
- en: LIST-DELETE(*L*, *x*)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: LIST-DELETE(*L*, *x*)
- en: '| 1 | **if** *x.prev* ≠ NIL |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **if** *x.prev* ≠ NIL |'
- en: '| 2 | *x.prev.next* = *x.next* |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *x.prev.next* = *x.next* |'
- en: '| 3 | **else** *L.head* = *x.next* |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **else** *L.head* = *x.next* |'
- en: '| 4 | **if** *x.next* ≠ NIL |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **if** *x.next* ≠ NIL |'
- en: '| 5 | *x.next.prev* = *x.prev* |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| 5 | *x.next.prev* = *x.prev* |'
- en: Insertion and deletion are faster operations on doubly linked lists than on
    arrays. If you want to insert a new first element into an array or delete the
    first element in an array, maintaining the relative order of all the existing
    elements, then each of the existing elements needs to be moved by one position.
    In the worst case, therefore, insertion and deletion take Θ(*n*) time in an array,
    compared with *O*(1) time for a doubly linked list. (Exercise 10.2-1 asks you
    to show that deleting an element from a singly linked list takes Θ(*n*) time in
    the worst case.) If, however, you want to find the *k*th element in the linear
    order, it takes just *O*(1) time in an array regardless of *k*, but in a linked
    list, you’d have to traverse *k* elements, taking Θ(*k*) time.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在双向链表上，插入和删除操作比在数组上快。如果要在数组中插入一个新的第一个元素或删除数组中的第一个元素，并保持所有现有元素的相对顺序，那么每个现有元素都需要移动一个位置。因此，在数组中，插入和删除在最坏情况下需要Θ(*n*)时间，而在双向链表中只需要*O*(1)时间。
    （练习10.2-1要求您证明从单链表中删除元素在最坏情况下需要Θ(*n*)时间。）然而，如果要在线性顺序中找到第*k*个元素，在数组中只需要*O*(1)时间，而在链表中，您需要遍历*k*个元素，需要Θ(*k*)时间。
- en: '**Sentinels**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**哨兵**'
- en: 'The code for LIST-DELETE is simpler if you ignore the boundary conditions at
    the head and tail of the list:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: LIST-DELETE的代码如果忽略列表头部和尾部的边界条件会更简单：
- en: '![art](images/Art_P371.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P371.jpg)'
- en: '**Figure 10.5** A circular, doubly linked list with a sentinel. The sentinel
    *L.nil*, in blue, appears between the head and tail. The attribute *L.head* is
    no longer needed, since the head of the list is *L.nil.next*. **(a)** An empty
    list. **(b)** The linked list from [Figure 10.4(a)](chapter010.xhtml#Fig_10-4),
    with key 9 at the head and key 1 at the tail. **(c)** The list after executing
    LIST-INSERT′ (*x*, *L.nil*), where *x.key* = 25\. The new object becomes the head
    of the list. **(d)** The list after deleting the object with key 1\. The new tail
    is the object with key 4\. **(e)** The list after executing LIST-INSERT′ (*x*,
    *y*), where *x.key* = 36 and *y* points to the object with key 9.'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '**图10.5** 带有哨兵的循环双向链表。蓝色的哨兵*L.nil*出现在头部和尾部之间。由于列���头部是*L.nil.next*，因此不再需要属性*L.head*。**(a)**
    空列表。**(b)** 来自[图10.4(a)](chapter010.xhtml#Fig_10-4)的链表，头部为键9，尾部为键1。**(c)** 执行LIST-INSERT′
    (*x*, *L.nil*)后的列表，其中*x.key* = 25。新对象成为列表的头部。**(d)** 删除键为1的对象后的列表。新尾部是键为4的对象。**(e)**
    执行LIST-INSERT′ (*x*, *y*)后的列表，其中*x.key* = 36，*y*指向键为9的对象。'
- en: LIST-DELETE′ (*x*)
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: LIST-DELETE′ (*x*)
- en: '| 1 | *x.prev.next* = *x.next* |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *x.prev.next* = *x.next* |'
- en: '| 2 | *x.next.prev* = *x.prev* |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *x.next.prev* = *x.prev* |'
- en: A ***sentinel*** is a dummy object that allows us to simplify boundary conditions.
    In a linked list *L*, the sentinel is an object *L.nil* that represents NIL but
    has all the attributes of the other objects in the list. References to NIL are
    replaced by references to the sentinel *L.nil*. As shown in [Figure 10.5](chapter010.xhtml#Fig_10-5),
    this change turns a regular doubly linked list into a ***circular, doubly linked
    list with a sentinel***, in which the sentinel *L.nil* lies between the head and
    tail. The attribute *L.nil.next* points to the head of the list, and *L.nil.prev*
    points to the tail. Similarly, both the *next* attribute of the tail and the *prev*
    attribute of the head point to *L.nil*. Since *L.nil.next* points to the head,
    the attribute *L.head* is eliminated altogether, with references to it replaced
    by references to *L.nil.next*. [Figure 10.5(a)](chapter010.xhtml#Fig_10-5) shows
    that an empty list consists of just the sentinel, and both *L.nil.next* and *L.nil.prev*
    point to *L.nil*.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '***哨兵***是一个虚拟对象，允许我们简化边界条件。在链表*L*中，哨兵是一个代表NIL的对象*L.nil*，但具有列表中其他对象的所有属性。对NIL的引用被替换为对哨兵*L.nil*的引用。如[图10.5](chapter010.xhtml#Fig_10-5)所示，这个改变将一个常规的双向链表转变为一个带有哨兵的***循环双向链表***，其中哨兵*L.nil*位于头部和尾部之间。属性*L.nil.next*指向列表的头部，*L.nil.prev*指向尾部。同样，尾部的*next*属性和头部的*prev*属性都指向*L.nil*。由于*L.nil.next*指向头部，属性*L.head*被完全消除，引用被替换为*L.nil.next*的引用。[图10.5(a)](chapter010.xhtml#Fig_10-5)显示了一个空列表只包含哨兵，*L.nil.next*和*L.nil.prev*都指向*L.nil*。'
- en: To delete an element from the list, just use the two-line procedure LIST-DELETE′
    from before. Just as LIST-INSERT never references the list object *L*, neither
    does LIST-DELETE′. You should never delete the sentinel *L.nil* unless you are
    deleting the entire list!
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要从列表中删除一个元素，只需使用之前的两行过程LIST-DELETE′。就像LIST-INSERT从不引用列表对象*L*一样，LIST-DELETE′也不会。除非你要删除整个列表，否则永远不要删除哨兵*L.nil*！
- en: 'The LIST-INSERT′ procedure inserts an element *x* into the list following object
    *y*. No separate procedure for prepending is necessary: to insert at the head
    of the list, let *y* be *L.nil*; and to insert at the tail, let *y* be *L.nil.prev*.
    [Figure 10.5](chapter010.xhtml#Fig_10-5) shows the effects of LIST-INSERT′ and
    LIST-DELETE′ on a sample list.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: LIST-INSERT′过程将元素*x*插入到对象*y*之后的列表中。不需要单独的前置过程：要在列表头部插入，让*y*为*L.nil*；要在尾部插入，让*y*为*L.nil.prev*。[图10.5](chapter010.xhtml#Fig_10-5)展示了LIST-INSERT′和LIST-DELETE′对示例列表的影响。
- en: LIST-INSERT′ (*x*, *y*)
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: LIST-INSERT′ (*x*, *y*)
- en: '| 1 | *x.next* = *y.next* |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *x.next* = *y.next* |'
- en: '| 2 | *x.prev* = *y* |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *x.prev* = *y* |'
- en: '| 3 | *y.next.prev* = *x* |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *y.next.prev* = *x* |'
- en: '| 4 | *y.next* = *x* |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *y.next* = *x* |'
- en: 'Searching a circular, doubly linked list with a sentinel has the same asymptotic
    running time as without a sentinel, but it is possible to decrease the constant
    factor. The test in line 2 of LIST-SEARCH makes two comparisons: one to check
    whether the search has run off the end of the list and, if not, one to check whether
    the key resides in the current element *x*. Suppose that you *know* that the key
    is somewhere in the list. Then you do not need to check whether the search runs
    off the end of the list, thereby eliminating one comparison in each iteration
    of the **while** loop.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 使用哨兵的循环双向链表搜索具有与不使用哨兵相同的渐近运行时间，但可以减少常数因子。LIST-SEARCH中第2行的测试进行两次比较：一次检查搜索是否已经超出列表的末尾，如果没有，则检查关键字是否位于当前元素*x*中。假设你*知道*关键字在列表中的某处。那么你就不需要检查搜索是否超出列表的末尾，从而在**while**循环的每次迭代中消除一次比较。
- en: The sentinel provides a place to put the key before starting the search. The
    search starts at the head *L.nil.next* of list *L*, and it stops if it finds the
    key somewhere in the list. Now the search is guaranteed to find the key, either
    in the sentinel or before reaching the sentinel. If the key is found before reaching
    the sentinel, then it really is in the element where the search stops. If, however,
    the search goes through all the elements in the list and finds the key only in
    the sentinel, then the key is not really in the list, and the search returns NIL.
    The procedure LIST-SEARCH′ embodies this idea. (If your sentinel requires its
    *key* attribute to be NIL, then you might want to assign *L.nil.key* = NIL before
    line 5.)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 哨兵提供了一个放置关键字的位置，用于开始搜索。搜索从列表*L*的头部*L.nil.next*开始，并且如果在列表中找到关键字，则停止。现在搜索保证会在哨兵或在到达哨兵之前找到关键字。如果在到达哨兵之前找到了关键字，那么它确实在搜索停止的元素中。然而，如果搜索遍历列表中的所有元素，并且只在哨兵中找到关键字，则关键字实际上不在列表中，搜索返回NIL。LIST-SEARCH′过程体现了这个想法。（如果你的哨兵需要其*key*属性为NIL，则可能需要在第5行之前分配*L.nil.key*
    = NIL。）
- en: LIST-SEARCH′ (*L*, *k*)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: LIST-SEARCH′ (*L*, *k*)
- en: '| 1 | *L.nil.key* = *k* | **//** store the key in the sentinel to guarantee
    it is in list |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *L.nil.key* = *k* | **//** 将关���字存储在哨兵中以确保其在列表中 |'
- en: '| 2 | *x* = *L.nil.next* | **//** start at the head of the list |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *x* = *L.nil.next* | **//** 从列表头部开始 |'
- en: '| 3 | **while** *x.key* ≠ *k* |  |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **while** *x.key* ≠ *k* |  |'
- en: '| 4 | *x* = *x.next* |  |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *x* = *x.next* |  |'
- en: '| 5 | **if** *x* == *L.nil* | **//** found *k* in the sentinel |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **if** *x* == *L.nil* | **//** 在哨兵中找到*k* |'
- en: '| 6 | **return** NIL | **//** *k* was not really in the list |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 6 | **return** NIL | **//** *k*实际上不在列表中 |'
- en: '| 7 | **else return** *x* | **//** found *k* in element *x* |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 7 | **else return** *x* | **//** 在元素*x*中找到*k* |'
- en: Sentinels often simplify code and, as in searching a linked list, they might
    speed up code by a small constant factor, but they don’t typically improve the
    asymptotic running time. Use them judiciously. When there are many small lists,
    the extra storage used by their sentinels can represent significant wasted memory.
    In this book, we use sentinels only when they significantly simplify the code.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 哨兵通常简化代码，并且在搜索链表时，它们可能通过一个小的常数因子加速代码，但通常不会改善渐近运行时间。要明智地使用它们。当存在许多小列表时，它们的哨兵使用的额外存储可能代表显著的浪费内存。在本书中，我们仅在它们显著简化代码时使用哨兵。
- en: '**Exercises**'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***10.2-1***'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.2-1***'
- en: Explain why the dynamic-set operation INSERT on a singly linked list can be
    implemented in *O*(1) time, but the worst-case time for DELETE is Θ(*n*).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 解释为什么在单链表上实现的动态集操作INSERT可以在*O*(1)时间内完成，但DELETE的最坏情况时间为Θ(*n*)。
- en: '***10.2-2***'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.2-2***'
- en: Implement a stack using a singly linked list. The operations PUSH and POP should
    still take *O*(1) time. Do you need to add any attributes to the list?
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单链表实现一个栈。操作PUSH和POP仍然应该在*O*(1)时间内完成。你需要向列表添加任何属性吗？
- en: '***10.2-3***'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.2-3***'
- en: Implement a queue using a singly linked list. The operations ENQUEUE and DEQUEUE
    should still take *O*(1) time. Do you need to add any attributes to the list?
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单链表实现一个队列。操作ENQUEUE和DEQUEUE仍然应该在*O*(1)时间内完成。你需要向列表添加任何属性吗？
- en: '***10.2-4***'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.2-4***'
- en: The dynamic-set operation UNION takes two disjoint sets *S*[1] and *S*[2] as
    input, and it returns a set *S* = *S*[1] ⋃ *S*[2] consisting of all the elements
    of *S*[1] and *S*[2]. The sets *S*[1] and *S*[2] are usually destroyed by the
    operation. Show how to support UNION in *O*(1) time using a suitable list data
    structure.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 动态集操作UNION接受两个不相交的集合*S*[1]和*S*[2]作为输入，并返回一个由*S*[1]和*S*[2]的所有元素组成的集合*S* = *S*[1]
    ⋃ *S*[2]。通常情况下，集合*S*[1]和*S*[2]会被该操作销毁。展示如何使用适当的列表数据结构在*O*(1)时间内支持UNION。
- en: '***10.2-5***'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.2-5***'
- en: Give a Θ(*n*)-time nonrecursive procedure that reverses a singly linked list
    of *n* elements. The procedure should use no more than constant storage beyond
    that needed for the list itself.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个Θ(*n*)时间的非递归过程，用于反转一个包含*n*个元素的单链表。该过程除了列表本身所需的存储空间外，不应使用更多的常数存储空间。
- en: ★ ***10.2-6***
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***10.2-6***
- en: Explain how to implement doubly linked lists using only one pointer value *x.np*
    per item instead of the usual two (*next* and *prev*). Assume that all pointer
    values can be interpreted as *k*-bit integers, and define *x.np* = *x.next* XOR
    *x.prev*, the *k*-bit “exclusive-or” of *x.next* and *x.prev*. The value NIL is
    represented by 0\. Be sure to describe what information you need to access the
    head of the list. Show how to implement the SEARCH, INSERT, and DELETE operations
    on such a list. Also show how to reverse such a list in *O*(1) time.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 解释如何使用每个项目仅一个指针值 *x.np* 来实现双向链表，而不是通常的两个（*next* 和 *prev*）。假设所有指针值都可以解释为 *k*
    位整数，并定义 *x.np* = *x.next* XOR *x.prev*，*x.next* 和 *x.prev* 的 *k* 位“异或”。值 NIL 由
    0 表示。确保描述访问列表头部所需的信息。展示如何在 *O*(1) 时间内反转这样的列表。展示如何在 *O*(1) 时间内反转这样的列表。
- en: '[**10.3    Representing rooted trees**](toc.xhtml#Rh1-59)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[**10.3    表示根树**](toc.xhtml#Rh1-59)'
- en: Linked lists work well for representing linear relationships, but not all relationships
    are linear. In this section, we look specifically at the problem of representing
    rooted trees by linked data structures. We first look at binary trees, and then
    we present a method for rooted trees in which nodes can have an arbitrary number
    of children.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 链表适用于表示线性关系，但并非所有关系都是线性的。在本节中，我们专门研究通过链接数据结构表示根树的问题。我们首先看二叉树，然后介绍一种根树的方法，其中节点可以有任意数量的子节点。
- en: We represent each node of a tree by an object. As with linked lists, we assume
    that each node contains a *key* attribute. The remaining attributes of interest
    are pointers to other nodes, and they vary according to the type of tree.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过对象表示树的每个节点。与链表一样，我们假设每个节点包含一个 *key* 属性。感兴趣的其余属性是指向其他节点的指针，根据树的类型而变化。
- en: '**Binary trees**'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '**二叉树**'
- en: '[Figure 10.6](chapter010.xhtml#Fig_10-6) shows how to use the attributes *p*,
    *left*, and *right* to store pointers to the parent, left child, and right child
    of each node in a binary tree *T*. If *x.p* = NIL, then *x* is the root. If node
    *x* has no left child, then *x.left* = NIL, and similarly for the right child.
    The root of the entire tree *T* is pointed to by the attribute *T.root*. If *T.root*
    = NIL, then the tree is empty.'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 10.6](chapter010.xhtml#Fig_10-6)展示了如何使用属性 *p*、*left* 和 *right* 存储二叉树 *T*
    中每个节点的父节点、左子节点和右子节点的指针。如果 *x.p* = NIL，则 *x* 是根。如果节点 *x* 没有左子节点，则 *x.left* = NIL，右子节点同理。整个树
    *T* 的根由属性 *T.root* 指向。如果 *T.root* = NIL，则树为空。'
- en: '**Rooted trees with unbounded branching**'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '**具有无界分支的根树**'
- en: 'It’s simple to extend the scheme for representing a binary tree to any class
    of trees in which the number of children of each node is at most some constant
    *k*: replace the *left* and *right* attributes by *child*[1], *child*[2], … ,
    *child[k]*. This scheme no longer works when the number of children of a node
    is unbounded, however, since we do not know how many attributes to allocate in
    advance. Moreover, if *k*, the number of children, is bounded by a large constant
    but most nodes have a small number of children, we may waste a lot of memory.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 将用于表示二叉树的方案扩展到每个节点的子节点数最多为某个常数 *k* 的树类：将 *left* 和 *right* 属性替换为 *child*[1]、*child*[2]、…、*child[k]*。然而，当节点的子节点数是无界的时，这种方案不再适用，因为我们无法提前知道要分配多少属性。此外，如果子节点数
    *k* 受到较大常数的限制，但大多数节点的子节点数较少，我们可能会浪费大量内存。
- en: 'Fortunately, there is a clever scheme to represent trees with arbitrary numbers
    of children. It has the advantage of using only *O*(*n*) space for any *n*-node
    rooted tree. The ***left-child, right-sibling representation*** appears in [Figure
    10.7](chapter010.xhtml#Fig_10-7). As before, each node contains a parent pointer
    *p*, and *T.root* points to the root of tree *T*. Instead of having a pointer
    to each of its children, however, each node *x* has only two pointers:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '幸运的是，有一种巧妙的方案可以表示具有任意数量子节点的树。对于任何 *n* 节点的根树，它的优点是只使用 *O*(*n*) 空间。***左子右兄表示***
    出现在[图 10.7](chapter010.xhtml#Fig_10-7)���。与以前一样，每个节点包含一个父指针 *p*，*T.root* 指向树 *T*
    的根。然而，每个节点 *x* 不是有指向每个子节点的指针，而是只有两个指针： '
- en: '*x.left-child* points to the leftmost child of node *x*, and'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x.left-child* 指向节点 *x* 的最左子节点，而'
- en: '*x.right-sibling* points to the sibling of *x* immediately to its right.'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*x.right-sibling* 指向其右侧紧邻的 *x* 的兄弟。'
- en: If node *x* has no children, then *x.left-child* = NIL, and if node *x* is the
    rightmost child of its parent, then *x.right-sibling* = NIL.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果节点 *x* 没有子节点，则 *x.left-child* = NIL，如果节点 *x* 是其父节点的最右子节点，则 *x.right-sibling*
    = NIL。
- en: '![art](images/Art_P372.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P372.jpg)'
- en: '**Figure 10.6** The representation of a binary tree *T*. Each node *x* has
    the attributes *x.p* (top), *x.left* (lower left), and *x.right* (lower right).
    The *key* attributes are not shown.'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.6** 二叉树 *T* 的表示。每个节点 *x* 都有属性 *x.p*（顶部）、*x.left*（左下）和 *x.right*（右下）。未显示
    *key* 属性。'
- en: '![art](images/Art_P373.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P373.jpg)'
- en: '**Figure 10.7** The left-child, right-sibling representation of a tree *T*.
    Each node *x* has attributes *x.p* (top), *x.left-child* (lower left), and *x.right-sibling*
    (lower right). The *key* attributes are not shown.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 10.7** 树 *T* 的左子右兄表示。每个节点 *x* 都有属性 *x.p*（顶部）、*x.left-child*（左下）和 *x.right-sibling*（右下）。未显示
    *key* 属性。'
- en: '**Other tree representations**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**其他树表示方式**'
- en: 'We sometimes represent rooted trees in other ways. In [Chapter 6](chapter006.xhtml),
    for example, we represented a heap, which is based on a complete binary tree,
    by a single array along with an attribute giving the index of the last node in
    the heap. The trees that appear in [Chapter 19](chapter019.xhtml) are traversed
    only toward the root, and so only the parent pointers are present: there are no
    pointers to children. Many other schemes are possible. Which scheme is best depends
    on the application.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有时以其他方式表示根树。例如，在[第6章](chapter006.xhtml)中，我们表示了一个堆，它基于完全二叉树，通过一个单独的数组以及一个给出堆中最后一个节点索引的属性来表示。出现在[第19章](chapter019.xhtml)中的树只朝根部遍历，因此只有父指针存在：没有指向子节点的指针。许多其他方案也是可能的。哪种方案最好取决于应用。
- en: '**Exercises**'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***10.3-1***'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.3-1***'
- en: 'Draw the binary tree rooted at index 6 that is represented by the following
    attributes:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制以索引6为根的二叉树，其属性如下所示：
- en: '| index | *key* | *left* | *right* |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 索引 | *key* | *left* | *right* |'
- en: '| 1 | 17 | 8 | 9 |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 17 | 8 | 9 |'
- en: '| 2 | 14 | NIL | NIL |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 14 | NIL | NIL |'
- en: '| 3 | 12 | NIL | NIL |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 12 | NIL | NIL |'
- en: '| 4 | 20 | 10 | NIL |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 20 | 10 | NIL |'
- en: '| 5 | 33 | 2 | NIL |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 33 | 2 | NIL |'
- en: '| 6 | 15 | 1 | 4 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 15 | 1 | 4 |'
- en: '| 7 | 28 | NIL | NIL |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 28 | NIL | NIL |'
- en: '| 8 | 22 | NIL | NIL |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 8 | 22 | NIL | NIL |'
- en: '| 9 | 13 | 3 | 7 |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 9 | 13 | 3 | 7 |'
- en: '| 10 | 25 | NIL | 5 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 25 | NIL | 5 |'
- en: '***10.3-2***'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.3-2***'
- en: Write an *O*(*n*)-time recursive procedure that, given an *n*-node binary tree,
    prints out the key of each node in the tree.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个*O*(*n*)时间的递归过程，给定一个*n*节点的二叉树，在树中打印出每个节点的键。
- en: '***10.3-3***'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.3-3***'
- en: Write an *O*(*n*)-time nonrecursive procedure that, given an *n*-node binary
    tree, prints out the key of each node in the tree. Use a stack as an auxiliary
    data structure.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个*O*(*n*)时间的非递归过程，给定一个*n*节点的二叉树，在树中打印出每个节点的键。使用堆栈作为辅助数据结构。
- en: '***10.3-4***'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '***10.3-4***'
- en: Write an *O*(*n*)-time procedure that prints out all the keys of an arbitrary
    rooted tree with *n* nodes, where the tree is stored using the left-child, right-sibling
    representation.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个*O*(*n*)时间的过程，打印出具有*n*个节点的任意根树的所有键，其中树使用左子节点，右兄弟表示法存储。
- en: ★ ***10.3-5***
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***10.3-5***
- en: Write an *O*(*n*)-time nonrecursive procedure that, given an *n*-node binary
    tree, prints out the key of each node. Use no more than constant extra space outside
    of the tree itself and do not modify the tree, even temporarily, during the procedure.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个*O*(*n*)时间的非递归过程，给定一个*n*节点的二叉树，在过程中除了树本身外不使用更多的常量额外空间，并且在过程中不要修改树，即使是临时的。
- en: ★ ***10.3-6***
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***10.3-6***
- en: 'The left-child, right-sibling representation of an arbitrary rooted tree uses
    three pointers in each node: *left-child*, *right-sibling*, and *parent*. From
    any node, its parent can be accessed in constant time and all its children can
    be accessed in time linear in the number of children. Show how to use only two
    pointers and one boolean value in each node *x* so that *x*’s parent or all of
    *x*’s children can be accessed in time linear in the number of *x*’s children.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 任意根树的左子节点，右兄弟表示法在每个节点中使用三个指针：*left-child*、*right-sibling*和*parent*。从任何节点，其父节点可以在常数时间内访问，所有子节点可以在与子节点数量成正比的时间内访问。展示如何在每个节点*x*中只使用两个指针和一个布尔值，以便在与*x*的子节点数量成正比的时间内访问*x*的父节点或所有子节点。
- en: '**Problems**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '***10-1     Comparisons among lists***'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '***10-1     列表之间的比较***'
- en: For each of the four types of lists in the following table, what is the asymptotic
    worst-case running time for each dynamic-set operation listed?
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下表中四种类型的列表，列出每个动态集操作的渐进最坏情况运行时间是多少？
- en: '|   | unsorted, singly linked | sorted, singly linked | unsorted, doubly linked
    | sorted, doubly linked |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|   | 无序，单链表 | 排序，单链表 | 无序，双链表 | 排序，双链表 |'
- en: '| SEARCH |  |  |  |  |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 搜索 |  |  |  |  |'
- en: '| INSERT |  |  |  |  |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 插入 |  |  |  |  |'
- en: '| DELETE |  |  |  |  |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| 删除 |  |  |  |  |'
- en: '| SUCCESSOR |  |  |  |  |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| 后继 |  |  |  |  |'
- en: '| PREDECESSOR |  |  |  |  |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| 前驱 |  |  |  |  |'
- en: '| MINIMUM |  |  |  |  |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| 最小值 |  |  |  |  |'
- en: '| MAXIMUM |  |  |  |  |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| 最大值 |  |  |  |  |'
- en: '***10-2     Mergeable heaps using linked lists***'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '***10-2     使用链表实现可合并堆***'
- en: 'A ***mergeable heap*** supports the following operations: MAKE-HEAP (which
    creates an empty mergeable heap), INSERT, MINIMUM, EXTRACT-MIN, and UNION.^([1](#footnote_1)) Show
    how to implement mergeable heaps using linked lists in each of the following cases.
    Try to make each operation as efficient as possible. Analyze the running time
    of each operation in terms of the size of the dynamic set(s) being operated on.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 一个***可合并堆***支持以下操作：MAKE-HEAP（创建一个空的可合并堆）、INSERT、MINIMUM、EXTRACT-MIN和UNION。^([1](#footnote_1)) 展示如何在以下每种情况下使用链表实现可合并堆。尽量使每个操作尽可能高效。根据被操作的动态集大小分析每个操作的运行时间。
- en: '***a.*** Lists are sorted.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 列表是排序的。'
- en: '***b.*** Lists are unsorted.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 列表是无序的。'
- en: '***c.*** Lists are unsorted, and dynamic sets to be merged are disjoint.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 列表是无序的，要合并的动态集是不相交的。'
- en: '***10-3     Searching a sorted compact list***'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '***10-3     搜索排序的紧凑列表***'
- en: We can represent a singly linked list with two arrays, *key* and *next*. Given
    the index *i* of an element, its value is stored in *key*[*i*], and the index
    of its successor is given by *next*[*i*], where *next*[*i*] = NIL for the last
    element. We also need the index *head* of the first element in the list. An *n*-element
    list stored in this way is ***compact*** if it is stored only in positions 1 through
    *n* of the *key* and *next* arrays.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用两个数组*key*和*next*表示一个单链表。给定元素的索引*i*，其值存储在*key*[*i*]中，其后继的索引由*next*[*i*]给出，其中对于最后一个元素，*next*[*i*]
    = NIL。我们还需要列表中第一个元素的索引*head*。以这种方式存储的*n*个元素列表如果仅存储在*key*和*next*数组的1到*n*位置中，则为***紧凑***。
- en: Let’s assume that all keys are distinct and that the compact list is also sorted,
    that is, *key*[*i*] < *key*[*next*[*i*]] for all *i* = 1, 2, … , *n* such that
    *next*[*i*] ≠ NIL. Under these assumptions, you will show that the randomized
    algorithm COMPACT-LIST-SEARCH searches the list for key *k* in ![art](images/Art_P374.jpg)
    expected time.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 假设所有键都是不同的，并且紧凑列表也是排序的，即对于所有*i* = 1, 2, … , *n*，使得*next*[*i*] ≠ NIL，都有*key*[*i*]
    < *key*[*next*[*i*]]。在这些假设下，您将展示随机算法COMPACT-LIST-SEARCH在期望时间![art](images/Art_P374.jpg)内搜索列表中的键*k*。
- en: COMPACT-LIST-SEARCH(*key*, *next*, *head*, *n*, *k*)
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: COMPACT-LIST-SEARCH(*key*, *next*, *head*, *n*, *k*)
- en: '|   1 | *i* = *head* |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '|   1 | *i* = *head* |'
- en: '|   2 | **while** *i* ≠ NIL and *key*[*i*] < *k* |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '|   2 | **当** *i* ≠ NIL 并且 *key*[*i*] < *k* |'
- en: '|   3 | *j* = RANDOM(1, *n*) |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '|   3 | *j* = RANDOM(1, *n*) |'
- en: '|   4 | **if** *key*[*i*] < *key*[*j*] and *key*[*j*] ≤ *k* |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '|   4 | **如果** *key*[*i*] < *key*[*j*] 并且 *key*[*j*] ≤ *k* |'
- en: '|   5 | *i* = *j* |'
  id: totrans-216
  prefs: []
  type: TYPE_TB
  zh: '|   5 | *i* = *j* |'
- en: '|   6 | **if** *key*[*i*] == *k* |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '|   6 | **如果** *key*[*i*] == *k* |'
- en: '|   7 | **return** *i* |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|   7 | **返回** *i* |'
- en: '|   8 | *i* = *next*[*i*] |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|   8 | *i* = *next*[*i*] |'
- en: '|   9 | **if** *i* == NIL or *key*[*i*] > *k* |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|   9 | **如果** *i* == NIL 或 *key*[*i*] > *k* |'
- en: '| 10 | **return** NIL |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 10 | **返回** NIL |'
- en: '| 11 | **else return** *i* |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 11 | **否则返回** *i* |'
- en: If you ignore lines 3–7 of the procedure, you can see that it’s an ordinary
    algorithm for searching a sorted linked list, in which index *i* points to each
    position of the list in turn. The search terminates once the index *i* “falls
    off” the end of the list or once *key*[*i*] ≥ *k*. In the latter case, if *key*[*i*]
    = *k*, the procedure has found a key with the value *k*. If, however, *key*[*i*]
    > *k*, then the search will never find a key with the value *k*, so that terminating
    the search was the correct action.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 如果忽略过程的第3-7行，你会发现这是一个搜索排序链表的普通算法，其��索引 *i* 依次指向列表的每个位置。搜索在索引 *i* “掉出”列表末尾或 *key*[*i*]
    ≥ *k* 时终止。在后一种情况下，如果 *key*[*i*] = *k*，则该过程已找到值为 *k* 的键。然而，如果 *key*[*i*] > *k*，则搜索永远不会找到值为
    *k* 的键，因此终止搜索是正确的操作。
- en: Lines 3–7 attempt to skip ahead to a randomly chosen position *j*. Such a skip
    helps if *key*[*j*] is larger than *key*[*i*] and no larger than *k*. In such
    a case, *j* marks a position in the list that *i* would reach during an ordinary
    list search. Because the list is compact, we know that any choice of *j* between
    1 and *n* indexes some element in the list.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 第3-7行尝试跳转到随机选择的位置 *j*。如果 *key*[*j*] 大于 *key*[*i*] 且不大于 *k*，这样的跳转有助于搜索。在这种情况下，*j*
    标记了列表中 *i* 在普通列表搜索中会到达的位置。由于列表是紧凑的，我们知道在1到 *n* 之间选择的任何 *j* 都会索引列表中的某个元素。
- en: Instead of analyzing the performance of COMPACT-LIST-SEARCH directly, you will
    analyze a related algorithm, COMPACT-LIST-SEARCH, which executes two separate
    loops. This algorithm takes an additional parameter *t*, which specifies an upper
    bound on the number of iterations of the first loop.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 不直接分析 COMPACT-LIST-SEARCH 的性能，而是分析一个相关算法 COMPACT-LIST-SEARCH，该算法执行两个单独的循环。该算法接受一个额外的参数
    *t*，指定第一个循环的迭代次数的上限。
- en: COMPACT-LIST-SEARCH′ (*key*, *next*, *head*, *n*, *k*, *t*)
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: COMPACT-LIST-SEARCH′ (*key*, *next*, *head*, *n*, *k*, *t*)
- en: '|   1 | *i* = *head* |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|   1 | *i* = *head* |'
- en: '|   2 | **for** *q* = 1 **to** *t* |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|   2 | **对于** *q* = 1 **到** *t* |'
- en: '|   3 | *j* = RANDOM(1, *n*) |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|   3 | *j* = RANDOM(1, *n*) |'
- en: '|   4 | **if** *key*[*i*] < *key*[*j*] and *key*[*j*] ≤ *k* |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '|   4 | **如果** *key*[*i*] < *key*[*j*] 且 *key*[*j*] ≤ *k* |'
- en: '|   5 | *i* = *j* |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '|   5 | *i* = *j* |'
- en: '|   6 | **if** *key*[*i*] == *k* |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|   6 | **如果** *key*[*i*] == *k* |'
- en: '|   7 | **return** *i* |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '|   7 | **返回** *i* |'
- en: '|   8 | **while** *i* ≠ NIL and *key*[*i*] < *k* |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|   8 | **当** *i* ≠ NIL 且 *key*[*i*] < *k* |'
- en: '|   9 | *i* = *next*[*i*] |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|   9 | *i* = *next*[*i*] |'
- en: '| 10 | **if** *i* == NIL or *key*[*i*] > *k* |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 10 | **如果** *i* == NIL 或 *key*[*i*] > *k* |'
- en: '| 11 | **return** NIL |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 11 | **返回** NIL |'
- en: '| 12 | **else return** *i* |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 12 | **否则返回** *i* |'
- en: To compare the execution of the two algorithms, assume that the sequence of
    calls of RANDOM(1, *n*) yields the same sequence of integers for both algorithms.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了比较两个算法的执行，假设 RANDOM(1, *n*) 的调用序列对两个算法都产生相同的整数序列。
- en: '***a.*** Argue that for any value of *t*, COMPACT-LIST-SEARCH(*key*, *next*,
    *head*, *n*, *k*) and COMPACT-LIST-SEARCH′ (*key*, *next*, *head*, *n*, *k*, *t*)
    return the same result and that the number of iterations of the **while** loop
    of lines 2–8 in COMPACT-LIST-SEARCH is at most the total number of iterations
    of both the **for** and **while** loops in COMPACT-LIST-SEARCH′.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 论证对于任何 *t* 的值，COMPACT-LIST-SEARCH(*key*, *next*, *head*, *n*, *k*)
    和 COMPACT-LIST-SEARCH′ (*key*, *next*, *head*, *n*, *k*, *t*) 返回相同的结果，并且 COMPACT-LIST-SEARCH
    中第2-8行的 **while** 循环的迭代次数最多等于 COMPACT-LIST-SEARCH′ 中 **for** 和 **while** 循环的总迭代次数。'
- en: In the call COMPACT-LIST-SEARCH′ (*key*, *next*, *head*, *n*, *k*, *t*), let
    *X[t]* be the random variable that describes the distance in the linked list (that
    is, through the chain of *next* pointers) from position *i* to the desired key
    *k* after *t* iterations of the **for** loop of lines 2–7 have occurred.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 在调用 COMPACT-LIST-SEARCH′ (*key*, *next*, *head*, *n*, *k*, *t*) 时，让 *X[t]* 是描述链表中（即通过
    *next* 指针链）从位置 *i* 到所需键 *k* 的距离的随机变量，经过第2-7行的 **for** 循环的 *t* 次迭代后。
- en: '***b.*** Argue that COMPACT-LIST-SEARCH′ (*key*, *next*, *head*, *n*, *k*,
    *t*) has an expected running time of *O*(*t* + E [*X[t]*]).'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 论证 COMPACT-LIST-SEARCH′ (*key*, *next*, *head*, *n*, *k*, *t*) 的期望运行时间为
    *O*(*t* + E [*X[t]*])。'
- en: '***c.*** Show that ![art](images/Art_P375.jpg). (*Hint:* Use equation (C.28)
    on page 1193.)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 证明 ![art](images/Art_P375.jpg)。（*提示：* 使用第1193页上的方程式（C.28））'
- en: '***d.*** Show that ![art](images/Art_P376.jpg). (*Hint:* Use inequality (A.18)
    on page 1150.)'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 证明 ![art](images/Art_P376.jpg)。（*提示：* 使用第1150页上的不等式（A.18））'
- en: '***e.*** Prove that E [*X[t]*] ≤ *n*/(*t* + 1).'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** 证明 E [*X[t]*] ≤ *n*/(*t* + 1)。'
- en: '***f.*** Show that COMPACT-LIST-SEARCH′ (*key*, *next*, *head*, *n*, *k*, *t*)
    has an expected running time of *O*(*t* + *n*/*t*).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '***f.*** 证明 COMPACT-LIST-SEARCH′ (*key*, *next*, *head*, *n*, *k*, *t*) 的期望运行时间为
    *O*(*t* + *n*/*t*)。'
- en: '***g.*** Conclude that COMPACT-LIST-SEARCH runs in ![art](images/Art_P377.jpg)
    expected time.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '***g.*** 得出结论，COMPACT-LIST-SEARCH 的期望运行时间为 ![art](images/Art_P377.jpg)。'
- en: '***h.*** Why do we assume that all keys are distinct in COMPACT-LIST-SEARCH?
    Argue that random skips do not necessarily help asymptotically when the list contains
    repeated key values.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '***h.*** 为什么我们假设 COMPACT-LIST-SEARCH 中所有键都是不同的？论证当列表包含重复键值时，随机跳跃在渐近情况下并不一定有帮助。'
- en: '**Chapter notes**'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节注释**'
- en: Aho, Hopcroft, and Ullman [[6](bibliography001.xhtml#endnote_6)] and Knuth [[259](bibliography001.xhtml#endnote_259)]
    are excellent references for elementary data structures. Many other texts cover
    both basic data structures and their implementation in a particular programming
    language. Examples of these types of textbooks include Goodrich and Tamassia [[196](bibliography001.xhtml#endnote_196)],
    Main [[311](bibliography001.xhtml#endnote_311)], Shaffer [[406](bibliography001.xhtml#endnote_406)],
    and Weiss [[452](bibliography001.xhtml#endnote_452), [453](bibliography001.xhtml#endnote_453),
    [454](bibliography001.xhtml#endnote_454)]. The book by Gonnet and Baeza-Yates
    [[193](bibliography001.xhtml#endnote_193)] provides experimental data on the performance
    of many data-structure operations.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Aho、Hopcroft 和 Ullman [[6](bibliography001.xhtml#endnote_6)] 以及 Knuth [[259](bibliography001.xhtml#endnote_259)]
    是初级数据结构的优秀参考书。许多其他文本涵盖了基本数据结构及其在特定编程语言中的实现。这些类型的教材的例子包括 Goodrich 和 Tamassia [[196](bibliography001.xhtml#endnote_196)]、Main
    [[311](bibliography001.xhtml#endnote_311)]、Shaffer [[406](bibliography001.xhtml#endnote_406)]
    和 Weiss [[452](bibliography001.xhtml#endnote_452), [453](bibliography001.xhtml#endnote_453),
    [454](bibliography001.xhtml#endnote_454)]。Gonnet 和 Baeza-Yates 的书籍 [[193](bibliography001.xhtml#endnote_193)]
    提供了许多数据结构操作性能的实验数据。
- en: The origin of stacks and queues as data structures in computer science is unclear,
    since corresponding notions already existed in mathematics and paper-based business
    practices before the introduction of digital computers. Knuth [[259](bibliography001.xhtml#endnote_259)]
    cites A. M. Turing for the development of stacks for subroutine linkage in 1947.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机科学中栈和队列作为数据结构的起源并不清楚，因为在数字计算机引入之前，对应的概念已经存在于数学和基于纸张的商业实践中。Knuth [[259](bibliography001.xhtml#endnote_259)]
    引用了 A. M. 图灵在 1947 年为子程序链接开发栈的工作。
- en: Pointer-based data structures also seem to be a folk invention. According to
    Knuth, pointers were apparently used in early computers with drum memories. The
    A-1 language developed by G. M. Hopper in 1951 represented algebraic formulas
    as binary trees. Knuth credits the IPL-II language, developed in 1956 by A. Newell,
    J. C. Shaw, and H. A. Simon, for recognizing the importance and promoting the
    use of pointers. Their IPL-III language, developed in 1957, included explicit
    stack operations.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 基于指针的数据结构似乎也是一种民间发明。据 Knuth 称，指针显然在早期带有鼓式存储器的计算机中使用。G. M. 霍普在 1951 年开发的 A-1
    语言将代数公式表示为二叉树。Knuth 归功于 A. Newell、J. C. Shaw 和 H. A. Simon 在 1956 年开发的 IPL-II
    语言，他们认识到指针的重要性并推动了指针的使用。他们在 1957 年开发的 IPL-III 语言包括显式的栈操作。
- en: '[¹](#footnote_ref_1) Because we have defined a mergeable heap to support MINIMUM
    and EXTRACT-MIN, we can also refer to it as a ***mergeable min-heap***. Alternatively,
    if it supports MAXIMUM and EXTRACT-MAX, it is a ***mergeable max-heap***.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '[¹](#footnote_ref_1) 因为我们已经定义了一个可合并堆来支持 MINIMUM 和 EXTRACT-MIN，我们也可以称之为***可合并最小堆***。或者，如果它支持
    MAXIMUM 和 EXTRACT-MAX，那么它就是一个***可合并最大堆***。'
