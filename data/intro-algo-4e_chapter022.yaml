- en: '[**22        Single-Source Shortest Paths**](toc.xhtml#chap-22)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[**22        单源最短路径**](toc.xhtml#chap-22)'
- en: Suppose that you need to drive from Oceanside, New York, to Oceanside, California,
    by the shortest possible route. Your GPS contains information about the entire
    road network of the United States, including the road distance between each pair
    of adjacent intersections. How can your GPS determine this shortest route?
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您需要从纽约州奥申赛德尽可能短的路线驾驶到加利福尼亚州奥申赛德。您的GPS包含有关美国整个道路网络的信息，包括相邻交叉口之间的道路距离。您的GPS如何确定这条最短路径��
- en: One possible way is to enumerate all the routes from Oceanside, New York, to
    Oceanside, California, add up the distances on each route, and select the shortest.
    But even disallowing routes that contain cycles, your GPS would need to examine
    an enormous number of possibilities, most of which are simply not worth considering.
    For example, a route that passes through Miami, Florida, is a poor choice, because
    Miami is several hundred miles out of the way.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 一种可能的方法是列举从纽约州奥申赛德到加利福尼亚州奥申赛德的所有路线，计算每条路线上的距离总和，并选择最短路径。但即使不允许包含循环的路线，您的GPS也需要检查大量可能性，其中大多数根本不值得考虑。例如，经过佛罗里达州迈阿密的路线是一个糟糕的选择，因为迈阿密偏离了几百英里的路程。
- en: 'This chapter and [Chapter 23](chapter023.xhtml) show how to solve such problems
    efficiently. The input to a ***shortest-paths problem*** is a weighted, directed
    graph *G* = (*V*, *E*), with a weight function *w* : *E* → ℝ mapping edges to
    real-valued weights. The ***weight*** *w*(*p*) of path *p* = 〈*v*[0], *v*[1],
    … , *v[k]*〉 is the sum of the weights of its constituent edges:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章和[第23章](chapter023.xhtml)展示了如何高效解决这类问题。***最短路径问题***的输入是一个加权有向图*G* = (*V*,
    *E*)，其中权重函数*w*：*E* → ℝ将边映射到实值权重。路径*p* = 〈*v*[0]，*v*[1]，…，*v[k]*〉的***权重*** *w*(*p*)是其组成边的权重之和：
- en: '![art](images/Art_P626.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P626.jpg)'
- en: We define the ***shortest-path weight*** δ(*u*, *v*) from *u* to *v* by
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过以下方式定义从*u*到*v*的***最短路径权重***δ(*u*, *v*)：
- en: '![art](images/Art_P627.jpg)'
  id: totrans-6
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P627.jpg)'
- en: A ***shortest path*** from vertex *u* to vertex *v* is then defined as any path
    *p* with weight *w*(*p*) = δ(*u*, *v*).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶点*u*到顶点*v*的***最短路径***定义为权重为*w*(*p*) = δ(*u*, *v*)的任何路径*p*。
- en: 'In the example of going from Oceanside, New York, to Oceanside, California,
    your GPS models the road network as a graph: vertices represent intersections,
    edges represent road segments between intersections, and edge weights represent
    road distances. The goal is to find a shortest path from a given intersection
    in Oceanside, New York (say, Brower Avenue and Skillman Avenue) to a given intersection
    in Oceanside, California (say, Topeka Street and South Horne Street).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在从纽约州奥申赛德到加利福尼亚州奥申赛德的例子中，您的GPS将道路网络建模为图：顶点表示交叉口，边表示交叉口之间的道路段，边的权重表示道路距离。目标是从纽约州奥申赛德的给定交叉口（比如，布劳尔大道和斯基尔曼大道）到加利福尼亚州奥申赛德的给定交叉口（比如，托皮卡街和南霍恩街）找到最短路径。
- en: Edge weights can represent metrics other than distances, such as time, cost,
    penalties, loss, or any other quantity that accumulates linearly along a path
    and that you want to minimize.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 边的权重可以表示除距离之外的其他度量，例如时间、成本、惩罚、损失或沿路径线性累积且希望最小化的任何其他数量。
- en: The breadth-first-search algorithm from [Section 20.2](chapter020.xhtml#Sec_20.2)
    is a shortest-paths algorithm that works on unweighted graphs, that is, graphs
    in which each edge has unit weight. Because many of the concepts from breadth-first
    search arise in the study of shortest paths in weighted graphs, you might want
    to review [Section 20.2](chapter020.xhtml#Sec_20.2) before proceeding.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[第20.2节](chapter020.xhtml#Sec_20.2)的广度优先搜索算法是一种适用于无权图的最短路径算法，即每条边的权重均为单位权重的图。由于广度优先搜索中的许多概念出现在加权图中最短路径的研究中，您可能需要在继续之前复习[第20.2节](chapter020.xhtml#Sec_20.2)。
- en: '**Variants**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**变体**'
- en: 'This chapter focuses on the ***single-source shortest-paths problem***: given
    a graph *G* = (*V*, *E*), find a shortest path from a given ***source vertex***
    *s* ∈ *V* to every vertex *v* ∈ *V*. The algorithm for the single-source problem
    can solve many other problems, including the following variants.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章重点讨论***单源最短路径问题***：给定图*G* = (*V*, *E*)，找到从给定***源顶点*** *s* ∈ *V*到每个顶点*v* ∈
    *V*的最短路径。单源问题的算法可以解决许多其他问题，包括以下变体。
- en: '**Single-destination shortest-paths problem:** Find a shortest path to a given
    ***destination vertex*** *t* from each vertex *v*. By reversing the direction
    of each edge in the graph, you can reduce this problem to a single-source problem.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**单目的地最短路径问题：**找到从每个顶点*v*到给定的***目的地顶点*** *t*的最短路径。通过颠倒图中每条边的方向，您可以将此问题简化为单源问题。'
- en: '**Single-pair shortest-path problem:** Find a shortest path from *u* to *v*
    for given vertices *u* and *v*. If you solve the single-source problem with source
    vertex *u*, you solve this problem also. Moreover, all known algorithms for this
    problem have the same worst-case asymptotic running time as the best single-source
    algorithms.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**单对最短路径问题：**为给定顶点*u*和*v*找到从*u*到*v*的最短路径。如果您解决了以源顶点*u*解决单源问题，那么您也解决了这个问题。此外，所有已知的解决此问题的算法的最坏情况渐近运行时间与最佳单源算法相同。'
- en: '**All-pairs shortest-paths problem:** Find a shortest path from *u* to *v*
    for every pair of vertices *u* and *v*. Although you can solve this problem by
    running a single-source algorithm once from each vertex, you often can solve it
    faster. Additionally, its structure is interesting in its own right. [Chapter
    23](chapter023.xhtml) addresses the all-pairs problem in detail.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**全对最短路径问题：**为每对顶点*u*和*v*找到从*u*到*v*的最短路径。虽然您可以通过从每个顶点运行单源算法一次来解决此问题，但通常可以更快地解决它。此外，它的结构本身也很有趣。[第23章](chapter023.xhtml)详细讨论了全对问题。'
- en: '**Optimal substructure of a shortest path**'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**最短路径的最优子结构**'
- en: Shortest-paths algorithms typically rely on the property that a shortest path
    between two vertices contains other shortest paths within it. (The Edmonds-Karp
    maximum-flow algorithm in [Chapter 24](chapter024.xhtml) also relies on this property.)
    Recall that optimal substructure is one of the key indicators that dynamic programming
    ([Chapter 14](chapter014.xhtml)) and the greedy method ([Chapter 15](chapter015.xhtml))
    might apply. Dijkstra’s algorithm, which we shall see in [Section 22.3](chapter022.xhtml#Sec_22.3),
    is a greedy algorithm, and the Floyd-Warshall algorithm, which finds a shortest
    path between every pair of vertices (see [Section 23.2](chapter023.xhtml#Sec_23.2)),
    is a dynamic-programming algorithm. The following lemma states the optimal-substructure
    property of shortest paths more precisely.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 最短路径算法通常依赖于这样一个性质：两个顶点之间的最短路径中包含其他最短路径。（[第24章](chapter024.xhtml)中的Edmonds-Karp最大流算法也依赖于这一性质。）回想一下，最优子结构是动态规划（[第14章](chapter014.xhtml)）和贪婪方法（[第15章](chapter015.xhtml)）可能适用的关键指标之一。我们将在[第22.3节](chapter022.xhtml#Sec_22.3)中看到的Dijkstra算法是一种贪婪算法，而Floyd-Warshall算法，用于找到每对顶点之间的最短路径（参见[第23.2节](chapter023.xhtml#Sec_23.2)），是一种动态规划算法。以下引理更准确地陈述了最短路径的最优子结构性质。
- en: '***Lemma 22.1 (Subpaths of shortest paths are shortest paths)***'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 22.1（最短路径的子路径也是最短路径）***'
- en: 'Given a weighted, directed graph *G* = (*V*, *E*) with weight function *w*
    : *E* → ℝ let *p* = 〈*v*[0], *v*[1], … , *v[k]*〉 be a shortest path from vertex
    *v*[0] to vertex *v[k]* and, for any *i* and *j* such that 0 ≤ *i* ≤ *j* ≤ *k*,
    let *p[ij]* = 〈*v[i]*, *v*[*i*+1], … , *v[j]*〉 be the subpath of *p* from vertex
    *v[i]* to vertex *v[j]*. Then, *p[ij]* is a shortest path from *v[i]* to *v[j]*.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 给定带权重的有向图*G* = (*V*, *E*)，权重函数为*w*：*E* → ℝ，设*p* = 〈*v*[0], *v*[1], … , *v[k]*〉是从顶点*v*[0]到顶点*v[k]*的最短路径，对于任意*i*和*j*，使得0
    ≤ *i* ≤ *j* ≤ *k*，设*p[ij]* = 〈*v[i]*, *v*[*i*+1], … , *v[j]*〉是*p*的从顶点*v[i]*到*v[j]*的子路径。那么，*p[ij]*是从*v[i]*到*v[j]*的最短路径。
- en: '***Proof***   Decompose path *p* into ![art](images/Art_P628.jpg), so that
    *w*(*p*) = *w*(*p*[0*i*]) + *w*(*p[ij]*) + *w*(*p[jk]*). Now, assume that there
    is a path ![art](images/Art_P629.jpg) from *v[i]* to *v[j]* with weight ![art](images/Art_P630.jpg).
    Then, ![art](images/Art_P631.jpg) is a path from *v*[0] to *v[k]* whose weight
    ![art](images/Art_P632.jpg) is less than *w*(*p*), which contradicts the assumption
    that *p* is a shortest path from *v*[0] to *v[k]*.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 将路径*p*分解为![art](images/Art_P628.jpg)，使得*w*(*p*) = *w*(*p*[0*i*]) +
    *w*(*p[ij]*) + *w*(*p[jk]*)。现在，假设存在一条从*v[i]*到*v[j]*的路径![art](images/Art_P629.jpg)，其权重为![art](images/Art_P630.jpg)。那么，![art](images/Art_P631.jpg)是一条从*v*[0]到*v[k]*的路径，其权重![art](images/Art_P632.jpg)小于*p*的权重，这与*p*是从*v*[0]到*v[k]*的最短路径的假设相矛盾。'
- en: ▪
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Negative-weight edges**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**负权边**'
- en: Some instances of the single-source shortest-paths problem may include edges
    whose weights are negative. If the graph *G* = (*V*, *E*) contains no negative-weight
    cycles reachable from the source *s*, then for all *v* ∈ *V*, the shortest-path
    weight δ(*s*, *v*) remains well defined, even if it has a negative value. If the
    graph contains a negative-weight cycle reachable from *s*, however, shortest-path
    weights are not well defined. No path from *s* to a vertex on the cycle can be
    a shortest path—you can always find a path with lower weight by following the
    proposed “shortest” path and then traversing the negative-weight cycle. If there
    is a negative-weight cycle on some path from *s* to *v*, we define δ(*s*, *v*)
    = −∞.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在单源最短路径问题的一些情况中，可能存在权重为负的边。如果图*G* = (*V*, *E*)中不存在从源点*s*可达的负权重环路，则对于所有*v* ∈
    *V*，最短路径权重δ(*s*, *v*)仍然是明确定义的，即使它是负值。然而，如果图中存在从*s*可达的负权重环路，则最短路径权重就不再明确定义。从*s*到环路上某个顶点的路径都不可能是最短路径——你总是可以通过跟随提议的“最短”路径然后遍历负权重环路找到更低权重的路径。如果从*s*到*v*的某条路径上存在负权重环路，我们定义δ(*s*,
    *v*) = −∞。
- en: '[Figure 22.1](chapter022.xhtml#Fig_22-1) illustrates the effect of negative
    weights and negative-weight cycles on shortest-path weights. Because there is
    only one path from *s* to *a* (the path 〈*s*, *a*〉), we have δ(*s*, *a*) = *w*(*s*,
    *a*) = 3\. Similarly, there is only one path from *s* to *b*, and so δ(*s*, *b*)
    = *w*(*s*, *a*) + *w*(*a*, *b*) = 3 + (−4) = −1\. There are infinitely many paths
    from *s* to *c*: 〈*s*, *c*〉, 〈*s*, *c*, *d*, *c*〉, 〈*s*, *c*, *d*, *c*, *d*, *c*〉,
    and so on. Because the cycle 〈*c*, *d*, *c*〉 has weight 6 + (−3) = 3 > 0, the
    shortest path from *s* to *c* is 〈*s*, *c*〉, with weight δ(*s*, *c*) = *w*(*s*,
    *c*) = 5, and the shortest path from *s* to *d* is 〈*s*, *c*, *d*〉, with weight
    δ(*s*, *d*) = *w*(*s*, *c*) + *w*(*c*, *d*) = 11\. Analogously, there are infinitely
    many paths from *s* to *e*: 〈*s*, *e*〉, 〈*s*, *e*, *f*, *e*〉, 〈*s*, *e*, *f*,
    *e*, *f*, *e*〉, and so on. Because the cycle 〈*e*, *f*, *e*〉 has weight 3 + (−6)
    = −3 < 0, however, there is no shortest path from *s* to *e*. By traversing the
    negative-weight cycle 〈*e*, *f*, *e*〉 arbitrarily many times, you can find paths
    from *s* to *e* with arbitrarily large negative weights, and so δ(*s*, *e*) =
    −∞. Similarly, δ(*s*, *f*) = −∞. Because *g* is reachable from *f*, you can also
    find paths with arbitrarily large negative weights from *s* to *g*, and so δ(*s*,
    *g*) = −∞. Vertices *h*, *i*, and *j* also form a negative-weight cycle. They
    are not reachable from *s*, however, and so δ(*s*, *h*) = δ(*s*, *i*) = δ(*s*,
    *j*) = ∞.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[图22.1](chapter022.xhtml#Fig_22-1)展示了负权重和负权重环对最短路径权重的影响。因为从*s*到*a*只有一条路径（路径〈*s*,
    *a*〉），所以我们有δ(*s*, *a*) = *w*(*s*, *a*) = 3。类似地，从*s*到*b*也只有一条路径，因此δ(*s*, *b*) =
    *w*(*s*, *a*) + *w*(*a*, *b*) = 3 + (−4) = −1。从*s*到*c*有无限多条路径：〈*s*, *c*〉，〈*s*,
    *c*, *d*, *c*〉，〈*s*, *c*, *d*, *c*, *d*, *c*〉等等。因为循环〈*c*, *d*, *c*〉的权重为6 + (−3)
    = 3 > 0，所以从*s*到*c*的最短路径是〈*s*, *c*〉，权重为δ(*s*, *c*) = *w*(*s*, *c*) = 5，从*s*到*d*的最短路径是〈*s*,
    *c*, *d*〉，权重为δ(*s*, *d*) = *w*(*s*, *c*) + *w*(*c*, *d*) = 11。类似地，从*s*到*e*有无限多条路径：〈*s*,
    *e*〉，〈*s*, *e*, *f*, *e*〉，〈*s*, *e*, *f*, *e*, *f*, *e*〉等等。然而，因为循环〈*e*, *f*, *e*〉的权重为3
    + (−6) = −3 < 0，所以从*s*到*e*没有最短路径。通过任意多次遍历负权重循环〈*e*, *f*, *e*〉，你可以找到从*s*到*e*权重任意大的路径，因此δ(*s*,
    *e*) = −∞。类似地，δ(*s*, *f*) = −∞。因为*g*可以从*f*到达，你也可以找到从*s*到*g*权重任意大的路径，因此δ(*s*, *g*)
    = −∞。顶点*h*、*i*和*j*也形成一个负权重循环。然而，它们无法从*s*到达，因此δ(*s*, *h*) = δ(*s*, *i*) = δ(*s*,
    *j*) = ∞。'
- en: '![art](images/Art_P633.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P633.jpg)'
- en: '**Figure 22.1** Negative edge weights in a directed graph. The shortest-path
    weight from source *s* appears within each vertex. Because vertices *e* and *f*
    form a negative-weight cycle reachable from *s*, they have shortest-path weights
    of −∞. Because vertex *g* is reachable from a vertex whose shortest-path weight
    is −∞, it, too, has a shortest-path weight of −∞. Vertices such as *h*, *i*, and
    *j* are not reachable from *s*, and so their shortest-path weights are ∞, even
    though they lie on a negative-weight cycle.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**图22.1** 有向图中的负边权重。源点*s*的最短路径权重显示在每个顶点内。因为顶点*e*和*f*形成了从*s*可达的负权重循环，它们的最短路径权重为−∞。因为顶点*g*可以从最短路径权重为−∞的顶点到达，所以它的最短路径权重也为−∞。像*h*、*i*和*j*这样的顶点无法从*s*到达，因此它们的最短路径权重为∞，尽管它们位于负权重循环上。'
- en: Some shortest-paths algorithms, such as Dijkstra’s algorithm, assume that all
    edge weights in the input graph are nonnegative, as in a road network. Others,
    such as the Bellman-Ford algorithm, allow negative-weight edges in the input graph
    and produce a correct answer as long as no negative-weight cycles are reachable
    from the source. Typically, if there is such a negative-weight cycle, the algorithm
    can detect and report its existence.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一些最短路径算法，如迪杰斯特拉算法，假设输入图中的所有边权重都是非负的，就像在道路网络中一样。其他算法，如贝尔曼-福特算法，允许输入图中存在负权重边，并在源点不可达负权重环的情况下产生正确答案。通常，如果存在这样的负权重环，算法可以检测并报告其存在。
- en: '**Cycles**'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环**'
- en: Can a shortest path contain a cycle? As we have just seen, it cannot contain
    a negative-weight cycle. Nor can it contain a positive-weight cycle, since removing
    the cycle from the path produces a path with the same source and destination vertices
    and a lower path weight. That is, if *p* = 〈*v*[0], *v*[1], … , *v[k]*〉 is a path
    and *c* = 〈*v[i]*, *v*[*i*+1], … , *v[j]*〉 is a positive-weight cycle on this
    path (so that *v[i]* = *v[j]* and *w*(*c*) > 0), then the path *p*′ = 〈*v*[0],
    *v*[1], … , *v[i]*, *v*[*j*+1], *v*[*j*+2], … , *v[k]*〉 has weight *w*(*p*′) =
    *w*(*p*) − *w*(*c*) < *w*(*p*), and so *p* cannot be a shortest path from *v*[0]
    to *v[k]*.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 最短路径可以包含循环吗？正如我们刚刚看到的，它不能包含负权重循环。它也不能包含正权重循环，因为从路径中移除循环会产生具有相同源点和目标点顶点以及更低路径权重的路径。也就是说，如果*p*
    = 〈*v*[0], *v*[1], … , *v[k]*〉是一条路径，*c* = 〈*v[i]*, *v*[*i*+1], … , *v[j]*〉是该路径上的正权重循环（使得*v[i]*
    = *v[j]*且*w*(*c*) > 0），那么路径*p*′ = ���*v*[0], *v*[1], … , *v[i]*, *v*[*j*+1], *v*[*j*+2],
    … , *v[k]*〉的权重为*w*(*p*′) = *w*(*p*) − *w*(*c*) < *w*(*p*)，因此*p*不能是从*v*[0]到*v[k]*的最短路径。
- en: That leaves only 0-weight cycles. You can remove a 0-weight cycle from any path
    to produce another path whose weight is the same. Thus, if there is a shortest
    path from a source vertex *s* to a destination vertex *v* that contains a 0-weight
    cycle, then there is another shortest path from *s* to *v* without this cycle.
    As long as a shortest path has 0-weight cycles, you can repeatedly remove these
    cycles from the path until you have a shortest path that is cycle-free. Therefore,
    without loss of generality, assume that shortest paths have no cycles, that is,
    they are simple paths. Since any acyclic path in a graph *G* = (*V*, *E*) contains
    at most |*V*| distinct vertices, it also contains at most |*V*| − 1 edges. Assume,
    therefore, that any shortest path contains at most |*V*| − 1 edges.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这只留下了0权重循环。你可以从任何路径中移除0权重循环，得到另一条权重相同的路径。因此，如果从源顶点*s*到目标顶点*v*有一条包含0权重循环的最短路径，那么从*s*到*v*的另一条最短路径就没有这个循环。只要最短路径包含0权重循环，你可以反复从路径中移除这些循环，直到得到一个无循环的最短路径。因此，不失一般性地假设最短路径没有循环，也就是说，它们是简单路径。由于图*G*
    = (*V*, *E*)中的任何无环路径最多包含|*V*|个不同顶点，因此它也最多包含|*V*| − 1条边。因此，可以假设任何最短路径最多包含|*V*|
    − 1条边。
- en: '**Representing shortest paths**'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**表示最短路径**'
- en: It is usually not enough to compute only shortest-path weights. Most applications
    of shortest paths need to know the vertices on shortest paths as well. For example,
    if your GPS told you the distance to your destination but not how to get there,
    it would not be terribly useful. We represent shortest paths similarly to how
    we represented breadth-first trees in [Section 20.2](chapter020.xhtml#Sec_20.2).
    Given a graph *G* = (*V*, *E*), maintain for each vertex *v* ∈ *V* a ***predecessor***
    *v*.π that is either another vertex or NIL. The shortest-paths algorithms in this
    chapter set the π attributes so that the chain of predecessors originating at
    a vertex *v* runs backward along a shortest path from *s* to *v*. Thus, given
    a vertex *v* for which *v*.π ≠ NIL, the procedure PRINT-PATH(*G*, *s*, *v*) from
    [Section 20.2](chapter020.xhtml#Sec_20.2) prints a shortest path from *s* to *v*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 仅计算最短路径权重通常是不够的。大多数最短路径的应用需要知道最短路径上的顶点。例如，如果您的GPS告诉您到目的地的距离，但没有告诉您如何到达那里，那将没有太大用处。我们表示最短路径的方式类似于我们在[第20.2节](chapter020.xhtml#Sec_20.2)中表示广度优先树的方式。给定一个图
    *G* = (*V*, *E*)，对于每个顶点 *v* ∈ *V*，维护一个***前驱*** *v*.π���它可以是另一个顶点或NIL。本章中的最短路径算法设置
    π 属性，使得从顶点 *v* 开始的前驱链沿着从 *s* 到 *v* 的最短路径反向运行。因此，对于一个顶点 *v*，如果 *v*.π ≠ NIL，则来自[第20.2节](chapter020.xhtml#Sec_20.2)的
    PRINT-PATH(*G*, *s*, *v*) 程序打印从 *s* 到 *v* 的最短路径。
- en: 'In the midst of executing a shortest-paths algorithm, however, the π values
    might not indicate shortest paths. The ***predecessor subgraph*** *G*[π] = (*V*[π],
    *E*[π]) induced by the π values is defined the same for single-source shortest
    paths as for breadth-first search in equations (20.2) and (20.3) on page 561:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在执行最短路径算法时，π 值可能不表示最短路径。由π 值引起的***前驱子图*** *G*[π] = (*V*[π], *E*[π])，对于单源最短路径与第561页上广度优先搜索中的方程式(20.2)和(20.3)定义相同：
- en: '*V*[π] = {*v* ∈ *V* : *v*.π ≠ NIL} ∪ {*s*},'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*V*[π] = {*v* ∈ *V* : *v*.π ≠ NIL} ∪ {*s*},'
- en: '*E*[π] = {(*v*.π, *v*) ∈ *E* : *v* ∈ *V*[π] − {*s*}}.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '*E*[π] = {(*v*.π, *v*) ∈ *E* : *v* ∈ *V*[π] − {*s*}}.'
- en: 'We’ll prove that the π values produced by the algorithms in this chapter have
    the property that at termination *G*[π] is a “shortest-paths tree”—informally,
    a rooted tree containing a shortest path from the source *s* to every vertex that
    is reachable from s. *A* shortest-paths tree is like the breadth-first tree from
    [Section 20.2](chapter020.xhtml#Sec_20.2), but it contains shortest paths from
    the source defined in terms of edge weights instead of numbers of edges. To be
    precise, let *G* = (*V*, *E*) be a weighted, directed graph with weight function
    *w* : *E* → ℝ, and assume that *G* contains no negative-weight cycles reachable
    from the source vertex *s* ∈ *V*, so that shortest paths are well defined. *A****shortest-paths
    tree*** rooted at *s* is a directed subgraph *G*′ = (*V*′, *E*′), where *V*′ ⊆
    *V* and *E*′ ⊆ *E*, such that'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '我们将证明本章中算法产生的 π 值具有以下性质：在终止时，*G*[π] 是一个“最短路径树”——非正式地说，是一个根节点包含从源点 *s* 到每个可达顶点的最短路径的树。*最短路径树*类似于[第20.2节](chapter020.xhtml#Sec_20.2)中的广度优先树，但它包含以边权重而不是边数定义的源点到目标点的最短路径。具体来说，设
    *G* = (*V*, *E*) 是一个带权重的有向图，权重函数为 *w* : *E* → ℝ，并假设 *G* 不包含从源顶点 *s* ∈ *V* 可达的负权重环，因此最短路径是明确定义的。以
    *s* 为根的***最短路径树***是一个有向子图 *G*′ = (*V*′, *E*′)，其中 *V*′ ⊆ *V*，*E*′ ⊆ *E*，满足以下条件：'
- en: '*V*′ is the set of vertices reachable from *s* in *G*,'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*V*′ 是在 *G* 中从 *s* 可达的顶点集合，'
- en: '*G*′ forms a rooted tree with root *s*, and'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*G*′ 形成以 *s* 为根的树，'
- en: for all *v* ∈ *V*′, the unique simple path from *s* to *v* in *G*′ is a shortest
    path from *s* to *v* in *G*.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于所有 *v* ∈ *V*′，在 *G*′ 中从 *s* 到 *v* 的唯一简单路径是 *G* 中从 *s* 到 *v* 的最短路径。
- en: '![art](images/Art_P634.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P634.jpg)'
- en: '**Figure 22.2 (a)** *A* weighted, directed graph with shortest-path weights
    from source *s*. **(b)** The blue edges form a shortest-paths tree rooted at the
    source *s*. **(c)** Another shortest-paths tree with the same root.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**图22.2 (a)** *一个* 带权重的有向图，从源点 *s* 开始的最短路径权重。 **(b)** 蓝色边构成以源点 *s* 为根的最短路径树。
    **(c)** 另一个以相同根节点的最短路径树。'
- en: Shortest paths are not necessarily unique, and neither are shortest-paths trees.
    For example, [Figure 22.2](chapter022.xhtml#Fig_22-2) shows a weighted, directed
    graph and two shortest-paths trees with the same root.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最短路径不一定是唯一的，最短路径树也不是唯一的。例如，[图22.2](chapter022.xhtml#Fig_22-2)展示了一个带权重的有向图和两个以相同根节点的最短路径树。
- en: '**Relaxation**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**松弛**'
- en: The algorithms in this chapter use the technique of ***relaxation***. For each
    vertex *v* ∈ *V*, the single-source shortest paths algorithms maintain an attribute
    *v.d*, which is an upper bound on the weight of a shortest path from source *s*
    to *v*. We call *v.d* a ***shortest-path estimate***. To initialize the shortest-path
    estimates and predecessors, call the Θ(*V*)-time procedure INITIALIZE-SINGLE-SOURCE.
    After initialization, we have *v*.π = NIL for all *v* ∈ *V*, *s.d* = 0 and *v.d*
    = ∞ for *v* ∈ *V* − {*s*}.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的算法使用***松弛***技术。对于每个顶点 *v* ∈ *V*，单源最短路径算法维护一个属性 *v.d*，它是从源点 *s* 到 *v* 的最短路径权重的上界。我们称
    *v.d* 为***最短路径估计***。为了初始化最短路径估计和前驱节点，请调用Θ(*V*)时间复杂度的 INITIALIZE-SINGLE-SOURCE
    程序。初始化后，对于所有 *v* ∈ *V*，有 *v*.π = NIL，*s.d* = 0，对于 *v* ∈ *V* − {*s*}，有 *v.d* =
    ∞。
- en: INITIALIZE-SINGLE-SOURCE(*G*, *s*)
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: INITIALIZE-SINGLE-SOURCE(*G*, *s*)
- en: '| 1 | **for** each vertex *v* ∈ *G.V* |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **对于** 每个顶点 *v* ∈ *G.V* |'
- en: '| 2 | *v.d* = ∞ |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *v.d* = ∞ |'
- en: '| 3 | *v*.π = NIL |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *v*.π = NIL |'
- en: '| 4 | *s.d* = 0 |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *s.d* = 0 |'
- en: The process of ***relaxing*** an edge (*u*, *v*) consists of testing whether
    going through vertex *u* improves the shortest path to vertex *v* found so far
    and, if so, updating *v.d* and *v*.π. A relaxation step might decrease the value
    of the shortest-path estimate *v.d* and update *v*’s predecessor attribute *v*.π.
    The RELAX procedure on the following page performs a relaxation step on edge (*u*,
    *v*) in *O*(1) time. [Figure 22.3](chapter022.xhtml#Fig_22-3) shows two examples
    of relaxing an edge, one in which a shortest-path estimate decreases and one in
    which no estimate changes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '***松弛*** 边 (*u*, *v*) 的过程包括测试通过顶点 *u* 是否改进到目前为止找到的到顶点 *v* 的最短路径，并且如果是，则更新 *v.d*
    和 *v*.π。松弛步骤可能会减小最短路径估计值 *v.d* 并更新 *v* 的前驱属性 *v*.π。下一页的 RELAX 程序在 *O*(1) 时间内执行边
    (*u*, *v*) 的松弛步骤。[图 22.3](chapter022.xhtml#Fig_22-3)展示了两个边进行松弛的示例，一个是最短路径估计值减小的情况，另一个是没有估计值改变的情况。'
- en: '![art](images/Art_P635.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P635.jpg)'
- en: '**Figure 22.3** Relaxing an edge (*u*, *v*) with weight *w*(*u*, *v*) = 2\.
    The shortest-path estimate of each vertex appears within the vertex. **(a)** Because
    *v.d* > *u.d* + *w*(*u*, *v*) prior to relaxation, the value of *v.d* decreases.
    **(b)** Since we have *v.d* ≤ *u.d* + *w*(*u*, *v*) before relaxing the edge,
    the relaxation step leaves *v.d* unchanged.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 22.3** 对权重为 *w*(*u*, *v*) = 2 的边 (*u*, *v*) 进行松弛。每个顶点的最短路径估计显示在顶点内部。**(a)**
    在松弛之前，因为 *v.d* > *u.d* + *w*(*u*, *v*)，所以 *v.d* 的值会减小。**(b)** 在边进行松弛之前，由于我们有 *v.d*
    ≤ *u.d* + *w*(*u*, *v*)，所以松弛步骤不会改变 *v.d* 的值。'
- en: RELAX(*u*, *v*, *w*)
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: RELAX(*u*, *v*, *w*)
- en: '| 1 | **if** *v.d* > *u.d* + *w*(*u*, *v*) |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **如果** *v.d* > *u.d* + *w*(*u*, *v*) |'
- en: '| 2 | *v.d* = *u.d* + *w*(*u*, *v*) |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *v.d* = *u.d* + *w*(*u*, *v*) |'
- en: '| 3 | *v*.π = *u* |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *v*.π = *u* |'
- en: Each algorithm in this chapter calls INITIALIZE-SINGLE-SOURCE and then repeatedly
    relaxes edges.^([1](#footnote_1)) Moreover, relaxation is the only means by which
    shortest-path estimates and predecessors change. The algorithms in this chapter
    differ in how many times they relax each edge and the order in which they relax
    edges. Dijkstra’s algorithm and the shortest-paths algorithm for directed acyclic
    graphs relax each edge exactly once. The Bellman-Ford algorithm relaxes each edge
    |*V*| − 1 times.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的每个算法都调用 INITIALIZE-SINGLE-SOURCE，然后重复地对边进行松弛。此外，松弛是最短路径估计和前驱更改的唯一方式。本章中的算法在对每条边进行松弛的次数和对边进行松弛的顺序上有所不同。Dijkstra
    算法和有向无环图的最短路径算法对每条边进行一次松弛。Bellman-Ford 算法对每条边进行松弛 |*V*| − 1 次。
- en: '**Properties of shortest paths and relaxation**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**最短路径和松弛的性质**'
- en: To prove the algorithms in this chapter correct, we’ll appeal to several properties
    of shortest paths and relaxation. We state these properties here, and [Section
    22.5](chapter022.xhtml#Sec_22.5) proves them formally. For your reference, each
    property stated here includes the appropriate lemma or corollary number from [Section
    22.5](chapter022.xhtml#Sec_22.5). The latter five of these properties, which refer
    to shortest-path estimates or the predecessor subgraph, implicitly assume that
    the graph is initialized with a call to INITIALIZE-SINGLE-SOURCE(*G*, *s*) and
    that the only way that shortest-path estimates and the predecessor subgraph change
    are by some sequence of relaxation steps.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明本章中的算法正确性，我们将依赖于最短路径和松弛的几个性质。我们在这里陈述这些性质，并且[第 22.5 节](chapter022.xhtml#Sec_22.5)对其进行正式证明。供参考，这里陈述的每个性质都包括来自[第
    22.5 节](chapter022.xhtml#Sec_22.5)的适当引理或推论编号。这些性质中的后五个，涉及最短路径估计或前驱子图，隐含地假定图是通过调用
    INITIALIZE-SINGLE-SOURCE(*G*, *s*) 进行初始化的，并且最短路径估计和前驱子图的改变只能通过一系列松弛步骤来实现。
- en: '**Triangle inequality** (Lemma 22.10)'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '**三角不等式** (引理 22.10)'
- en: For any edge (*u*, *v*) ∈ *E*, we have δ(*s*, *v*) ≤ δ(*s*, *u*) + *w*(*u*,
    *v*).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意边 (*u*, *v*) ∈ *E*，我们有 δ(*s*, *v*) ≤ δ(*s*, *u*) + *w*(*u*, *v*)。
- en: '**Upper-bound property** (Lemma 22.11)'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**上界性质** (引理 22.11)'
- en: We always have *v.d* ≥ δ(*s*, *v*) for all vertices *v* ∈ *V*, and once *v.d*
    achieves the value δ(*s*, *v*), it never changes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有顶点 *v* ∈ *V*，我们始终有 *v.d* ≥ δ(*s*, *v*)，一旦 *v.d* 达到值 δ(*s*, *v*)，它就不会再改变。
- en: '**No-path property** (Corollary 22.12)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**无路径性质** (推论 22.12)'
- en: If there is no path from *s* to *v*, then we always have *v.d* = δ(*s*, *v*)
    = ∞.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果从 *s* 到 *v* 不存在路径，则我们始终有 *v.d* = δ(*s*, *v*) = ∞。
- en: '**Convergence property** (Lemma 22.14)'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '**收敛性质** (引理 22.14)'
- en: If *s* ⇝ *u* → *v* is a shortest path in *G* for some *u*, *v* ∈ *V*, and if
    *u.d* = δ(*s*, *u*) at any time prior to relaxing edge (*u*, *v*), then *v.d*
    = δ(*s*, *v*) at all times afterward.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *s* ⇝ *u* → *v* 是 *G* 中某些 *u*, *v* ∈ *V* 的最短路径，并且在松弛边 (*u*, *v*) 之前的任何时间点
    *u.d* = δ(*s*, *u*)，那���在之后的任何时间点 *v.d* = δ(*s*, *v*)。
- en: '**Path-relaxation property** (Lemma 22.15)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**路径松弛性质** (引理 22.15)'
- en: If *p* = 〈*v*[0], *v*[1], … , *v[k]*〉 is a shortest path from *s* = *v*[0] to
    *v[k]*, and the edges of *p* are relaxed in the order (*v*[0], *v*[1]), (*v*[1],
    *v*[2]), … , (*v*[*k*−1], *v[k]*), then *v*[*k*].*d* = δ(*s*, *v[k]*). This property
    holds regardless of any other relaxation steps that occur, even if they are intermixed
    with relaxations of the edges of *p*.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *p* = 〈*v*[0], *v*[1], … , *v[k]*〉 是从 *s* = *v*[0] 到 *v[k]* 的最短路径，并且路径 *p*
    中的边按顺序 (*v*[0], *v*[1]), (*v*[1], *v*[2]), … , (*v*[*k*−1], *v[k]*) 进行松弛，那么 *v*[*k*].*d*
    = δ(*s*, *v[k]*)。无论发生任何其他松弛步骤，即使它们与路径 *p* 的边的松弛交错进行，这个性质仍然成立。
- en: '**Predecessor-subgraph property** (Lemma 22.17)'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**前驱子图性质** (引理 22.17)'
- en: Once *v.d* = δ(*s*, *v*) for all *v* ∈ *V*, the predecessor subgraph is a shortest-paths
    tree rooted at *s*.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对于所有 *v* ∈ *V* 都有 *v.d* = δ(*s*, *v*)，前驱子图就是以 *s* 为根的最短路径树。
- en: '**Chapter outline**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节大纲**'
- en: '[Section 22.1](chapter022.xhtml#Sec_22.1) presents the Bellman-Ford algorithm,
    which solves the single-source shortest-paths problem in the general case in which
    edges can have negative weight. The Bellman-Ford algorithm is remarkably simple,
    and it has the further benefit of detecting whether a negative-weight cycle is
    reachable from the source. [Section 22.2](chapter022.xhtml#Sec_22.2) gives a linear-time
    algorithm for computing shortest paths from a single source in a directed acyclic
    graph. [Section 22.3](chapter022.xhtml#Sec_22.3) covers Dijkstra’s algorithm,
    which has a lower running time than the Bellman-Ford algorithm but requires the
    edge weights to be nonnegative. [Section 22.4](chapter022.xhtml#Sec_22.4) shows
    how to use the Bellman-Ford algorithm to solve a special case of linear programming.
    Finally, [Section 22.5](chapter022.xhtml#Sec_22.5) proves the properties of shortest
    paths and relaxation stated above.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '[第22.1节](chapter022.xhtml#Sec_22.1)介绍了贝尔曼-福特算法，它解决了边权重可能为负的一般情况下的单源最短路径问题。贝尔曼-福特算法非常简单，并且还具有检测是否从源可达负权重环的额外好处。[第22.2节](chapter022.xhtml#Sec_22.2)给出了在有向无环图中从单个源计算最短路径的线性时间算法。[第22.3节](chapter022.xhtml#Sec_22.3)介绍了迪杰斯特拉算法，其运行时间低于贝尔曼-福特算法，但要求边权重为非负。[第22.4节](chapter022.xhtml#Sec_22.4)展示了如何使用贝尔曼-福特算法解决线性规划的特��情况。最后，[第22.5节](chapter022.xhtml#Sec_22.5)证明了上述最短路径和松弛性质。'
- en: This chapter does arithmetic with infinities, and so we need some conventions
    for when ∞ or −∞ appears in an arithmetic expression. We assume that for any real
    number *a* ≠ −∞, we have *a* + ∞ = ∞ + *a* = ∞. Also, to make our proofs hold
    in the presence of negative-weight cycles, we assume that for any real number
    *a* ≠ ∞, we have *a* + (−∞) = (−∞) + *a* = −∞.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 本章进行了无穷大的算术运算，因此我们需要一些约定，以处理算术表达式中出现∞或−∞的情况。我们假设对于任何实数*a* ≠ −∞，我们有*a* + ∞ =
    ∞ + *a* = ∞。此外，为了使我们的证明在存在负权重环的情况下成立，我们假设对于任何实数*a* ≠ ∞，我们有*a* + (−∞) = (−∞) +
    *a* = −∞。
- en: All algorithms in this chapter assume that the directed graph *G* is stored
    in the adjacency-list representation. Additionally, stored with each edge is its
    weight, so that as each algorithm traverses an adjacency list, it can find edge
    weights in *O*(1) time per edge.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的所有算法都假定有向图*G*以邻接表表示存储。此外，对于每条边，存储其权重，因此当每个算法遍历邻接表时，它可以在每条边上以*O*(1)的时间找到边权重。
- en: '[**22.1    The Bellman-Ford algorithm**](toc.xhtml#Rh1-129)'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '[**22.1    贝尔曼-福特算法**](toc.xhtml#Rh1-129)'
- en: 'The ***Bellman-Ford algorithm*** solves the single-source shortest-paths problem
    in the general case in which edge weights may be negative. Given a weighted, directed
    graph *G* = (*V*, *E*) with source vertex *s* and weight function *w* : *E* →
    ℝ, the Bellman-Ford algorithm returns a boolean value indicating whether there
    is a negative-weight cycle that is reachable from the source. If there is such
    a cycle, the algorithm indicates that no solution exists. If there is no such
    cycle, the algorithm produces the shortest paths and their weights.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '***贝尔曼-福特算法***解决了一般情况下边权值可能为负的单源最短路径问题。给定带有源顶点*s*和权重函数*w*：*E* → ℝ的加权有向图*G*
    = (*V*, *E*)，贝尔曼-福特算法返回一个布尔值，指示是否存在从源可达的负权重环。如果存在这样的环，算法指示不存在解决方案。如果没有这样的环，算法会产生最短路径及其权重。'
- en: The procedure BELLMAN-FORD relaxes edges, progressively decreasing an estimate
    *v.d* on the weight of a shortest path from the source *s* to each vertex *v*
    ∈ *V* until it achieves the actual shortest-path weight δ(*s*, *v*). The algorithm
    returns TRUE if and only if the graph contains no negative-weight cycles that
    are reachable from the source.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: BELLMAN-FORD过程逐渐减小对源*s*到每个顶点*v* ∈ *V*的最短路径权重δ(*s*, *v*)的估计*v.d*。如果图中不包含可从源到达的负权重环，则算法返回TRUE。
- en: BELLMAN-FORD(*G*, *w*, *s*)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: BELLMAN-FORD(*G*, *w*, *s*)
- en: '| 1 | INITIALIZE-SINGLE-SOURCE(*G*, *s*) |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 1 | INITIALIZE-SINGLE-SOURCE(*G*, *s*) |'
- en: '| 2 | **for** *i* = 1 **to** &#124;*G.V*&#124; − 1 |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **for** *i* = 1 **to** &#124;*G.V*&#124; − 1 |'
- en: '| 3 | **for** each edge (*u*, *v*) ∈ *G.E* |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **for** each edge (*u*, *v*) ∈ *G.E* |'
- en: '| 4 | RELAX(*u*, *v*, *w*) |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 4 | RELAX(*u*, *v*, *w*) |'
- en: '| 5 | **for** each edge (*u*, *v*) = *G.E* |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **for** each edge (*u*, *v*) = *G.E* |'
- en: '| 6 | **if** *v.d* > *u.d* + *w*(*u*, *v*) |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 6 | **if** *v.d* > *u.d* + *w*(*u*, *v*) |'
- en: '| 7 | **return** FALSE |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| 7 | **return** FALSE |'
- en: '| 8 | **return** TRUE |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 8 | **return** TRUE |'
- en: '[Figure 22.4](chapter022.xhtml#Fig_22-4) shows the execution of the Bellman-Ford
    algorithm on a graph with 5 vertices. After initializing the *d* and π values
    of all vertices in line 1, the algorithm makes |*V*| − 1 passes over the edges
    of the graph. Each pass is one iteration of the **for** loop of lines 2–4 and
    consists of relaxing each edge of the graph once. [Figures 22.4(b)](chapter022.xhtml#Fig_22-4)–[(e)](chapter022.xhtml#Fig_22-4)
    show the state of the algorithm after each of the four passes over the edges.
    After making |*V*| − 1 passes, lines 5–8 check for a negative-weight cycle and
    return the appropriate boolean value. (We’ll see a little later why this check
    works.)'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '[图22.4](chapter022.xhtml#Fig_22-4)展示了在具有5个顶点的图上执行贝尔曼-福特算法的过程。在第1行初始化所有顶点的*d*和π值之后，算法对图的边进行|*V*|
    − 1次遍历。每次遍历都是行2-4的**for**循环的一次迭代，包括对图的每条边进行一次松弛操作。[图22.4(b)](chapter022.xhtml#Fig_22-4)–[(e)](chapter022.xhtml#Fig_22-4)展示了每次对边进行四次遍历后算法的状态。经过|*V*|
    − 1次遍历后，行5-8检查是否存在负权重环，并返回相应的布尔值。（稍后我们会看到为什么这个检查有效。）'
- en: '![art](images/Art_P636.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P636.jpg)'
- en: '**Figure 22.4** The execution of the Bellman-Ford algorithm. The source is
    vertex *s*. The *d* values appear within the vertices, and blue edges indicate
    predecessor values: if edge (*u*, *v*) is blue, then *v*.π = *u*. In this particular
    example, each pass relaxes the edges in the order (*t*, *x*), (*t*, *y*), (*t*,
    *z*), (*x*, *t*), (*y*, *x*), (*y*, *z*), (*z*, *x*), (*z*, *s*), (*s*, *t*),
    (*s*, *y*). **(a)** The situation just before the first pass over the edges. **(b)–(e)**
    The situation after each successive pass over the edges. Vertices whose shortest-path
    estimates and predecessors have changed due to a pass are highlighted in orange.
    The *d* and π values in part (e) are the final values. The Bellman-Ford algorithm
    returns TRUE in this example.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 22.4** Bellman-Ford算法的执行。源是顶点*s*。*d*值出现在顶点内部，蓝色边表示前任值：如果边(*u*, *v*)是蓝色的，则*v*.π
    = *u*。在这个特定的例子中，每次通过以顺序(*t*, *x*)，(*t*, *y*)，(*t*, *z*)，(*x*, *t*)，(*y*, *x*)，(*y*,
    *z*)，(*z*, *x*)，(*z*, *s*)，(*s*, *t*)，(*s*, *y*) 松弛边。**(a)** 在第一次通过边之前的情况。**(b)–(e)**
    每次通过边后的情况。由于通过一次后，最短路径估计和前任发生了变化的顶点被突出显示为橙色。部分(e)中的*d*和π值是最终值。在这个例子中，Bellman-Ford算法返回TRUE。'
- en: The Bellman-Ford algorithm runs in *O*(*V*² + *VE*) time when the graph is represented
    by adjacency lists, since the initialization in line 1 takes Θ(*V*) time, each
    of the |*V*| − 1 passes over the edges in lines 2–4 takes Θ(*V* + *E*) time (examining
    |*V*| adjacency lists to find the |*E*| edges), and the **for** loop of lines
    5–7 takes *O*(*V* + *E*) time. Fewer than |*V*| − 1 passes over the edges sometimes
    suffice (see Exercise 22.1-3), which is why we say *O*(*V*²+*VE*) time, rather
    than Θ(*V*²+*VE*) time. In the frequent case where |*E*| = Ω(*V*), we can express
    this running time as *O*(*VE*). Exercise 22.1-5 asks you to make the Bellman-Ford
    algorithm run in *O*(*VE*) time even when |*E*| = *o*(*V*).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 当图由邻接表表示时，Bellman-Ford算法的运行时间为*O*(*V*² + *VE*)，因为第1行的初始化需要Θ(*V*)时间，第2-4行中对边的|*V*|
    − 1次迭代需要Θ(*V* + *E*)时间（检查|*V*|个邻接表以找到|*E*|条边），而第5-7行的**for**循环需要*O*(*V* + *E*)时间。有时少于|*V*|
    − 1次对边的迭代就足够了（参见练习22.1-3），这就是为什么我们说*O*(*V*²+*VE*)时间，而不是Θ(*V*²+*VE*)时间。在|*E*| =
    Ω(*V*)的常见情况下，我们可以将这个运行时间表示为*O*(*VE*)。练习22.1-5要求您使Bellman-Ford算法在|*E*| = *o*(*V*)时以*O*(*VE*)时间运行。
- en: To prove the correctness of the Bellman-Ford algorithm, we start by showing
    that if there are no negative-weight cycles, the algorithm computes correct shortest-path
    weights for all vertices reachable from the source.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明Bellman-Ford算法的正确性，我们首先展示如果没有负权重环路，算法会计算出所有从源可达的顶点的正确最短路径权重。
- en: '***Lemma 22.2***'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 22.2***'
- en: 'Let *G* = (*V*, *E*) be a weighted, directed graph with source vertex *s* and
    weight function *w* : *E* → ℝ, and assume that *G* contains no negative-weight
    cycles that are reachable from *s*. Then, after the |*V*| − 1 iterations of the
    **for** loop of lines 2–4 of BELLMAN-FORD, *v.d* = δ(*s*, *v*) for all vertices
    *v* that are reachable from *s*.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 让*G* = (*V*, *E*)是一个带有源顶点*s*和权重函数*w*：*E* → ℝ的加权有向图，并假设*G*不包含从*s*可达的负权重环路。那么，在BELLMAN-FORD的第2-4行的**for**循环的|*V*|
    − 1次迭代之后，对于所有从*s*可达的顶点*v*，*v.d* = δ(*s*, *v*)。
- en: '***Proof***   We prove the lemma by appealing to the path-relaxation property.
    Consider any vertex *v* that is reachable from *s*, and let *p* = 〈*v*[0], *v*[1],
    … , *v[k]*〉, where *v*[0] = *s* and *v[k]* = *v*, be any shortest path from *s*
    to *v*. Because shortest paths are simple, *p* has at most |*V*| − 1 edges, and
    so *k* ≤ |*V*| − 1\. Each of the |*V*| − 1 iterations of the **for** loop of lines
    2–4 relaxes all |*E*| edges. Among the edges relaxed in the *i*th iteration, for
    *i* = 1, 2, … , *k*, is (*v*[*i*−1], *v[i]*). By the path-relaxation property,
    therefore, *v.d* = *v[k].d* = δ(*s*, *v[k]*) = δ(*s*, *v*).'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   我们通过引用路径松弛性质来证明引理。考虑任意可从*s*到达的顶点*v*，并且让*p* = 〈*v*[0], *v*[1], …
    , *v[k]*〉，其中*v*[0] = *s*且*v[k]* = *v*，是从*s*到*v*的任意最短路径。因为最短路径是简单的，*p*最多有|*V*|
    − 1条边，因此*k* ≤ |*V*| − 1。每次第*i*次迭代的**for**循环的|*E*|条边都会被松弛。在第*i*次迭代中被松弛的边，对于*i*
    = 1, 2, … , *k*，是(*v*[*i*−1], *v[i]*)。因此，根据路径松弛性质，*v.d* = *v[k].d* = δ(*s*, *v[k]*)
    = δ(*s*, *v*)。'
- en: ▪
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Corollary 22.3***'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论 22.3***'
- en: 'Let *G* = (*V*, *E*) be a weighted, directed graph with source vertex *s* and
    weight function *w* : *E* → ℝ. Then, for each vertex *v* ∈ *V*, there is a path
    from *s* to *v* if and only if BELLMAN-FORD terminates with *v.d* < ∞ when it
    is run on *G*.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让*G* = (*V*, *E*)是一个带有源顶点*s*和权重函数*w*：*E* → ℝ的加权有向图。那么，对于每个顶点*v* ∈ *V*，当在*G*上运行时，如果BELLMAN-FORD以*v.d*
    < ∞终止，则从*s*到*v*存在一条路径。
- en: '***Proof***   The proof is left as Exercise 22.1-2.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   证明留作练习22.1-2。'
- en: ▪
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Theorem 22.4 (Correctness of the Bellman-Ford algorithm)***'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 22.4 (Bellman-Ford算法的正确性)***'
- en: 'Let BELLMAN-FORD be run on a weighted, directed graph *G* = (*V*, *E*) with
    source vertex *s* and weight function *w* : *E* → ℝ. If *G* contains no negative-weight
    cycles that are reachable from *s*, then the algorithm returns TRUE, *v.d* = δ(*s*,
    v) for all vertices *v* ∈ *V*, and the predecessor subgraph *G*[π] is a shortest-paths
    tree rooted at *s*. If *G* does contain a negative-weight cycle reachable from
    *s*, then the algorithm returns FALSE.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让BELLMAN-FORD在带有源顶点*s*和权重函数*w*：*E* → ℝ的加权有向图*G* = (*V*, *E*)上运行。如果*G*不包含从*s*可达的负权重环路，则算法返回TRUE，对于所有顶点*v*
    ∈ *V*，*v.d* = δ(*s*, v)，并且前任子图*G*[π]是以*s*为根的最短路径树。如果*G*确实包含从*s*可达的负权重环路，则算法返回FALSE。
- en: '***Proof***   Suppose that graph *G* contains no negative-weight cycles that
    are reachable from the source s. We first prove the claim that at termination,
    *v.d* = δ(*s*, *v*) for all vertices *v* ∈ *V*. If vertex *v* is reachable from
    *s*, then Lemma 22.2 proves this claim. If *v* is not reachable from *s*, then
    the claim follows from the no-path property. Thus, the claim is proven. The predecessor-subgraph
    property, along with the claim, implies that *G*[π] is a shortest-paths tree.
    Now we use the claim to show that BELLMAN-FORD returns TRUE. At termination, for
    all edges (*u*, *v*) ∈ *E* we have'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   假设图 *G* 不包含从源点 s 可达的负权重环。我们首先证明在终止时，对于所有顶点 *v* ∈ *V*，*v.d* = δ(*s*,
    *v*)。如果顶点 *v* 是从 *s* 可达的，则引理 22.2 证明了这一点。如果 *v* 从 *s* 不可达，则该声明来自无路径性质。因此���该声明得到证明。前驱子图性质以及该声明意味着
    *G*[π] 是一棵最短路径树。现在我们使用该声明来展示 BELLMAN-FORD 返回 TRUE。在终止时，对于所有边 (*u*, *v*) ∈ *E*，我们有'
- en: '| *v.d* | = | δ(*s*, *v*) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| *v.d* | = | δ(*s*, *v*) |'
- en: '|  | ≤ | δ(*s*, *u*) + *w*(*u*, *v*) (by the triangle inequality) |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | δ(*s*, *u*) + *w*(*u*, *v*)（根据三角不等式） |'
- en: '|  | = | *u.d* + *w*(*u*, *v*), |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *u.d* + *w*(*u*, *v*)， |'
- en: and so none of the tests in line 6 causes BELLMAN-FORD to return FALSE. Therefore,
    it returns TRUE.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第 6 行中的所有测试都不会导致 BELLMAN-FORD 返回 FALSE。因此，它返回 TRUE。
- en: Now, suppose that graph *G* contains a negative-weight cycle reachable from
    the source *s*. Let this cycle be *c* = 〈*v*[0], *v*[1], … , *v[k]*〉, where *v*[0]
    = *v[k]*, in which case we have
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设图 *G* 包含从源点 *s* 可达的负权重环。让这个环为 *c* = 〈*v*[0], *v*[1], … , *v[k]*〉，其中 *v*[0]
    = *v[k]*，在这种情况下我们有
- en: '![art](images/Art_P637.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P637.jpg)'
- en: Assume for the purpose of contradiction that the Bellman-Ford algorithm returns
    TRUE. Thus, *v[i].d* ≤ *v*[*i*−1].*d* + *w*(*v*[*i*−1], *v[i]*) for *i* = 1, 2,
    … , *k*. Summing the inequalities around cycle *c* gives
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 假设为了推导，Bellman-Ford 算法返回 TRUE。因此，对于 *i* = 1, 2, … , *k*，有 *v[i].d* ≤ *v*[*i*−1].*d*
    + *w*(*v*[*i*−1], *v[i]*)。对环 *c* 周围的不等式求和得到
- en: '![art](images/Art_P638.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P638.jpg)'
- en: Since *v*[0] = *v[k]*, each vertex in *c* appears exactly once in each of the
    summations ![art](images/Art_P639.jpg) and ![art](images/Art_P640.jpg), and so
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *v*[0] = *v[k]*，所以 *c* 中的每个顶点在求和 ![艺术](images/Art_P639.jpg) 和 ![艺术](images/Art_P640.jpg)
    中都恰好出现一次，因此
- en: '![art](images/Art_P641.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P641.jpg)'
- en: Moreover, by Corollary 22.3, *v[i].d* is finite for *i* = 1, 2, … , *k*. Thus,
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，根据推论 22.3，对于 *i* = 1, 2, … , *k*，*v[i].d* 都是有限的。因此，
- en: '![art](images/Art_P642.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P642.jpg)'
- en: which contradicts inequality (22.1). We conclude that the Bellman-Ford algorithm
    returns TRUE if graph *G* contains no negative-weight cycles reachable from the
    source, and FALSE otherwise.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这与不等式 (22.1) 矛盾。我们得出结论，如果图 *G* 中不包含从源点可达的负权重环，则 BELLMAN-FORD 算法返回 TRUE，否则返回
    FALSE。
- en: ▪
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Exercises**'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***22.1-1***'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.1-1***'
- en: Run the Bellman-Ford algorithm on the directed graph of [Figure 22.4](chapter022.xhtml#Fig_22-4),
    using vertex *z* as the source. In each pass, relax edges in the same order as
    in the figure, and show the *d* and π values after each pass. Now, change the
    weight of edge (*z*, *x*) to 4 and run the algorithm again, using *s* as the source.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在有向图 [图 22.4](chapter022.xhtml#Fig_22-4) 上使用顶点 *z* 作为源点运行 BELLMAN-FORD 算法。在每次迭代中，按照图中的顺序放松边，并展示每次迭代后的
    *d* 和 π 值。现在，将边 (*z*, *x*) 的权重更改为 4，再次使用 *s* 作为源点运行算法。
- en: '***22.1-2***'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.1-2***'
- en: Prove Corollary 22.3.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 证明推论 22.3。
- en: '***22.1-3***'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.1-3***'
- en: Given a weighted, directed graph *G* = (*V*, *E*) with no negative-weight cycles,
    let *m* be the maximum over all vertices *v* ∈ *V* of the minimum number of edges
    in a shortest path from the source *s* to *v*. (Here, the shortest path is by
    weight, not the number of edges.) Suggest a simple change to the Bellman-Ford
    algorithm that allows it to terminate in *m* + 1 passes, even if *m* is not known
    in advance.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个没有负权重环的带权重的有向图 *G* = (*V*, *E*)，让 *m* 是所有顶点 *v* ∈ *V* 中从源点 *s* 到 *v* 的最短路径中边的最小数量的最大值。建议对
    BELLMAN-FORD 算法进行简单更改，使其在 *m* + 1 次迭代中终止，即使 *m* 事先未知。
- en: '***22.1-4***'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.1-4***'
- en: Modify the Bellman-Ford algorithm so that it sets *v.d* to −∞ for all vertices
    *v* for which there is a negative-weight cycle on some path from the source to
    *v*.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 Bellman-Ford 算法，使其对于所有存在从源点到 *v* 的路径上存在负权重环的顶点 *v* 将 *v.d* 设置为 −∞。
- en: '***22.1-5***'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.1-5***'
- en: Suppose that the graph given as input to the Bellman-Ford algorithm is represented
    with a list of |*E*| edges, where each edge indicates the vertices it leaves and
    enters, along with its weight. Argue that the Bellman-Ford algorithm runs in *O*(*VE*)
    time without the constraint that |*E*| = Ω(*V*). Modify the Bellman-Ford algorithm
    so that it runs in *O*(*VE*) time in all cases when the input graph is represented
    with adjacency lists.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 假设输入给 BELLMAN-FORD 算法的图是由 |*E*| 条边的列表表示的，其中每条边指示它离开和进入的顶点，以及它的权重。证明 BELLMAN-FORD
    算法在不受 |*E*| = Ω(*V*) 约束的情况下以 *O*(*VE*) 时间运行。修改 BELLMAN-FORD 算法，使其在输入图用邻接表表示时在所有情况下以
    *O*(*VE*) 时间运行。
- en: '***22.1-6***'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.1-6***'
- en: 'Let *G* = (*V*, *E*) be a weighted, directed graph with weight function *w*
    : *E* → ℝ. Give an *O*(*VE*)-time algorithm to find, for all vertices *v* ∈ *V*,
    the value δ*(*v*) = min {δ(*u*, *v*) : *u* ∈ *V*}.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '设 *G* = (*V*, *E*) 是一个带权重的有向图，权重函数为 *w* : *E* → ℝ。给出一个 *O*(*VE*) 时间复杂度的算法，用于找到所有顶点
    *v* ∈ *V* 的值 δ*(*v*) = min {δ(*u*, *v*) : *u* ∈ *V*}。'
- en: '***22.1-7***'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.1-7***'
- en: Suppose that a weighted, directed graph *G* = (*V*, *E*) contains a negative-weight
    cycle. Give an efficient algorithm to list the vertices of one such cycle. Prove
    that your algorithm is correct.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 假设带权重的有向图 *G* = (*V*, *E*) 包含一个负权重环。给出一个有效的算法来列出这样一个环的顶点。证明你的算法是正确的。
- en: '[**22.2    Single-source shortest paths in directed acyclic graphs**](toc.xhtml#Rh1-130)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[**22.2    有向无环图中的单源最短路径**](toc.xhtml#Rh1-130)'
- en: 'In this section, we introduce one further restriction on weighted, directed
    graphs: they are acyclic. That is, we are concerned with weighted dags. Shortest
    paths are always well defined in a dag, since even if there are negative-weight
    edges, no negative-weight cycles can exist. We’ll see that if the edges of a weighted
    dag *G* = (*V*, *E*) are relaxed according to a topological sort of its vertices,
    it takes only Θ(*V* + *E*) time to compute shortest paths from a single source.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们对加权有向图引入了进一步的限制：它们是无环的。也就是说，我们关注的是加权有向无环图。在无环图中，最短路径总是明确定义的，因为即使存在负权边，也不会存在负权环。我们将看到，如果加权有向无环图
    *G* = (*V*, *E*) 的边根据其顶点的拓扑排序进行松弛，从单个源点计算最短路径只需要 Θ(*V* + *E*) 的时间。
- en: The algorithm starts by topologically sorting the dag (see [Section 20.4](chapter020.xhtml#Sec_20.4))
    to impose a linear ordering on the vertices. If the dag contains a path from vertex
    *u* to vertex *v*, then *u* precedes *v* in the topological sort. The DAG-SHORTEST-PATHS
    procedure makes just one pass over the vertices in the topologically sorted order.
    As it processes each vertex, it relaxes each edge that leaves the vertex. [Figure
    22.5](chapter022.xhtml#Fig_22-5) shows the execution of this algorithm.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法首先对有向无环图进行拓扑排序（参见[第 20.4 节](chapter020.xhtml#Sec_20.4)），为顶点施加线性顺序。如果有从顶点
    *u* 到顶点 *v* 的路径，则在拓扑排序中 *u* 在 *v* 之前。DAG-SHORTEST-PATHS 过程只需按照拓扑排序顺序对顶点进行一次遍历。在处理每个顶点时，它会松弛离开该顶点的每条边。[图
    22.5](chapter022.xhtml#Fig_22-5) 展示了该算法的执行过程。
- en: DAG-SHORTEST-PATHS(*G*, *w*, *s*)
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: DAG-SHORTEST-PATHS(*G*, *w*, *s*)
- en: '| 1 | topologically sort the vertices of *G* |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 对 *G* 的顶点进行拓扑排序 |'
- en: '| 2 | INITIALIZE-SINGLE-SOURCE(*G*, *s*) |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 2 | INITIALIZE-SINGLE-SOURCE(*G*, *s*) |'
- en: '| 3 | **for** each vertex *u* ∈ *G.V*, taken in topologically sorted order
    |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **对于** *G.V* **中的每个顶点** *u*，**按拓扑排序顺序取出** |'
- en: '| 4 | **for** each vertex *v* in *G.Adj*[*u*] |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **对于** *G.Adj*[*u*] **中的每个顶点** *v* |'
- en: '| 5 | RELAX(*u*, *v*, *w*) |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 5 | RELAX(*u*, *v*, *w*) |'
- en: Let’s analyze the running time of this algorithm. As shown in [Section 20.4](chapter020.xhtml#Sec_20.4),
    the topological sort of line 1 takes Θ(*V* + *E*) time. The call of INITIALIZE-SINGLE-SOURCE
    in line 2 takes Θ(*V*) time. The **for** loop of lines 3–5 makes one iteration
    per vertex. Altogether, the **for** loop of lines 4–5 relaxes each edge exactly
    once. (We have used an aggregate analysis here.) Because each iteration of the
    inner **for** loop takes Θ(1) time, the total running time is Θ(*V* + *E*), which
    is linear in the size of an adjacency-list representation of the graph.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析这个算法的运行时间。如[第 20.4 节](chapter020.xhtml#Sec_20.4)所示，第 1 行的拓扑排序需要 Θ(*V* +
    *E*) 的时间。第 2 行调用 INITIALIZE-SINGLE-SOURCE 需要 Θ(*V*) 的时间。第 3-5 行的 **for** 循环每个顶点进行一次迭代。总体来说，第
    4-5 行的 **for** 循环对每条边进行一次松弛。（这里我们使用了聚合分析。）由于内部 **for** 循环的每次迭代需要 Θ(1) 的时间，总运行时间为
    Θ(*V* + *E*)，这在图的邻接表表示中是线性的。
- en: The following theorem shows that the DAG-SHORTEST-PATHS procedure correctly
    computes the shortest paths.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的定理表明 DAG-SHORTEST-PATHS 过程正确计算了最短路径。
- en: '***Theorem 22.5***'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 22.5***'
- en: If a weighted, directed graph *G* = (*V*, *E*) has source vertex *s* and no
    cycles, then at the termination of the DAG-SHORTEST-PATHS procedure, *v.d* = δ(*s*,
    *v*) for all vertices *v* ∈ *V*, and the predecessor subgraph *G*[π] is a shortest-paths
    tree.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 如果加权有向图 *G* = (*V*, *E*) 有源顶点 *s* 且没有环路，那么在 DAG-SHORTEST-PATHS 过程终止时，对于所有顶点
    *v* ∈ *V*，*v.d* = δ(*s*, *v*)，并且前驱子图 *G*[π] 是一棵最短路径树。
- en: '***Proof***   We first show that *v.d* = δ(*s*, *v*) for all vertices *v* ∈
    *V* at termination. If *v* is not reachable from *s*, then *v.d* = δ(*s*, *v*)
    = 1 by the no-path property. Now, suppose that *v* is reachable from *s*, so that
    there is a shortest path *p* = 〈*v*[0], *v*[1], … , *v[k]*〉, where *v*[0] = *s*
    and *v[k]* = *v*. Because DAG-SHORTEST-PATHS processes the vertices in topologically
    sorted order, it relaxes the edges on *p* in the order (*v*[0], *v*[1]), (*v*[1],
    *v*[2]), … , (*v*[*k*−1], *v[k]*). The path-relaxation property implies that *v[i].d*
    = δ(*s*, *v[i]*) at termination for *i* = 0, 1, … , *k*. Finally, by the predecessor-subgraph
    property, *G*[π] is a shortest-paths tree.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 我们首先证明在终止时对于所有顶点 *v* ∈ *V*，*v.d* = δ(*s*, *v*)。如果 *v* 从 *s* 不可达，则根据无路径性质，*v.d*
    = δ(*s*, *v*) = 1。现在，假设 *v* 从 *s* 可达，因此存在最短路径 *p* = 〈*v*[0], *v*[1], … , *v[k]*〉，其中
    *v*[0] = *s* 且 *v[k]* = *v*。由于 DAG-SHORTEST-PATHS 按拓扑排序顺序处理顶点，它按顺序松弛 *p* 上的边，即
    (*v*[0], *v*[1])，(*v*[1], *v*[2])，…，(*v*[*k*−1], *v[k]*)。路径松弛性质意味着对于 *i* = 0,
    1, … , *k*，在终止时 *v[i].d* = δ(*s*, *v[i]*)。最后，根据前驱子图性质，*G*[π] 是一棵最短路径树。'
- en: ▪
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: 'A useful application of this algorithm arises in determining critical paths
    in ***PERT chart***^([2](#footnote_2)) analysis. *A* job consists of several tasks.
    Each task takes a certain amount of time, and some tasks must be completed before
    others can be started. For example, if the job is to build a house, then the foundation
    must be completed before starting to frame the exterior walls, which must be completed
    before starting on the roof. Some tasks require more than one other task to be
    completed before they can be started: before the drywall can be installed over
    the wall framing, both the electrical system and plumbing must be installed. A
    dag models the tasks and dependencies. Edges represent tasks, with the weight
    of an edge indicating the time required to perform the task. Vertices represent
    “milestones,” which are achieved when all the tasks represented by the edges entering
    the vertex have been completed. If edge (*u*, *v*) enters vertex *v* and edge
    (*v*, *x*) leaves *v*, then task (*u*, *v*) must be completed before task (*v*,
    *x*) is started. A path through this dag represents a sequence of tasks that must
    be performed in a particular order. A ***critical path*** is a *longest* path
    through the dag, corresponding to the longest time to perform any sequence of
    tasks. Thus, the weight of a critical path provides a lower bound on the total
    time to perform all the tasks, even if as many tasks as possible are performed
    simultaneously. You can find a critical path by either'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法的一个有用应用是在PERT图分析中确定关键路径。一个工作由多个任务组成。每个任务需要一定的时间完成，有些任务必须在其他任务开始之前完成。例如，如果工作是建造一座房子，那么在开始构建外墙框架之前必须完成地基，而在开始屋顶之前必须完成外墙框架。有些任务需要完成多于一个其他任务才能开始：在干墙安装在墙框架上之前，电气系统和管道必须安装。dag模拟了任务和依赖关系。边代表任务，边的权重表示执行任务所需的时间。顶点代表“里程碑”，当进入顶点的所有边代表的任务都完成时达到。如果边(*u*,
    *v*)进入顶点*v*，边(*v*, *x*)离开*v*，则任务(*u*, *v*)必须在任务(*v*, *x*)开始之前完成。通过dag的路径表示必须按特定顺序执行的任务序列。一个***关键路径***是dag中的*最长*路径，对应于执行任何任务序列所需的最长时间。因此，关键路径的权重提供了执行所有任务所需的总时间的下界，即使尽可能多的任务同时执行。你可以通过以下方式找到关键路径
- en: negating the edge weights and running DAG-SHORTEST-PATHS, or
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反转边权重并运行DAG-SHORTEST-PATHS，或
- en: running DAG-SHORTEST-PATHS, but replacing “∞” by “−∞” in line 2 of INITIALIZE-SINGLE-SOURCE
    and “>” by “<” in the RELAX procedure.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行DAG-SHORTEST-PATHS，但在INITIALIZE-SINGLE-SOURCE的第2行将“∞”替换为“-∞”，在RELAX过程中将“>”替换为“<”。
- en: '![art](images/Art_P643.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P643.jpg)'
- en: '**Figure 22.5** The execution of the algorithm for shortest paths in a directed
    acyclic graph. The vertices are topologically sorted from left to right. The source
    vertex is *s*. The *d* values appear within the vertices, and blue edges indicate
    the π values. **(a)** The situation before the first iteration of the **for**
    loop of lines 3–5\. **(b)–(g)** The situation after each iteration of the **for**
    loop of lines 3–5\. Blue vertices have had their outgoing edges relaxed. The vertex
    highlighted in orange was used as *u* in that iteration. Each edge highlighted
    in orange caused a *d* value to change when it was relaxed in that iteration.
    The values shown in part (g) are the final values.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 22.5** 在有向无环图中最短路径算法的执行过程。顶点从左到右进行拓扑排序。源顶点为*s*。*d*值出现在顶点内部，蓝色边表示π值。**(a)**
    在第3-5行的**for**循环的第一次迭代之前的情况。**(b)-(g)** 在第3-5行的**for**循环的每次迭代之后的情况。蓝色顶点已经放松了其出边。橙色突出显示的顶点在该迭代中被用作*u*。每条橙色突出显示的边在被该迭代中放松时导致*d*值发生变化。在(g)部分显示的值是最终值。'
- en: '**Exercises**'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***22.2-1***'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.2-1***'
- en: Show the result of running DAG-SHORTEST-PATHS on the directed acyclic graph
    of [Figure 22.5](chapter022.xhtml#Fig_22-5), using vertex *r* as the source.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 展示在有向无环图[图 22.5](chapter022.xhtml#Fig_22-5)上以顶点*r*为源运行DAG-SHORTEST-PATHS的结果。
- en: '***22.2-2***'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.2-2***'
- en: Suppose that you change line 3 of DAG-SHORTEST-PATHS to read
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你将DAG-SHORTEST-PATHS的第3行改为
- en: '| 3 | **for** the first &#124;*V*&#124; − 1 vertices, taken in topologically
    sorted order |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **对于**第&#124;*V*&#124; − 1个顶点，按拓扑排序顺序选择 |'
- en: Show that the procedure remains correct.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 证明该过程仍然是正确的。
- en: '***22.2-3***'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.2-3***'
- en: An alternative way to represent a PERT chart looks more like the dag of [Figure
    20.7](chapter020.xhtml#Fig_20-7) on page 574\. Vertices represent tasks and edges
    represent sequencing constraints, that is, edge (*u*, *v*) indicates that task
    *u* must be performed before task *v*. Vertices, not edges, have weights. Modify
    the DAG-SHORTEST-PATHS procedure so that it finds a longest path in a directed
    acyclic graph with weighted vertices in linear time.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 代表PERT图的另一种方式更像是[图 20.7](chapter020.xhtml#Fig_20-7)在第574页的dag。顶点代表任务，边代表顺序约束，也就是说，边(*u*,
    *v*)表示任务*u*必须在任务*v*之前执行。顶点而非边具有权重。修改DAG-SHORTEST-PATHS过程，使其能在线性时间内找到有权重顶点的有向无环图中的最长路径。
- en: ★ ***22.2-4***
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***22.2-4***
- en: Give an efficient algorithm to count the total number of paths in a directed
    acyclic graph. The count should include all paths between all pairs of vertices
    and all paths with 0 edges. Analyze your algorithm.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个高效的算法来计算有向无环图中路径的总数。计数应包括所有顶点对之间的所有路径和具有0条边的所有路径。分析你的算法。
- en: '[**22.3    Dijkstra’s algorithm**](toc.xhtml#Rh1-131)'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '[**22.3    Dijkstra算法**](toc.xhtml#Rh1-131)'
- en: 'Dijkstra’s algorithm solves the single-source shortest-paths problem on a weighted,
    directed graph *G* = (*V*, *E*), but it requires nonnegative weights on all edges:
    *w*(*u*, *v*) ≥ 0 for each edge (*u*, *v*) ∈ *E*. As we shall see, with a good
    implementation, the running time of Dijkstra’s algorithm is lower than that of
    the Bellman-Ford algorithm.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra算法解决了加权有向图*G* = (*V*, *E*)上的单源最短路径问题，但它要求所有边上的权重为非负：对于每条边(*u*, *v*)
    ∈ *E*，*w*(*u*, *v*) ≥ 0。正如我们将看到的，通过良好的实现，Dijkstra算法的运行时间低于Bellman-Ford算法。
- en: You can think of Dijkstra’s algorithm as generalizing breadth-first search to
    weighted graphs. A wave emanates from the source, and the first time that a wave
    arrives at a vertex, a new wave emanates from that vertex. Whereas breadth-first
    search operates as if each wave takes unit time to traverse an edge, in a weighted
    graph, the time for a wave to traverse an edge is given by the edge’s weight.
    Because a shortest path in a weighted graph might not have the fewest edges, a
    simple, first-in, first-out queue won’t suffice for choosing the next vertex from
    which to send out a wave.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将Dijkstra算法视为将广度优先搜索推广到加权图的过程。一波波从源点传播，当一波波到达一个顶点时，从该顶点再传播出一波波。而广度优先搜索则是假设每一波波在穿过一条边时花费单位时间，在加权图中，一波波穿过一条边所需时间由边的权重给出。因为在加权图中最短路径可能不是边数最少的路径，简单的先进先出队列无法选择下一个顶点来传播波波。
- en: Instead, Dijkstra’s algorithm maintains a set *S* of vertices whose final shortest-path
    weights from the source *s* have already been determined. The algorithm repeatedly
    selects the vertex *u* ∈ *V* – *S* with the minimum shortest-path estimate, adds
    *u* into *S*, and relaxes all edges leaving *u*. The procedure DIJKSTRA replaces
    the first-in, first-out queue of breadth-first search by a min-priority queue
    *Q* of vertices, keyed by their *d* values.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，Dijkstra算法维护一个顶点集合*S*，其中已经确定了从源点*s*到达的最短路径权重。该算法重复选择顶点*u* ∈ *V* – *S*，其具有最小的最短路径估计值，将*u*添加到*S*中，并放松所有从*u*出发的边。DIJKSTRA过程用最小优先队列*Q*替换了广度优先搜索的先进先出队列，其键值为它们的*d*值。
- en: DIJKSTRA(*G*, *w*, *s*)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: DIJKSTRA(*G*, *w*, *s*)
- en: '|   1 | INITIALIZE-SINGLE-SOURCE(*G*, *s*) |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '|   1 | 初始化单源(*G*, *s*) |'
- en: '|   2 | *S* = Ø |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '|   2 | *S* = Ø |'
- en: '|   3 | *Q* = Ø |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|   3 | *Q* = Ø |'
- en: '|   4 | **for** each vertex *u* ∈ *G.V* |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '|   4 | **对于** 每个顶点 *u* ∈ *G.V* **执行** |'
- en: '|   5 | INSERT(*Q, u*) |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '|   5 | 插入(*Q, u*) |'
- en: '|   6 | **while** *Q* ≠ Ø |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '|   6 | **当** *Q* ≠ Ø **时** |'
- en: '|   7 | *u* = EXTRACT-MIN(*Q*) |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|   7 | *u* = 取出最小(*Q*) |'
- en: '|   8 | S = *S* ∪ {u} |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|   8 | *S* = *S* ∪ {u} |'
- en: '|   9 | **for** each vertex *v* in *G.Adj*[*u*] |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '|   9 | **对于** 每个顶点*v*在*G.Adj*[*u*] **中** |'
- en: '| 10 | RELAX(*u*, *v*, *w*) |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 放松(*u*, *v*, *w*) |'
- en: '| 11 | **if** the call of RELAX decreased *v.d* |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 11 | **如果** 调用RELAX减小了 *v.d* **则** |'
- en: '| 12 | DECREASE-KEY(*Q*, *v*, *v.d*) |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 减小键值(*Q*, *v*, *v.d*) |'
- en: Dijkstra’s algorithm relaxes edges as shown in [Figure 22.6](chapter022.xhtml#Fig_22-6).
    Line 1 initializes the *d* and π values in the usual way, and line 2 initializes
    the set *S* to the empty set. The algorithm maintains the invariant that *Q* =
    *V* − *S* at the start of each iteration of the **while** loop of lines 6–12\.
    Lines 3–5 initialize the min-priority queue *Q* to contain all the vertices in
    *V*. Since *S* = Ø at that time, the invariant is true upon first reaching line
    6\. Each time through the **while** loop of lines 6–12, line 7 extracts a vertex
    *u* from *Q* = *V* − *S* and line 8 adds it to set *S*, thereby maintaining the
    invariant. (The first time through this loop, *u* = *s*.) Vertex *u*, therefore,
    has the smallest shortest-path estimate of any vertex in *V* − *S*. Then, lines
    9–12 relax each edge (*u*, *v*) leaving *u*, thus updating the estimate *v.d*
    and the predecessor *v*.π if the shortest path to *v* found so far improves by
    going through *u*. Whenever a relaxation step changes the *d* and π values, the
    call to DECREASE-KEY in line 12 updates the min-priority queue. The algorithm
    never inserts vertices into *Q* after the **for** loop of lines 4–5, and each
    vertex is extracted from *Q* and added to *S* exactly once, so that the **while**
    loop of lines 6–12 iterates exactly |*V*| times.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra算法如[图22.6](chapter022.xhtml#Fig_22-6)所示放松边。第1行通常方式初始化*d*和π值，第2行将集合*S*初始化为空集。算法保持不变式，即在每次循环的开始，*Q*
    = *V* − *S*。第3–5行将最小优先队列*Q*初始化为包含*V*中所有顶点。因为此时*S* = Ø，因此在第一次到达第6行时不变式成立。每次通过第6–12行的**当**循环时，第7行从*Q*
    = *V* − *S*中取出一个顶点*u*，第8行将其添加到集合*S*中，从而保持不变式。（第一次循环时，*u* = *s*。）因此，顶点*u*具有*V*
    − *S*中任何顶点中最小的最短路径估计值。然后，第9–12行放松每条离开*u*的边(*u*, *v*)，从而更新估计值*v.d*和前驱*v*.π，如果到目前为止通过*u*找到的到*v*的最短路径得到改进。每当放松步骤改变*d*和π值时，第12行的DECREASE-KEY调用更新最小优先队列。算法在第4–5行的**对于**循环后不再向*Q*中插入顶点，每个顶点仅从*Q*中提取并添加到*S*中一次，因此第6–12行的**当**循环正好迭代了|*V*|次。
- en: '![art](images/Art_P644.jpg)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P644.jpg)'
- en: '**Figure 22.6** The execution of Dijkstra’s algorithm. The source *s* is the
    leftmost vertex. The shortest-path estimates appear within the vertices, and blue
    edges indicate predecessor values. Blue vertices belong to the set *S*, and tan
    vertices are in the min-priority queue *Q* = *V* − *S*. **(a)** The situation
    just before the first iteration of the **while** loop of lines 6–12\. **(b)–(f)**
    The situation after each successive iteration of the **while** loop. In each part,
    the vertex highlighted in orange was chosen as vertex *u* in line 7, and each
    edge highlighted in orange caused a *d* value and a predecessor to change when
    the edge was relaxed. The *d* values and predecessors shown in part (f) are the
    final values.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**图22.6** Dijkstra算法的执行过程。源点*s*是最左侧的顶点。最短路径估计值显示在顶点内部，蓝色边表示前驱值。蓝色顶点属于集合*S*，棕色顶点在最小优先队列*Q*
    = *V* − *S*中。**(a)** 在第6–12行的第一次循环之前的情况。**(b)–(f)** 每次循环后的情况。在每个部分中，橙色高亮显示的顶点被选择为第7行的顶点*u*，每条橙色高亮显示的边在放松时导致*d*值和前驱值的改变。在(f)部分中显示的*d*值和前驱值是最终值。'
- en: Because Dijkstra’s algorithm always chooses the “lightest” or “closest” vertex
    in *V* − *S* to add to set *S*, you can think of it as using a greedy strategy.
    [Chapter 15](chapter015.xhtml) explains greedy strategies in detail, but you need
    not have read that chapter to understand Dijkstra’s algorithm. Greedy strategies
    do not always yield optimal results in general, but as the following theorem and
    its corollary show, Dijkstra’s algorithm does indeed compute shortest paths. The
    key is to show that *u.d* = δ(*s*, *u*) each time it adds a vertex *u* to set
    *S*.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 因为Dijkstra算法总是选择*V* − *S*中“最轻”或“最近”的顶点添加到集合*S*中，你可以将其视为使用贪婪策略。[第15章](chapter015.xhtml)详细解释了贪婪策略，但你不需要阅读该章节就能理解Dijkstra算法。一般情况下，贪婪策略并不总是产生最优结果，但正如以下定理及其推论所示，Dijkstra算法确实计算出最短路径。关键在于展示每次将顶点*u*添加到集合*S*时，*u.d*
    = δ(*s*, *u*)。
- en: '![art](images/Art_P645.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P645.jpg)'
- en: '**Figure 22.7** The proof of Theorem 22.6\. Vertex *u* is selected to be added
    into set *S* in line 7 of DIJKSTRA. Vertex *y* is the first vertex on a shortest
    path from the source *s* to vertex *u* that is not in set *S*, and *x* ∈ *S* is
    *y*’s predecessor on that shortest path. The subpath from *y* to *u* may or may
    not re-enter set *S*.'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**图22.7** 定理22.6的证明。顶点*u*被选择添加到集合*S*中的DIJKSTRA第7行。顶点*y*是从源*s*到顶点*u*的最短路径上第一个不在集合*S*中的顶点，*x*
    ∈ *S*是该最短路径上*y*的前驱。从*y*到*u*的子路径可能会或可能不会重新进入集合*S*。'
- en: '***Theorem 22.6 (Correctness of Dijkstra’s algorithm)***'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 22.6（Dijkstra算法的正确性）***'
- en: Dijkstra’s algorithm, run on a weighted, directed graph *G* = (*V*, *E*) with
    nonnegative weight function *w* and source vertex *s*, terminates with *u.d* =
    δ(*s*, *u*) for all vertices *u* ∈ *V*.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在加权有向图*G* = (*V*, *E*)上运行的Dijkstra算法，其中权重函数*w*为非负，源顶点为*s*，对于所有顶点*u* ∈ *V*，终止时*u.d*
    = δ(*s*, *u*)。
- en: '***Proof***   We will show that at the start of each iteration of the **while**
    loop of lines 6–12, we have *v.d* = δ(*s*, *v*) for all *v* ∈ *S*. The algorithm
    terminates when *S* = *V*, so that *v.d* = δ(*s*, *v*) for all *v* ∈ *V*.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   我们将展示在第6-12行的**while**循环的每次迭代开始时，对于所有*v* ∈ *S*，*v.d* = δ(*s*, *v*)。算法在*S*
    = *V*时终止，因此对于所有*v* ∈ *V*，*v.d* = δ(*s*, *v*)。'
- en: 'The proof is by induction on the number of iterations of the **while** loop,
    which equals |*S*| at the start of each iteration. There are two bases: for |*S*|
    = 0, so that *S* = Ø and the claim is trivially true, and for |*S*| = 1, so that
    *S* = {*s*} and *s.d* = δ(*s*, *s*) = 0.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 证明通过对**while**循环迭代次数进行归纳，该次数等于每次迭代开始时的|*S*|。有两个基础情况：对于|*S*| = 0，使得*S* = Ø，命题显然成立；对于|*S*|
    = 1，使得*S* = {*s*}，*s.d* = δ(*s*, *s*) = 0。
- en: For the inductive step, the inductive hypothesis is that *v.d* = δ(*s*, *v*)
    for all *v* ∈ *S*. The algorithm extracts vertex *u* from *V* − *S*. Because the
    algorithm adds *u* into *S*, we need to show that *u.d* = δ(*s*, *u*) at that
    time. If there is no path from *s* to *u*, then we are done, by the no-path property.
    If there is a path from *s* to *u*, then, as [Figure 22.7](chapter022.xhtml#Fig_22-7)
    shows, let *y* be the first vertex on a shortest path from *s* to *u* that is
    not in *S*, and let *x* ∈ *S* be the predecessor of *y* on that shortest path.
    (We could have *y* = *u* or *x* = *s*.) Because *y* appears no later than *u*
    on the shortest path and all edge weights are nonnegative, we have δ(*s*, *y*)
    ≤ δ(*s*, *u*). Because the call of EXTRACT-MIN in line 7 returned *u* as having
    the minimum *d* value in *V* − *S*, we also have *u.d* ≤ *y.d*, and the upper-bound
    property gives δ(*s*, *u*) ≤ *u.d*.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 对于归纳步骤，归纳假设是对于所有*v* ∈ *S*，*v.d* = δ(*s*, *v*)。算法从*V* − *S*中提取顶点*u*。因为算法将*u*添加到*S*中，我们需要展示在那时*u.d*
    = δ(*s*, *u*)。如果从*s*到*u*没有路径，那么我们已经完成，根据无路径性质。如果从*s*到*u*有路径，那么，正如[图22.7](chapter022.xhtml#Fig_22-7)所示，让*y*是从*s*到*u*的最短路径上第一个不在*S*中的顶点，让*x*
    ∈ *S*是该最短路径上*y*的前驱。（我们可能有*y* = *u*或*x* = *s*。）因为*y*在最短路径上不晚于*u*出现，且所有边权重为非负，我们有δ(*s*,
    *y*) ≤ δ(*s*, *u*)。因为第7行中EXTRACT-MIN的调用返回*u*作为在*V* − *S*中具有最小*d*值的顶点，我们也有*u.d*
    ≤ *y.d*，并且上界性质给出δ(*s*, *u*) ≤ *u.d*。
- en: Since *x* ∈ *S*, the inductive hypothesis implies that *x.d* = δ(*s*, *x*).
    During the iteration of the **while** loop that added *x* into *S*, edge (*x*,
    *y*) was relaxed. By the convergence property, *y.d* received the value of δ(*s*,
    *y*) at that time. Thus, we have
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*x* ∈ *S*，归纳假设意味着*x.d* = δ(*s*, *x*)。在将*x*添加到*S*的**while**循环迭代期间，边(*x*, *y*)被放松。根据收敛性质，*y.d*在那时接收到了δ(*s*,
    *y*)的值。因此，我们有
- en: δ(*s*, *y*) ≤ δ(*s*, *u*) ≤ *u.d* ≤ *y.d* and *y.d* = δ(*s*, *y*),
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: δ(*s*, *y*) ≤ δ(*s*, *u*) ≤ *u.d* ≤ *y.d*且*y.d* = δ(*s*, *y*)，
- en: so that
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 因此
- en: δ(*s*, *y*) = δ(*s*, *u*) = *u.d* = *y.d*.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: δ(*s*, *y*) = δ(*s*, *u*) = *u.d* = *y.d*。
- en: Hence, *u.d* = δ(*s*, *u*), and by the upper-bound property, this value never
    changes again.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*u.d* = δ(*s*, *u*)，根据上界性质，这个值再也不会改变。
- en: ▪
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Corollary 22.7***'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论 22.7***'
- en: After Dijkstra’s algorithm is run on a weighted, directed graph *G* = (*V*,
    *E*) with nonnegative weight function *w* and source vertex *s*, the predecessor
    subgraph *G*[π] is a shortest-paths tree rooted at *s*.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在加权有向图*G* = (*V*, *E*)上运行Dijkstra算法，其中权重函数*w*为非负，源顶点为*s*，前驱子图*G*[π]是以*s*为根的最短路径树。
- en: '***Proof***   Immediate from Theorem 22.6 and the predecessor-subgraph property.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   根据定理22.6和前驱子图性质立即得出。'
- en: ▪
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Analysis**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**'
- en: 'How fast is Dijkstra’s algorithm? It maintains the min-priority queue *Q* by
    calling three priority-queue operations: INSERT (in line 5), EXTRACT-MIN (in line
    7), and DECREASE-KEY (in line 12). The algorithm calls both INSERT and EXTRACT-MIN
    once per vertex. Because each vertex *u* ∈ *V* is added to set *S* exactly once,
    each edge in the adjacency list *Adj*[*u*] is examined in the **for** loop of
    lines 9–12 exactly once during the course of the algorithm. Since the total number
    of edges in all the adjacency lists is |*E*|, this **for** loop iterates a total
    of |*E*| times, and thus the algorithm calls DECREASE-KEY at most |*E*| times
    overall. (Observe once again that we are using aggregate analysis.)'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra 算法有多快？它通过调用三个优先队列操作来维护最小优先队列*Q*：INSERT（第5行）、EXTRACT-MIN（第7行）和 DECREASE-KEY（第12行）。算法每个顶点都会调用一次
    INSERT 和 EXTRACT-MIN。因为每个顶点*u* ∈ *V*只会被添加到集合*S*一次，所以算法在执行过程中会在*Adj*[*u*]的邻接表中的每条边都会被**for**循环（第9-12行）检查一次。由于所有邻接表中的边的总数为|*E*|，所以这个**for**循环总共迭代了|*E*|次，因此算法总共最多调用DECREASE-KEY次数为|*E*|。（再次注意，我们使用的是聚合分析。）
- en: 'Just as in Prim’s algorithm, the running time of Dijkstra’s algorithm depends
    on the specific implementation of the min-priority queue *Q*. A simple implementation
    takes advantage of the vertices being numbered 1 to |*V*|: simply store *v.d*
    in the *v*th entry of an array. Each INSERT and DECREASE-KEY operation takes *O*(1)
    time, and each EXTRACT-MIN operation takes *O*(*V*) time (since it has to search
    through the entire array), for a total time of *O*(*V*² + *E*) = *O*(*V*²).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 Prim 算法一样，Dijkstra 算法的运行时间取决于最小优先队列*Q*的具体实现。一个简单的实现利用了顶点编号为1到|*V*|的特点：只需将*v.d*存储在数组的第*v*个条目中。每个INSERT和DECREASE-KEY操作都需要*O*(1)的时间，而每个EXTRACT-MIN操作需要*O*(*V*)的时间（因为它必须搜索整个数组），因此总时间为*O*(*V*²
    + *E*) = *O*(*V*²)。
- en: If the graph is sufficiently sparse—in particular, *E* = *o*(*V*²/lg *V*)—you
    can improve the running time by implementing the min-priority queue with a binary
    min-heap that includes a way to map between vertices and their corresponding heap
    elements. Each EXTRACT-MIN operation then takes *O*(lg *V*) time. As before, there
    are |*V*| such operations. The time to build the binary min-heap is *O*(*V*).
    (As noted in [Section 21.2](chapter021.xhtml#Sec_21.2), you don’t even need to
    call BUILD-MIN-HEAP.) Each DECREASE-KEY operation takes *O*(lg *V*) time, and
    there are still at most |*E*| such operations. The total running time is therefore
    *O*((*V* + *E*) lg *V*), which is *O*(*E* lg *V*) in the typical case that |*E*|
    = Ω(*V*). This running time improves upon the straightforward *O*(*V*²)-time implementation
    if *E* = *o*(*V*²/lg *V*).
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果图足够稀疏，特别是*E* = *o*(*V*²/lg *V*)，您可以通过使用包含顶点和它们对应堆元素之间映射的二叉最小堆来实现最小优先队列，从而提高运行时间。然后，每个EXTRACT-MIN操作都需��*O*(lg
    *V*)的时间。与以前一样，有|*V*|此类操作。构建二叉最小堆的时间为*O*(*V*)。（如[第21.2节](chapter021.xhtml#Sec_21.2)中所述，甚至不需要调用BUILD-MIN-HEAP。）每个DECREASE-KEY操作都需要*O*(lg
    *V*)的时间，而且最多有|*E*|此类操作。因此，总运行时间为*O*((*V* + *E*) lg *V*)，在|*E*| = Ω(*V*)的典型情况下为*O*(*E*
    lg *V*)。如果*E* = *o*(*V*²/lg *V*)，则此运行时间优于直接*O*(*V*²)时间的实现。
- en: By implementing the min-priority queue with a Fibonacci heap (see page 478),
    you can improve the running time to *O*(*V* lg *V* + *E*). The amortized cost
    of each of the |*V*| EXTRACT-MIN operations is *O*(lg *V*), and each DECREASE-KEY
    call, of which there are at most |*E*|, takes only *O*(1) amortized time. Historically,
    the development of Fibonacci heaps was motivated by the observation that Dijkstra’s
    algorithm typically makes many more DECREASE-KEY calls than EXTRACT-MIN calls,
    so that any method of reducing the amortized time of each DECREASE-KEY operation
    to *o*(lg *V*) without increasing the amortized time of EXTRACT-MIN would yield
    an asymptotically faster implementation than with binary heaps.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用斐波那契堆实现最小优先队列（见第478页），您可以将运行时间提高到*O*(*V* lg *V* + *E*)。每个|*V*| EXTRACT-MIN
    操作的摊销成本为*O*(lg *V*)，而每个 DECREASE-KEY 调用（最多为|*E*|）仅需要*O*(1)的摊销时间。历史上，斐波那契堆的发展受到的启发是观察到
    Dijkstra 算法通常会进行比 EXTRACT-MIN 调用更多的 DECREASE-KEY 调用，因此任何一种将每个 DECREASE-KEY 操作的摊销时间降低到*o*(lg
    *V*)而不增加 EXTRACT-MIN 操作的摊销时间的方法都会比使用二叉堆实现更快。
- en: Dijkstra’s algorithm resembles both breadth-first search (see [Section 20.2](chapter020.xhtml#Sec_20.2))
    and Prim’s algorithm for computing minimum spanning trees (see [Section 21.2](chapter021.xhtml#Sec_21.2)).
    It is like breadth-first search in that set *S* corresponds to the set of black
    vertices in a breadth-first search. Just as vertices in *S* have their final shortest-path
    weights, so do black vertices in a breadth-first search have their correct breadth-first
    distances. Dijkstra’s algorithm is like Prim’s algorithm in that both algorithms
    use a min-priority queue to find the “lightest” vertex outside a given set (the
    set *S* in Dijkstra’s algorithm and the tree being grown in Prim’s algorithm),
    add this vertex into the set, and adjust the weights of the remaining vertices
    outside the set accordingly.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Dijkstra 算法类似于广度优先搜索（见[第20.2节](chapter020.xhtml#Sec_20.2)）和 Prim 算法计算最小生成树（见[第21.2节](chapter021.xhtml#Sec_21.2)）。它类似于广度优先搜索，因为集合*S*对应于广度优先搜索中的黑色顶点集合。就像*S*中的顶点具有最终的最短路径权重一样，广度优先搜索中的黑色顶点具有正确的广度优先距离。Dijkstra
    算法类似于 Prim 算法，因为这两种算法都使用最小优先队列来找到给定集合之外的“最轻”顶点（Dijkstra 算法中的集合*S*和Prim 算法中正在生成的树），将该顶点添加到集合中，并相应地调整集合之外的剩余顶点的权重。
- en: '**Exercises**'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***22.3-1***'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.3-1***'
- en: Run Dijkstra’s algorithm on the directed graph of [Figure 22.2](chapter022.xhtml#Fig_22-2),
    first using vertex *s* as the source and then using vertex *z* as the source.
    In the style of [Figure 22.6](chapter022.xhtml#Fig_22-6), show the *d* and π values
    and the vertices in set *S* after each iteration of the **while** loop.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图22.2](chapter022.xhtml#Fig_22-2)的有向图上运行Dijkstra算法，首先使用顶点*s*作为源，然后使用顶点*z*作为源。按照[图22.6](chapter022.xhtml#Fig_22-6)的风格，展示每次**while**循环迭代后的*d*和π值以及集合*S*中的顶点。
- en: '***22.3-2***'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.3-2***'
- en: Give a simple example of a directed graph with negative-weight edges for which
    Dijkstra’s algorithm produces an incorrect answer. Why doesn’t the proof of Theorem
    22.6 go through when negative-weight edges are allowed?
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个带有负权边的有向图的简单示例，对于这个示例，Dijkstra 算法会产生错误的答案。为什么当允许负权边时，定理 22.6 的证明不成立？
- en: '***22.3-3***'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.3-3***'
- en: Suppose that you change line 6 of Dijkstra’s algorithm to read
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你将 Dijkstra 算法的第 6 行改为
- en: '| 6    | **while** &#124;*Q*&#124; > 1 |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 6    | **当** &#124;*Q*&#124; > 1 |'
- en: This change causes the **while** loop to execute |*V*| − 1 times instead of
    |*V*| times. Is this proposed algorithm correct?
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 这个改变导致 **while** 循环执行 |*V*| − 1 次而不是 |*V*| 次。这个提议的算法正确吗？
- en: '***22.3-4***'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.3-4***'
- en: 'Modify the DIJKSTRA procedure so that the priority queue *Q* is more like the
    queue in the BFS procedure in that it contains only vertices that have been reached
    from source *s* so far: *Q* ⊆ *V* − *S* and *v* ∈ *Q* implies *v.d* ≠ ∞.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 DIJKSTRA 程序，使得优先队列 *Q* 更像 BFS 程序中的队列，其中只包含到目前为止从源 *s* 到达的顶点：*Q* ⊆ *V* − *S*
    且 *v* ∈ *Q* 意味着 *v.d* ≠ ∞。
- en: '***22.3-5***'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.3-5***'
- en: Professor Gaedel has written a program that he claims implements Dijkstra’s
    algorithm. The program produces *v.d* and *v*.π for each vertex *v* ∈ *V*. Give
    an *O*(*V* + *E*)-time algorithm to check the output of the professor’s program.
    It should determine whether the *d* and π attributes match those of some shortest-paths
    tree. You may assume that all edge weights are nonnegative.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: Gaedel 教授编写了一个程序，他声称实现了 Dijkstra 算法。该程序为每个顶点 *v* ∈ *V* 生成 *v.d* 和 *v*.π。给出一个
    *O*(*V* + *E*) 时间的算法来检查教授程序的输出。它应该确定 *d* 和 π 属性是否与某些最短路径树的匹配。你可以假设所有边的权重都是非负的。
- en: '***22.3-6***'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.3-6***'
- en: Professor Newman thinks that he has worked out a simpler proof of correctness
    for Dijkstra’s algorithm. He claims that Dijkstra’s algorithm relaxes the edges
    of every shortest path in the graph in the order in which they appear on the path,
    and therefore the path-relaxation property applies to every vertex reachable from
    the source. Show that the professor is mistaken by constructing a directed graph
    for which Dijkstra’s algorithm relaxes the edges of a shortest path out of order.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: Newman 教授认为他已经找到了一个更简单的 Dijkstra 算法正确性证明。他声称 Dijkstra 算法按照路径上出现的顺序放松图中每条最短路径的边，因此路径放松属性适用于从源可达的每个顶点。通过构造一个有向图，展示教授是错误的，因为
    Dijkstra 算法按顺序放松了最短路径的边。
- en: '***22.3-7***'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.3-7***'
- en: Consider a directed graph *G* = (*V*, *E*) on which each edge (*u*, *v*) ∈ *E*
    has an associated value *r*(*u*, *v*), which is a real number in the range 0 ≤
    *r*(*u*, *v*) ≤ 1 that represents the reliability of a communication channel from
    vertex *u* to vertex *v*. Interpret *r*(*u*, *v*) as the probability that the
    channel from *u* to *v* will not fail, and assume that these probabilities are
    independent. Give an efficient algorithm to find the most reliable path between
    two given vertices.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个有向图 *G* = (*V*, *E*)，其中每条边 (*u*, *v*) ∈ *E* 都有一个关联值 *r*(*u*, *v*)，它是一个范围在
    0 ≤ *r*(*u*, *v*) ≤ 1 的实数，表示从顶点 *u* 到顶点 *v* 的通信信道的可靠性。将 *r*(*u*, *v*) 解释为通道从 *u*
    到 *v* 不会失败的概率，并假设这些概率是独立的。给出一个有效的算法来找到两个给定顶点之间的最可靠路径。
- en: '***22.3-8***'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.3-8***'
- en: 'Let *G* = (*V*, *E*) be a weighted, directed graph with positive weight function
    *w* : *E* → {1, 2, … , *W*} for some positive integer *W*, and assume that no
    two vertices have the same shortest-path weights from source vertex *s*. Now define
    an unweighted, directed graph *G*′ = (*V* ∪ *V*′, *E*′) by replacing each edge
    (*u*, *v*) ∈ *E* with *w*(*u*, *v*) unit-weight edges in series. How many vertices
    does *G*′ have? Now suppose that you run a breadth-first search on *G*′. Show
    that the order in which the breadth-first search of *G*′ colors vertices in *V*
    black is the same as the order in which Dijkstra’s algorithm extracts the vertices
    of *V* from the priority queue when it runs on *G*.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '令 *G* = (*V*, *E*) 为一个带有正权重函数 *w* : *E* → {1, 2, … , *W*} 的加权有向图，假设没有两个顶点从源顶点
    *s* 具有相同的最短路径权重。现在定义一个无权重的有向图 *G*′ = (*V* ∪ *V*′, *E*′)，通过用串联的 *w*(*u*, *v*) 单位权重边替换每条边
    (*u*, *v*) ∈ *E*。*G*′ 有多少个顶点？现在假设你在 *G*′ 上运行广度优先搜索。展示当广度优先搜索 *G*′ 时，将 *V* 中的顶点标记为黑色的顺序与
    Dijkstra 算法在 *G* 上运行时从优先队列中提取顶点的顺序相同。'
- en: '***22.3-9***'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.3-9***'
- en: 'Let *G* = (*V*, *E*) be a weighted, directed graph with nonnegative weight
    function *w* : *E* → {0, 1, … , *W*} for some nonnegative integer *W*. Modify
    Dijkstra’s algorithm to compute the shortest paths from a given source vertex
    *s* in *O*(*W V* + *E*) time.'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '令 *G* = (*V*, *E*) 为一个带有非负权重函数 *w* : *E* → {0, 1, … , *W*} 的加权有向图。修改 Dijkstra
    算法以在 *O*(*W V* + *E*) 时间内计算从给定源顶点 *s* 到其他顶点的最短路径。'
- en: '***22.3-10***'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.3-10***'
- en: Modify your algorithm from Exercise 22.3-9 to run in *O*((*V* + *E*) lg *W*)
    time. (*Hint:* How many distinct shortest-path estimates can *V* − *S* contain
    at any point in time?)
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 修改你在练习 22.3-9 中的算法，使其在 *O*((*V* + *E*) lg *W*) 时间内运行。(*提示:* 在任何时间点，*V* − *S*
    可能包含多少个不同的最短路径估计？)
- en: '***22.3-11***'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.3-11***'
- en: Suppose that you are given a weighted, directed graph *G* = (*V*, *E*) in which
    edges that leave the source vertex *s* may have negative weights, all other edge
    weights are nonnegative, and there are no negative-weight cycles. Argue that Dijkstra’s
    algorithm correctly finds shortest paths from *s* in this graph.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个加权有向图 *G* = (*V*, *E*)，其中离开源顶点 *s* 的边可能具有负权重，所有其他边的权重都是非负的，并且没有负权重环。论证
    Dijkstra 算法在这个图中正确地找到从 *s* 开始的最短路径。
- en: '***22.3-12***'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.3-12***'
- en: Suppose that you have a weighted directed graph *G* = (*V*, *E*) in which all
    edge weights are positive real values in the range [*C*, 2*C*] for some positive
    constant *C*. Modify Dijkstra’s algorithm so that it runs in *O*(*V* + *E*) time.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个加权有向图 *G* = (*V*, *E*)，其中所有边的权重都是在 [*C*, 2*C*] 范围内的正实数，其中 *C* 是一个正常数。修改
    Dijkstra 算法以在 *O*(*V* + *E*) ��间内运行。
- en: '[**22.4    Difference constraints and shortest paths**](toc.xhtml#Rh1-132)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[**22.4    差分约束和最短路径**](toc.xhtml#Rh1-132)'
- en: '[Chapter 29](chapter029.xhtml) studies the general linear-programming problem,
    showing how to optimize a linear function subject to a set of linear inequalities.
    This section investigates a special case of linear programming that reduces to
    finding shortest paths from a single source. The Bellman-Ford algorithm then solves
    the resulting single-source shortest-paths problem, thereby also solving the linear-programming
    problem.'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '[第29章](chapter029.xhtml)研究了一般的线性规划问题，展示了如何在一组线性不等式下优化线性函数。本节研究了线性规划的一个特殊情况，将其简化为从单个源点找到最短路径。然后，贝尔曼-福特算法解决了由此产生的单源最短路径问题，从而解决了线性规划问题。'
- en: '**Linear programming**'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '**线性规划**'
- en: In the general ***linear-programming problem***, the input is an *m* × *n* matrix
    *A*, an *m*-vector *b*, and an *n*-vector *c*. The goal is to find a vector *x*
    of *n* elements that maximizes the ***objective function*** ![art](images/Art_P646.jpg)
    subject to the *m* constraints given by *Ax* ≤ *b*.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般的***线性规划问题***中，输入是一个 *m* × *n* 矩阵 *A*，一个 *m* 维向量 *b*，和一个 *n* 维向量 *c*。目标是找到一个
    *n* 元素的向量 *x*，使得在满足 *Ax* ≤ *b* 的 *m* 个约束条件下，最大化***目标函数*** ![art](images/Art_P646.jpg)。
- en: The most popular method for solving linear programs is the ***simplex algorithm***,
    which [Section 29.1](chapter029.xhtml#Sec_29.1) discusses. Although the simplex
    algorithm does not always run in time polynomial in the size of its input, there
    are other linear-programming algorithms that do run in polynomial time. We offer
    here two reasons to understand the setup of linear-programming problems. First,
    if you know that you can cast a given problem as a polynomial-sized linear-programming
    problem, then you immediately have a polynomial-time algorithm to solve the problem.
    Second, faster algorithms exist for many special cases of linear programming.
    For example, the single-pair shortest-path problem (Exercise 22.4-4) and the maximum-flow
    problem (Exercise 24.1-5) are special cases of linear programming.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 解线性规划问题最流行的方法是***单纯形算法***，[第29.1节](chapter029.xhtml#Sec_29.1)进行了讨论。虽然单纯形算法并不总是在其输入规模的多项式时间内运行，但还有其他线性规划算法可以在多项式时间内运行。我们在这里提供两个理由来理解线性规划问题的设置。首先，如果你知道可以将给定问题转化为多项式规模的线性规划问题，那么你立即就有了一个多项式时间算法来解决这个问题。其次，对于许多线性规划的特殊情况存在更快的算法。例如，单对最短路径问题（练习22.4-4）和最大流问题（练习24.1-5）是线性规划的特殊情况。
- en: 'Sometimes the objective function does not matter: it’s enough just to find
    any ***feasible solution***, that is, any vector *x* that satisfies *Ax* ≤ *b*,
    or to determine that no feasible solution exists. This section focuses on one
    such ***feasibility problem***.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 有时目标函数并不重要：只需找到任何一个***可行解***就足够了，即任何满足 *Ax* ≤ *b* 的向量 *x*，或者确定不存在可行解。本节重点讨论这样一个***可行性问题***。
- en: '**Systems of difference constraints**'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**差分约束系统**'
- en: In a ***system of difference constraints***, each row of the linear-programming
    matrix *A* contains one 1 and one −1, and all other entries of *A* are 0\. Thus,
    the constraints given by *Ax* ≤ *b* are a set of *m****difference constraints***
    involving *n* unknowns, in which each constraint is a simple linear inequality
    of the form
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个***差分约束系统***中，线性规划矩阵 *A* 的每一行包含一个1和一个−1，其余所有元素为0。因此，由 *Ax* ≤ *b* 给出的约束是涉及
    *n* 个未知数的 *m* 个***差分约束***集合，其中每个约束是形如
- en: '*x[j]* − *x[i]* ≤ *b[k]*,'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*x[j]* − *x[i]* ≤ *b[k]*,'
- en: where 1 ≤ *i*, *j* ≤ *n*, *i* ≠ *j*, and 1 ≤ *k* ≤ *m*.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 1 ≤ *i*, *j* ≤ *n*, *i* ≠ *j*, 且 1 ≤ *k* ≤ *m*。
- en: For example, consider the problem of finding a 5-vector *x* = (*x[i]*) that
    satisfies
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，考虑找到一个5维向量 *x* = (*x[i]*)，满足以下条件
- en: '![art](images/Art_P647.jpg)'
  id: totrans-246
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P647.jpg)'
- en: 'This problem is equivalent to finding values for the unknowns *x*[1], *x*[2],
    *x*[3], *x*[4], *x*[5], satisfying the following 8 difference constraints:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题等同于找到未知数 *x*[1], *x*[2], *x*[3], *x*[4], *x*[5] 的值，满足以下8个差分约束条件：
- en: '![art](images/Art_P648.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P648.jpg)'
- en: 'One solution to this problem is *x* = (−5, −3, 0, −1, −4), which you can verify
    directly by checking each inequality. In fact, this problem has more than one
    solution. Another is *x*′ = (0, 2, 5, 4, 1). These two solutions are related:
    each component of *x*′ is 5 larger than the corresponding component of *x*. This
    fact is not mere coincidence.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的一个解是 *x* = (−5, −3, 0, −1, −4)，你可以通过直接检查每个不等式来验证。事实上，这个问题有不止一个解。另一个解是 *x*′
    = (0, 2, 5, 4, 1)。这两个解是相关的：*x*′ 的每个分量比 *x* 对应的分量大5。这个事实并非偶然。
- en: '***Lemma 22.8***'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 22.8***'
- en: Let *x* = (*x*[1], *x*[2], … , *x[n]*) be a solution to a system A*x* ≤ *b*
    of difference constraints, and let *d* be any constant. Then *x* + *d* = (*x*[1]
    + *d*, *x*[2] + *d*, … , *x[n]* + *d*) is a solution to *Ax* ≤ *b* as well.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 设 *x* = (*x*[1], *x*[2], … , *x[n]*) 是差分约束系统 A*x* ≤ *b* 的一个解，*d* 是任意常数。那么 *x*
    + *d* = (*x*[1] + *d*, *x*[2] + *d*, … , *x[n]* + *d*) 也是满足 *Ax* ≤ *b* 的解。
- en: '***Proof***   For each *x[i]* and *x[j]*, we have (*x[j]* + *d*) − (*x[i]*
    + *d*) = *x[j]* − *x[i]*. Thus, if *x* satisfies *Ax* ≤ *b*, so does *x* + *d*.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   对于每个 *x[i]* 和 *x[j]*，我们有 (*x[j]* + *d*) − (*x[i]* + *d*) = *x[j]*
    − *x[i]*。因此，如果 *x* 满足 *Ax* ≤ *b*，那么 *x* + *d* 也满足。'
- en: ▪
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Systems of difference constraints occur in various applications. For example,
    the unknowns *x[i]* might be times at which events are to occur. Each constraint
    states that at least a certain amount of time, or at most a certain amount of
    time, must elapse between two events. Perhaps the events are jobs to be performed
    during the assembly of a product. If the manufacturer applies an adhesive that
    takes 2 hours to set at time *x*[1] and has to wait until it sets to install a
    part at time *x*[2], then there is a constraint that *x*[2] ≥ *x*[1] + 2 or, equivalently,
    that *x*[1] − *x*[2] ≤ −2\. Alternatively, the manufacturer might require the
    part to be installed after the adhesive has been applied but no later than the
    time that the adhesive has set halfway. In this case, there is a pair of constraints
    *x*[2] ≥ *x*[1] and *x*[2] ≤ *x*[1] + 1 or, equivalently, *x*[1] − *x*[2] ≤ 0
    and *x*[2] − *x*[1] ≤ 1.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '差分约束系统出现在各种应用中。例如，未知数*x[i]*可能是事件发生的时间。每个约束说明两个事件之间必须至少经过一定的时间，或者最多经过一定的时间。也许这些事件是在产品组装过程中要执行的工作。如果制���商在时间*x*[1]施加需要2小时凝固的胶水，并且必须等到胶水凝固后才能在时间*x*[2]安装零件，那么有一个约束*x*[2]
    ≥ *x*[1] + 2或者等价地，*x*[1] − *x*[2] ≤ −2。或者，制造商可能要求在胶水施加后立即安装零件，但不能晚于胶水凝固一半的时间。在这种情况下，有一对约束*x*[2]
    ≥ *x*[1]和*x*[2] ≤ *x*[1] + 1或者等价地，*x*[1] − *x*[2] ≤ 0和*x*[2] − *x*[1] ≤ 1。 '
- en: 'If all the constraints have nonnegative numbers on the right-hand side—that
    is, if *b[i]* ≥ 0 for *i* = 1, 2, … , *m*—then finding a feasible solution is
    trivial: just set all the unknowns *x[i]* equal to each other. Then all the differences
    are 0, and every constraint is satisfied. The problem of finding a feasible solution
    to a system of difference constraints is interesting only if at least one constraint
    has *b[i]* < 0.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有约束的右侧都是非负数，即如果对于*i* = 1, 2, … , *m*，都有*b[i]* ≥ 0，则找到一个可行解是微不足道的：只需将所有未知数*x[i]*设为相等。然后所有差异都为0，每个约束都得到满足。只有至少一个约束的*b[i]*
    < 0时，解决差分约束系统的问题才是有趣的。
- en: '**Constraint graphs**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**约束图**'
- en: We can interpret systems of difference constraints from a graph-theoretic point
    of view. For a system *Ax* ≤ *b* of difference constraints, let’s view the *m*
    × *n* linear-programming matrix *A* as the transpose of an incidence matrix (see
    Exercise 20.1-7) for a graph with *n* vertices and *m* edges. Each vertex *v[i]*
    in the graph, for *i* = 1, 2, … , *n*, corresponds to one of the *n* unknown variables
    *x[i]*. Each directed edge in the graph corresponds to one of the *m* inequalities
    involving two unknowns.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从图论的角度解释差分约束系统。对于一个差分约束系统*Ax* ≤ *b*，让我们将*m* × *n*线性规划矩阵*A*视为一个具有*n*个顶点和*m*条边的图的关联矩阵的转置（参见练习20.1-7）。图中的每个顶点*v[i]*，对于*i*
    = 1, 2, … , *n*，对应于*n*个未知变量*x[i]*中的一个。图中的每条有向边对应于涉及两个未知数中的*m*个不等式中的一个。
- en: More formally, given a system *Ax* ≤ *b* of difference constraints, the corresponding
    ***constraint graph*** is a weighted, directed graph *G* = (*V*, *E*), where
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 更正式地说，给定一个差分约束系统*Ax* ≤ *b*，对应的***约束图***是一个加权有向图*G* = (*V*, *E*)，其中
- en: '*V* = {*v*[0], *v*[1], … , *v[n]*}'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '*V* = {*v*[0], *v*[1], … , *v[n]*}'
- en: and
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '| *E* = | {(*v[i]*, *v[j]*) : *x[j]* − *x[i]* ≤ *b[k]* is a constraint} |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '| *E* = | {(*v[i]*, *v[j]*) : *x[j]* − *x[i]* ≤ *b[k]* 是一个约束} |'
- en: '|  |    ∪ {(*v*[0], *v*[1]), (*v*[0], *v*[2]), (*v*[0], *v*[3]), … , (*v*[0],
    *v[n]*)}. |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '|  |    ∪ {(*v*[0], *v*[1]), (*v*[0], *v*[2]), (*v*[0], *v*[3]), … , (*v*[0],
    *v*[n]*)}. |'
- en: The constraint graph includes the additional vertex *v*[0], as we shall see
    shortly, to guarantee that the graph has some vertex that can reach all other
    vertices. Thus, the vertex set *V* consists of a vertex *v[i]* for each unknown
    *x[i]*, plus an additional vertex *v*[0]. The edge set *E* contains an edge for
    each difference constraint, plus an edge (*v*[0], *v[i]*) for each unknown *x[i]*.
    If *x[j]* − *x[i]* ≤ *b[k]* is a difference constraint, then the weight of edge
    (*v[i]*, *v[j]*) is *w*(*v[i]*, *v[j]*) = *b[k]*. The weight of each edge leaving
    *v*[0] is 0\. [Figure 22.8](chapter022.xhtml#Fig_22-8) shows the constraint graph
    for the system (22.2)–(22.9) of difference constraints.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 约束图包括额外的顶点*v*[0]，我们很快就会看到，以确保图中有一个顶点可以到达所有其他顶点。因此，顶点集*V*包含每个未知数*x[i]*的顶点*v[i]*，以及额外的顶点*v*[0]。边集*E*包含每个差分约束的边，以及每个未知数*x[i]*的边(*v*[0],
    *v[i]*)。如果*x[j]* − *x[i]* ≤ *b[k]*是一个差分约束，则边(*v[i]*, *v[j]*)的权重为*w*(*v[i]*, *v[j]*)
    = *b[k]*。离开*v*[0]的每条边的权重为0。[图 22.8](chapter022.xhtml#Fig_22-8)展示了差分约束系统（22.2）-（22.9）的约束图。
- en: '![art](images/Art_P649.jpg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P649.jpg)'
- en: '**Figure 22.8** The constraint graph corresponding to the system (22.2)–(22.9)
    of difference constraints. The value of δ(*v*[0], *v[i]*) appears in each vertex
    *v[i]*. One feasible solution to the system is *x* = (−5, −3, 0, −1, −4).'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 22.8** 对应于差分约束系统（22.2）-（22.9）的约束图。每个顶点*v[i]*中都包含δ(*v*[0], *v[i]*)的值。系统的一个可行解是*x*
    = (−5, −3, 0, −1, −4)。'
- en: The following theorem shows how to solve a system of difference constraints
    by finding shortest-path weights in the corresponding constraint graph.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的定理展示了如何通过在对应的约束图中找到最短路径权重来解决差分约束系统。
- en: '***Theorem 22.9***'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 22.9***'
- en: Given a system *Ax* ≤ *b* of difference constraints, let *G* = (*V*, *E*) be
    the corresponding constraint graph. If *G* contains no negative-weight cycles,
    then
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个差分约束系统*Ax* ≤ *b*，让*G* = (*V*, *E*)为对应的约束图。如果*G*不包含负权重循环，则
- en: '![art](images/Art_P650.jpg)'
  id: totrans-269
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P650.jpg)'
- en: is a feasible solution for the system. If *G* contains a negative-weight cycle,
    then there is no feasible solution for the system.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 是系统的一个可行解。如果*G*包含负权重循环，则系统没有可行解。
- en: '***Proof***   We first show that if the constraint graph contains no negative-weight
    cycles, then equation (22.10) gives a feasible solution. Consider any edge (*v[i]*,
    *v[j]*) ∈ *E*. The triangle inequality implies that δ(*v*[0], *v[j]*) ≤ δ(*v*[0],
    *v[i]*) + *w*(*v[i]*, *v[j]*), which is equivalent to δ(*v*[0], *v[j]*)−δ(*v*[0],
    *v[i]*) ≤ *w*(*v[i]*, *v[j]*). Thus, letting *x[i]* = δ(*v*[0], *v[i]*) and *x[j]*
    = δ(*v*[0], *v[j]*) satisfies the difference constraint *x[j]* − *x[i]* ≤ *w*(*v[i]*,
    *v[j]*) that corresponds to edge (*v[i]*, *v[j]*).'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   我们首先证明，如果约束图中不包含负权重环路，则方程（22.10）给出一个可行解。考虑任意边（*v[i]*, *v[j]*) ∈
    *E*。三角不等式意味着δ(*v*[0], *v[j]*) ≤ δ(*v*[0], *v[i]*) + *w*(*v[i]*, *v[j]*)，这等价于δ(*v*[0],
    *v[j]*)−δ(*v*[0], *v[i]*) ≤ *w*(*v[i]*, *v[j]*)。因此，令*x[i]* = δ(*v*[0], *v[i]*)和*x[j]*
    = δ(*v*[0], *v[j]*)满足对应于边（*v[i]*, *v[j]*)的差分约束*x[j]* − *x[i]* ≤ *w*(*v[i]*, *v[j]*)。'
- en: 'Now we show that if the constraint graph contains a negative-weight cycle,
    then the system of difference constraints has no feasible solution. Without loss
    of generality, let the negative-weight cycle be *c* = 〈*v*[1], *v*[2], … , *v[k]*〉,
    where *v*[1] = *v[k]*. (The vertex *v*[0] cannot be on cycle *c*, because it has
    no entering edges.) Cycle *c* corresponds to the following difference constraints:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们证明，如果约束图中包含负权重环路，则差分约束系统没有可行解。不失一般性，设负权重环路为*c* = 〈*v*[1], *v*[2], … , *v[k]*〉，其中*v*[1]
    = *v[k]*。（顶点*v*[0]*不能在环路*c*上，因为它没有入边。）环路*c*对应以下差分约束：
- en: '| *x*[2] − *x*[1] | ≤ | *w*(*v*[1], *v*[2]), |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| *x*[2] − *x*[1] | ≤ | *w*(*v*[1], *v*[2]), |'
- en: '| *x*[3] − *x*[2] | ≤ | *w*(*v*[2], *v*[3]), |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| *x*[3] − *x*[2] | ≤ | *w*(*v*[2], *v*[3]), |'
- en: '|  | ⋮ |  |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '|  | ⋮ |  |'
- en: '| *x*[*k*−1] − *x*[*k*−2] | ≤ | *w*(*v*[*k*−2], *v*[*k*−1]), |'
  id: totrans-276
  prefs: []
  type: TYPE_TB
  zh: '| *x*[*k*−1] − *x*[*k*−2] | ≤ | *w*(*v*[*k*−2], *v*[*k*−1]), |'
- en: '| *x*[*k*] − *x*[*k*−1] | ≤ | *w*(*v*[*k*−1], *v[k]*). |'
  id: totrans-277
  prefs: []
  type: TYPE_TB
  zh: '| *x*[*k*] − *x*[*k*−1] | ≤ | *w*(*v*[*k*−1], *v[k]*). |'
- en: We’ll assume that *x* has a solution satisfying each of these *k* inequalities
    and then derive a contradiction. The solution must also satisfy the inequality
    that results from summing the *k* inequalities together. In summing the left-hand
    sides, each unknown *x[i]* is added in once and subtracted out once (remember
    that *v*[1] = *v[k]* implies *x*[1] = *x[k]*), so that the left-hand side sums
    to 0\. The right-hand side sums to the weight *w*(*c*) of the cycle, giving 0
    ≤ *w*(*c*). But since *c* is a negative-weight cycle, *w*(*c*) < 0, and we obtain
    the contradiction that 0 ≤ *w*(*c*) < 0.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 我们假设*x*有一个满足每个这些*k*个不等式的解，然后推导出矛盾。解还必须满足从这*k*个不等式求和得到的不等式。在求和左侧时，每个未知数*x[i]*被加入一次并减去一次（记住*v*[1]
    = *v[k]*意味着*x*[1] = *x[k]*），因此左侧求和为0。右侧求和为环路的权重*w*(*c*)，得到0 ≤ *w*(*c*)。但由于*c*是一个负权重环路，*w*(*c*)
    < 0，我们得到矛盾，即0 ≤ *w*(*c*) < 0。
- en: ▪
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Solving systems of difference constraints**'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '**解决差分约束系统**'
- en: Theorem 22.9 suggests how to use the Bellman-Ford algorithm to solve a system
    of difference constraints. Because the constraint graph contains edges from the
    source vertex *v*[0] to all other vertices, any negative-weight cycle in the constraint
    graph is reachable from *v*[0]. If the Bellman-Ford algorithm returns TRUE, then
    the shortest-path weights give a feasible solution to the system. In [Figure 22.8](chapter022.xhtml#Fig_22-8),
    for example, the shortest-path weights provide the feasible solution *x* = (−5,
    −3, 0, −1, −4), and by Lemma 22.8, *x* = (*d* − 5, *d* − 3, *d*, *d* − 1, *d*
    − 4) is also a feasible solution for any constant *d*. If the Bellman-Ford algorithm
    returns FALSE, there is no feasible solution to the system of difference constraints.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 定理22.9建议如何使用Bellman-Ford算法解决差分约束��统。因为约束图包含从源顶点*v*[0]到所有其他顶点的边，约束图中的任何负权重环路都可以从*v*[0]到达。如果Bellman-Ford算法返回TRUE，则最短路径权重给出系统的可行解。例如，在[图22.8](chapter022.xhtml#Fig_22-8)中，最短路径权重提供了可行解*x*
    = (−5, −3, 0, −1, −4)，并且根据引理22.8，*x* = (*d* − 5, *d* − 3, *d*, *d* − 1, *d* −
    4)也是任何常数*d*的可行解。如果Bellman-Ford算法返回FALSE，则差分约束系统没有可行解。
- en: A system of difference constraints with *m* constraints on *n* unknowns produces
    a graph with *n* + 1 vertices and *n* + *m* edges. Thus, the Bellman-Ford algorithm
    provides a way to solve the system in *O*((*n* + 1)(*n* + *m*)) = *O*(*n*² + *nm*)
    time. Exercise 22.4-5 asks you to modify the algorithm to run in *O*(*nm*) time,
    even if *m* is much less than *n*.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 一个包含*n*个未知数的*m*个约束的差分约束系统产生一个具有*n* + 1个顶点和*n* + *m*条边的图。因此，Bellman-Ford算法提供了一种在*O*((*n*
    + 1)(*n* + *m*)) = *O*(*n*² + *nm*)时间内解决系统的方法。练习22.4-5要求您修改算法，使其在*O*(*nm*)时间内运行，即使*m*远小于*n*。
- en: '**Exercises**'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题**'
- en: '***22.4-1***'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.4-1***'
- en: 'Find a feasible solution or determine that no feasible solution exists for
    the following system of difference constraints:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 对以下差分约束系统找到一个可行解或确定不存在可行解：
- en: '| *x*[1] − *x*[2] | ≤ | 1, |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1] − *x*[2] | ≤ | 1, |'
- en: '| *x*[1] − *x*[4] | ≤ | −4, |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1] − *x*[4] | ≤ | −4, |'
- en: '| *x*[2] − *x*[3] | ≤ | 2, |'
  id: totrans-288
  prefs: []
  type: TYPE_TB
  zh: '| *x*[2] − *x*[3] | ≤ | 2, |'
- en: '| *x*[2] − *x*[5] | ≤ | 7, |'
  id: totrans-289
  prefs: []
  type: TYPE_TB
  zh: '| *x*[2] − *x*[5] | ≤ | 7, |'
- en: '| *x*[2] − *x*[6] | ≤ | 5, |'
  id: totrans-290
  prefs: []
  type: TYPE_TB
  zh: '| *x*[2] − *x*[6] | ≤ | 5, |'
- en: '| *x*[3] − *x*[6] | ≤ | 10, |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| *x*[3] − *x*[6] | ≤ | 10, |'
- en: '| *x*[4] − *x*[2] | ≤ | 2, |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| *x*[4] − *x*[2] | ≤ | 2, |'
- en: '| *x*[5] − *x*[1] | ≤ | −1, |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| *x*[5] − *x*[1] | ≤ | −1, |'
- en: '| *x*[5] − *x*[4] | ≤ | 3, |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| *x*[5] − *x*[4] | ≤ | 3, |'
- en: '| *x*[6] − *x*[3] | ≤ | −8. |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| *x*[6] − *x*[3] | ≤ | −8. |'
- en: '***22.4-2***'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.4-2***'
- en: 'Find a feasible solution or determine that no feasible solution exists for
    the following system of difference constraints:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 对以下差分约束系统找到一个可行解或确定不存在可行解：
- en: '| *x*[1] − *x*[2] | ≤ | 4, |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1] − *x*[2] | ≤ | 4, |'
- en: '| *x*[1] − *x*[5] | ≤ | 5, |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| *x*[1] − *x*[5] | ≤ | 5, |'
- en: '| *x*[2] − *x*[4] | ≤ | −6, |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| *x*[2] − *x*[4] | ≤ | −6, |'
- en: '| *x*[3] − *x*[2] | ≤ | 1, |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| *x*[3] − *x*[2] | ≤ | 1, |'
- en: '| *x*[4] − *x*[1] | ≤ | 3, |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| *x*[4] − *x*[1] | ≤ | 3, |'
- en: '| *x*[4] − *x*[3] | ≤ | 5, |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| *x*[4] − *x*[3] | ≤ | 5, |'
- en: '| *x*[4] − *x*[5] | ≤ | 10, |'
  id: totrans-304
  prefs: []
  type: TYPE_TB
  zh: '| *x*[4] − *x*[5] | ≤ | 10, |'
- en: '| *x*[5] − *x*[3] | ≤ | −4, |'
  id: totrans-305
  prefs: []
  type: TYPE_TB
  zh: '| *x*[5] − *x*[3] | ≤ | −4, |'
- en: '| *x*[5] − *x*[4] | ≤ | −8. |'
  id: totrans-306
  prefs: []
  type: TYPE_TB
  zh: '| *x*[5] − *x*[4] | ≤ | −8. |'
- en: '***22.4-3***'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.4-3***'
- en: Can any shortest-path weight from the new vertex *v*[0] in a constraint graph
    be positive? Explain.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在约束图中，新顶点*v*[0]的任何最短路径权重都可能是正的吗？请解释。
- en: '***22.4-4***'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.4-4***'
- en: Express the single-pair shortest-path problem as a linear program.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 将单对最短路径问题表达为线性规划。
- en: '***22.4-5***'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.4-5***'
- en: Show how to modify the Bellman-Ford algorithm slightly so that when using it
    to solve a system of difference constraints with *m* inequalities on *n* unknowns,
    the running time is *O*(*nm*).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何略微修改贝尔曼-福特算法，以便在解决具有*n*个未知数上的*m*个不等式的差分约束系统时，运行时间为*O*(*nm*)。
- en: '***22.4-6***'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.4-6***'
- en: Consider adding ***equality constraints*** of the form *x[i]* = *x[j]* + *b[k]*
    to a system of difference constraints. Show how to solve this variety of constraint
    system.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑将形式为*x[i]* = *x[j]* + *b[k]*的***等式约束***添加到差分约束系统中。展示如何解决这种类型的约束系统。
- en: '***22.4-7***'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.4-7***'
- en: Show how to solve a system of difference constraints by a Bellman-Ford-like
    algorithm that runs on a constraint graph without the extra vertex *v*[0].
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何通过类似贝尔曼-福特算法的算法来解决一个差分约束系统，该算法在没有额外顶点*v*[0]的约束图上运行。
- en: ★ ***22.4-8***
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***22.4-8***
- en: Let *Ax* ≤ *b* be a system of *m* difference constraints in *n* unknowns. Show
    that the Bellman-Ford algorithm, when run on the corresponding constraint graph,
    maximizes ![art](images/Art_P651.jpg) subject to *Ax* ≤ *b* and *x[i]* ≤ 0 for
    all *x[i]*.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 让*Ax* ≤ *b*成为*n*个未知数中的*m*个差分约束的系统。展示当在相应的约束图上运行贝尔曼-福特算法时，最大化![art](images/Art_P651.jpg)受限于*Ax*
    ≤ *b*和所有*x[i]* ≤ 0。
- en: ★ ***22.4-9***
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***22.4-9***
- en: Show that the Bellman-Ford algorithm, when run on the constraint graph for a
    system *Ax* ≤ *b* of difference constraints, minimizes the quantity (max {*x[i]*}−min
    {*x[i]*}) subject to *Ax* ≤ *b*. Explain how this fact might come in handy if
    the algorithm is used to schedule construction jobs.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 展示当在差分约束系统的约束图上运行贝尔曼-福特算法时，最小化(max {*x[i]*}−min {*x[i]*})受限于*Ax* ≤ *b*。解释如果算法用于调度施工作业，这个事实可能会有所帮助。
- en: '***22.4-10***'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.4-10***'
- en: Suppose that every row in the matrix *A* of a linear program *Ax* ≤ *b* corresponds
    to a difference constraint, a single-variable constraint of the form *x[i]* ≤
    *b[k]*, or a single-variable constraint of the form −*x[i]* ≤ *b[k]*. Show how
    to adapt the Bellman-Ford algorithm to solve this variety of constraint system.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 假设线性规划*Ax* ≤ *b*的矩阵*A*中的每一行对应于一个差分约束，一个形式为*x[i]* ≤ *b[k]*的单变量约束，或一个形式为−*x[i]*
    ≤ *b[k]*的单变量约束。展示如何调整贝尔曼-福特算法来解决这种类型的约束系统。
- en: '***22.4-11***'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.4-11***'
- en: Give an efficient algorithm to solve a system *Ax* ≤ *b* of difference constraints
    when all of the elements of *b* are real-valued and all of the unknowns *x[i]*
    must be integers.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个有效的算法来解决一个差分约束系统*Ax* ≤ *b*，其中*b*的所有元素都是实数，所有未知数*x[i]*必须是整数。
- en: ★ ***22.4-12***
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***22.4-12***
- en: Give an efficient algorithm to solve a system *Ax* ≤ *b* of difference constraints
    when all of the elements of *b* are real-valued and a specified subset of some,
    but not necessarily all, of the unknowns *x[i]* must be integers.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个有效的算法来解决一个差分约束系统*Ax* ≤ *b*，其中*b*的所有元素都是实数，而一些但不一定是所���未知数*x[i]*必须是整数的指定子集。
- en: '[**22.5    Proofs of shortest-paths properties**](toc.xhtml#Rh1-133)'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '[**22.5    最短路径性质的证明**](toc.xhtml#Rh1-133)'
- en: Throughout this chapter, our correctness arguments have relied on the triangle
    inequality, upper-bound property, no-path property, convergence property, path-relaxation
    property, and predecessor-subgraph property. We stated these properties without
    proof on page 611\. In this section, we prove them.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们的正确性论证依赖于三角不等式、上界性质、无路径性质、收敛性质、路径松弛性质和前驱子图性质。我们在第611页陈述了这些性质，但没有给出证明。在本节中，我们将证明它们。
- en: '**The triangle inequality**'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '**三角不等式**'
- en: In studying breadth-first search ([Section 20.2](chapter020.xhtml#Sec_20.2)),
    we proved as Lemma 20.1 a simple property of shortest distances in unweighted
    graphs. The triangle inequality generalizes the property to weighted graphs.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在研究广度优先搜索（[Section 20.2](chapter020.xhtml#Sec_20.2)）时，我们在引理20.1中证明了无权图中最短距离的一个简单性质。三角不等式将这个性质推广到加权图中。
- en: '***Lemma 22.10 (Triangle inequality)***'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理22.10（三角不等式）***'
- en: 'Let *G* = (*V*, *E*) be a weighted, directed graph with weight function *w*
    : *E* → ℝ and source vertex *s*. Then, for all edges (*u*, *v*) ∈ *E*,'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 设*G* = (*V*, *E*)是一个带有权重函数*w*：*E* → ℝ和源顶点*s*的加权有向图。那么，对于所有的边(*u*, *v*) ∈ *E*，
- en: δ(*s*, *v*) ≤ δ(*s*, *u*) + *w*(*u*, *v*).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: δ(*s*, *v*) ≤ δ(*s*, *u*) + *w*(*u*, *v*).
- en: '***Proof***   Suppose that *p* is a shortest path from source *s* to vertex
    *v*. Then *p* has no more weight than any other path from *s* to *v*. Specifically,
    path *p* has no more weight than the particular path that takes a shortest path
    from source *s* to vertex *u* and then takes edge (*u*, *v*).'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   假设*p*是从源*s*到顶点*v*的最短路径。那么*p*的权重不会比从源*s*到顶点*u*的最短路径，然后经过边(*u*, *v*)的任何其他路径更大。具体来说，路径*p*的权重不会比从源*s*到顶点*u*的最短路径，然后经过边(*u*,
    *v*)的路径更大。'
- en: Exercise 22.5-3 asks you to handle the case in which there is no shortest path
    from *s* to *v*.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 练习22.5-3要求你处理从*s*到*v*没有最短路径的情况。
- en: ▪
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Effects of relaxation on shortest-path estimates**'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '**松弛对最短路径估计的影响**'
- en: The next group of lemmas describes how shortest-path estimates are affected
    by executing a sequence of relaxation steps on the edges of a weighted, directed
    graph that has been initialized by INITIALIZE-SINGLE-SOURCE.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 下一组引理描述了在加权有向图上执行一系列松弛步骤时，最短路径估计如何受到影响，该图已由INITIALIZE-SINGLE-SOURCE初始化。
- en: '***Lemma 22.11 (Upper-bound property)***'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理22.11（上界性质）***'
- en: 'Let *G* = (*V*, *E*) be a weighted, directed graph with weight function *w*
    : *E* → ℝ. Let *s* ∈ *V* be the source vertex, and let the graph be initialized
    by INITIALIZE-SINGLE-SOURCE(*G*, *s*). Then, *v.d* ≥ δ(*s*, *v*) for all *v* ∈
    *V*, and this invariant is maintained over any sequence of relaxation steps on
    the edges of *G*. Moreover, once *v.d* achieves its lower bound δ(*s*, *v*), it
    never changes.'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 设*G* = (*V*, *E*)是一个带有权重函数*w*：*E* → ℝ的加权有向图。让*s* ∈ *V*是源顶点，并且图由INITIALIZE-SINGLE-SOURCE(*G*,
    *s*)初始化。那么，对于所有的*v* ∈ *V*，*v.d* ≥ δ(*s*, *v*)，并且这个不变量在*G*的边上的任何一系列松弛步骤中都得以保持。此外，一旦*v.d*达到其下界δ(*s*,
    *v*)，它就不会再改变。
- en: '***Proof***   We prove the invariant *v.d* ≥ δ(*s*, *v*) for all vertices *v*
    ∈ *V* by induction over the number of relaxation steps.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 我们通过对松弛步骤的数量进行归纳证明了对于所有顶点*v* ∈ *V*，不变量*v.d* ≥ δ(*s*, *v*)成立。'
- en: For the base case, *v.d* ≥ δ(*s*, *v*) holds after initialization, since if
    *v.d* = ∞, then *v.d* ≥ δ(*s*, *v*) for all *v* ∈ *V* − {*s*}, and since *s.d*
    = 0 ≥ δ(*s*, *s*). (Note that δ(*s*, *s*) = −∞ if *s* is on a negative-weight
    cycle and that δ(*s*, *s*) = 0 otherwise.)
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 对于基本情况，在初始化后，*v.d* ≥ δ(*s*, *v*)保持成立，因为如果*v.d* = ∞，那么对于所有*v* ∈ *V* − {*s*}，*v.d*
    ≥ δ(*s*, *v*)，并且因为*s.d* = 0 ≥ δ(*s*, *s*)。 (请注意，如果*s*在负权重循环上，则δ(*s*, *s*) = −∞，否则δ(*s*,
    *s*) = 0。)
- en: For the inductive step, consider the relaxation of an edge (*u*, *v*). By the
    inductive hypothesis, *x.d* ≥ δ(*s*, *x*) for all *x* ∈ *V* prior to the relaxation.
    The only *d* value that may change is *v.d*. If it changes, we have
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 对于归纳步骤，考虑边(*u*, *v*)的松弛。根据归纳假设，对于所有*x* ∈ *V*，在松弛之前*x.d* ≥ δ(*s*, *x*)。唯一可能改变的*d*值是*v.d*。如果它改变了，我们有
- en: '| *v.d* | = | *u.d* + *w*(*u*, *v*) |  |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| *v.d* | = | *u.d* + *w*(*u*, *v*) |  |'
- en: '|  | ≥ | δ(*s*, *u*) + *w*(*u*, *v*) | (by the inductive hypothesis) |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '|  | ≥ | δ(*s*, *u*) + *w*(*u*, *v*) | (根据归纳假设) |'
- en: '|  | ≥ | δ(*s*, *v*) | (by the triangle inequality), |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '|  | ≥ | δ(*s*, *v*) | (根据三角不等式) |'
- en: and so the invariant is maintained.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，不变量得以保持。
- en: The value of *v.d* never changes once *v.d* = δ(*s*, *v*) because, having achieved
    its lower bound, *v.d* cannot decrease since we have just shown that *v.d* ≥ δ(*s*,
    *v*), and it cannot increase because relaxation steps do not increase *d* values.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦*v.d* = δ(*s*, *v*)，*v.d*的值就不会再改变，因为已经达到了下界，*v.d*不能减少，因为我们刚刚证明了*v.d* ≥ δ(*s*,
    *v*)，也不能增加，因为松弛步骤不会增加*d*值。
- en: ▪
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Corollary 22.12 (No-path property)***'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论 22.12 (无路径性质)***'
- en: 'Suppose that in a weighted, directed graph *G* = (*V*, *E*) with weight function
    *w* : *E* → ℝ, no path connects a source vertex *s* ∈ *V* to a given vertex *v*
    ∈ *V*. Then, after the graph is initialized by INITIALIZE-SINGLE-SOURCE(*G*, *s*),
    we have *v.d* = δ(*s*, *v*) = ∞, and this equation is maintained as an invariant
    over any sequence of relaxation steps on the edges of *G*.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 假设在带权重的有向图*G* = (*V*, *E*)中，没有路径连接源顶点*s* ∈ *V*和给定顶点*v* ∈ *V*。那么，在通过INITIALIZE-SINGLE-SOURCE(*G*,
    *s*)对图进行初始化后，我们有*v.d* = δ(*s*, *v*) = ∞，并且这个等式在对*G*的边进行任何一系列松弛步骤时都保持不变。
- en: '***Proof***   By the upper-bound property, we always have ∞ = δ(*s*, *v*) ≤
    *v.d*, and thus *v.d* = ∞ = δ(*s*, *v*).'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 根据上界性质，我们始终有∞ = δ(*s*, *v*) ≤ *v.d*，因此*v.d* = ∞ = δ(*s*, *v*)。'
- en: ▪
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Lemma 22.13***'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 22.13***'
- en: 'Let *G* = (*V*, *E*) be a weighted, directed graph with weight function *w*
    : *E* → ℝ, and let (*u*, *v*) ∈ *E*. Then, immediately after edge (*u*, *v*) is
    relaxed by a call of RELAX(*u*, *v*, *w*), we have *v.d* ≤ *u.d* + *w*(*u*, *v*).'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 设*G* = (*V*, *E*)为带权重的有向图，权重函数为*w*：*E* → ℝ，(*u*, *v*) ∈ *E*。那么，在边(*u*, *v*)被RELAX(*u*,
    *v*, *w*)调用松弛后，我们有*v.d* ≤ *u.d* + *w*(*u*, *v*)。
- en: '***Proof***   If, just prior to relaxing edge (*u*, *v*), we have *v.d* > *u.d*
    + *w*(*u*, *v*), then *v.d* = *u.d* + *w*(*u*, *v*) afterward. If, instead, *v.d*
    ≤ *u.d* + *w*(*u*, *v*) just before the relaxation, then neither *u.d* nor *v.d*
    changes, and so *v.d* ≤ *u.d* + *w*(*u*, *v*) afterward.'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 如果在松弛边(*u*, *v*)之前，我们有*v.d* > *u.d* + *w*(*u*, *v*)，那么之后*v.d* = *u.d*
    + *w*(*u*, *v*)。如果相反，在松弛之前*v.d* ≤ *u.d* + *w*(*u*, *v*)，那么在松弛之后，*u.d* 和 *v.d*
    都不会改变，因此之后*v.d* ≤ *u.d* + *w*(*u*, *v*)。'
- en: ▪
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Lemma 22.14 (Convergence property)***'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 22.14 (收敛性质)***'
- en: 'Let *G* = (*V*, *E*) be a weighted, directed graph with weight function *w*
    : *E* → ℝ, let *s* ∈ *V* be a source vertex, and let *s* ⇝ *u* → *v* be a shortest
    path in *G* for some vertices *u, v* ∈ *V*. Suppose that *G* is initialized by
    INITIALIZE-SINGLE-SOURCE(*G*, *s*) and then a sequence of relaxation steps that
    includes the call RELAX(*u*, *v*, *w*) is executed on the edges of *G*. If *u.d*
    = δ(*s*, *u*) at any time prior to the call, then *v.d* = δ(*s*, *v*) at all times
    after the call.'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 设*G* = (*V*, *E*)为带权重的有向图，权重函数为*w*：*E* → ℝ，*s* ∈ *V*为源顶点，*s* ⇝ *u* → *v*为*G*中一条从顶点*s*到顶点*v*的最短路径。假设*G*通过INITIALIZE-SINGLE-SOURCE(*G*,
    *s*)进行初始化，然后在*G*的边上执行包括调用RELAX(*u*, *v*, *w*)的一系列松弛步骤。如果在调用之前的任何时间点*u.d* = δ(*s*,
    *u*)，那么在调用之后*v.d* = δ(*s*, *v*)。
- en: '***Proof***   By the upper-bound property, if *u.d* = δ(*s*, *u*) at some point
    prior to relaxing edge (*u*, *v*), then this equation holds thereafter. In particular,
    after edge (*u*, *v*) is relaxed, we have'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 根据上界性质，如果在松弛边(*u*, *v*)之前*u.d* = δ(*s*, *u*)，那么之后这个等式仍然成立。特别地，在边(*u*,
    *v*)被松弛后，我们有'
- en: '| *v.d* | ≤ | *u.d* + *w*(*u*, *v*) | (by Lemma 22.13) |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| *v.d* | ≤ | *u.d* + *w*(*u*, *v*) | (根据引理22.13) |'
- en: '|  | = | δ(*s*, *u*) + *w*(*u*, *v*) |  |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '|  | = | δ(*s*, *u*) + *w*(*u*, *v*) |  |'
- en: '|  | = | δ(*s*, *u*) | (by Lemma 22.1 on page 606). |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '|  | = | δ(*s*, *u*) | (根据第606页的引理22.1) |'
- en: The upper-bound property gives *v.d* ≥ δ(*s*, *v*), from which we conclude that
    *v.d* = δ(*s*, *v*), and this equation is maintained thereafter.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 上界性质给出*v.d* ≥ δ(*s*, *v*)，由此我们得出*v.d* = δ(*s*, *v*)，并且这个等式在之后保持不变。
- en: ▪
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Lemma 22.15 (Path-relaxation property)***'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 22.15 (路径松弛性质)***'
- en: 'Let *G* = (*V*, *E*) be a weighted, directed graph with weight function *w*
    : *E* → ℝ, and let *s* ∈ *V* be a source vertex. Consider any shortest path *p*
    = 〈*v*[0], *v*[1], … , *v[k]*〉 from *s* = *v*[0] to *v[k]*. If *G* is initialized
    by INITIALIZE-SINGLE-SOURCE(*G*, *s*) and then a sequence of relaxation steps
    occurs that includes, in order, relaxing the edges (*v*[0], *v*[1]), (*v*[1],
    *v*[2]), … , (*v*[*k*−1], *v[k]*), then *v[k].d* = δ(*s*, *v[k]*) after these
    relaxations and at all times afterward. This property holds no matter what other
    edge relaxations occur, including relaxations that are intermixed with relaxations
    of the edges of *p*.'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 设*G* = (*V*, *E*)为带权重的有向图，权重函数为*w*：*E* → ℝ，*s* ∈ *V*为源顶点。考虑任意从*s* = *v*[0]到*v[k]*的最短路径*p*
    = 〈*v*[0], *v*[1], … , *v[k]*〉。如果*G*通过INITIALIZE-SINGLE-SOURCE(*G*, *s*)进行初始化，然后发生一系列松弛步骤，包括按顺序松弛边(*v*[0],
    *v*[1])，(*v*[1], *v*[2])，…，(*v*[*k*−1], *v[k]*)，那么在这些松弛之后以及之后的任何时间点，*v[k].d* =
    δ(*s*, *v[k]*)。无论发生什么其他边的松弛，包括与*p*的边的松弛交错的松弛，这个性质都成立。
- en: '***Proof***   We show by induction that after the *i*th edge of path *p* is
    relaxed, we have *v[i].d* = δ(*s*, *v[i]*). For the base case, *i* = 0, and before
    any edges of *p* have been relaxed, we have from the initialization that *v*[0].*d*
    = *s.d* = 0 = δ(*s*, *s*). By the upper-bound property, the value of *s.d* never
    changes after initialization.'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 我们通过归纳证明，在路径*p*的第*i*条边被松弛后，我们有*v[i].d* = δ(*s*, *v[i]*)。对于基本情况，*i*
    = 0，在任何边被松弛之前，我们从初始化中得知*v*[0].*d* = *s.d* = 0 = δ(*s*, *s*)。根据上界性质，*s.d*的值在初始化后永远不会改变。'
- en: For the inductive step, assume that *v*[*i*−1].*d* = δ(*s*, *v*[*i*−1]). What
    happens when edge (*v*[*i*−1], *v[i]*) is relaxed? By the convergence property,
    after this relaxation, we have *v[i].d* = δ(*s*, *v[i]*), and this equation is
    maintained at all times thereafter.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 对于归纳步骤，假设*v*[*i*−1].*d* = δ(*s*, *v*[*i*−1*）。当边(*v*[*i*−1], *v[i]*)被松弛时会发生什么？根据收敛性质，经过这次松弛后，我们有*v[i].d*
    = δ(*s*, *v[i]*)，并且此方程在此后的所有时间内都保持不变。
- en: ▪
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Relaxation and shortest-paths trees**'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: '**松弛和最短路径树**'
- en: We now show that once a sequence of relaxations has caused the shortest-path
    estimates to converge to shortest-path weights, the predecessor subgraph *G*[π]
    induced by the resulting π values is a shortest-paths tree for *G*. We start with
    the following lemma, which shows that the predecessor subgraph always forms a
    rooted tree whose root is the source.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在展示，一旦一系列松弛导致最短路径估计收敛到最短路径权重，由结果π值引起的前驱子图*G*[π]是*G*的最短路径树。我们从以下引理开始，它表明前驱子图始终形成一个以源为根的树。
- en: '***Lemma 22.16***'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理22.16***'
- en: 'Let *G* = (*V*, *E*) be a weighted, directed graph with weight function *w*
    : *E* → ℝ let *s* ∈ *V* be a source vertex, and assume that *G* contains no negative-weight
    cycles that are reachable from *s*. Then, after the graph is initialized by INITIALIZE-SINGLE-SOURCE(*G*,
    *s*), the predecessor subgraph *G*[π] forms a rooted tree with root *s*, and any
    sequence of relaxation steps on edges of *G* maintains this property as an invariant.'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 设*G* = (*V*, *E*)是一个带有权重函数*w*：*E* → ℝ的加权有向图，让*s* ∈ *V*是源顶点，并假设*G*不包含可从*s*到达的负权重环。那么，在通过INITIALIZE-SINGLE-SOURCE(*G*,
    *s*)初始化图之后，前驱子图*G*[π]形成一个以*s*为根的树，并且对*G*的边进行的任何一系列松弛步骤都保持这个性质作为不变量。
- en: '***Proof***   Initially, the only vertex in *G*[π] is the source vertex, and
    the lemma is trivially true. Consider a predecessor subgraph *G*[π] that arises
    after a sequence of relaxation steps. We first prove that *G*[π] is acyclic. Suppose
    for the sake of contradiction that some relaxation step creates a cycle in the
    graph *G*[π]. Let the cycle be *c* = 〈*v*[0], *v*[1], … , *v[k]*〉, where *v[k]*
    = *v*[0]. Then, *v[i]*.π = *v*[*i*−1] for *i* = 1, 2, … , *k* and, without loss
    of generality, assume that relaxing edge (*v*[*k*−1], *v[k]*) created the cycle
    in *G*[π].'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 最初，*G*[π]中唯一的顶点是源顶点���引理显然成立。考虑在一系列松弛步骤之后产生的前驱子图*G*[π]。我们首先证明*G*[π]是无环的。假设为了推导出图*G*[π]中的某个松弛步骤创建了一个循环。让循环为*c*
    = 〈*v*[0], *v*[1], … , *v[k]*〉，其中*v[k]* = *v*[0]。然后，*v[i]*.π = *v*[*i*−1]对于*i*
    = 1, 2, … , *k*，并且，不失一般性地，假设松弛边(*v*[*k*−1], *v[k]*)在*G*[π]中创建了循环。'
- en: We claim that all vertices on cycle *c* are reachable from the source vertex
    *s*. Why? Each vertex on *c* has a non-NIL predecessor, and so each vertex on
    *c* was assigned a finite shortest-path estimate when it was assigned its non-*NIL*
    π value. By the upper-bound property, each vertex on cycle *c* has a finite shortest-path
    weight, which means that it is reachable from *s*.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声称环*c*上的所有顶点都可以从源顶点*s*到达。为什么？因为*c*上的每个顶点都有一个非NIL的前驱，所以当它被分配非NIL的π值时，每个*c*上的顶点都被分配了有限的最短路径估计。根据上界性质，环*c*上的每个顶点都有一个有限的最短路径权重，这意味着它是可达的。
- en: We’ll examine the shortest-path estimates on cycle *c* immediately before the
    call RELAX(*v*[*k*−1], *v[k]*, *w*) and show that *c* is a negative-weight cycle,
    thereby contradicting the assumption that *G* contains no negative-weight cycles
    that are reachable from the source. Just before the call, we have *v[i]*.π = *v*[*i*−1]
    for *i* = 1, 2, … , *k* − 1\. Thus, for *i* = 1, 2, … , *k* − 1, the last update
    to *v[i].d* was by the assignment *v[i].d* = *v*[*i*−1].*d*+*w*(*v*[*i*−1], *v[i]*).
    If *v*[*i*−1].*d* changed since then, it decreased. Therefore, just before the
    call RELAX(*v*[*k*−1], *v[k]*, *w*), we have
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在调用RELAX(*v*[*k*−1], *v[k]*, *w*)之前立即检查环*c*上的最短路径估计，并展示*c*是一个负权重环，从而与*G*不包含可从源到达的负权重环的假设相矛盾。在调用之前，我们有*v[i]*.π
    = *v*[*i*−1]对于*i* = 1, 2, … , *k* − 1。因此，对于*i* = 1, 2, … , *k* − 1，*v[i].d*的最后更新是通过赋值*v[i].d*
    = *v*[*i*−1].*d*+*w*(*v*[*i*−1], *v[i]*)。如果*v*[*i*−1].*d*自那时起发生了变化，那么它会减少。因此，在调用RELAX(*v*[*k*−1],
    *v[k]*, *w*)之前，我们有
- en: '![art](images/Art_P652.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P652.jpg)'
- en: Because *v[k]*.π is changed by the call RELAX(*v*[*k*−1], *v[k]*, *w*), immediately
    beforehand we also have the strict inequality
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*v[k]*.π是通过调用RELAX(*v*[*k*−1], *v[k]*, *w*)改变的，因此我们也有严格不等式
- en: '*v[k].d* > *v*[*k*−1].*d* + *wv*[*k*−1], *v[k]*):'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '*v[k].d* > *v*[*k*−1].*d* + *wv*[*k*−1], *v[k]*):'
- en: 'Summing this strict inequality with the *k* − 1 inequalities (22.11), we obtain
    the sum of the shortest-path estimates around cycle *c*:'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 将这个严格不等式与* k * − 1个不等式（22.11）相加，我们得到环*c*周围最短路径估计的总和：
- en: '![art](images/Art_P653.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P653.jpg)'
- en: But
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 但是
- en: '![art](images/Art_P654.jpg)'
  id: totrans-384
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P654.jpg)'
- en: '![art](images/Art_P655.jpg)'
  id: totrans-385
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P655.jpg)'
- en: '**Figure 22.9** Showing that a simple path in *G*[π] from source vertex *s*
    to vertex *v* is unique. If *G*[π] contains two paths *p*[1] (*s* ⇝ *u* ⇝ *x*
    → *z* ⇝ *v*) and *p*[2] (*s* ⇝ *u* ⇝ *y* → *z* ⇝ *v*), where *x* ≠ *y*, then *z*.π
    = *x* and *z*.π = *y*, a contradiction.'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**图22.9** 显示了从源顶点*s*到顶点*v*的*G*[π]中的简单路径是唯一的。如果*G*[π]包含两条路径*p*[1]（*s* ⇝ *u*
    ⇝ *x* → *z* ⇝ *v*）和*p*[2]（*s* ⇝ *u* ⇝ *y* → *z* ⇝ *v*），其中*x* ≠ *y*，那么*z*.π = *x*和*z*.π
    = *y*，这是一个矛盾。'
- en: since each vertex in the cycle *c* appears exactly once in each summation. This
    equation implies
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 因为每个环*c*中的顶点在每个求和中只出现一次。这个方程意味着
- en: '![art](images/Art_P656.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P656.jpg)'
- en: Thus, the sum of weights around the cycle c is negative, which provides the
    desired contradiction.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，环*c*周围的权重总和为负，这提供了所需的矛盾。
- en: We have now proven that *G*[π] is a directed, acyclic graph. To show that it
    forms a rooted tree with root *s*, it suffices (see Exercise B.5-2 on page 1175)
    to prove that for each vertex *v* ∈ *V*[π], there is a unique simple path from
    *s* to *v* in *G*[π].
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经证明*G*[π]是一个有向无环图。为了证明它形成以*s*为根的有根树，只需（参见第1175页的练习B.5-2）证明对于每个顶点*v* ∈ *V*[π]，在*G*[π]中从*s*到*v*存在唯一简单路径即可。
- en: The vertices in *V*[π] are those with non-NIL values, plus *s*. Exercise 22.5-6
    asks you to prove that a path from *s* exists to each vertex in *V*[π].
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '*V*[π]中的顶点是那些具有非NIL值的顶点，再加上*s*。练习22.5-6要求您证明从*s*到*V*[π]中的每个顶点存在一条路径。'
- en: 'To complete the proof of the lemma, we now show that for any vertex *v* ∈ *V*[π],
    the graph *G*[π] contains at most one simple path from *s* to *v*. Suppose otherwise.
    That is, suppose that, as [Figure 22.9](chapter022.xhtml#Fig_22-9) illustrates,
    *G*[π] contains two simple paths from *s* to some vertex *v*: *p*[1], which we
    decompose into *s* ⇝ *u* ⇝ *x* → *z* ⇝ *v*, and *p*[2], which we decompose into
    *s* ⇝ *u* ⇝ *y* → *z* ⇝ *v*, where *x* ≠ *y* (though *u* could be *s* and *z*
    could be *v*). But then, *z*.π = *x* and *z*.π = *y*, which implies the contradiction
    that *x* = *y*. We conclude that *G*[π] contains a unique simple path from *s*
    to *v*, and thus *G*[π] forms a rooted tree with root *s*.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成引理的证明，我们现在展示对于任意顶点*v* ∈ *V*[π]，图*G*[π]中从*s*到*v*的简单路径最多只有一条。假设相反情况。也就是说，假设，正如[图22.9](chapter022.xhtml#Fig_22-9)所示，*G*[π]包含从*s*到某个顶点*v*的两条简单路径：*p*[1]，我们将其分解为*s*
    ⇝ *u* ⇝ *x* → *z* ⇝ *v*，和*p*[2]，我们将其分解为*s* ⇝ *u* ⇝ *y* → *z* ⇝ *v*，其中*x* ≠ *y*（尽管*u*可能是*s*，*z*可能是*v*）。但是，那么，*z*.π
    = *x*和*z*.π = *y*，这意味着矛盾，即*x* = *y*。我们得出结论，*G*[π]包含从*s*到*v*的唯一简单路径，因此*G*[π]形成以*s*为根的有根树。
- en: ▪
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: We can now show that if all vertices have been assigned their true shortest-path
    weights after a sequence of relaxation steps, then the predecessor subgraph *G*[π]
    is a shortest-paths tree.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以展示，如果在一系列松弛步骤之后，所有顶点都被分配了它们真实的最短路径权重，那么前驱子图*G*[π]就是最短路径树。
- en: '***Lemma 22.17 (Predecessor-subgraph property)***'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理22.17（前驱子图属性）***'
- en: 'Let *G* = (*V*, *E*) be a weighted, directed graph with weight function *w*
    : *E* → ℝ, let *s* ∈ *V* be a source vertex, and assume that *G* contains no negative-weight
    cycles that are reachable from *s*. Then, after a call to INITIALIZE-SINGLE-SOURCE(*G*,
    *s*) followed by any sequence of relaxation steps on edges of *G* that produces
    *v.d* = δ(*s*, *v*) for all *v* ∈ *V*, the predecessor subgraph *G*[π] is a shortest-paths
    tree rooted at *s*.'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 设*G* = (*V*, *E*)是一个带有权重函数*w*：*E* → ℝ的加权有向图，*s* ∈ *V*是源顶点，并假设*G*不包含从*s*可达的负权重环。那么，在对*G*进行INITIALIZE-SINGLE-SOURCE(*G*,
    *s*)调用后，接着对*G*的边进行任意一系列松弛步骤，使得对所有*V*中的*v*，都有*v.d* = δ(*s*, *v*)，则前驱子图*G*[π]是以*s*为根的最短路径树。
- en: '***Proof***   We must prove that the three properties of shortest-paths trees
    given on page 608 hold for *G*[π]. To show the first property, we must show that
    *V*[π] is the set of vertices reachable from *s*. By definition, a shortest-path
    weight δ(*s*, *v*) is finite if and only if *v* is reachable from *s*, and thus
    the vertices that are reachable from *s* are exactly those with finite *d* values.
    But a vertex *v* ∈ *V* − {*s*} has been assigned a finite value for *v.d* if and
    only if *v*.π ≠ NIL, since both assignments occur in RELAX. Thus, the vertices
    in *V*[π] are exactly those reachable from *s*.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 我们必须证明给出在第608页的最短路径树的三个属性对*G*[π]成立。为了展示第一个属性，我们必须展示*V*[π]是从*s*可达的顶点集。根据定义，从*s*到*v*的最短路径权重δ(*s*,
    *v*)是有限的当且仅当*v*是从*s*可达的，因此从*s*可达的顶点正是那些具有有限*d*值的顶点。但是，当且仅当*v*.π ≠ NIL时，顶点*v* ∈
    *V* − {*s*}才被分配了*v.d*的有限值，因为这两个分配都发生在RELAX中。因此，*V*[π]中的顶点正是从*s*可达的顶点。'
- en: The second property, that *G*[π] forms a rooted tree with root *s*, follows
    directly from Lemma 22.16.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个属性，即*G*[π]形成以*s*为根的有根树，直接由引理22.16得出。
- en: 'It remains, therefore, to prove the last property of shortest-paths trees:
    for each vertex *v* ∈ *V*[π], the unique simple path ![art](images/Art_P657.jpg)
    in *G*[π] is a shortest path from *s* to *v* in *G*. Let *p* = 〈*v*[0], *v*[1],
    … , *v[k]*〉, where *v*[0] = *s* and *v[k]* = *v*. Consider an edge (*v*[*i*−1],
    *v[i]*) in path *p*. Because this edge belongs to *G*[π], the last relaxation
    that changed *v[i].d* must have been of this edge. After that relaxation, we had
    *v[i].d* = *v*[*i*−1].*d* + (*v*[*i*−1], *v[i]*). Subsequently, an edge entering
    *v*[*i*−1] could have been relaxed, causing *v*[*i*−1].*d* to decrease further,
    but without changing *v[i].d*. Therefore, we have *v[i].d* ≥ *v*[*i*−1].*d* +
    *w*(*v*[*i*−1], *v[i]*). Thus, for *i* = 1, 2, … , *k*, we have both *v[i].d*
    = δ(*s*, *v[i]*) and *v[i].d* ≥ *v*[*i*−1].*d* + *w*(*v*[*i*−1], *v[i]*), which
    together imply *w*(*v*[*i*−1], *v[i]*) ≤ δ(*s*, *v[i]*) − δ(*s*, *v*[*i*−1]).
    Summing the weights along path *p* yields'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要证明最短路径树的最后一个属性：对于每个顶点*v* ∈ *V*[π]，*G*[π]中的唯一简单路径![艺术](images/Art_P657.jpg)是从*s*到*v*在*G*中的最短路径。设*p*
    = 〈*v*[0], *v*[1], … , *v[k]*〉，其中*v*[0] = *s*且*v[k]* = *v*。考虑路径*p*中的边(*v*[i−1],
    *v[i]*)。因为这条边属于*G*[π]，改变*v[i].d*的最后一次松弛必须是这条边。在那次松弛之后，我们有*v[i].d* = *v*[i−1].*d*
    + (*v*[i−1], *v[i]*)。随后，进入*v*[i−1]的边可能已经被松弛，导致*v*[i−1].*d*进一步减小，但不会改变*v[i].d*。因此，我们有*v[i].d*
    ≥ *v*[i−1].*d* + *w*(*v*[i−1], *v[i]*)。因此，对于*i* = 1, 2, … , *k*，我们有*v[i].d* =
    δ(*s*, *v[i]*)和*v[i].d* ≥ *v*[i−1].*d* + *w*(*v*[i−1], *v[i]*)，这两者共同暗示*w*(*v*[i−1],
    *v[i]*) ≤ δ(*s*, *v[i]*) − δ(*s*, *v*[i−1])。沿着路径*p*求和权重得到
- en: '![art](images/Art_P658.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P658.jpg)'
- en: Thus, we have *w*(*p*) ≤ δ(*s*, *v[k]*). Since δ(*s*, *v[k]*) is a lower bound
    on the weight of any path from *s* to *v[k]*, we conclude that *w*(*p*) = δ(*s*,
    *v[k]*), and *p* is a shortest path from *s* to *v* = *v[k]*.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有*w*(*p*) ≤ δ(*s*, *v[k]*)。由于δ(*s*, *v[k]*)是从*s*到*v[k]*的任何路径的权重的下界，我���得出*w*(*p*)
    = δ(*s*, *v[k]*)，而*p*是从*s*到*v* = *v[k]*的最短路径。
- en: ▪
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Exercises**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***22.5-1***'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.5-1***'
- en: Give two shortest-paths trees for the directed graph of [Figure 22.2](chapter022.xhtml#Fig_22-2)
    on page 609 other than the two shown.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 给出除了所示之外的[图22.2](chapter022.xhtml#Fig_22-2)上的有向图的两个最短路径树。
- en: '***22.5-2***'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.5-2***'
- en: 'Give an example of a weighted, directed graph *G* = (*V*, *E*) with weight
    function *w* : *E* → ℝ and source vertex *s* such that *G* satisfies the following
    property: For every edge (*u*, *v*) ∈ *E*, there is a shortest-paths tree rooted
    at *s* that contains (*u*, *v*) and another shortest-paths tree rooted at *s*
    that does not contain (*u*, *v*).'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '给出一个带有权重、有向图*G* = (*V*, *E*)和权重函数*w* : *E* → ℝ以及源顶点*s*的示例，使得*G*满足以下属性：对于每条边(*u*,
    *v*) ∈ *E*，存在以*s*为根的包含(*u*, *v*)的最短路径树，以及另一个以*s*为根的不包含(*u*, *v*)的最短路径树。'
- en: '***22.5-3***'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.5-3***'
- en: Modify the proof of Lemma 22.10 to handle cases in which shortest-path weights
    are ∞ or −∞.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 修改引理22.10的证明，以处理最短路径权重为∞或−∞的情况。
- en: '***22.5-4***'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.5-4***'
- en: Let *G* = (*V*, *E*) be a weighted, directed graph with source vertex *s*, and
    let *G* be initialized by INITIALIZE-SINGLE-SOURCE(*G*, *s*). Prove that if a
    sequence of relaxation steps sets *s*.π to a non-NIL value, then *G* contains
    a negative-weight cycle.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 设*G* = (*V*, *E*)为带有源顶点*s*的带权重、有向图，并且让*G*通过INITIALIZE-SINGLE-SOURCE(*G*, *s*)进行初始化。证明如果一系列松弛操作将*s*.π设置为非NIL值，则*G*包含负权重环。
- en: '***22.5-5***'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.5-5***'
- en: Let *G* = (*V*, *E*) be a weighted, directed graph with no negative-weight edges.
    Let *s* ∈ *V* be the source vertex, and suppose that *v*.π is allowed to be the
    predecessor of *v* on *any* shortest path to *v* from source *s* if *v* ∈ *V*
    − {*s*} is reachable from *s*, and NIL otherwise. Give an example of such a graph
    *G* and an assignment of π values that produces a cycle in *G*[π]. (By Lemma 22.16,
    such an assignment cannot be produced by a sequence of relaxation steps.)
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 设*G* = (*V*, *E*)为不含负权重边的带权重、有向图。设*s* ∈ *V*为源顶点，并且假设如果*v* ∈ *V* − {*s*}可从源*s*到达，则*v*.π可以是*v*在从源*s*到*v*的*任意*最短路径上的前驱，否则为NIL。给出这样一个图*G*和π值的分配的示例，使得在*G*[π]中产生一个环。（根据引理22.16，这样的分配不能通过一系列松弛操作产生。）
- en: '***22.5-6***'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.5-6***'
- en: 'Let *G* = (*V*, *E*) be a weighted, directed graph with weight function *w*
    : *E* → ℝ and no negative-weight cycles. Let *s* ∈ *V* be the source vertex, and
    let *G* be initialized by INITIALIZE-SINGLE-SOURCE(*G*, *s*). Use induction to
    prove that for every vertex *v* ∈ *V*[π], there exists a path from *s* to *v*
    in *G*[π] and that this property is maintained as an invariant over any sequence
    of relaxations.'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '设*G* = (*V*, *E*)为带有权重、有向图，权重函数*w* : *E* → ℝ且没有负权重环。设*s* ∈ *V*为源顶点，并且让*G*通过INITIALIZE-SINGLE-SOURCE(*G*,
    *s*)进行初始化。使用归纳法证明对于每个顶点*v* ∈ *V*[π]，在*G*[π]中存在一条从*s*到*v*的路径，并且这个属性在任何一系列松弛操作中都保持不变。'
- en: '***22.5-7***'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.5-7***'
- en: Let *G* = (*V*, *E*) be a weighted, directed graph that contains no negative-weight
    cycles. Let *s* ∈ *V* be the source vertex, and let *G* be initialized by INITIALIZESINGLE-SOURCE(*G*,
    *s*). Prove that there exists a sequence of |*V*| − 1 relaxation steps that produces
    *v.d* = δ(*s*, *v*) for all *v* ∈ *V*.
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 设*G* = (*V*, *E*)为不含负权重环的带权重、有向图。设*s* ∈ *V*为源顶点，并且让*G*通过INITIALIZE-SINGLE-SOURCE(*G*,
    *s*)进行初始化���证明存在一系列|*V*| − 1次松弛操作，使得对于所有*v* ∈ *V*，都有*v.d* = δ(*s*, *v*)。
- en: '***22.5-8***'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '***22.5-8***'
- en: Let *G* be an arbitrary weighted, directed graph with a negative-weight cycle
    reachable from the source vertex s. Show how to construct an infinite sequence
    of relaxations of the edges of *G* such that every relaxation causes a shortest-path
    estimate to change.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 设*G*为带有从源顶点*s*可达的负权重环的任意带权重、有向图。展示如何构造*G*的边的无限序列的松弛，使得每次松弛都会导致最短路径估计值的变化。
- en: '**Problems**'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '***22-1     Yen’s improvement to Bellman-Ford***'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '***22-1     Yen对Bellman-Ford的改进***'
- en: 'The Bellman-Ford algorithm does not specify the order in which to relax edges
    in each pass. Consider the following method for deciding upon the order. Before
    the first pass, assign an arbitrary linear order *v*[1], *v*[2], … , *v*[|*V*|]
    to the vertices of the input graph *G* = (*V*, *E*). Then partition the edge set
    *E* into *E[f]* ∪ *E[b]*, where *E[f]* = {(*v[i]*, *v[j]*) ∈ *E* : *i* < *j*}
    and *E[b]* = {(*v[i]*, *v[j]*) ∈ *E* : *i* > *j*}. (Assume that *G* contains no
    self-loops, so that every edge belongs to either *E[f]* or *E[b]*.) Define *G[f]*
    = (*V*, *E[f]*) and *G[b]* = (*V*, *E[b]*).'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 'Bellman-Ford算法没有规定每次遍历中松弛边的顺序。考虑以下决定顺序的方法。在第一次遍历之前，为输入图*G* = (*V*, *E*)的顶点分配任意线性顺序*v*[1]，*v*[2]，…，*v*[|*V*|]。然后将边集*E*划分为*E[f]*
    ∪ *E[b]*，其中*E[f]* = {(*v[i]*, *v[j]*) ∈ *E* : *i* < *j*}，*E[b]* = {(*v[i]*, *v[j]*)
    ∈ *E* : *i* > *j*}。（假设*G*不包含自环，因此每条边都属于*E[f]*或*E[b]*。）定义*G[f]* = (*V*, *E[f]*)和*G[b]*
    = (*V*, *E[b]*)。'
- en: '***a.*** Prove that *G[f]* is acyclic with topological sort 〈*v*[1], *v*[2],
    … , *v*[|*V*|]〉 and that *G[b]* is acyclic with topological sort 〈*v*[|*V*|],
    *v*[|*V*|−1], … , *v*[1]〉.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 证明*G[f]*是无环的，具有拓扑排序〈*v*[1]，*v*[2]，…，*v*[|*V*|]〉，并且*G[b]*是无环的，具有拓扑排序〈*v*[|*V*|]，*v*[|*V*|−1]，…，*v*[1]〉。'
- en: Suppose that each pass of the Bellman-Ford algorithm relaxes edges in the following
    way. First, visit each vertex in the order *v*[1], *v*[2], … , *v*[|*V*|], relaxing
    edges of *E[f]* that leave the vertex. Then visit each vertex in the order *v*[|*V*|],
    *v*[|*V*|−1], …, *v*[1], relaxing edges of *E[b]* that leave the vertex.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 假设Bellman-Ford算法的每次遍历都以以下方式松弛边。首先，按顺序访问每个顶点*v*[1]，*v*[2]，…，*v*[|*V*|]，松弛离开该顶点的边。然后按顺序访问每个顶点*v*[|*V*|]，*v*[|*V*|−1]，…，*v*[1]，松弛离开该顶点的边。
- en: '***b.*** Prove that with this scheme, if *G* contains no negative-weight cycles
    that are reachable from the source vertex *s*, then after only ⌈|*V*| / 2⌉ passes
    over the edges, *v.d* = δ(*s*, *v*) for all vertices *v* ∈ *V*.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 证明使用这种方案，如果*G*不包含从源顶点*s*可达的负权重环，则在仅经过⌈|*V*| / 2⌉次边的遍历后，对于所有顶点*v* ∈
    *V*，都有*v.d* = δ(*s*, *v*)。'
- en: '***c.*** Does this scheme improve the asymptotic running time of the Bellman-Ford
    algorithm?'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 这种方案是否改进了Bellman-Ford算法的渐进运行时间？'
- en: '***22-2     Nesting boxes***'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '***22-2     嵌套盒子***'
- en: A *d*-dimensional box with dimensions (*x*[1], *x*[2], … , *x[d]*) ***nests***
    within another box with dimensions (*y*[1], *y*[2], … , *y[d]*) if there exists
    a permutation π on {1, 2, … , *d*} such that *x*[π(1)] < *y*[1], *x*[π(2)] < *y*[2],
    … , *x*[π(*d*)] < *y[d]*.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 *d* 维箱子，其尺寸为 (*x*[1], *x*[2], … , *x[d]*)，***嵌套*** 在另一个尺寸为 (*y*[1], *y*[2],
    … , *y[d]*) 的箱子中，如果存在一个置换 π 在 {1, 2, … , *d*} 上，使得 *x*[π(1)] < *y*[1], *x*[π(2)]
    < *y*[2], … , *x*[π(*d*)] < *y[d]*。
- en: '***a.*** Argue that the nesting relation is transitive.'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 论证嵌套关系是传递的。'
- en: '***b.*** Describe an efficient method to determine whether one *d*-dimensional
    box nests inside another.'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 描述一种高效的方法来确定一个 *d* 维箱子是否嵌套在另一个箱子中。'
- en: '***c.*** You are given a set of *n d*-dimensional boxes {*B*[1], *B*[2], …
    , *B[n]*}. Give an efficient algorithm to find the longest sequence ![art](images/Art_P660.jpg)
    of boxes such that ![art](images/Art_P661.jpg) nests within ![art](images/Art_P662.jpg)
    for *j* = 1, 2, … , *k* − 1\. Express the running time of your algorithm in terms
    of *n* and *d*.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 给定一组 *n* 个 *d* 维箱子 {*B*[1], *B*[2], … , *B[n]*}。给出一个高效的算法，找到最长的箱子序列
    ![art](images/Art_P660.jpg)，使得 ![art](images/Art_P661.jpg) 嵌套在 ![art](images/Art_P662.jpg)
    中，对于 *j* = 1, 2, … , *k* − 1\. 用 *n* 和 *d* 表示算法的运行时间。'
- en: '***22-3     Arbitrage***'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: '***22-3     套汇***'
- en: '***Arbitrage*** is the use of discrepancies in currency exchange rates to transform
    one unit of a currency into more than one unit of the same currency. For example,
    suppose that one U.S. dollar buys 64 Indian rupees, one Indian rupee buys 1:8
    Japanese yen, and one Japanese yen buys 0:009 U.S. dollars. Then, by converting
    currencies, a trader can start with 1 U.S. dollar and buy 64 × 1.8 × 0.009 = 1.0368
    U.S. dollars, thus turning a profit of 3.68%.'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: '***套汇*** 是利用货币汇率的差异将一单位货币转换为多于一单位相同货币的行为。例如，假设一美元可以购买 64 印度卢比，一印度卢比可以购买 1:8
    日元，一日元可以购买 0:009 美元。通过转换货币，交易员可以以 1 美元开始，购买 64 × 1.8 × 0.009 = 1.0368 美元，从而获利
    3.68%。'
- en: Suppose that you are given *n* currencies *c*[1], *c*[2], … , *c[n]* and an
    *n* × *n* table *R* of exchange rates, such that 1 unit of currency *c[i]* buys
    *R*[*i*, *j*] units of currency *c[j]*.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您有 *n* 种货币 *c*[1], *c*[2], … , *c[n]* 和一个 *n* × *n* 的汇率表 *R*，其中 1 单位货币 *c[i]*
    可以购买 *R*[*i*, *j*] 单位货币 *c[j]*。
- en: '***a.*** Give an efficient algorithm to determine whether there exists a sequence
    of currencies ![art](images/Art_P663.jpg) such that'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 给出一个高效的算法，以确定是否存在一系列货币 ![art](images/Art_P663.jpg)，使得'
- en: '*R*[*i*[1], *i*[2]] · *R*[*i*[2], *i*[3]] … *R*[*i*[*k*−1], *i[k]*] · *R*[*i[k]*,
    *i*[1]] > 1.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '*R*[*i*[1], *i*[2]] · *R*[*i*[2], *i*[3]] … *R*[*i*[*k*−1], *i[k]*] · *R*[*i[k]*,
    *i*[1]] > 1.'
- en: Analyze the running time of your algorithm.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 分析算法的运行时间。
- en: '***b.*** Give an efficient algorithm to print out such a sequence if one exists.
    Analyze the running time of your algorithm.'
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 给出一个高效的算法，如果存在这样的序列，则打印出来。分析算法的运行时间。'
- en: '***22-4     Gabow’s scaling algorithm for single-source shortest paths***'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: '***22-4     Gabow''s scaling algorithm for single-source shortest paths***'
- en: A ***scaling*** algorithm solves a problem by initially considering only the
    highest-order bit of each relevant input value, such as an edge weight, assuming
    that these values are nonnegative integers. The algorithm then refines the initial
    solution by looking at the two highest-order bits. It progressively looks at more
    and more high-order bits, refining the solution each time, until it has examined
    all bits and computed the correct solution.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 一个***缩放***算法通过最初仅考虑每个相关输入值的最高位，例如边权重，来解决问题，假设这些值是非负整数。然后，算法通过查看两个最高位来完善初始解决方案。它逐渐查看更多高位，每次完善解决方案，直到检查所有位并计算出正确的解决方案。
- en: 'This problem examines an algorithm for computing the shortest paths from a
    single source by scaling edge weights. The input is a directed graph *G* = (*V*,
    *E*) with nonnegative integer edge weights *w*. Let *W* = max {*w*(*u*, *v*) :
    (*u*, *v*) = *E*} be the maximum weight of any edge. In this problem, you will
    develop an algorithm that runs in *O*(*E* lg *W*) time. Assume that all vertices
    are reachable from the source.'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: '这个问题考察了通过缩放边权重计算从单个源到最短路径的算法。输入是一个有向图 *G* = (*V*, *E*)，具有非负整数边权重 *w*。设 *W*
    = max {*w*(*u*, *v*) : (*u*, *v*) = *E*} 是任何边的最大权重。在这个问题中，您将开发一个在 *O*(*E* lg *W*)
    时间内运行的算法。假设所有顶点都可以从源点到达。'
- en: The scaling algorithm uncovers the bits in the binary representation of the
    edge weights one at a time, from the most significant bit to the least significant
    bit. Specifically, let *k* = ⌈lg(*W* + 1)⌉ be the number of bits in the binary
    representation of *W*, and for *i* = 1, 2, … , *k*, let *w[i]*(*u*,*v*) = ⌊*w*(*u*,*v*)/2^(*k*–*i*)⌋.
    That is, *w[i]* (*u*, *v*) is the “scaled-down” version of *w*(*u*, *v*) given
    by the *i* most significant bits of *w*(*u*, *v*). (Thus, *w[k]*(*u*, *v*) = *w*(*u*,
    *v*) for all (*u*, *v*) ∈ *E*.) For example, if *k* = 5 and *w*(*u*, *v*) = 25,
    which has the binary representation 〈11001〉, then *w*[3](*u*, *v*) = 〈110〉 = 6\.
    Also with *k* = 5, if *w*(*u*, *v*) = 〈00100〉 = 4, then *w*[4](*u*, *v*) = 〈0010〉
    = 2\. Define δ[*i*](*u*, *v*) as the shortest-path weight from vertex *u* to vertex
    *v* using weight function *w[i]*, so that δ[*k*](*u*, *v*) = δ(*u*, *v*) for all
    *u*, *v* ∈ *V*. For a given source vertex *s*, the scaling algorithm first computes
    the shortest-path weights δ[1](*s*, *v*) for all *v* ∈ *V*, then computes δ[2](*s*,
    *v*) for all *v* ∈ *V*, and so on, until it computes δ[*k*](*s*, *v*) for all
    *v* ∈ *V*. Assume throughout that |*E*| ≥ |*V*| − 1\. You will show how to compute
    δ[*i*] from δ[*i*−1] in *O*(*E*) time, so that the entire algorithm takes *O*(*kE*)
    = *O*(*E* lg *W*) time.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 缩放算法逐个揭示边权重的二进制表示中的位，从最高有效位到最低有效位。具体来说，让*k* = ⌈lg(*W* + 1)⌉是*W*的二进制表示中的位数，对于*i*
    = 1, 2, … , *k*，让*w[i]*(*u*,*v*) = ⌊*w*(*u*,*v*)/2^(*k*–*i*)⌋。也就是说，*w[i]* (*u*,
    *v*)是*w*(*u*, *v*)的*i*个最高有效位的“缩小”版本。（因此，对于所有(*u*, *v*) ∈ *E*，*w[k]*(*u*, *v*)
    = *w*(*u*, *v*)。）例如，如果*k* = 5且*w*(*u*, *v*) = 25，其二进制表示为〈11001〉，那么*w*[3](*u*,
    *v*) = 〈110〉 = 6��同样，如果*k* = 5且*w*(*u*, *v*) = 〈00100〉 = 4，则*w*[4](*u*, *v*) =
    〈0010〉 = 2。将δ[*i*](*u*, *v*)定义为使用权重函数*w[i]*从顶点*u*到顶点*v*的最短路径权重，以便对于所有*u*, *v*
    ∈ *V*，δ[*k*](*u*, *v*) = δ(*u*, *v*)。对于给定的源顶点*s*，缩放算法首先计算所有*v* ∈ *V*的最短路径权重δ[1](*s*,
    *v*)，然后计算所有*v* ∈ *V*的δ[2](*s*, *v*)，依此类推，直到计算所有*v* ∈ *V*的δ[*k*](*s*, *v*)。始终假设|*E*|
    ≥ |*V*| − 1。你将展示如何在*O*(*E*)时间内从δ[*i*−1]计算δ[*i*]，使得整个算法花费*O*(*kE*) = *O*(*E* lg
    *W*)时间。
- en: '***a.*** Suppose that for all vertices *v* ∈ *V*, we have δ(*s*, *v*) ≤ |*E*|.
    Show how to compute δ(*s*, *v*) for all *v* ∈ *V* in *O*(*E*) time.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 假设对于所有顶点*v* ∈ *V*，我们有δ(*s*, *v*) ≤ |*E*|。展示如何在*O*(*E*)时间内计算所有*v* ∈
    *V*的δ(*s*, *v*)。'
- en: '***b.*** Show how to compute δ[1](*s*, *v*) for all *v* ∈ *V* in *O*(*E*) time.'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 展示如何在*O*(*E*)时间内计算所有*v* ∈ *V*的δ[1](*s*, *v*)。'
- en: Now focus on computing δ[i] from δ[*i*−1].
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 现在专注于从δ[*i*−1]计算δ[i]。
- en: '***c.*** Prove that for *i* = 2, 3, … , *k*, either *w[i]*(*u*, *v*) = 2*w*[*i*−1](*u*,
    *v*) or *w[i]*(*u*, *v*) = 2*w*[*i*−1](*u*, *v*) + 1\. Then prove that'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 证明对于*i* = 2, 3, … , *k*，要么*w[i]*(*u*, *v*) = 2*w*[*i*−1](*u*, *v*)，要么*w[i]*(*u*,
    *v*) = 2*w*[*i*−1](*u*, *v*) + 1。然后证明'
- en: 2δ[*i*−1](*s*, *v*) ≤ δ[*i*](*s*, *v*) ≤ 2δ[*i*−1](*s*, *v*) + |*V*| − 1
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 2δ[*i*−1](*s*, *v*) ≤ δ[*i*](*s*, *v*) ≤ 2δ[*i*−1](*s*, *v*) + |*V*| − 1
- en: for all *v* ∈ *V*.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有*v* ∈ *V*。
- en: '***d.*** Define, for *i* = 2, 3, … , *k* and all (*u*, *v*) ∈ *E*,'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 定义，对于*i* = 2, 3, … , *k*和所有(*u*, *v*) ∈ *E*，'
- en: '*ŵ*[*i*](*u*, *v*) = *w[i]*(*u*, *v*) + 2δ[*i*−1](*s*, *u*) − 2δ[*i*−1](*s*,
    *v*).'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '*ŵ*[*i*](*u*, *v*) = *w[i]*(*u*, *v*) + 2δ[*i*−1](*s*, *u*) − 2δ[*i*−1](*s*,
    *v*)。'
- en: Prove that for *i* = 2, 3, … , *k* and all *u*, *v* ∈ *V*, the “reweighted”
    value *ŵ[i]*(*u*, *v*) of edge (*u*, *v*) is a nonnegative integer.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 证明对于*i* = 2, 3, … , *k*和所有*u*, *v* ∈ *V*，边(*u*, *v*)的“重新加权”值*ŵ[i]*(*u*, *v*)是非负整数。
- en: '***e.*** Now define ![art](images/Art_P666.jpg) as the shortest-path weight
    from *s* to *v* using the weight function *ŵ[i]*. Prove that for *i* = 2, 3, …
    , *k* and all *v* ∈ *V*,'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** 现在将![艺术](images/Art_P666.jpg)定义为使用权重函数*ŵ[i]*从*s*到*v*的最短路径权重。证明对于*i*
    = 2, 3, … , *k*和所有*v* ∈ *V*，'
- en: '![art](images/Art_P667.jpg)'
  id: totrans-453
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P667.jpg)'
- en: and that ![art](images/Art_P668.jpg).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 并且![艺术](images/Art_P668.jpg)。
- en: '***f.*** Show how to compute δ[*i*](*s*, *v*) from δ[*i*−1](*s*, *v*) for all
    *v* ∈ *V* in *O*(*E*) time. Conclude that you can compute δ(*s*, *v*) for all
    *v* ∈ *V* in *O*(*E* lg *W*) time.'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '***f.*** 展示如何在*O*(*E*)时间内从δ[*i*−1](*s*, *v*)计算所有*v* ∈ *V*的δ[*i*](*s*, *v*)。得出结论，你可以在*O*(*E*
    lg *W*)时间内计算所有*v* ∈ *V*的δ(*s*, *v*)。'
- en: '***22-5     Karp’s minimum mean-weight cycle algorithm***'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '***22-5     卡普的最小平均权重循环算法***'
- en: 'Let *G* = (*V*, *E*) be a directed graph with weight function *w* : *E* → ℝ,
    and let *n* = |*V*|. We define the ***mean weight*** of a cycle *c* = 〈*e*[1],
    *e*[2], … , *e[k]*〉 of edges in *E* to be'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 让*G* = (*V*, *E*)是具有权重函数*w*：*E* → ℝ的有向图，让*n* = |*V*|。我们将边集*E*中的边循环*c* = 〈*e*[1],
    *e*[2], … , *e[k]*〉的***平均权重***定义为
- en: '![art](images/Art_P669.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P669.jpg)'
- en: 'Let μ* = min {μ(*c*) : *c* is a directed cycle in *G*}. We call a cycle *c*
    for which μ(*c*) = μ* a ***minimum mean-weight cycle***. This problem investigates
    an efficient algorithm for computing μ*.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 让μ* = min {μ(*c*)：*c*是*G*中的有向循环}。我们称满足μ(*c*) = μ*的循环*c*为***最小平均权重循环***。这个问题探讨了一个计算μ*的高效算法。
- en: Assume without loss of generality that every vertex *v* ∈ *V* is reachable from
    a source vertex *s* ∈ *V*. Let δ(*s*, *v*) be the weight of a shortest path from
    *s* to *v*, and let δ[*k*](*s*, *v*) be the weight of a shortest path from *s*
    to *v* consisting of *exactly k* edges. If there is no path from *s* to *v* with
    exactly *k* edges, then δ[*k*](*s*, *v*) = ∞.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 不失一般性地假设每个顶点*v* ∈ *V*都可以从源顶点*s* ∈ *V*到达。让δ(*s*, *v*)是从*s*到*v*的最短路径的权重，让δ[*k*](*s*,
    *v*)是由*恰好k*条边组成的从*s*到*v*的最短路径的权重。如果从*s*到*v*没有恰好*k*条边的路径，则δ[*k*](*s*, *v*) = ∞。
- en: '***a.*** Show that if μ* = 0, then *G* contains no negative-weight cycles and
    δ(*s*, *v*) = min {δ[*k*](*s*, *v*) : 0 ≤ *k* ≤ *n* − 1} for all vertices *v*
    ∈ *V*.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 展示如果μ* = 0，则*G*不包含负权重循环且对于所有*v* ∈ *V*，有δ(*s*, *v*) = min {δ[*k*](*s*,
    *v*)：0 ≤ *k* ≤ *n* − 1}。'
- en: '***b.*** Show that if μ* = 0, then'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 展示如果μ* = 0，则'
- en: '![art](images/Art_P670.jpg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P670.jpg)'
- en: for all vertices *v* ∈ *V*. (*Hint:* Use both properties from part (a).)
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有顶点*v* ∈ *V*。（提示：使用(a)部分的两个属性。）
- en: '***c.*** Let *c* be a 0-weight cycle, and let *u* and *v* be any two vertices
    on *c*. Suppose that μ* = 0 and that the weight of the simple path from *u* to
    *v* along the cycle is *x*. Prove that δ(*s*, *v*) = δ(*s*, *u*) + *x*. (*Hint:*
    The weight of the simple path from *v* to *u* along the cycle is −*x*.)'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 让 *c* 是一个0权重循环，让 *u* 和 *v* 是循环上的任意两个顶点。假设 μ* = 0 并且沿着循环从 *u* 到 *v*
    的简单路径的权重为 *x*。证明 δ(*s*, *v*) = δ(*s*, *u*) + *x*。(*提示:* 沿着循环从 *v* 到 *u* 的简单路径的权重为
    −*x*)。'
- en: '***d.*** Show that if μ* = 0, then on each minimum mean-weight cycle there
    exists a vertex *v* such that'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 证明如果 μ* = 0，则在每个最小平均权重循环中都存在一个顶点 *v*，使得'
- en: '![art](images/Art_P671.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P671.jpg)'
- en: (*Hint:* Show how to extend a shortest path to any vertex on a minimum mean-weight
    cycle along the cycle to make a shortest path to the next vertex on the cycle.)
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: (*提示:* 展示如何将最短路径延伸到沿着循环到达最小平均权重循环上的任意顶点，以便形成到达循环上下一个顶点的最短路径。)
- en: '***e.*** Show that if μ* = 0, then the minimum value of'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** 证明如果 μ* = 0，则'
- en: '![art](images/Art_P672.jpg)'
  id: totrans-470
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P672.jpg)'
- en: taken over all vertices *v* ∈ *V*, equals 0.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有顶点 *v* ∈ *V*，等于0。
- en: '***f.*** Show that if you add a constant *t* to the weight of each edge of
    *G*, then μ* increases by *t*. Use this fact to show that μ* equals the minimum
    value of'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '***f.*** 证明如果您将 *G* 的每条边的权重增加一个常数 *t*，则 μ* 会增加 *t*。利用这个事实证明 μ* 等于'
- en: '![art](images/Art_P673.jpg)'
  id: totrans-473
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P673.jpg)'
- en: taken over all vertices *v* ∈ *V*.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有顶点 *v* ∈ *V*。
- en: '***g.*** Give an *O*(*VE*)-time algorithm to compute μ*.'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '***g.*** 给出一个 *O*(*VE*) 时间的算法来计算 μ*。'
- en: '***22-6     Bitonic shortest paths***'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '***22-6     双调最短路径***'
- en: A sequence is ***bitonic*** if it monotonically increases and then monotonically
    decreases, or if by a circular shift it monotonically increases and then monotonically
    decreases. For example the sequences 〈1, 4, 6, 8, 3, −2〉, 〈9, 2, −4, −10, −5〉,
    and 〈1, 2, 3, 4〉 are bitonic, but 〈1, 3, 12, 4, 2, 10〉 is not bitonic. (See Problem
    14-3 on page 407 for the bitonic euclidean traveling-salesperson problem.)
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个序列单调递增然后单调递减，或者通过循环移位单调递增然后单调递减，则称为***双调***。例如序列 〈1, 4, 6, 8, 3, −2〉，〈9,
    2, −4, −10, −5〉 和 〈1, 2, 3, 4〉 是双调的，但序列 〈1, 3, 12, 4, 2, 10〉 不是双调的。（有关双调欧几里德旅行推销员问题，请参见第407页的问题14-3。）
- en: 'Suppose that you are given a directed graph *G* = (*V*, *E*) with weight function
    *w* : *E* → ℝ, where all edge weights are unique, and you wish to find single-source
    shortest paths from a source vertex *s*. You are given one additional piece of
    information: for each vertex *v* ∈ *V*, the weights of the edges along any shortest
    path from *s* to *v* form a bitonic sequence.'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: '假设给定一个带有权重函数 *w* : *E* → ℝ 的有向图 *G* = (*V*, *E*), 其中所有边的权重都是唯一的，并且您希望从源顶点 *s*
    找到单源最短路径。您还获得了额外的信息：对于每个顶点 *v* ∈ *V*，从 *s* 到 *v* 的任何最短路径上的边的权重形成一个双调序列。'
- en: Give the most efficient algorithm you can to solve this problem, and analyze
    its running time.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 给出您能够解决此问题的最有效算法，并分析其运行时间。
- en: '**Chapter notes**'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节注释**'
- en: The shortest-path problem has a long history that is nicely desribed in an article
    by Schrijver [[400](bibliography001.xhtml#endnote_400)]. He credits the general
    idea of repeatedly executing edge relaxations to Ford [[148](bibliography001.xhtml#endnote_148)].
    Dijkstra’s algorithm [[116](bibliography001.xhtml#endnote_116)] appeared in 1959,
    but it contained no mention of a priority queue. The Bellman-Ford algorithm is
    based on separate algorithms by Bellman [[45](bibliography001.xhtml#endnote_45)]
    and Ford [[149](bibliography001.xhtml#endnote_149)]. The same algorithm is also
    attributed to Moore [[334](bibliography001.xhtml#endnote_334)]. Bellman describes
    the relation of shortest paths to difference constraints. Lawler [[276](bibliography001.xhtml#endnote_276)]
    describes the linear-time algorithm for shortest paths in a dag, which he considers
    part of the folklore.
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 最短路径问题有一个悠久的历史，Schrijver 的一篇文章中很好地描述了这一点[[400](bibliography001.xhtml#endnote_400)]。他将反复执行边松弛的一般思想归功于
    Ford[[148](bibliography001.xhtml#endnote_148)]。Dijkstra 算法[[116](bibliography001.xhtml#endnote_116)]于1959年出现，但没有提及优先队列。Bellman-Ford
    算法基于 Bellman[[45](bibliography001.xhtml#endnote_45)] 和 Ford[[149](bibliography001.xhtml#endnote_149)]
    的单独算法。相同的算法也归因于 Moore[[334](bibliography001.xhtml#endnote_334)]。Bellman描述了最短路径与差分约束的关系。Lawler[[276](bibliography001.xhtml#endnote_276)]描述了有向无环图中最短路径的线性时间算法，他认为这是传统知识的一部分。
- en: When edge weights are relatively small nonnegative integers, more efficient
    algorithms result from using min-priority queues that require integer keys and
    rely on the sequence of values returned by the EXTRACT-MIN calls in Dijkstra’s
    algorithm monotonically increasing over time. Ahuja, Mehlhorn, Orlin, and Tarjan
    [[8](bibliography001.xhtml#endnote_8)] give an algorithm that runs in ![art](images/Art_P674.jpg)
    time on graphs with nonnegative edge weights, where *W* is the largest weight
    of any edge in the graph. The best bounds are by Thorup [[436](bibliography001.xhtml#endnote_436)],
    who gives an algorithm that runs in *O*(*E* lg lg *V*) time, and by Raman [[375](bibliography001.xhtml#endnote_375)],
    who gives an algorithm that runs in *O*(*E* + *V* min {(lg *V*)^(1/3+ε), (lg *W*)^(1/4+ε)})
    time. These two algorithms use an amount of space that depends on the word size
    of the underlying machine. Although the amount of space used can be unbounded
    in the size of the input, it can be reduced to be linear in the size of the input
    using randomized hashing.
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 当边的权重相对较小且为非负整数时，使用需要整数键的最小优先队列会导致更有效的算法，并依赖于 Dijkstra 算法中 EXTRACT-MIN 调用返回的值序列随时间单调递增。Ahuja,
    Mehlhorn, Orlin 和 Tarjan [[8](bibliography001.xhtml#endnote_8)] 给出了一种算法，该算法在具有非负边权重的图上运行时间为
    ![艺术](images/Art_P674.jpg)，其中 *W* 是图中任意边的最大权重。最佳界限由 Thorup [[436](bibliography001.xhtml#endnote_436)]
    给出，他提供了一种在 *O*(*E* lg lg *V*) 时间内运行的算法，以及由 Raman [[375](bibliography001.xhtml#endnote_375)]
    给出的一种在 *O*(*E* + *V* min {(lg *V*)^(1/3+ε), (lg *W*)^(1/4+ε)}) 时间内运行的算法。这两种算法使用取决于底层机器的字大小的空间量。尽管使用的空间量可能随输入大小而无限增长，但可以通过随机哈希减少到与输入大小线性相关。
- en: For undirected graphs with integer weights, Thorup [[435](bibliography001.xhtml#endnote_435)]
    gives an algorithm that runs in *O*(*V* + *E*) time for single-source shortest
    paths. In contrast to the algorithms mentioned in the previous paragraph, the
    sequence of values returned by EXTRACT-MIN calls does not monotonically increase
    over time, and so this algorithm is not an implementation of Dijkstra’s algorithm.
    Pettie and Ramachandran [[357](bibliography001.xhtml#endnote_357)] remove the
    restriction of integer weights on undirected graphs. Their algorithm entails a
    preprocessing phase, followed by queries for specific source vertices. Preprocessing
    takes *O*(*MST*(*V*, *E*) + min {*V* lg *V*, *V* lg lg r}) time, where *MST*(*V*,
    *E*) is the time to compute a minimum spanning tree and *r* is the ratio of the
    maximum edge weight to the minimum edge weight. After preprocessing, each query
    takes ![art](images/Art_P675.jpg) time, where ![art](images/Art_P676.jpg) is the
    inverse of Ackermann’s function. (See the chapter notes for [Chapter 19](chapter019.xhtml)
    for a brief discussion of Ackermann’s function and its inverse.)
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 对于具有整数权重的无向图，Thorup[[435](bibliography001.xhtml#endnote_435)]提供了一种在*O*(*V* +
    *E*)时间内运行的单源最短路径算法。与前一段提到的算法不同，EXTRACT-MIN调用返回的值序列随时间不是单调递增的，因此这个算法不是Dijkstra算法的实现。Pettie和Ramachandran[[357](bibliography001.xhtml#endnote_357)]消除了对无向图上整数权重的限制。他们的算法包括一个预处理阶段，然后是对特定源顶点的查询。预处理需要*O*(*MST*(*V*,
    *E*) + min {*V* lg *V*, *V* lg lg r})时间，其中*MST*(*V*, *E*)是计算最小生成树的时间，*r*是最大边权重与最小边权重的比率。预处理后，每个查询需要![art](images/Art_P675.jpg)时间，其中![art](images/Art_P676.jpg)是Ackermann函数的倒数。
    （有关Ackermann函数及其倒数的简要讨论，请参阅[第19章](chapter019.xhtml)的章节注释。）
- en: 'For graphs with negative edge weights, an algorithm due to Gabow and Tarjan
    [[167](bibliography001.xhtml#endnote_167)] runs in ![art](images/Art_P677.jpg)
    time, and one by Goldberg [[186](bibliography001.xhtml#endnote_186)] runs in ![art](images/Art_P678.jpg)
    time, where *W* = max {|*w*(*u*, *v*)| : (*u*, *v*) ∈ *E*}. There has also been
    some progress based on methods that use continuous optimization and electrical
    flows. Cohen et al. [[98](bibliography001.xhtml#endnote_98)] give such an algorithm,
    which is randomized and runs in *Õ*(*E*^(10/7) lg *W*) expected time (see Problem
    3-6 on page 73 for the defintion of *Õ*-notation). There is also a pseudopolyomial-time
    algorithm based on fast matrix multiplication. Sankowski [[394](bibliography001.xhtml#endnote_394)]
    and Yuster and Zwick [[465](bibliography001.xhtml#endnote_465)] designed an algorithm
    for shortest paths that runs in *Õ*(*W V*^ω) time, where two *n* × *n* matrices
    can be multiplied in *O*(*n*^ω) time, giving a faster algorithm than the previously
    mentioned algorithms for small values of *W* on dense graphs.'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '对于具有负边权重的图，由Gabow和Tarjan提出的算法[[167](bibliography001.xhtml#endnote_167)]在![art](images/Art_P677.jpg)时间内运行，Goldberg提出的算法[[186](bibliography001.xhtml#endnote_186)]在![art](images/Art_P678.jpg)时间内运行，其中*W*
    = max {|*w*(*u*, *v*)| : (*u*, *v*) ∈ *E*}。也有一些基于连续优化和电流的方法取得了一些进展。Cohen等人[[98](bibliography001.xhtml#endnote_98)]提供了这样一种随机算法，其预期运行时间为*Õ*(*E*^(10/7)
    lg *W*)（有关*Õ*符号的定义，请参见第73页的问题3-6）。还有一种基于快速矩阵乘法的伪多项式时间算法。Sankowski[[394](bibliography001.xhtml#endnote_394)]和Yuster以及Zwick[[465](bibliography001.xhtml#endnote_465)]设计了一种最短路径算法，其运行时间为*Õ*(*W
    V*^ω)，其中两个*n*×*n*矩阵可以在*O*(*n*^ω)时间内相乘，对于稠密图上小值的*W*，这比先前提到的算法更快。'
- en: Cherkassky, Goldberg, and Radzik [[89](bibliography001.xhtml#endnote_89)] conducted
    extensive experiments comparing various shortest-path algorithms. Shortest-path
    algorithms are widely used in real-time navigation and route-planning applications.
    Typically based on Dijkstra’s algorithm, these algorithms use many clever ideas
    to be able to compute shortest paths on networks with many millions of vertices
    and edges in fractions of a second. Bast et al. [[36](bibliography001.xhtml#endnote_36)]
    survey many of these developments.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: Cherkassky，Goldberg和Radzik[[89](bibliography001.xhtml#endnote_89)]进行了大量实验，比较了各种最短路径算法。最短路径算法广泛应用于实时导航和路径规划应用程序。这些算法通常基于Dijkstra算法，利用许多巧妙的想法，能够在几秒钟内计算出具有数百万个顶点和边的网络的最短路径。Bast等人[[36](bibliography001.xhtml#endnote_36)]对这些发展进行了调查。
- en: '[¹](#footnote_ref_1) It may seem strange that the term “relaxation” is used
    for an operation that tightens an upper bound. The use of the term is historical.
    The outcome of a relaxation step can be viewed as a relaxation of the constraint
    *v.d* ≤ *u.d* + *w*(*u*, *v*), which, by the triangle inequality (Lemma 22.10
    on page 633), must be satisfied if *u.d* = δ(*s*, *u*) and *v.d* = δ(*s*, *v*).
    That is, if *v.d* ≤ *u.d* + *w*(*u*, *v*), there is no “pressure” to satisfy this
    constraint, so the constraint is “relaxed.”'
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: '[¹](#footnote_ref_1) 也许奇怪的是，“松弛”这个术语用于指紧束上限的操作。这个术语的使用是历史性的。松弛步骤的结果可以被视为对约束*v.d*
    ≤ *u.d* + *w*(*u*, *v*)的松弛，根据三角不等式（第633页的引理22.10），如果*u.d* = δ(*s*, *u*)和*v.d*
    = δ(*s*, *v*)必须满足。也就是说，如果*v.d* ≤ *u.d* + *w*(*u*, *v*)，那么没有“压力”来满足这个约束，所以约束被“松弛”了。'
- en: '[²](#footnote_ref_2) “PERT” is an acronym for “program evaluation and review
    technique.”'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '[²](#footnote_ref_2) “PERT”是“程序评估和审查技术”的缩写。'
