- en: '[**25        Matchings in Bipartite Graphs**](toc.xhtml#chap-25)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[**25        二部图中的匹配**](toc.xhtml#chap-25)'
- en: Many real-world problems can be modeled as finding matchings in an undirected
    graph. For an undirected graph *G* = (*V*, *E*), a ***matching*** is a subset
    of edges *M* ⊆ *E* such that every vertex in *V* has at most one incident edge
    in *M*.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多现实世界问题可以建模为在无向图中找到匹配。对于无向图*G* = (*V*, *E*)，***匹配***是边的子集*M* ⊆ *E*，使得*V*中的每个顶点最多有一条*M*中的关联边。
- en: 'For example, consider the following scenario. You have one or more positions
    to fill and several candidates to interview. According to your schedule, you are
    able to interview candidates at certain time slots. You ask the candidates to
    indicate the subsets of time slots at which they are available. How can you schedule
    the interviews so that each time slot has at most one candidate scheduled, while
    maximizing the number of candidates that you can interview? You can model this
    scenario as a matching problem on a bipartite graph in which each vertex represents
    either a candidate or a time slot, with an edge between a candidate and a time
    slot if the candidate is available then. If an edge is included in the matching,
    that means you are scheduling a particular candidate for a particular time slot.
    Your goal is to find a ***maximum matching***: a matching of maximum cardinality.
    One of the authors of this book was faced with exactly this situation when hiring
    teaching assistants for a large class. He used the Hopcroft-Karp algorithm in
    [Section 25.1](chapter025.xhtml#Sec_25.1) to schedule the interviews.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下情景。你有一个或多个职位需要填补，以及几个候选人需要面试。根据你的时间表，你可以在特定时间段面试候选人。你要求候选人指出他们可以面试的时间段子集。你如何安排面试，以便每个时间段最多安排一个候选人，同时最大化你可以面试的候选人数量？你可以将这种情况建模为一个二部图上的匹配问题，其中每个顶点代表候选人或时间段，如果候选人可用，则候选人和时间段之间有一条边。如果匹配中包含一条边，那意味着你正在为特定时间段安排特定候选人的面试。你的目标是找到***最大匹配***：最大基数的匹配。本书的一位作者在为一门大课程招聘助教时正好面临这种情况。他使用了[第25.1节](chapter025.xhtml#Sec_25.1)中的Hopcroft-Karp算法来安排面试。
- en: Another application of matching is the U.S. National Resident Matching Program,
    in which medical students are matched to hospitals where they will be stationed
    as medical residents. Each student ranks the hospitals by preference, and each
    hospital ranks the students. The goal is to assign students to hospitals so that
    there is never a student and a hospital that both have regrets because the student
    was not assigned to the hospital, yet each ranked the other higher than who or
    where they were assigned. This scenario is perhaps the best-known real-world example
    of the “stable-marriage problem,” which [Section 25.2](chapter025.xhtml#Sec_25.2)
    examines.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个匹配的应用是美国国家住院医师匹配计划，医学生将被分配到医院作为住院医师。每个学生按偏好对医院进行排名，每个医院对学生进行排名。目标是将学生分配到医院，以便永远不会有学生和医院都感到遗憾，因为学生没有被分配到医院，但每个人都将对方排名更高。这种情况可能是“稳定婚姻问题”的最著名的现实世界例子，[第25.2节](chapter025.xhtml#Sec_25.2)进行了探讨。
- en: Yet another instance where matching comes into play occurs when workers must
    be assigned to tasks in order to maximize the overall effectiveness of the assignment.
    For each worker and each task, the worker has some quantified effectiveness for
    that task. Assuming that there are equal numbers of workers and tasks, the goal
    is to find a matching with the maximum total effectiveness. Such a situation is
    an example of an assignment problem, which [Section 25.3](chapter025.xhtml#Sec_25.3)
    shows how to solve.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当工人必须被分配到任务以最大化任务的整体效果时，匹配也会发挥作用。对于每个工人和每个任务，工人对该任务有一定的量化效果。假设工人和任务的数量相等，目标是找到总效果最大的匹配。这种情况是一个分配问题的例子，[第25.3节](chapter025.xhtml#Sec_25.3)展示了如何解决。
- en: The algorithms in this chapter find matchings in ***bipartite*** graphs. As
    in [Section 24.3](chapter024.xhtml#Sec_24.3), the input is an undirected graph
    *G* = (*V*, *E*), where *V* = *L* ∪ *R*, the vertex sets *L* and *R* are disjoint,
    and every edge in *E* is incident on one vertex in *L* and one vertex in *R*.
    A matching, therefore, matches vertices in *L* with vertices in *R*. In some applications,
    the sets *L* and *R* have equal cardinality, and in other applications they need
    not be the same size.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的算法在***二部图***中找到匹配。与[第24.3节](chapter024.xhtml#Sec_24.3)一样，输入是一个无向图*G* = (*V*,
    *E*)，其中*V* = *L* ∪ *R*，顶点集*L*和*R*是不相交的，并且*E*中的每条边都与*L*中的一个顶点和*R*中的一个顶点相邻。因此，匹配将*L*中的顶点与*R*中的顶点匹配。在一些应用中，集合*L*和*R*具有相等的基数，而在其他应用中，它们的大小可能不相同。
- en: An undirected graph need not be bipartite for the concept of matching to apply.
    Matching in general undirected graphs has applications in areas such as scheduling
    and computational chemistry. It models problems in which you want to pair up entities,
    represented by vertices. Two vertices are adjacent if they represent compatible
    entities, and you need to find a large set of compatible pairs. Maximum-matching
    and maximum-weight matching problems on general graphs can be solved by polynomial-time
    algorithms whose running times are similar to those for bipartite matching, but
    the algorithms are significantly more complicated. Exercise 25.2-5 discusses the
    general version of the stable-marriage problem, known as the “stable-roommates
    problem.” Although matching applies to general undirected graphs, this chapter
    deals only with bipartite graphs.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 无向图不一定要是二部图才能应用匹配的概念。一般无向图中的匹配在调度和计算化学等领域有应用。它模拟了想要将由顶点表示的实体配对的问题。如果两个顶点表示兼容实体，则它们是相邻的，您需要找到一组大的兼容对。在一般图上的最大匹配和最大权匹配问题可以通过多项式时间算法解决，其运行时间与二部图匹配的运行时间类似，但算法要复杂得多。练习25.2-5讨论了稳定婚姻问题的一般版本，称为“稳定室友问题”。尽管匹配适用于一般无向图，但本章仅涉及二部图。
- en: '[**25.1    Maximum bipartite matching (revisited)**](toc.xhtml#Rh1-146)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[**25.1    最大二分匹配（再探）**](toc.xhtml#Rh1-146)'
- en: '[Section 24.3](chapter024.xhtml#Sec_24.3) demonstrated one way to find a maximum
    matching in a bipartite graph, by finding a maximum flow. This section provides
    a more efficient method, the Hopcroft-Karp algorithm, which runs in ![art](images/Art_P790.jpg)
    time. [Figure 25.1(a)](chapter025.xhtml#Fig_25-1) shows a matching in an undirected
    bipartite graph. A vertex that has an incident edge in matching *M* is ***matched***
    under *M*, and otherwise, it is ***unmatched***. A ***maximal matching*** is a
    matching *M* to which no other edges can be added, that is, for every edge *e*
    ∈ *E* − *M*, the edge set *M* ∪ {*e*} fails to be a matching. A maximum matching
    is always maximal, but the reverse does not always hold.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '[24.3节](chapter024.xhtml#Sec_24.3)展示了在二分图中找到最大匹配的一种方法，即通过找到最大流。本节提供了一种更高效的方法，霍普克罗夫特-卡普算法，其运行时间为![art](images/Art_P790.jpg)。[图
    25.1(a)]展示了一个无向二分图中的匹配。一个在匹配*M*下有关联边的顶点被称为***匹配的***，否则被称为***未匹配的***。一个***极大匹配***是一个不能再添加其他边的匹配*M*，也就是说，对于每条边*e*
    ∈ *E* − *M*，边集*M* ∪ {*e*}都不构成一个匹配。一个最大匹配总是极大的，但反之则不一定成立。'
- en: 'Many algorithms to find maximum matchings, the Hopcroft-Karp algorithm included,
    work by incrementally increasing the size of a matching. Given a matching *M*
    in an undirected graph *G* = (*V*, *E*), an ***M-alternating path*** is a simple
    path whose edges alternate between being in *M* and being in *E* − *M*. [Figure
    25.1(b)](chapter025.xhtml#Fig_25-1) depicts an ***M-augmenting path*** (sometimes
    called an augmenting path with respect to *M*): an *M*-alternating path whose
    first and last edges belong to *E* − *M*. Since an *M*-augmenting path contains
    one more edge in *E* − *M* than in *M*, it must consist of an odd number of edges.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 许多用于寻找最大匹配的算法，包括霍普克罗夫特-卡普算法在内，都是通过逐步增加匹配的大小来工作的。给定无向图*G* = (*V*, *E*)中的一个匹配*M*，一个***M-交替路径***是一条简单路径，其边交替在*M*和*E*
    − *M*之间。[图 25.1(b)]展示了一个***M-增广路径***（有时称为相对于*M*的增广路径）：一个*M*-交替路径，其第一条和最后一条边属于*E*
    − *M*。由于*M*-增广路径在*E* − *M*中包含一条比*M*多的边，所以它必须由奇数条边组成。
- en: '![art](images/Art_P791.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P791.jpg)'
- en: '**Figure 25.1** A bipartite graph, where *V* = *L* ∪ *R*, *L* = {*l*[1], *l*[2],
    … , *l*[7]}, and *R* = {*r*[1], *r*[2], … , *r*[8]}. **(a)** A matching *M* with
    cardinality 4, highlighted in blue. Matched vertices are blue, and unmatched vertices
    are tan. **(b)** The five edges highlighted in orange form an *M*-augmenting path
    *P* going between vertices *l*[6] and *r*[8]. **(c)** The set of edges *M*′ =
    *M* ⊕ *P* highlighted in blue is a matching containing one more edge than *M*
    and adding *l*[6] and *r*[8] to the matched vertices. This matching is not a maximum
    matching (see Exercise 25.1-1).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 25.1** 一个二分图，其中*V* = *L* ∪ *R*，*L* = {*l*[1], *l*[2], … , *l*[7]}，*R* =
    {*r*[1], *r*[2], … , *r*[8]}。**(a)** 一个基数为4的匹配*M*，用蓝色标出。匹配的顶点为蓝色，未匹配的顶点为棕色。**(b)**
    五条橙色标出的边形成一个*M*-增广路径*P*，连接顶点*l*[6]和*r*[8]。**(c)** 边集*M*′ = *M* ⊕ *P*用蓝色标出，是一个比*M*多一条边的匹配，并将*l*[6]和*r*[8]添加到匹配的顶点中。这个匹配不是最大匹配（见练习
    25.1-1）。'
- en: '[Figure 25.1(c)](chapter025.xhtml#Fig_25-1) demonstrates the following lemma,
    which shows that by removing from matching *M* the edges in an *M*-augmenting
    path that belong to *M* and adding to *M* the edges in the *M*-augmenting path
    that are not in *M*, the result is a new matching with one more edge than *M*.
    Since a matching is a set of edges, the lemma relies on the notion of the ***symmetric
    difference*** of two sets: *X* ⊕ *Y* = (*X* − *Y*) ∪ (*Y* − *X*), that is, the
    elements that belong to *X* or *Y*, but not both. Alternatively, you can think
    of *X* ⊕ *Y* as (*X* ∪ *Y*)−(*X* ∩ *Y*). The operator ⊕ is commutative and associative.
    Furthermore, *X* ⊕ *X* = Ø and *X* ⊕ Ø = Ø ⊕ *X* = *X* for any set *X*, so that
    the empty set is the identity for ⊕.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 25.1(c)](chapter025.xhtml#Fig_25-1)展示了以下引理，它表明通过从匹配*M*中移除属于*M*的*M*-增广路径中的边，并将不属于*M*的*M*-增广路径中的边添加到*M*中，结果是一个比*M*多一条边的新匹配。由于匹配是一组边的集合，该引理依赖于两个集合的***对称差***的概念：*X*
    ⊕ *Y* = (*X* − *Y*) ∪ (*Y* − *X*)，即属于*X*或*Y*但不同时属于*X*和*Y*的元素。或者，你可以将*X* ⊕ *Y*看作(*X*
    ∪ *Y*)−(*X* ∩ *Y*)。运算符⊕是可交换和可结合的。此外，*X* ⊕ *X* = Ø，*X* ⊕ Ø = Ø ⊕ *X* = *X*对��任何集合*X*都成立，因此空集是⊕的单位元。'
- en: '***Lemma 25.1***'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 25.1***'
- en: Let *M* be a matching in any undirected graph *G* = (*V*, *E*), and let *P*
    be an *M*-augmenting path. Then the set of edges *M*′ = *M* ⊕ *P* is also a matching
    in *G* with |*M*′| = |*M*| + 1.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 设*M*是任意无向图*G* = (*V*, *E*)中的一个匹配，*P*是一个*M*-增广路径。那么边集*M*′ = *M* ⊕ *P*也是*G*中的一个匹配，且|*M*′|
    = |*M*| + 1。
- en: '***Proof***   Let *P* contain *q* edges, so that ⌈q/2⌉ edges belong to *E*
    − *M* and ⌊q/2⌋ edges belong to *M*, and let these *q* edges be (*v*[1], *v*[2]),
    (*v*[2], *v*[3]), … , (*v*[*q*], *v*[*q*+1]). Because *P* is an *M*-augmenting
    path, vertices *v*[1] and *v*[*q*+1] are unmatched under *M* and all other vertices
    in *P* are matched. Edges (*v*[1], *v*[2]), (*v*[3], *v*[4]), … , (*v*[*q*], *v*[*q*+1])
    belong to *E* − *M*, and edges (*v*[2], *v*[3]), (*v*[4], *v*[5]), … , (*v*[*q*−1],
    *v*[*q*]) belong to *M*. The symmetric difference *M*′ = *M* ⊕ *P* reverses these
    roles, so that edges (*v*[1], *v*[2]), (*v*[3], *v*[4]), … , (*v*[*q*], *v*[*q*+1])
    belong to *M*′ and (*v*[2], *v*[3]), (*v*[4], *v*[5]), … , (*v*[*q*−1], *v*[*q*])
    belong to *E* − *M*′. Each vertex *v*[1], *v*[2], … , *v*[*q*], *v*[*q*+1] is
    matched under *M*′, which gains one additional edge relative to *M*, and no other
    vertices or edges in *G* are affected by the change from *M* to *M*′. Hence, *M*′
    is a matching in *G*, and |*M*′| = |*M*| + 1.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   假设 *P* 包含 *q* 条边，使得 ⌈q/2⌉ 条边属于 *E* − *M*，⌊q/2⌋ 条边属于 *M*，并且让这些 *q*
    条边为 (*v*[1], *v*[2])，(*v*[2], *v*[3])，…，(*v*[*q*], *v*[*q*+1])。因为 *P* 是一个 *M*-增广路径，顶点
    *v*[1] 和 *v*[*q*+1] 在 *M* 下没有匹配，而 *P* 中的其他顶点都有匹配。边 (*v*[1], *v*[2])，(*v*[3], *v*[4])，…，(*v*[*q*],
    *v*[*q*+1]) 属于 *E* − *M*，边 (*v*[2], *v*[3])，(*v*[4], *v*[5])，…，(*v*[*q*−1], *v*[*q*])
    属于 *M*。对称差 *M*′ = *M* ⊕ *P* 颠倒了这些角色，使得边 (*v*[1], *v*[2])，(*v*[3], *v*[4])，…，(*v*[*q*],
    *v*[*q*+1]) 属于 *M*′，而 (*v*[2], *v*[3])，(*v*[4], *v*[5])，…，(*v*[*q*−1], *v*[*q*])
    属于 *E* − *M*′。每个顶点 *v*[1]，*v*[2]，…，*v*[*q*]，*v*[*q*+1] 在 *M*′ 下都有匹配，相对于 *M* 多了一条边，而
    *G* 中的其他顶点或边并不受从 *M* 到 *M*′ 的变化影响。因此，*M*′ 是 *G* 中的一个匹配，且 |*M*′| = |*M*| + 1。'
- en: ▪
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Since taking the symmetric difference of a matching *M* with an *M*-augmenting
    path increases the size of the matching by 1, the following corollary shows that
    taking the symmetric difference of *M* with *k* vertex-disjoint *M*-augmenting
    paths increases the size of the matching by *k*.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于将匹配 *M* 与一个 *M*-增广路径的对称差会使匹配的大小增加 1，下面的推论表明将 *M* 与 *k* 个顶点不相交的 *M*-增广路径的对称差会使匹配的大小增加
    *k*。
- en: '***Corollary 25.2***'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论 25.2***'
- en: Let *M* be a matching in any undirected graph *G* = (*V*, *E*) and *P*[1], *P*[2],
    … , *P*[*k*] be vertex-disjoint *M*-augmenting paths. Then the set of edges *M*′
    = *M* ⊕ (*P*[1] ∪ *P*[2] ∪ … ∪ *P*[*k*]) is a matching in *G* with |*M*′| = |*M*|
    + *k*.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *M* 是任意无向图 *G* = (*V*, *E*) 中的一个匹配，*P*[1]、*P*[2]、…、*P*[*k*] 是顶点不相交的 *M*-增广路径。那么边集
    *M*′ = *M* ⊕ (*P*[1] ∪ *P*[2] ∪ … ∪ *P*[*k*]) 是图 *G* 中的一个匹配，且 |*M*′| = |*M*| +
    *k*。
- en: '***Proof***   Since the *M*-augmenting paths *P*[1], *P*[2], … , *P*[*k*] are
    vertex-disjoint, we have that *P*[1] ∪ *P*[2] ∪⋯∪ *P*[*k*] = *P*[1]⊕ *P*[2] ⊕⋯⊕
    *P*[*k*]. Because the operator ⊕ is associative, we have'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   由于 *M*-增广路径 *P*[1]、*P*[2]、…、*P*[*k*] 是顶点不相交的，我们有 *P*[1] ∪ *P*[2]
    ∪⋯∪ *P*[*k*] = *P*[1]⊕ *P*[2] ⊕⋯⊕ *P*[*k*]。由于运算符 ⊕ 是结合的，我们有'
- en: '| *M* ⊕ (*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*k*]) | = | *M* ⊕ (*P*[1] ⊕ *P*[2] ⊕ ⋯ ⊕
    *P*[*k*]) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| *M* ⊕ (*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*k*]) | = | *M* ⊕ (*P*[1] ⊕ *P*[2] ⊕ ⋯ ⊕
    *P*[*k*]) |'
- en: '|  | = | (⋯ ((*M* ⊕ *P*[1]) ⊕ *P*[2]) ⊕ ⋯ ⊕ *P*[*k*−1]) ⊕ *P*[*k*]. |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '|  | = | (⋯ ((*M* ⊕ *P*[1]) ⊕ *P*[2]) ⊕ ⋯ ∪ *P*[*k*−1]) ⊕ *P*[*k*]. |'
- en: A simple induction on *i* using Lemma 25.1 shows that *M* ⊕ (*P*[1] ∪ *P*[2]
    ∪ ⋯ ∪ *P*[*i*−1]) is a matching in *G* containing |*M*| + *i* − 1 edges and that
    path *P*[*i*] is an augmenting path with respect to *M* ⊕ (*P*[1] ∪ *P*[2] ∪ ⋯
    ∪ *P*[*i*−1]). Each of these augmenting paths increases the size of the matching
    by 1, and so |*M*′| = |*M*| + *k*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 利用引理 25.1 进行简单归纳可知，*M* ⊕ (*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*i*−1]) 是图 *G* 中的一个匹配，包含
    |*M*| + *i* − 1 条边，并且路径 *P*[*i*] 相对于 *M* ⊕ (*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*i*−1])
    是一个增广路径。这些增广路径中的每一个都使匹配的大小增加 1，因此 |*M*′| = |*M*| + *k*。
- en: ▪
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: As the Hopcroft-Karp algorithm goes from matching to matching, it will be useful
    to consider the symmetric difference between two matchings.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当霍普克罗夫特-卡普算法从一个匹配到另一个匹配时，考虑两个匹配之间的对称差是很有用的。
- en: '***Lemma 25.3***'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 25.3***'
- en: Let *M* and *M** be matchings in graph *G* = (*V*, *E*), and consider the graph
    *G*′ = (*V*, *E*′), where *E*′ = *M* ⊕ *M**. Then, *G*′ is a disjoint union of
    simple paths, simple cycles, and/or isolated vertices. The edges in each such
    simple path or simple cycle alternate between *M* and *M**. If |*M**| > |*M*|,
    then *G*′ contains at least |*M**|−|*M*| vertex-disjoint *M*-augmenting paths.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *M* 和 *M*′ 是图 *G* = (*V*, *E*) 中的匹配，并考虑图 *G*′ = (*V*, *E*′)，其中 *E*′ = *M*
    ⊕ *M*′。那么，*G*′ 是简单路径、简单环和/或孤立顶点的不相交并集。每个简单路径或简单环中的边在 *M* 和 *M*′ 之间交替。如果 |*M*′|
    > |*M*|，那么 *G*′ 包含至少 |*M*′|−|*M*| 个顶点不相交的 *M*-增广路径。
- en: '***Proof***   Each vertex in *G*′ has degree 0, 1, or 2, since at most two
    edges of *E*′ can be incident on a vertex: at most one edge from *M* and at most
    one edge from *M**. Therefore, each connected component of *G*′ is either a singleton
    vertex, an even-length simple cycle with edges alternately in *M* and *M**, or
    a simple path with edges alternately in *M* and *M**. Since'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   *G*′ 中的每个顶点的度数为 0、1 或 2，因为 *E*′ 中最多可以有两条边与一个顶点关联：最多一条来自 *M*，最多一条来自
    *M**。因此，*G*′ 的每个连通分量要么是一个单独的顶点，要么是边交替在 *M* 和 *M** 中的偶数长度简单环，要么是边交替在 *M* 和 *M**
    中的简单路径。由于'
- en: '| *E*′ | = | *M* ⊕ *M** |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| *E*′ | = | *M* ⊕ *M** |'
- en: '|  | = | (*M* ∪ *M**) − (*M* ∩ *M**) |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '|  | = | (*M* ∪ *M**) − (*M* ∩ *M**) |'
- en: and |*M**| > |*M*|, the edge set *E*′ must contain |*M**| − |*M*| more edges
    from *M** than from *M*. Because each cycle in *G*′ has an even number of edges
    drawn alternately from *M* and *M**, each cycle has an equal number of edges from
    *M* and *M**. Therefore, the simple paths in *G*′ account for there being |*M**|
    − |*M*| more edges from *M** than *M*. Each path containing a different number
    of edges from *M* and *M** either starts and ends with edges from *M*, containing
    one more edge from *M* than from *M**, or starts and ends with edges from *M**,
    containing one more edge from *M** than from *M*. Because *E*′ contains |*M**|
    − |*M*| more edges from *M** than from *M*, there are at least |*M**| − |*M*|
    paths of the latter type, and each one is an *M*-augmenting path. Because each
    vertex has at most two incident edges from *E*′, these paths must be vertex-disjoint.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 且 |*M**| > |*M*|，边集 *E*′ 必须包含比 *M* 多 |*M**| − |*M*| 条边。因为 *G*′ 中的每个循环都有偶数条边，交替地来自
    *M* 和 *M**，每个循环中来自 *M* 和 *M** 的边数相等。因此，*G*′ 中的简单路径说明了 *M** 比 *M* 多 |*M**| − |*M*|
    条边。每条路径包含不同数量的来自 *M* 和 *M** 的边，要么以来自 *M* 的边开始和结束，比来自 *M** 的边多一条，要么以来自 *M** 的边开始和结束，比来自
    *M* 的边多一条。因为 *E*′ 包含比 *M* 多 |*M**| − |*M*| 条边，至少有 |*M**| − |*M*| 条属于后一种类型的路径，每一条都是
    *M*-增广路径。因为每个顶点最多有两条来自 *E*′ 的关联边，这些路径必须是顶点不相交的。
- en: ▪
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: 'If an algorithm finds a maximum matching by incrementally increasing the size
    of the matching, how does it determine when to stop? The following corollary gives
    the answer: when there are no augmenting paths.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个算法通过逐步增加匹配的大小找到最大匹配，那么它如何确定何时停止？以下推论给出了答案：当没有增广路径时。
- en: '***Corollary 25.4***'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论 25.4***'
- en: Matching *M* in graph *G* = (*V*, *E*) is a maximum matching if and only if
    *G* contains no *M*-augmenting path.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 *G* = (*V*, *E*) 中的匹配 *M* 是最大匹配当且仅当 *G* 不包含 *M*-增广路径。
- en: '***Proof***   We prove the contrapositive of both directions of the lemma statement.
    The contrapositive of the forward direction is straightforward. If there is an
    *M*-augmenting path *P* in *G*, then by Lemma 25.1, the matching *M* ⊕ *P* contains
    one more edge than *M*, meaning that *M* could not be a maximum matching.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   我们证明引理陈述的两个方向的逆否命题。正向方向的逆否命题很明显。如果 *G* 中存在 *M*-增广路径 *P*，那么根据引理 25.1，匹配
    *M* ⊕ *P* 比 *M* 多一条边，意味着 *M* 不能是最大匹配。'
- en: To show the contrapositive of the backward direction—if *M* is not a maximum
    matching, then *G* contains an *M*-augmenting path—let *M** be a maximum matching
    in Lemma 25.3, so that |*M**| > |*M*|. Then *G* contains at least |*M**| − |*M*|
    > 0 vertex-disjoint *M*-augmenting paths.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要证明反向方向的逆否命题——如果 *M* 不是最大匹配，那么 *G* 包含一个 *M*-增广路径——让 *M** 是引理 25.3 中的最大匹配，使得
    |*M**| > |*M*|。那么 *G* 至少包含 |*M**| − |*M*| > 0 条顶点不相交的 *M*-增广路径。
- en: ▪
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: We already have learned enough to create a maximum-matching algorithm that runs
    in *O*(*VE*) time. Start with the matching *M* empty. Then repeatedly run a variant
    of either breadth-first search or depth-first search from an unmatched vertex
    that takes alternating paths until you find another unmatched vertex. Use the
    resulting *M*-augmenting path to increase the size of *M* by 1.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学到足够的知识来创建一个运行时间为 *O*(*VE*) 的最大匹配算法。从匹配 *M* 为空开始。然后从一个未匹配的顶点开始反复运行广度优先搜索或深度优先搜索的变体，直到找到另一个未匹配的顶点。利用得到的
    *M*-增广路径将 *M* 的大小增加 1。
- en: '**The Hopcroft-Karp algorithm**'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '**霍普克罗夫特-卡普算法**'
- en: The Hopcroft-Karp algorithm improves the running time to ![art](images/Art_P792.jpg).
    The procedure HOPCROFT-KARP is given an undirected bipartite graph, and it uses
    Corollary 25.2 to repeatedly increase the size of the matching *M* it finds. Corollary
    25.4 proves that the algorithm is correct, since it terminates once there are
    no *M*-augmenting paths. It remains to show that the algorithm does run in ![art](images/Art_P793.jpg)
    time. We’ll see that the **repeat** loop of lines 2–5 iterates ![art](images/Art_P794.jpg)
    times and how to implement line 3 so that it runs in *O*(*E*) time in each iteration.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 霍普克罗夫特-卡普算法将运行时间优化到 ![art](images/Art_P792.jpg)。算法 HOPCROFT-KARP 给定一个无向二分图，并使用推论
    25.2 反复增加找到的匹配 *M* 的大小。推论 25.4 证明了算法的正确性，因为一旦没有 *M*-增广路径，算法就会终止。现在要证明算法确实在 ![art](images/Art_P793.jpg)
    时间内运行。我们将看到行 2–5 的 **重复** 循环迭代 ![art](images/Art_P794.jpg) 次，以及如何实现行 3，使其在每次迭代中以
    *O*(*E*) 时间运行。
- en: HOPCROFT-KARP (*G*)
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 霍普克罗夫特-卡普 (*G*)
- en: '| 1 | *M* = Ø |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *M* = Ø |'
- en: '| 2 | **repeat** |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **重复** |'
- en: '| 3 | let P = {*P*[1], *P*[2], … , *P*[*k*]} be a maximal set of vertex-disjoint
    shortest *M*-augmenting paths |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 令 P = {*P*[1], *P*[2], … , *P*[*k*]} 为一组最大的顶点不相交的最短 *M*-增广路径 |'
- en: '| 4 | *M* = *M* ⊕ (*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*k*]) |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *M* = *M* ⊕ (*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*k*]) |'
- en: '| 5 | **until** P == Ø |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **直到** P == Ø |'
- en: '| 6 | **return** *M* |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| 6 | **返回** *M* |'
- en: Let’s first see how to find a maximal set of vertex-disjoint shortest *M*-augmenting
    paths in *O*(*E*) time. There are three phases. The first phase forms a directed
    version *G*[*M*] of the undirected bipartite graph *G*. The second phase creates
    a directed acyclic graph *H* from *G*[*M*] via a variant of breadth-first search.
    The third phase finds a maximal set of vertex-disjoint shortest *M*-augmenting
    paths by running a variant of depth-first search on the transpose *H*^T of *H*.
    (Recall that the transpose of a directed graph reverses the direction of each
    edge. Since *H* is acyclic, so is *H*^T.)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先看看如何在 *O*(*E*) 时间内找到一组最大的顶点不相交的最短 *M*-增广路径。有三个阶段。第一阶段形成无向二分图 *G* 的有向版本 *G*[*M*]。第二阶段通过广度优先搜索的变体从
    *G*[*M*] 创建一个有向无环图 *H*。第三阶段通过在 *H* 的转置 *H*^T 上运行深度优先搜索的变体，找到一组最大的顶点不相交的最短 *M*-增广路径。（回想一下，有向图的转置会颠倒每条边的方向。由于
    *H* 是无环的，所以 *H*^T 也是无环的。）
- en: 'Given a matching *M*, you can think of an *M*-augmenting path *P* as starting
    at an unmatched vertex in *L*, traversing an odd number of edges, and ending at
    an unmatched vertex in *R*. The edges in *P* traversed from *L* to *R* must belong
    to *E* − *M*, and the edges in *P* traversed from *R* to *L* must belong to *M*.
    The first phase, therefore, creates the directed graph *G*[*M*] by directing the
    edges accordingly: *G*[*M*] = (*V*, *E*[*M*]), where'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 给定匹配*M*，你可以将*M*增广路径*P*视为从*L*中的未匹配顶点开始，穿过奇数条边，然后结束在*R*中的未匹配顶点。从*L*到*R*穿过的*P*中的边必须属于*E*
    − *M*，而从*R*到*L*穿过的*P*中的边必须属于*M*。因此，第一阶段通过相应地指向边来创建有向图*G*[*M*]：*G*[*M*] = (*V*,
    *E*[*M*])，其中
- en: '![art](images/Art_P795.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P795.jpg)'
- en: '**Figure 25.2 (a)** The directed graph *G*[*M*] created in the first phase
    for the undirected bipartite graph *G* and matching *M* in [Figure 25.1(a)](chapter025.xhtml#Fig_25-1).
    Breadth-first distances from any unmatched vertex in *L* appear next to each vertex.
    **(b)** The dag *H* created from *G*[*M*] in the second phase. Because the smallest
    distance to an unmatched vertex in *R* is 3, vertices *l*[7] and *r*[8], with
    distances greater than 3, are not in *H*.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**图25.2 (a)** 第一阶段为无向二分图*G*和匹配*M*创建的有向图*G*[*M*]。从任何未匹配顶点在*L*中的广度优先距离出现在每个顶点旁边。**(b)**
    第二阶段从*G*[*M*]创建的有向无环图*H*。因为到未匹配顶点在*R*中的最小距离为3，距离大于3的顶点*l*[7]和*r*[8]不在*H*中。'
- en: '| *E*[*M*] | = | {(*l*, *r*) : *l* ∈ *L*, *r* ∈ *R*, and (*l*, *r*) ∈ *E* −
    *M* } | (edges from *L* to *R*) |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| *E*[*M*] | = | {(*l*, *r*) : *l* ∈ *L*, *r* ∈ *R*, and (*l*, *r*) ∈ *E* −
    *M* } | (从*L*到*R*的边) |'
- en: '|  |  | ∪ {(*r*, *l*) : *r* ∈ *R*, *l* ∈ *L*, and (*l*, *r*) ∈ *M* } | (edges
    from *R* to *L*). |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '|  |  | ∪ {(*r*, *l*) : *r* ∈ *R*, *l* ∈ *L*, and (*l*, *r*) ∈ *M* } | (从*R*到*L*的边)。'
- en: '[Figure 25.2(a)](chapter025.xhtml#Fig_25-2) shows the graph *G*[*M*] for the
    graph *G* and matching *M* in [Figure 25.1(a)](chapter025.xhtml#Fig_25-1).'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '[图25.2(a)](chapter025.xhtml#Fig_25-2)展示了图*G*[*M*]，对应于[图25.1(a)](chapter025.xhtml#Fig_25-1)中的图*G*和匹配*M*。'
- en: 'The dag *H* = (*V*[*H*], *E*[*H*]) created by the second phase has layers of
    vertices. [Figure 25.2(b)](chapter025.xhtml#Fig_25-2) shows the dag *H* corresponding
    to the directed graph *G*[*M*] in part (a) of the figure. Each layer contains
    only vertices from *L* or only vertices from *R*, alternating from layer to layer.
    The layer that a vertex resides in is given by that vertex’s minimum breadth-first
    distance in *G*[*M*] from any unmatched vertex in *L*. Vertices in *L* appear
    in even-numbered layers, and vertices in *R* appear in odd-numbered layers. Let
    *q* denote the smallest distance in *G*[*M*] of any unmatched vertex in *R*. Then,
    the last layer in *H* contains the vertices in *R* with distance *q*. Vertices
    whose distance exceeds *q* do not appear in *V*[*H*]. (The graph *H* in [Figure
    25.2(b)](chapter025.xhtml#Fig_25-2) omits vertices *l*[7] and *r*[8] because their
    distances from any unmatched vertex in *L* exceed *q* = 3.) The edges in *E*[*H*]
    form a subset of *E*[*M*]:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第二阶段创建的有向无环图*H* = (*V*[*H*], *E*[*H*])具有顶点层。[图25.2(b)](chapter025.xhtml#Fig_25-2)展示了与图中部分(a)中的有向图*G*[*M*]对应的有向无环图*H*。每一层只包含来自*L*或来自*R*的顶点，从一层到另一层交替。顶点所在的层由该顶点在*G*[*M*]中距离任何未匹配顶点在*L*的最小广度优先距离确定。*L*中的顶点出现在偶数层，*R*中的顶点出现在奇数层。让*q*表示*R*中任何未匹配顶点在*G*[*M*]中的最小距离。因此，*H*中的最后一层包含距离*q*的*R*中的顶点。距离超过*q*的顶点不出现在*V*[*H*]中。([图25.2(b)](chapter025.xhtml#Fig_25-2)中的图*H*省略了顶点*l*[7]和*r*[8]，因为它们距离任何未匹配顶点在*L*的距离超过*q*
    = 3。) *E*[*H*]中的边形成*E*[*M*]的子集：
- en: '*E*[*H*] = {(*l*, *r*) ∈ *E*[*M*] : *r*.*d* ≤ *q* and *r*.*d* = *l*.*d* + 1}
    ∪ {(*r*, *l*) ∈ *E*[*M*] : *l*.*d* ≤ *q*},'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '*E*[*H*] = {(*l*, *r*) ∈ *E*[*M*] : *r*.*d* ≤ *q* and *r*.*d* = *l*.*d* + 1}
    ∪ {(*r*, *l*) ∈ *E*[*M*] : *l*.*d* ≤ *q*},'
- en: where the attribute *d* of a vertex gives the vertex’s breadth-first distance
    in *G*[*M*] from any unmatched vertex in *L*. Edges that do not go between two
    consecutive layers are omitted from *E*[*H*].
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 属性*d*表示顶点在*G*[*M*]中距离任何未匹配顶点在*L*中的广度优先距离。不在两个连续层之间的边将从*E*[*H*]中省略。
- en: To determine the breadth-first distances of vertices, run breadth-first search
    on the graph *G*[*M*], but starting from all the unmatched vertices in *L*. (In
    the BFS procedure on page 556, replace the root vertex *s* by the set of unmatched
    vertices in *L*.) The predecessor attributes *π* computed by the BFS procedure
    are not needed here, since *H* is a dag and not necessarily a tree.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定顶点的广度优先距离，对*G*[*M*]运行广度优先搜索，但是从所有未匹配顶点在*L*开始。（在第556页的BFS过程中，将根顶点*s*替换为未匹配顶点在*L*的集合。）由BFS过程计算的前驱属性*π*在这里不需要，因为*H*是有向无环图，不一定是树。
- en: Every path in *H* from a vertex in layer 0 to an unmatched vertex in layer *q*
    corresponds to a shortest *M*-augmenting path in the original bipartite graph
    *G*. Just use the undirected versions of the directed edges in *H*. Moreover,
    every shortest *M*-augmenting path in *G* is present in *H*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '*H*中从层0的顶点到层*q*的未匹配顶点的每条路径对应于原始二分图*G*中的最短*M*增广路径。只需使用*H*中有向边的无向版本。此外，*G*中的每条最短*M*增广路径都存在于*H*中。'
- en: The third phase identifies a maximal set of vertex-disjoint shortest *M*-augmenting
    paths. As [Figure 25.3](chapter025.xhtml#Fig_25-3) shows, it starts by creating
    the transpose *H*^T of *H*. Then, for each unmatched vertex *r* in layer *q*,
    it performs a depth-first search starting from *r* until it either reaches a vertex
    in layer 0 or has exhausted all possible paths without reaching a vertex in layer
    0\. Instead of maintaining discovery and finish times, the depth-first search
    just needs to keep track of the predecessor attributes *π* in the depth-first
    tree of each search. Upon reaching a vertex in layer 0, tracing back along the
    predecessors identifies an *M*-augmenting path. Each vertex is searched from only
    when it is first discovered in any search. If the search from a vertex *r* in
    layer *q* cannot find a path of undiscovered vertices to an undiscovered vertex
    in layer 0, then no *M*-augmenting path including *r* goes into the maximal set.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 第三阶段确定了一组顶点不相交的最短 *M* 增广路径的最大集合。正如[图 25.3](chapter025.xhtml#Fig_25-3)所示，它首先创建
    *H* 的转置 *H*^T。然后，对于每个第 *q* 层中的未匹配顶点 *r*，它从 *r* 开始执行深度优先搜索，直到要么到达第 0 层的顶点，要么耗尽所有可能的路径而没有到达第
    0 层的顶点。深度优先搜索不需要维护发现和完成时间，只需要跟踪每次搜索的深度优先树中的前任属性 *π*。到达第 0 ���的顶点后，沿着前任回溯可以确定一个
    *M* 增广路径。每个顶点只有在任何搜索中首次发现时才进行搜索。如果从第 *q* 层中的顶点 *r* 开始的搜索无法找到一条到未发现的第 0 层顶点的路径，则不包括
    *r* 的 *M* 增广路径进入最大集合。
- en: '[Figure 25.3](chapter025.xhtml#Fig_25-3) shows the result of the third phase.
    The first depth-first search starts from vertex *r*[1]. It identifies the *M*-augmenting
    path 〈(*r*[1], *l*[3]), (*l*[3], *r*[3]), (*r*[3], *l*[1])〉, which is highlighted
    in orange, and discovers vertices *r*[1], *l*[3], *r*[3], and *l*[1]. The next
    depth-first search starts from vertex *r*[4]. This search first examines the edge
    (*r*[4], *l*[3]), but because *l*[3] was already discovered, it backtracks and
    examines edge (*r*[4], *l*[5]). From there, it continues and identifies the *M*-augmenting
    path 〈(*r*[4], *l*[5]), (*l*[5], *r*[7]), (*r*[7], *l*[6])〉, which is highlighted
    in yellow, and discovers vertices *r*[4], *l*[5], *r*[7], and *l*[6]. The depth-first
    search from vertex *r*[6] gets stuck at vertices *l*[3] and *l*[5], which have
    already been discovered, and so this search fails to find a path of undiscovered
    vertices to a vertex in layer 0\. There is no depth-first search from vertex *r*[5]
    because it is matched, and depth-first searches start from unmatched vertices.
    Therefore, the maximal set of vertex-disjoint shortest *M*-augmenting paths found
    contains just the two *M*-augmenting paths (〈*r*[1], *l*[3]), (*l*[3], *r*[3]),
    (*r*[3], *l*[1])〉 and 〈(*r*[4], *l*[5]), (*l*[5], *r*[7]), (*r*[7], *l*[6])〉.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 25.3](chapter025.xhtml#Fig_25-3) 展示了第三阶段的结果。第一次深度优先搜索从顶点 *r*[1] 开始。它识别出橙色突出显示的
    *M* 增广路径 〈(*r*[1], *l*[3]), (*l*[3], *r*[3]), (*r*[3], *l*[1])〉，并发现顶点 *r*[1],
    *l*[3], *r*[3] 和 *l*[1]。接下来的深度优先搜索从顶点 *r*[4] 开始。这次搜索首先检查边 (*r*[4], *l*[3])，但由于
    *l*[3] 已经被发现，它回溯并检查边 (*r*[4], *l*[5])。然后，它继续并识别出黄色突出显示的 *M* 增广路径 〈(*r*[4], *l*[5]),
    (*l*[5], *r*[7]), (*r*[7], *l*[6])〉，并发现顶点 *r*[4], *l*[5], *r*[7] 和 *l*[6]。从顶点
    *r*[6] 开始的深度优先搜索卡在已经被发现的顶点 *l*[3] 和 *l*[5] 上，因此这次搜索无法找到一条到达第 0 层未发现顶点的路径。从顶点 *r*[5]
    开始的深度优先搜索不存在，因为它已经匹配，深度优先搜索从未匹配的顶点开始。因此，找到的顶点不相交的最短 *M* 增广路径集合只包含两条 *M* 增广路径（〈*r*[1],
    *l*[3]), (*l*[3], *r*[3]), (*r*[3], *l*[1])〉 和 〈(*r*[4], *l*[5]), (*l*[5], *r*[7]),
    (*r*[7], *l*[6])〉。'
- en: 'You might have noticed that in this example, this maximal set of two vertex-disjoint
    shortest *M*-augmenting paths is not a maximum set. The graph contains three vertex-disjoint
    shortest *M*-augmenting paths: 〈(*r*[1], *l*[2]), (*l*[2], *r*[2]), (*r*[2], *l*[1])〉,
    〈(*r*[4], *l*[3]), (*l*[3], *r*[3]), (*r*[3], *l*[4])〉, and 〈(*r*[6], *l*[5]),
    (*l*[5], *r*[7]), (*r*[7], *l*[6])〉. No matter: the algorithm requires the set
    of vertex-disjoint shortest *M*-augmenting paths found in line 3 of HOPCROFT-KARP
    to be only maximal, not necessarily maximum.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在这个例子中，这个最大的两个顶点不相交的最短 *M* 增广路径集合并不是最大的。图中包含三个顶点不相交的最短 *M* 增广路径：〈(*r*[1],
    *l*[2]), (*l*[2], *r*[2]), (*r*[2], *l*[1])〉，〈(*r*[4], *l*[3]), (*l*[3], *r*[3]),
    (*r*[3], *l*[4])〉，和 〈(*r*[6], *l*[5]), (*l*[5], *r*[7]), (*r*[7], *l*[6])〉。不过，算法要求在
    HOPCROFT-KARP 的第 3 行中找到的顶点不相交的最短 *M* 增广路径集合只需是最大的，不一定是最大的。
- en: '![art](images/Art_P796.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P796.jpg)'
- en: '**Figure 25.3** The transpose *H*^T of the dag *H* created in the third phase.
    The first depth-first search, starting from vertex *r*[1], identifies the *M*-augmenting
    path 〈(*r*[1], *l*[3]), (*l*[3], *r*[3]), (*r*[3], *l*[1])〉 highlighted in orange,
    and it discovers vertices *r*[1], *l*[3], *r*[3], *l*[1]. The second depth-first
    search, starting from vertex *r*[4], identifies the *M*-augmenting path 〈(*r*[4],
    *l*[5]), (*l*[5], *r*[7]), (*r*[7], *l*[6])〉 highlighted in yellow, discovering
    vertices *r*[4], *l*[5], *r*[7], *l*[6].'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 25.3** 第三阶段创建的转置 *H*^T 的 *H* 的转置。第一次深度优先搜索，从顶点 *r*[1] 开始，识别出橙色突出显示的 *M*
    增广路径 〈(*r*[1], *l*[3]), (*l*[3], *r*[3]), (*r*[3], *l*[1])〉，并发现顶点 *r*[1], *l*[3],
    *r*[3], *l*[1]。第二次深度优先搜索，从顶点 *r*[4] 开始，识别出黄色突出显示的 *M* 增广路径 〈(*r*[4], *l*[5]),
    (*l*[5], *r*[7]), (*r*[7], *l*[6])〉，发现顶点 *r*[4], *l*[5], *r*[7], *l*[6]。'
- en: 'It remains to show that all three phases of line 3 take *O*(*E*) time. We assume
    that in the original bipartite graph *G*, each vertex has at least one incident
    edge so that |*V*| = *O*(*E*), which in turn implies that |*V*| + |*E*| = *O*(*E*).
    The first phase creates the directed graph *G*[*M*] by simply directing each edge
    of *G*, so that |*V*[*M*]| = |*V*| and |*E*[*M*] = |*E*|. The second phase performs
    a breadth-first search on *G*[*M*], taking *O*(*V*[*M*] + *E*[*M*]) = *O*(*E*[*M*])
    = *O*(*E*) time. In fact, it can stop once the first distance in the queue within
    the breadth-first search exceeds the shortest distance *q* to an unmatched vertex
    in *R*. The dag *H* has |*V*[*H*]| ≤ |*V*[*M*]| and |*E*[*H*]| ≤ |*E*[*M*]|, so
    that it takes *O*(*V*[*H*] + *E*[*H*]) = *O*(*E*) time to construct. Finally,
    the third phase performs depth-first searches from the unmatched vertices in layer
    *q*. Once a vertex is discovered, it is not searched from again, and so the analysis
    of depth-first search from [Section 20.3](chapter020.xhtml#Sec_20.3) applies here:
    *O*(*V*[*H*] + *E*[*H*]) = *O*(*E*). Hence, all three phases take just *O*(*E*)
    time.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 仍需证明第 3 行的所有三个阶段都需要 *O*(*E*) 的时间。我们假设在原始的二分图 *G* 中，每个顶点至少有一条关联边，因此 |*V*| = *O*(*E*)，这进而意味着
    |*V*| + |*E*| = *O*(*E*)。第一阶段通过简单地将 *G* 的每条边定向来创建有向图 *G*[*M*]，因此 |*V*[*M*]| =
    |*V*|，|*E*[*M*] = |*E*|。第二阶段在 *G*[*M*] 上执行广度优先搜索，需要 *O*(*V*[*M*] + *E*[*M*]) =
    *O*(*E*[*M*]) = *O*(*E*) 的时间。实际上，一旦队列中的第一个距离超过到未匹配顶点 *R* 的最短距离 *q*，它就可以停止。有向无环图
    *H* 有 |*V*[*H*]| ≤ |*V*[*M*]| 和 |*E*[*H*]| ≤ |*E*[*M*]|，因此构建它需要 *O*(*V*[*H*] +
    *E*[*H*]) = *O*(*E*) 的时间。最后，第三阶段从第 *q* 层的未匹配顶点开始执行深度优先搜索。一旦发现一个顶点，就不再从中搜索，因此深度优先搜索的分析与
    [第 20.3 节](chapter020.xhtml#Sec_20.3) 中的相同：*O*(*V*[*H*] + *E*[*H*]) = *O*(*E*)。因此，所有三个阶段都只需要
    *O*(*E*) 的时间。
- en: Once the maximal set of vertex-disjoint shortest *M*-augmenting paths have been
    found in line 3, updating the matching in line 4 takes *O*(*E*) time, as it is
    just a matter of going through the edges of the *M*-augmenting paths and adding
    edges to and removing edges from the matching *M*. Thus, each iteration of the
    **repeat** loop of lines 2–5 can run in *O*(*E*) time.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在第 3 行找到了顶点不相交的最短 *M*-增广路径的最大集合，在第 4 行更新匹配需要 *O*(*E*) 的时间，因为只需遍历 *M*-增广路径的边，向匹配
    *M* 添加边或从中删除边。因此，第 2-5 行的 **repeat** 循环的每次迭代都可以在 *O*(*E*) 的时间内运行。
- en: It remains to show that the **repeat** loop iterates ![art](images/Art_P797.jpg)
    times. We start with the following lemma, which shows that after each iteration
    of the **repeat** loop, the length of an augmenting path increases.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 仍需证明 **repeat** 循环迭代 ![art](images/Art_P797.jpg) 次。我们从以下引理开始，该引理表明在 **repeat**
    循环的每次迭代后，增广路径的长度会增加。
- en: '***Lemma 25.5***'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 25.5***'
- en: Let *G* = (*V*, *E*) be an undirected bipartite graph with matching *M*, and
    let *q* be the length of a shortest *M*-augmenting path. Let P = {*P*[1], *P*[2],
    … , *P*[*k*]} be a maximal set of vertex-disjoint *M*-augmenting paths of length
    *q*. Let *M*′ = *M* ⊕ (*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*k*]), and suppose that *P* is
    a shortest *M*′-augmenting path. Then *P* has more than *q* edges.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 设 *G* = (*V*, *E*) 为一个无向二分图，其匹配为 *M*，*q* 为最短 *M*-增广路径的长度。设 P = {*P*[1], *P*[2],
    … , *P*[*k*]} 为长度为 *q* 的顶点不相交的 *M*-增广路径的最大集合。令 *M*′ = *M* ⊕ (*P*[1] ∪ *P*[2] ∪
    ⋯ ∪ *P*[*k*])，假设 *P* 是最短的 *M*′-增广路径。那么 *P* 的边数大于 *q*。
- en: '***Proof***   We consider separately the cases in which *P* is vertex-disjoint
    from the augmenting paths in P and in which it is not vertex-disjoint.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   我们分别考虑 *P* 与 P 中的增广路径是顶点不相交的情况和它们不是顶点不相交的情况。'
- en: First, assume that *P* is vertex-disjoint from the augmenting paths in P. Then,
    *P* contains edges that are in *M* but are not in any of *P*[1], *P*[2], … , *P*[*k*],
    so that *P* is also an *M*-augmenting path. Since *P* is disjoint from *P*[1],
    *P*[2], … , *P*[*k*] but is also an *M*-augmenting path, and since P is a maximal
    set of shortest *M*-augmenting paths, *P* must be longer than any of the augmenting
    paths in P, each of which has length *q*. Therefore, *P* has more than *q* edges.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，假设 *P* 与 P 中的增广路径是顶点不相交的。那么，*P* 包��在 *M* 中但不包含在任何 *P*[1]、*P*[2]、…、*P*[*k*]
    中的边，因此 *P* 也是一个 *M*-增广路径。由于 *P* 与 *P*[1]、*P*[2]、…、*P*[*k*] 不相交，但又是一个 *M*-增广路径，并且
    P 是最短的 *M*-增广路径的最大集合，*P* 必须比 P 中的任何增广路径都要长，而每个增广路径的长度为 *q*。因此，*P* 的边数大于 *q*。
- en: 'Now, assume that *P* visits at least one vertex from the *M*-augmenting paths
    in P. By Corollary 25.2, *M* ′ is a matching in *G* with |*M*′| = |*M*| + *k*.
    Since *P* is an *M*′-augmenting path, by Lemma 25.1, *M*′ ⊕ *P* is a matching
    with |*M*′ ⊕ *P*| = |*M*′| + 1 = |*M*| + *k* + 1\. Now let *A* = *M* ⊕ *M*′ ⊕
    *P*. We claim that *A* = (*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*k*]) ⊕ *P*:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设 *P* 至少访问了 P 中的一个增广路径的一个顶点。根据推论 25.2，*M*′ 是 *G* 中的一个匹配，|*M*′| = |*M| +
    *k*。由于 *P* 是一个 *M*′-增广路径，根据引理 25.1，*M*′ ⊕ *P* 是一个匹配，|*M*′ ⊕ *P*| = |*M*′| + 1
    = |*M| + *k* + 1。现在令 *A* = *M* ⊕ *M*′ ⊕ *P*。我们声称 *A* = (*P*[1] ∪ *P*[2] ∪ ⋯ ∪
    *P*[*k*]) ⊕ *P*：
- en: '| *A* | = | *M* ⊕ *M*′ ⊕ *P* |  |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| *A* | = | *M* ⊕ *M*′ ⊕ *P* |  |'
- en: '|  | = | *M* ⊕ (M ⊕ (*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*k*])) ⊕ *P* |  |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *M* ⊕ (*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*k*]) ⊕ *P* |  |'
- en: '|  | = | (*M* ⊕ *M*) ⊕ (*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*k*]) ⊕ *P* | (associativity
    of ⊕) |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '|  | = | (*M* ⊕ *M*) ⊕ (*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*k*]) ⊕ *P* | (结合律) |'
- en: '|  | = | Ø ⊕ (*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*k*]) ⊕ *P* | (*X* ⊕ *X* = Ø for all
    *X*) |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '|  | = | Ø ⊕ (*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*k*]) ⊕ *P* | (*X* ⊕ *X* = Ø 对于所有 *X*)
    |'
- en: '|  | = | (*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*k*]) ⊕ *P* | (Ø ⊕ *X* = *X* for all *X*).
    |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|  | = | (*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*k*]) ⊕ *P* | (Ø ⊕ *X* = *X* 对于所有 *X*)。
    |'
- en: Lemma 25.3 with *M** = *M*′ ⊕ *P* gives that *A* contains at least |*M*′ ⊕ *P*|
    − |*M*| = *k* + 1 vertex-disjoint *M*-augmenting paths. Since each such *M*-augmenting
    path has at least *q* edges, we have |*A*| ≥ (*k* + 1)*q* = *kq* + *q*.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 引理 25.3 中 *M** = *M*′ ⊕ *P* 表明 *A* 至少包含 |*M*′ ⊕ *P*| − |*M*| = *k* + 1 个顶点不相交的
    *M*-增广路径。由于每个这样的 *M*-增广路径至少有 *q* 条边，我们有 |*A*| ≥ (*k* + 1)*q* = *kq* + *q*。
- en: Now we claim that *P* shares at least one edge with some *M*-augmenting path
    in P. Under the matching *M*′, every vertex in each *M*-augmenting path in P is
    matched. (Only the first and last vertex in each *M*-augmenting path *P*[*i*]
    is unmatched under *M*, and under *M* ⊕ *P*[*i*], all vertices in *P*[*i*] are
    matched. Because the *M*-augmenting paths in P are vertex-disjoint, no other path
    in P can affect whether the vertices in *P*[*i*] are matched. That is, the vertices
    in *P*[*i*] are matched under (*M* ⊕ *P*[*i*]) ⊕ *P[j]* if and only if they are
    matched under *M* ⊕ *P*[*i*], for any other path *P*[*j*] ∈ P.) Suppose that *P*
    shares a vertex *v* with some path *P*[*i*] ∈ P. Vertex *v* cannot be an endpoint
    of *P*, because the endpoints of *P* are unmatched under *M*′. Therefore, *v*
    has an incident edge in *P* that belongs to *M*′. Since any vertex has at most
    one incident edge in a matching, this edge must also belong to *P*[*i*], thus
    proving the claim.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们声称*P*至少与P中的某个*M*增广路径共享一条边。在匹配*M*′下，P中每个*M*增广路径中的每个顶点都已匹配。（只有P中每个*M*增广路径*P*[*i*]的第一个和最后一个顶点在*M*下未匹配，在*M*
    ⊕ *P*[*i*]下，*P*[*i*]中的所有顶点都已匹配。由于P中的*M*增广路径是顶点不相交的，因此P中的其他路径不会影响*P*[*i*]中的顶点是否匹配。也就是说，当且仅当在*M*
    ⊕ *P*[*i*]下匹配了*P*[*i*]中的顶点时，*P*[*i*]中的顶点在(*M* ⊕ *P*[*i*]) ⊕ *P*[*j*]下是否匹配，其中*P*[*j*]
    ∈ P。）假设*P*与P中的某个路径*P*[*i*]共享一个顶点*v*。顶点*v*不能是*P*的端点，因为*P*的端点在*M*′下未匹配。因此，*v*在P中有一条属于*M*′的关联边。由于任何顶点在匹配中最多有一条关联边，这条边也必须属于*P*[*i*]，从而证明了这一点。
- en: Because *A* = (*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*k*]) ⊕ *P* and *P* shares at least
    one edge with some *P*[*i*] ∈ P, we have that |*A*| < |*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*k*]|
    + |*P*|. Thus, we have
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*A* = (*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*k*]) ⊕ *P*，而*P*至少与某个*P*[*i*] ∈ *P*共享一条边，我们有|*A*|
    < |*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P*[*k*]| + |*P*|。因此，我们有
- en: '| *kq* + *q* | ≤ | &#124;*A*&#124; |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| *kq* + *q* | ≤ | &#124;*A*&#124; |'
- en: '|  | < | &#124;*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P[k]*&#124; + &#124;*P*&#124; |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|  | < | &#124;*P*[1] ∪ *P*[2] ∪ ⋯ ∪ *P[k]*&#124; + &#124;*P*&#124; |'
- en: '|  | = | *kq* + &#124;*P*&#124;, |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *kq* + &#124;*P*&#124; |'
- en: so that *q* < |*P*|. We conclude that *P* contains more than *q* edges.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 所以*q* < |*P*|。我们得出结论，*P*包含的边数多于*q*。
- en: ▪
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: The next lemma bounds the size of a maximum matching, based on the length of
    a shortest augmenting path.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个引理根据最短增广路径的长度限制了最大匹配的大小。
- en: '***Lemma 25.6***'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 25.6***'
- en: Let *M* be a matching in graph *G* = (*V*, *E*), and let a shortest *M*-augmenting
    path in *G* contain *q* edges. Then the size of a maximum matching in *G* is at
    most |*M*| + |*V*| / (*q* + 1).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 设*M*是图*G* = (*V*, *E*)中的匹配，并且*G*中的最短*M*增广路径包含*q*条边。那么*G*中最大匹配的大小最多为|*M*| + |*V*|
    / (*q* + 1)。
- en: '***Proof***   Let *M** be a maximum matching in *G*. By Lemma 25.3, *G* contains
    at least |*M**| − |*M*| vertex-disjoint *M*-augmenting paths. Each of these paths
    contains at least *q* edges, and hence at least *q* + 1 vertices. Because these
    paths are vertex-disjoint, we have (|*M**|−|*M*|)(*q*+1) ≤ |*V*|, so that |*M**|
    ≤ |*M*| + |*V*|/(*q*+1).'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   设*M*是图*G*中的最大匹配。根据引理25.3，*G*至少包含|*M*|−|*M*|个顶点不相交的*M*增广路径。这些路径中每个至少包含*q*条边，因此至少包含*q*+1个顶点。由于这些路径是顶点不相交的，我们有(|*M*|−|*M*|)(*q*+1)
    ≤ |*V*|，因此|*M*| ≤ |*M*| + |*V*|/(*q*+1)。'
- en: ▪
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: The final lemma bounds the number of iterations of the **repeat** loop of lines
    2–5.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最终的引理限制了第2-5行的**重复**循环的迭代次数。
- en: '***Lemma 25.7***'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 25.7***'
- en: When the HOPCROFT-KARP procedure runs on an undirected bipartite graph *G* =
    (*V*, *E*), the **repeat** loop of lines 2–5 iterates ![art](images/Art_P798.jpg)
    times.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当HOPCROFT-KARP过程在无向二分图*G* = (*V*, *E*)上运行时，第2-5行的**重复**循环迭代![art](images/Art_P798.jpg)次。
- en: '***Proof***   By Lemma 25.5, the length *q* of the shortest *M*-augmenting
    paths found in line 3 increases from iteration to iteration. After ![art](images/Art_P799.jpg)
    iterations, therefore, we must have ![art](images/Art_P800.jpg). Consider the
    situation after the first time line 4 executes with *M*-augmenting paths whose
    length is at least ![art](images/Art_P801.jpg). Since the size of a matching increases
    by at least one edge per iteration, Lemma 25.6 implies that the number of additional
    iterations before achieving a maximum matching is at most'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   根据引理25.5，第3行找到的最短*M*增广路径的长度*q*从迭代到迭代增加。因此，经过![art](images/Art_P799.jpg)次迭代后，我们必须有![art](images/Art_P800.jpg)。考虑在第一次执行第4行时，具有至少![art](images/Art_P801.jpg)长度的*M*增广路径的情况。由于匹配的大小每次迭代至少增加一条边，引理25.6暗示在达到最大匹配之前的额外迭代次数最多为'
- en: '![art](images/Art_P802.jpg)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P802.jpg)'
- en: Hence, the total number of loop iterations is less than ![art](images/Art_P803.jpg).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，循环迭代的总次数小于![art](images/Art_P803.jpg)。
- en: ▪
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Thus, we have the following bound on the running time of the HOPCROFT-KARP procedure.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们对HOPCROFT-KARP过程的运行时间有以下限制。
- en: '***Theorem 25.8***'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 25.8***'
- en: The procedure HOPCROFT-KARP runs in ![art](images/Art_P804.jpg) time on an undirected
    bipartite graph *G* = (*V*, *E*).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: HOPCROFT-KARP过程在无向二分图*G* = (*V*, *E*)上运行时间为![art](images/Art_P804.jpg)。
- en: '***Proof***   By Lemma 25.7 the **repeat** loop iterates ![art](images/Art_P805.jpg)
    times, and we have seen how to implement each iteration in *O*(*E*) time.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   根据引理25.7，**重复**循环迭代![art](images/Art_P805.jpg)次，我们已经看到如何在*O*(*E*)时间内实现每次迭代。'
- en: ▪
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Exercises**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***25.1-1***'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '***25.1-1***'
- en: Use the Hopcroft-Karp algorithm to find a maximum matching for the graph in
    [Figure 25.1](chapter025.xhtml#Fig_25-1).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Hopcroft-Karp算法在[图25.1](chapter025.xhtml#Fig_25-1)中找到图的最大匹配。
- en: '***25.1-2***'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '***25.1-2***'
- en: How are *M*-augmenting paths and augmenting paths in flow networks similar?
    How do they differ?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '*M*增广路径和流网络中的增广路径有何相似之处？它们有何不同？'
- en: '***25.1-3***'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '***25.1-3***'
- en: What is the advantage of searching in the transpose *H*^T from unmatched vertices
    in layer *q* (the first layer that contains an unmatched vertex in *R*) to layer
    0 versus searching in the dag *H* from layer 0 to layer *q*?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 从未匹配的顶点在层*q*（包含*R*中未匹配顶点的第一层）中从转置*H*^T中搜索的优势是什么，相对于在dag *H*中从层0搜索到层*q*？
- en: '***25.1-4***'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '***25.1-4***'
- en: Show how to bound the number of iterations of the the **repeat** loop of lines
    2–5 of HOPCROFT-KARP by ![art](images/Art_P806.jpg).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何通过 ![art](images/Art_P806.jpg) 来限制 HOPCROFT-KARP 的第 2-5 行的 **repeat** 循环的迭代次数。
- en: ★ ***25.1-5***
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***25.1-5***
- en: A ***perfect matching*** is a matching under which every vertex is matched.
    Let *G* = (*V*, *E*) be an undirected bipartite graph with vertex partition *V*
    = *L* ∪ *R*, where |*L*| = |*R*|. For any *X* ⊆ *V*, define the ***neighborhood***
    of *X* as
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个***完美匹配***是一种每个顶点都被匹配的匹配。设 *G* = (*V*, *E*) 是一个无向二分图，顶点分区为 *V* = *L* ∪ *R*，其中
    |*L*| = |*R*|。对于任意 *X* ⊆ *V*，定义 *X* 的***邻域***为
- en: '*N*(*X*) = {*y* ∈ *V* : (*x*, *y*) ∈ *E* for some *x* ∈ *X*},'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '*N*(*X*) = {*y* ∈ *V* : (*x*, *y*) ∈ *E*，对于某个 *x* ∈ *X*},'
- en: 'that is, the set of vertices adjacent to some member of *X*. Prove ***Hall’s
    theorem***: there exists a perfect matching in *G* if and only if |*A*| ≤ |*N*(*A*)|
    for every subset *A* ⊆ *L*.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，与 *X* 的某个成员相邻的顶点集。证明***霍尔定理***：如果对于每个子集 *A* ⊆ *L*，都有 |*A*| ≤ |*N*(*A*)|，那么
    *G* 中存在一个完美匹配。
- en: '***25.1-6***'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '***25.1-6***'
- en: In a ***d-regular*** graph, every vertex has degree *d*. If *G* = (*V*, *E*)
    is bipartite with vertex partition *V* = *L* ∪ *R* and also *d*-regular, then
    |*L*| = |*R*|. Use Hall’s theorem (see Exercise 25.1-5) to prove that every *d*-regular
    bipartite graph contains a perfect matching. Then use that result to prove that
    every *d*-regular bipartite graph contains *d* disjoint perfect matchings.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个***d-正则***图中，每个顶点的度为 *d*。如果 *G* = (*V*, *E*) 是一个二分图，顶点分区为 *V* = *L* ∪ *R*，同时也是
    *d-正则*，那么 |*L*| = |*R*|。使用霍尔定理（见练习 25.1-5）证明每个 *d-正则* 二分图都包含一个完美匹配。然后利用该结果证明每个
    *d-正则* 二分图都包含 *d* 个不相交的完美匹配。
- en: '[**25.2    The stable-marriage problem**](toc.xhtml#Rh1-147)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '[**25.2    稳定婚姻问题**](toc.xhtml#Rh1-147)'
- en: In [Section 25.1](chapter025.xhtml#Sec_25.1), the goal was to find a maximum
    matching in an undirected bipartite graph. If you know that the graph *G* = (*V*,
    *E*) with vertex partition *V* = *L* ∪ *R* is a ***complete bipartite graph***^([1](#footnote_1))—containing
    an edge from every vertex in *L* to every vertex in *R*—then you can find a maximum
    matching by a simple greedy algorithm.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 25.1 节](chapter025.xhtml#Sec_25.1)中，目标是在无向二分图中找到一个最大匹配。如果知道图 *G* = (*V*,
    *E*)，顶点分区为 *V* = *L* ∪ *R* 是一个***完全二分图***—包含从 *L* 中的每个顶点到 *R* 中的每个顶点的边—那么可以通过一个简单的贪心算法找到一个最大匹配。
- en: 'When a graph can have several matchings, you might want to decide which matchings
    are most desirable. In [Section 25.3](chapter025.xhtml#Sec_25.3), we’ll add weights
    to the edges and find a matching of maximum weight. In this section, we will instead
    add some information to each vertex in a complete bipartite graph: a ranking of
    the vertices in the other side. That is, each vertex in *L* has an ordered list
    of all the vertices in *R*, and vice-versa. To keep things simple, let’s assume
    that *L* and *R* each contain *n* vertices. The goal here is to match each vertex
    in *L* with a vertex in *R* in a “stable” way.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个图可以有多个匹配时，您可能想决定哪些匹配是最理想的。在[第 25.3 节](chapter025.xhtml#Sec_25.3)中，我们将为边添加权重并找到最大权重的匹配。在本节中，我们将为完全二分图中的每个顶点添加一些信息：对另一侧顶点的排名。也就是说，*L*
    中的每个顶点都有另一侧所有顶点的有序列表，反之亦然。为了简化问题，让我们假设 *L* 和 *R* 每个包含 *n* 个顶点。这里的目标是以“稳定”的方式将
    *L* 中的每个顶点与 *R* 中的一个顶点配对。
- en: This problem derives its name, the ***stable-marriage problem***, from the notion
    of heterosexual marriage, viewing *L* as a set of women and *R* as a set of men.^([2](#footnote_2))
    Each woman ranks all the men in terms of desirability, and each man does the same
    with all the women. The goal is to pair up women and men (a matching) so that
    if a woman and a man are not matched to each other, then at least one of them
    prefers their assigned partner.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的名字，***稳定婚姻问题***，源自异性婚姻的概念，将 *L* 视为女性集合，*R* 视为男性集合。每个女性按吸引力对所有男性进行排名，每个男性也对所有女性进行相同操作。目标是配对女性和男性（一种匹配），以便如果一个女性和一个男性没有配对，那么至少有一个人喜欢他们的分配对象。
- en: If a woman and a man are not matched to each other but each prefers the other
    over their assigned partner, they form a ***blocking pair***. A blocking pair
    has incentive to opt out of the assigned pairing and get together on their own.
    If that were to occur, then this pair would block the matching from being “stable.”
    A ***stable matching***, therefore, is a matching that has no blocking pair. If
    there is a blocking pair, then the matching is ***unstable***.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个女人和一个男人互相喜欢对方而不喜欢自己的配对对象，他们就会形成一个***阻塞对***。阻塞对有动机退出分配的配对，自行组成一对。如果发生这种情况，那么这对将阻止匹配变得“稳定”。因此，***稳定匹配***是指没有阻塞对的匹配。如果存在阻塞对，那么匹配是***不稳定***的。
- en: 'Let’s look at an example with four women—Wanda, Emma, Lacey, and Karen—and
    four men—Oscar, Davis, Brent, and Hank—having the following preferences:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个有四名女性—Wanda、Emma、Lacey 和 Karen—和四名男性—Oscar、Davis、Brent 和 Hank—具有以下偏好的例子：
- en: '| Wanda: | Brent, Hank, Oscar, Davis |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| Wanda: | Brent, Hank, Oscar, Davis |'
- en: '| Emma: | Davis, Hank, Oscar, Brent |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| Emma: | Davis, Hank, Oscar, Brent |'
- en: '| Lacey: | Brent, Davis, Hank, Oscar |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| Lacey: | Brent, Davis, Hank, Oscar |'
- en: '| Karen: | Brent, Hank, Davis, Oscar |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| Karen: | Brent, Hank, Davis, Oscar |'
- en: '| Oscar: | Wanda, Karen, Lacey, Emma |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| Oscar: | Wanda, Karen, Lacey, Emma |'
- en: '| Davis: | Wanda, Lacey, Karen, Emma |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| Davis: | Wanda, Lacey, Karen, Emma |'
- en: '| Brent: | Lacey, Karen, Wanda, Emma |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| Brent: | Lacey, Karen, Wanda, Emma |'
- en: '| Hank: | Lacey, Wanda, Emma, Karen |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| Hank: | Lacey, Wanda, Emma, Karen |'
- en: 'A stable matching comprises the following pairs:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一个稳定匹配包括以下配对：
- en: '| Lacey and BrentWanda and HankKaren and DavisEmma and Oscar |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| Lacey 和 BrentWanda 和 HankKaren 和 DavisEmma 和 Oscar |'
- en: You can verify that this matching has no blocking pair. For example, even though
    Karen prefers Brent and Hank to her partner Davis, Brent prefers his partner Lacey
    to Karen, and Hank prefers his partner Wanda to Karen, so that neither Karen and
    Brent nor Karen and Hank form a blocking pair. In fact, this stable matching is
    unique. Suppose instead that the last two pairs were
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以验证这个匹配没有阻塞对。例���，即使 Karen 更喜欢 Brent 和 Hank 而不是她的伴侣 Davis，Brent 更喜欢他的伴侣 Lacey
    而不是 Karen，Hank 更喜欢他的伴侣 Wanda 而不是 Karen，所以既不是 Karen 和 Brent 也不是 Karen 和 Hank 形成阻塞对。事实上，这个稳定匹配是唯一的。假设最后两对是
- en: '| Emma and DavisKaren and Oscar |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 艾玛和戴维斯卡伦和奥斯卡 |'
- en: Then Karen and Davis would be a blocking pair, because they were not paired
    together, Karen prefers Davis to Oscar, and Davis prefers Karen to Emma. Therefore,
    this matching is not stable.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 那么卡伦和戴维斯将成为一个阻塞对，因为他们没有配对在一起，卡伦更喜欢戴维斯而不是奥斯卡，而戴维斯更喜欢卡伦而不是艾玛。因此，这种匹配不稳定。
- en: 'Stable matchings need not be unique. For example, suppose that there are three
    women—Monica, Phoebe, and Rachel—and three men—Chandler, Joey, and Ross—with these
    preferences:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定的匹配不一定是唯一的。例如，假设有三个女性——莫妮卡、菲比和瑞秋——和三个男性——钱德勒、乔伊和罗斯——他们的偏好如下：
- en: '| Monica: | Chandler, Joey, Ross |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 莫妮卡： | 钱德勒，乔伊，罗斯 |'
- en: '| Phoebe: | Joey, Ross, Chandler |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 菲比： | 乔伊，罗斯，钱德勒 |'
- en: '| Rachel: | Ross, Chandler, Joey |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 瑞秋： | 罗斯，钱德勒，乔伊 |'
- en: '| Chandler:  | Phoebe, Rachel, Monica |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 钱德勒： | 菲比，瑞秋，莫妮卡 |'
- en: '| Joey: | Rachel, Monica, Phoebe |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 乔伊： | 瑞秋，莫妮卡，菲比 |'
- en: '| Ross: | Monica, Phoebe, Rachel |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 罗斯： | 莫妮卡，菲比，瑞秋 |'
- en: 'In this case, there are three stable matchings:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，有三种稳定的匹配：
- en: '| Matching 1'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '| 匹配 1'
- en: '* * *'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '| Matching 2'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '| 匹配 2'
- en: '* * *'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '| Matching 3'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '| 匹配 3'
- en: '* * *'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '* * *'
- en: '|'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '| Monica and Chandler | Phoebe and Chandler | Rachel and Chandler |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 莫妮卡和钱德勒 | 菲比和钱德勒 | 瑞秋和钱德勒 |'
- en: '| Phoebe and Joey | Rachel and Joey | Monica and Joey |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| 菲比和乔伊 | 瑞秋和乔伊 | 莫妮卡和乔伊 |'
- en: '| Rachel and Ross | Monica and Ross | Phoebe and Ross |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| 瑞秋和罗斯 | 莫妮卡和罗斯 | 菲比和罗斯 |'
- en: In matching 1, all women get their first choice and all men get their last choice.
    Matching 2 is the opposite, with all men getting their first choice and all women
    getting their last choice. When all the women or all the men get their first choice,
    there plainly cannot be a blocking pair. In matching 3, everyone gets their second
    choice. You can verify that there are no blocking pairs.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 在匹配 1 中，所有女性都得到了她们的第一选择，而所有男性都得到了他们的最后选择。匹配 2 则相反，所有男性得到了他们的第一选择，而所有女性得到了她们的最后选择。当所有女性或所有男性都得到了他们的第一选择时，显然不可能存在阻塞对。在匹配
    3 中，每个人都得到了他们的第二选择。你可以验证没有阻塞对。
- en: 'You might wonder whether it is always possible to come up with a stable matching
    no matter what rankings each participant provides. The answer is yes. (Exercise
    25.2-3 asks you to show that even in the scenario of the National Resident Matching
    Program, where each hospital takes on multiple students, it is always possible
    to devise a stable assignment.) A simple algorithm known as the Gale-Shapley algorithm
    always finds a stable matching. The algorithm has two variants, which mirror each
    other: “woman-oriented” and “man-oriented.” Let’s examine the woman-oriented version.
    Each participant is either “free” or “engaged.” Everyone starts out free. Engagements
    occur when a free woman proposes to a man. When a man is first proposed to, he
    goes from free to engaged, and he always stays engaged, though not necessarily
    to the same woman. If an engaged man receives a proposal from a woman whom he
    prefers to the woman he’s currently engaged to, that engagement is broken, the
    woman to whom he had been engaged becomes free, and the man and the woman whom
    he prefers become engaged. Each woman proposes to the men in her preference list,
    in order, until the last time she becomes engaged. When a woman is engaged, she
    temporarily stops proposing, but if she becomes free again, she continues down
    her list. Once everyone is engaged, the algorithm terminates. The procedure GALE-SHAPLEY
    on the next page makes this process more concrete. The procedure allows for some
    choice: any free woman may be selected in line 2\. We’ll see that the procedure
    produces a stable matching regardless of the order in which line 2 chooses free
    women. For the man-oriented version, just reverse the roles of men and women in
    the procedure.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想知道，无论每个参与者提供的排名如何，是否总是可能得出一个稳定的匹配。答案是肯定的。（练习 25.2-3 要求你展示，即使在国家住院医师配对计划的情况下，每家医院接受多名学生，也总是可以设计出一个稳定的分配。）一个简单的算法，即盖尔-沙普利算法总是能找到一个稳定的匹配。该算法有两个变体，互为镜像：“以女性为导向”和“以男性为导向”。让我们来看看以女性为导向的版本。每个参与者要么是“自由”的，要么是“订婚”的。每个人最初都是自由的。当一个自由的女性向男性求婚时，就会发生订婚。当一个男性第一次被求婚时，他从自由变为订婚，并且他总是保持订婚状态，尽管不一定是与同一个女性。如果一个订婚的男性收到一个他更喜欢的女性的求婚，那么这段订婚关系就会被打破，他原来订婚的女性变为自由，而他和他更喜欢的女性订婚。每个女性按照她的偏好列表依次向男性求婚，直到最后一次她订婚。当一个女性订婚时，她暂时停止求婚，但如果她再次变为自由，她会继续按照列表顺序进行。一旦每个人都订婚了，算法就终止。下一页的盖尔-沙普利过程使这个过程更加具体化。该过程允许一些选择：第
    2 行可以选择任何自由女性。我们将看到，无论第 2 行选择自由女性的顺序如何，该过程都会产生一个稳定的匹配。对于以男性为导向的版本，只需在过程中颠倒男性和女性的角色。
- en: 'Let’s see how the GALE-SHAPLEY procedure executes on the example with Wanda,
    Emma, Lacey, Karen, Oscar, Davis, Brent, and Hank. After everyone is initialized
    to free, here is one possible version of what can occur in successive iterations
    of the **while** loop of lines 2–9:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看���尔-沙普利过程在���达、艾玛、莱西、卡伦、奥斯卡、戴维斯、布伦特和汉克的例子中是如何执行的。在每个人初始化为自由后，以下是循环的每一次迭代中可能发生的一个版本。
- en: Wanda proposes to Brent. Brent is free, so that Wanda and Brent become engaged
    and no longer free.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 旺达向布伦特求婚。布伦特是自由的，于是旺达和布伦特订婚，不再自由。
- en: Emma proposes to Davis. Davis is free, so that Emma and Davis become engaged
    and no longer free.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 艾玛向戴维斯求婚。戴维斯是自由的，于是艾玛和戴维斯订婚，不再自由。
- en: Lacey proposes to Brent. Brent is engaged to Wanda, but he prefers Lacey. Brent
    breaks the engagement to Wanda, who becomes free. Lacey and Brent become engaged,
    with Lacey no longer free.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 莱西向布伦特求婚。布伦特与旺达订婚，但他更喜欢莱西。布伦特终止与旺达的订婚，旺达变为自由。莱西和布伦特订婚，莱西不再自由。
- en: Karen proposes to Brent. Brent is engaged to Lacey, whom he prefers to Karen.
    Brent rejects Karen, who remains free.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卡伦向布伦特求婚。布伦特与莱西订婚，他更喜欢莱西而不是卡伦。布伦特拒绝了卡伦，卡伦仍然自由。
- en: Karen proposes to Hank. Hank is free, so that Karen and Hank become engaged
    and no longer free.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 卡伦向汉克求婚。汉克是自由的，于是卡伦和汉克订婚，不再自由。
- en: Wanda proposes to Hank. Hank is engaged to Karen, but he prefers Wanda. Hank
    breaks the engagement with Karen, who becomes free. Wanda and Hank become engaged,
    with Wanda no longer free.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Wanda向Hank求婚。Hank与Karen订婚，但他更喜欢Wanda。Hank取消与Karen的订婚，Karen变得自由。Wanda和Hank订婚，Wanda不再自由。
- en: Karen proposes to Davis. Davis is engaged to Emma, but he prefers Karen. Davis
    breaks the engagement to Emma, who becomes free. Karen and Davis become engaged,
    with Karen no longer free.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Karen向Davis求婚。Davis与Emma订婚，但他更喜欢Karen。Davis取消与Emma的订婚，Emma变得自由。Karen和Davis订婚，Karen不再自由。
- en: Emma proposes to Hank. Hank is engaged to Wanda, whom he prefers to Emma. Hank
    rejects Emma, who remains free.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Emma向Hank求婚。Hank与Wanda订婚，他更喜欢Wanda而不是Emma。Hank拒绝Emma，Emma保持自由。
- en: Emma proposes to Oscar. Oscar is free, so that Emma and Oscar become engaged
    and no longer free.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Emma向Oscar求婚。Oscar是自由的，因此Emma和Oscar订婚，不再自由。
- en: GALE-SHAPLEY (*men*, *women*, *rankings*)
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 盖尔-沙普利算法（*男性*，*女性*，*排名*）
- en: '|   1 | assign each woman and man as free |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '|   1 | 将每个女性和男性分配为自由的'
- en: '|   2 | **while** some woman *w* is free |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '|   2 | **当** 有女性 *w* 是自由的 **时**'
- en: '|   3 | let *m* be the first man on *w*’s ranked list to whom she has not proposed
    |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|   3 | 让 *m* 是 *w* 的排名列表上第一个她还没有向其求婚的男性'
- en: '|   4 | **if** *m* is free |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '|   4 | **如果** *m* 是自由的'
- en: '|   5 | *w* and *m* become engaged to each other (and not free) |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '|   5 | *w* 和 *m* 订婚（并非自由）'
- en: '|   6 | **elseif** *m* ranks *w* higher than the woman *w*′ he is currently
    engaged to |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '|   6 | **否则如果** *m* 将 *w* 排在他当前订婚的女性 *w*′ 之上'
- en: '|   7 | *m* breaks the engagement to *w*′, who becomes free |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '|   7 | *m* 取消与 *w*′ 的订婚，*w*′ 变得自由'
- en: '|   8 | *w* and *m* become engaged to each other (and not free) |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '|   8 | *w* 和 *m* 订婚（并非自由）'
- en: '|   9 | **else** *m* rejects *w*, with *w* remaining free |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '|   9 | **否则** *m* 拒绝 *w*，*w* 保持自由'
- en: '| 10 | **return** the stable matching consisting of the engaged pairs |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 10 | **返回** 由订婚对组成的稳定匹配'
- en: At this point, everyone is engaged and nobody is free, so the **while** loop
    terminates. The procedure returns the stable matching we saw earlier.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 此时，每个人都已订婚，没有人是自由的，因此**while**循环终止。该过程返回我们之前看到的稳定匹配。
- en: The following theorem shows that not only does GALE-SHAPLEY terminate, but that
    it always returns a stable matching, thereby proving that a stable matching always
    exists.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定理表明，盖尔-沙普利算法不仅终止，而且总是返回一个稳定匹配，从而证明稳定匹配总是存在。
- en: '***Theorem 25.9***'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 25.9***'
- en: The procedure GALE-SHAPLEY always terminates and returns a stable matching.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 盖尔-沙普利算法总是终止并返回一个稳定匹配。
- en: '***Proof***   Let’s first show that the **while** loop of lines 2–9 always
    terminates, so that the procedure terminates. The proof is by contradiction. If
    the loop fails to terminate, it is because some woman remains free. In order for
    a woman to remain free, she must have proposed to all the men and been rejected
    by each one. In order for a man to reject a woman, he must be already engaged.
    Therefore, all the men are engaged. Once engaged, a man stays engaged (though
    not necessarily to the same woman). There are an equal number *n* of women and
    men, however, which means that every woman is engaged, leading to the contradiction
    that no women are free. We must also show that the **while** loop makes a bounded
    number of iterations. Since each of the *n* women goes through her ranking of
    the *n* men in order, possibly not reaching the end of her list, the total number
    of iterations is at most *n*². Therefore, the **while** loop always terminates,
    and the procedure returns a matching.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   让我们首先证明行2-9的**while**循环总是终止，以便该过程终止。证明是通过反证法的。如果循环未能终止，那是因为某个女性仍然自由。为了让一个女性保持自由，她必须向所有男性求婚并被每个男性拒绝。为了让一个男性拒绝一个女性，他必须已经订婚。因此，所有男性都已订婚。一旦订婚，男性就会保持订婚（尽管不一定是同一个女性）。然而，女性和男性的数量相等，这意味着每个女性都已订婚，导致矛盾，即没有女性是自由的。我们还必须证明**while**循环执行有限次数。由于每个女性按顺序遍历她对男性的排名列表，可能不会到达列表的末尾，因此总迭代次数最多为
    *n*²。因此，**while**循环总是终止，该过程返回一个匹配。'
- en: We need to show that there are no blocking pairs. We first observe that once
    a man *m* is engaged to a woman *w*, all subsequent actions for *m* occur in lines
    6–8\. Therefore, once a man is engaged, he stays engaged, and any time he breaks
    an engagement to a woman *w*, it’s for a woman whom he prefers to *w*. Suppose
    that a woman *w* is matched with a man *m*, but she prefers man *m*′. We’ll show
    that *w* and *m*′ is not a blocking pair, because *m*′ does not prefer *w* to
    his partner. Because *w* ranks *m*′ higher than *m*, she must have proposed to
    *m*′ before proposing to *m*, and *m*′ either rejected her proposal or accepted
    it and later broke the engagement. If *m*′ rejected the proposal from *w*, it
    is because he was already engaged to some woman he prefers to *w*. If *m*′ accepted
    and later broke the engagement, he was at some point engaged to *w* but later
    accepted a proposal from a woman he prefers to *w*. In either case, he ultimately
    ends up with a partner whom he prefers to *w*. We conclude that even though *w*
    might prefer *m*′ to her partner *m*, it is not also the case that *m*′ prefers
    *w* to his partner. Therefore, the procedure returns a matching containing no
    blocking pairs.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要证明没有阻塞对。我们首先观察到一旦男性 *m* 与女性 *w* 订婚，*m* 的所有后续行动发生在行6-8中。因此，一旦男性订婚，他就会保持订婚，任何时候他取消与女性
    *w* 的订婚，都是因为他更喜欢另一位女性。假设女性 *w* 与男性 *m* 匹配，但她更喜欢男性 *m*′。我们将证明 *w* 和 *m*′ 不是阻塞对，因为
    *m*′ 不喜欢 *w* 胜过他的伴侣。因��� *w* 将 *m*′ 排在 *m* 之上，她必须先向 *m*′ 求婚，然后才向 *m* 求婚，而 *m*′
    要么拒绝她的求婚，要么接受了并后来取消了订婚。如果 *m*′ 拒绝了 *w* 的求婚，那是因为他已经与他更喜欢的某位女性订婚。如果 *m*′ 接受并后来取消了订婚，那是因为他曾经与
    *w* 订婚，但后来接受了他更喜欢的女性的求婚。无论哪种情况，他最终都会与他更喜欢的伴侣在一起。我们得出结论，即使 *w* 可能更喜欢 *m*′ 而不是她的伴侣
    *m*，但 *m*′ 也不一定更喜欢 *w* 而不是他的伴侣。因此，该过程返回一个不包含阻塞对的匹配。
- en: ▪
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Exercise 25.2-1 asks you to provide the proof of the following corollary.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 练习25.2-1要求您提供以下推论的证明。
- en: '***Corollary 25.10***'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论 25.10***'
- en: Given preference rankings for *n* women and *n* men, the Gale-Shapley algorithm
    can be implemented to run in *O*(*n*²) time.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 给定*n*名女性和*n*名男性的偏好排名，Gale-Shapley算法可以在*O*(*n*²)的时间内实现。
- en: ▪
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: 'Because line 2 can choose any free woman, you might wonder whether different
    choices can produce different stable matchings. The answer is no: as the following
    theorem shows, every execution of the GALE-SHAPLEY produces exactly the same result.
    Moreover, the stable matching returned is optimal for the women.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 因为第2行可以选择任何空闲女性，你可能会想知道不同的选择是否会产生不同的稳定匹配。答案是否定的：正如下面的定理所示，GALE-SHAPLEY的每次执行都会产生完全相同的结果。此外，返回的稳定匹配对于女性是最优的。
- en: '***Theorem 25.11***'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理25.11***'
- en: Regardless of how women are chosen in line 2 of GALE-SHAPLEY, the procedure
    always returns the same stable matching, and in this stable matching, each woman
    has the best partner possible in any stable matching.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 无论在GALE-SHAPLEY的第2行中如何选择女性，该过程总是返回相同的稳定匹配，在这个稳定匹配中，每个女性在任何稳定匹配中都有最佳伴侣。
- en: '***Proof***   The proof that each woman has the best partner possible in any
    stable matching is by contradiction. Suppose that the GALE-SHAPLEY procedure returns
    a stable matching *M*, but that there is a different stable matching *M*′ in which
    some woman *w* prefers her partner *m*′ to the partner *m* she has in *M*. Because
    *w* ranks *m*′ higher than *m*, she must have proposed to *m*′ before proposing
    to *m*. Then there is a woman *w*′ whom *m*′ prefers to *w*, and *m*′ was already
    engaged to *w*′ when *w* proposed or *m*′ accepted the proposal from *w* and later
    broke the engagement in favor of *w*′. Either way, there is a moment when *m*′
    decided against *w* in favor of *w*′. Now suppose, without loss of generality,
    that this moment was the first time that any man rejected a partner who belongs
    to some stable matching.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***  证明每个女性在任何稳定匹配中都有最佳伴侣是通过反证法。假设GALE-SHAPLEY过程返回一个稳定匹配*M*，但存在另一个稳定匹配*M*′，其中某个女性*w*更喜欢她在*M*中的伴侣*m*′而不是*m*。因为*w*将*m*′排在*m*之前，她必须先向*m*′求婚再向*m*求婚。然后有一个女性*w*′，*m*′更喜欢*w*′而不是*w*，当*w*求婚或*m*′接受*w*的求婚后，*m*′已经与*w*′订婚，后来为了*w*′而取消了与*w*的订婚。无论如何，*m*′都曾拒绝*w*，这是某个男性拒绝某个稳定匹配中的伴侣的第一次。'
- en: We claim that *w*′ cannot have a partner *m*″ in a stable matching whom she
    prefers to *m*′. If there were such a man *m*″, then in order for *w*′ to propose
    to *m*′, she would have proposed to *m*″ and been rejected at some point before
    proposing to *m*′. If *m*′ accepted the proposal from *w* and later broke it to
    accept *w*′, then since this was the first rejection in a stable matching, we
    get the contradiction that *m*″ could not have rejected *w*′ beforehand. If *m*″
    was already engaged to *w*′ when *w* proposed, then again, *m*″ could not have
    rejected *w*′ beforehand, thus proving the claim.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 我们声称*w*′在稳定匹配中不可能有一个她更喜欢的伴侣*m*″。如果有这样一个男性*m*″，那么为了向*m*′求婚，*w*′必须先向*m*″求婚并在向*m*′求婚之前的某个时刻被拒绝。如果*m*′接受了*w*的求婚并后来取消了以接受*w*′，那么由于这是稳定匹配中的第一次拒绝，我们得到了*m*″不可能在之前拒绝*w*′的矛盾。如果*m*″在*w*求婚时已经与*w*′订婚，那么同样，*m*″在之前不可能拒绝*w*′，从而证明了这一点。
- en: Since *w*′ does not prefer anyone to *m*′ in a stable matching and *w*′ is not
    matched with *m*′ in *M*′ (because *m*′ is matched with *w* in *M*′), *w*′ prefers
    *m*′ to her partner in *M*′. Since *w*′ prefers *m*′ over her partner in *M*′
    and *m*′ prefers *w*′ over his partner *w* in *M*′, the pair *w*′ and *m*′ is
    a blocking pair in *M*′. Because *M*′ has a blocking pair, it cannot be a stable
    matching, thereby contradicting the assumption that there exists some stable matching
    in which each woman has the best partner possible other than the matching *M*
    returned by GALE-SHAPLEY.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*w*′在稳定匹配中不偏好*m*′，且*w*′在*M*′中未与*m*′匹配（因为*m*′在*M*′中与*w*匹配），*w*′更喜欢*m*′而不是*M*′中的伴侣。由于*w*′更喜欢*m*′而不是*M*′中的伴侣，且*m*′更喜欢*w*′而不是*M*′中的伴侣*w*，所以*w*′和*m*′是*M*′中的一个阻塞对。因为*M*′有一个阻塞对，所以它不能是一个稳定匹配，从而与GALE-SHAPLEY返回的匹配*M*中每个女性都有最佳伴侣的假设相矛盾。
- en: We put no condition on the execution of the procedure, which means that all
    possible orders in which line 2 selects women result in the same stable matching
    being returned.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对程序的执行没有任何条件，这意味着第2行选择女性的所有可能顺序都会返回相同的稳定匹配。
- en: ▪
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Corollary 25.12***'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论25.12***'
- en: There can be stable matchings that the GALE-SHAPLEY procedure does not return.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 存在稳定匹配，但GALE-SHAPLEY过程未返回。
- en: '***Proof***   Theorem 25.11 says that for a given set of rankings, GALE-SHAPLEY
    returns just one matching, no matter how it chooses women in line 2\. The earlier
    example of three women and three men with three different stable matchings shows
    that there can be multiple stable matchings for a given set of rankings. A call
    of GALE-SHAPLEY is capable of returning only one of these stable matchings.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***  定理25.11表明，对于给定的排名��合，GALE-SHAPLEY只返回一个匹配，无论它如何在第2行选择女性。三名女性和三名男性有三种不同的稳定匹配的早期示例表明，对于给定的排名集合可能存在多个稳定匹配。GALE-SHAPLEY的调用只能返回其中一个稳定匹配。'
- en: ▪
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Although the GALE-SHAPLEY procedure gives the best possible outcome for the
    women, the following corollary shows that it also produces the worst possible
    outcome for the men.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管GALE-SHAPLEY过程为女性提供了最佳结果，但以下推论表明它也为男性提供了最差结果。
- en: '***Corollary 25.13***'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论25.13***'
- en: In the stable matching returned by the procedure GALE-SHAPLEY, each man has
    the worst partner possible in any stable matching.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在GALE-SHAPLEY过程返回的稳定匹配中，每个男性在任何稳定匹配中都有最差的伴侣。
- en: '***Proof***   Let *M* be the matching returned by a call to GALE-SHAPLEY. Suppose
    that there is another stable matching *M*′ and a man *m* who prefers his partner
    *w* in *M* to his partner *w*′ in *M*′. Let the partner of *w* in *M*′ be *m*′.
    By Theorem 25.11, *m* is the best partner that *w* can have in any stable matching,
    which means that *w* prefers *m* to *m*′. Since *m* prefers *w* to *w*′, the pair
    *w* and *m* is a blocking pair in *M*′, contradicting the assumption that *M*′
    is a stable matching.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 让*M*是GALE-SHAPLEY调用返回的匹配。假设存在另一个稳定匹配*M*′和一个男人*m*，他更喜欢他在*M*中的伴侣*w*，而不是在*M*′中的伴侣*w*′。让*M*′中*w*的伴侣是*m*′。根据定理25.11，*m*是*w*在任何稳定匹配中可以拥有的最佳伴侣，这意味着*w*更喜欢*m*而不是*m*′。由于*m*更喜欢*w*而不是*w*′，对*w*和*m*是*M*′中的一个阻塞对，与*M*′是稳定匹配的假设相矛盾。'
- en: ▪
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Exercises**'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***25.2-1***'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '***25.2-1***'
- en: Describe how to implement the Gale-Shapley algorithm so that it runs in *O*(*n*²)
    time.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 描述如何实现Gale-Shapley算法，使其在*O*(*n*²)时间内运行。
- en: '***25.2-2***'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '***25.2-2***'
- en: Is it possible to have an unstable matching with just two women and two men?
    If so, provide and justify an example. If not, argue why not.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 仅有两名女性和两名男性的情况下可能存在不稳定匹配吗？如果是，提供并证明一个例子。如果不是，说明为什么不可能。
- en: '***25.2-3***'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: '***25.2-3***'
- en: The National Resident Matching Program differs from the scenario for the stable-marriage
    problem set out in this section in two ways. First, a hospital may be matched
    with more than one student, so that hospital *h* takes *r*[*h*] ≥ 1 students.
    Second, the number of students might not equal the number of hospitals. Describe
    how to modify the Gale-Shapley algorithm to fit the requirements of the National
    Resident Matching Program.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 国家住院医师匹配计划与本节中稳定婚姻问题的情景有两点不同。首先，一个医院可能与多名学生匹配，因此医院*h*接受*r*[h] ≥ 1名学生。其次，学生人数可能不等于医院人数。描述如何修改Gale-Shapley算法以适应国家住院医师匹配计划的要求。
- en: '***25.2-4***'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '***25.2-4***'
- en: 'Prove the following property, which is known as ***weak Pareto optimality***:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 证明以下性质，即***弱帕累托最优性***：
- en: Let *M* be the stable matching produced by the GALE-SHAPLEY procedure, with
    women proposing to men. Then, for a given instance of the stable-marriage problem
    there is no matching—stable or unstable—such that every woman has a partner whom
    she prefers to her partner in the stable matching *M*.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 让*M*是GALE-SHAPLEY过程生成的稳定匹配，女性向男性求婚。那么，对于给定的稳定婚姻问题实例，不存在匹配——稳定或不稳定——使得每个女性都更喜欢她在稳定匹配*M*中的伴侣。
- en: '***25.2-5***'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '***25.2-5***'
- en: 'The ***stable-roommates problem*** is similar to the stable-marriage problem,
    except that the graph is a complete graph, not bipartite, with an even number
    of vertices. Each vertex represents a person, and each person ranks all the other
    people. The definitions of blocking pairs and stable matching extend in the natural
    way: a blocking pair comprises two people who both prefer each other to their
    current partner, and a matching is stable if there are no blocking pairs. For
    example, consider four people—Wendy, Xenia, Yolanda, and Zelda—with the following
    preference lists:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '***稳定室友问题***类似于稳定婚姻问题，不同之处在于图是完全图，而不是二部图，顶点数为偶数。每个顶点代表一个人，每个人对所有其他人进行排名。阻塞对和稳定匹配的定义自然地延伸：阻塞对包括两个人，他们都更喜欢对方而不是当前的伴侣，如果没有阻塞对，则匹配是稳定的。例如，考虑四个人——温迪、赛尼亚、约兰达和泽尔达，他们的偏好列表如下：'
- en: '| Wendy: | Xenia, Yolanda, Zelda |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '| 温迪: | 赛尼亚，约兰达，泽尔达 |'
- en: '| Xenia: | Wendy, Zelda, Yolanda |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '| 赛尼亚: | 温迪，泽尔达，约兰达 |'
- en: '| Yolanda:  | Wendy, Zelda, Xenia |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '| 约兰达: | 温迪，泽尔达，赛尼亚 |'
- en: '| Zelda: | Xenia, Yolanda, Wendy |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '| 泽尔达: | 赛尼亚，约兰达，温迪 |'
- en: 'You can verify that the following matching is stable:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以验证以下匹配是稳定的：
- en: '| Wendy and Xenia |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '| 温迪和赛尼亚 |'
- en: '| Yolanda and Zelda |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '| 约兰达和泽尔达 |'
- en: Unlike the stable-marriage problem, the stable-roommates problem can have inputs
    for which no stable matching exists. Find such an input and explain why no stable
    matching exists.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 与稳定婚姻问题不同，稳定室友问题可能存在无稳定匹配的输入。找到这样的输入，并解释为什么不存在稳定匹配。
- en: '[**25.3    The Hungarian algorithm for the assignment problem**](toc.xhtml#Rh1-148)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '[**25.3    匈牙利算法解决分配问题**](toc.xhtml#Rh1-148)'
- en: Let us once again add some information to a complete bipartite graph *G* = (*V*,
    *E*), where *V* = *L* ∪ *R*. This time, instead of having the vertices of each
    side rank the vertices on the other side, we assign a weight to each edge. Again,
    let’s assume that the vertex sets *L* and *R* each contain *n* vertices, so that
    the graph contains *n*² edges. For *l* ∈ *L* and *r* ∈ *R*, denote the weight
    of edge (*l*, *r*) by *w*(*l*, *r*), which represents the utility gained by matching
    vertex *l* with vertex *r*.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再次向完全二部图*G* = (*V*, *E*)添加一些信息，其中*V* = *L* ∪ *R*。这一次，与让每一侧的顶点对另一侧的顶点进行排名不同，我们为每条边分配一个权重。再次，假设顶点集合*L*和*R*各自包含*n*个顶点，因此图包含*n*²条边。对于*L*中的*l*和*R*中的*r*，将边(*l*,
    *r*)的权重表示为*w*(*l*, *r*)，它代表匹配顶点*l*和顶点*r*所获得的效用。
- en: The goal is to find a perfect matching *M** (see Exercises 25.1-5 and 25.1-6)
    whose edges have the maximum total weight over all perfect matchings. That is,
    letting *w*(*M*) = ∑[(*l*,*r*)∈*M*] *w*(*l*, *r*) denote the total weight of the
    edges in matching *M*, we want to find a perfect matching *M** such that
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 目标是找到一个完美匹配*M**（参见练习25.1-5和25.1-6），其边的总权重在所有完美匹配中最大。也就是说，让*w*(*M*) = ∑[(*l*,*r*)∈*M*]
    *w*(*l*, *r*)表示匹配*M*中边的总权重，我们希望找到一个完美匹配*M**，使得
- en: '*w*(*M**) = max {*w*(*M*) : *M* is a perfect matching}.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '*w*(*M**) = max {*w*(*M*) : *M*是完美匹配}。'
- en: 'We call finding such a maximum-weight perfect matching the ***assignment problem***.
    A solution to the assignment problem is a perfect matching that maximizes the
    total utility. Like the stable-marriage problem, the assignment problem finds
    a matching that is “good,” but with a different definition of good: maximizing
    total value rather than achieving stability.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称找到这样一��最大权重的完美匹配为***分配问题***。解决分配问题的方案是最大化总效用的完美匹配。与稳定婚姻问题类似，分配问题找到一个“好”的匹配，但“好”的定义不同：最大化总价值而不是实现稳定性。
- en: Although you could enumerate all n! perfect matchings to solve the assignment
    problem, an algorithm known as the ***Hungarian algorithm*** solves it much faster.
    This section will prove an *O*(*n*⁴) time bound, and Problem 25-2 asks you to
    refine the algorithm to reduce the running time to *O*(*n*³). Instead of working
    with the complete bipartite graph *G*, the Hungarian algorithm works with a subgraph
    of *G* called the “equality subgraph.” The equality subgraph, which is defined
    below, changes over time and has the beneficial property that any perfect matching
    in the equality subgraph is also an optimal solution to the assignment problem.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以枚举所有n!个完美匹配来解决分配问题，但一种称为***匈牙利算法***的算法解决得更快。本节将证明一个*O*(*n*⁴)的时间界限，问题25-2要求您优化算法以将运行时间降低到*O*(*n*³)。匈牙利算法不使用完全二分图*G*，而是使用*G*的一个子图称为“等权子图”。等权子图，如下所定义，随时间变化，并具有这样的有益特性，即等权子图中的任何完美匹配也是分配问题的最优解。
- en: The equality subgraph depends on assigning an attribute *h* to each vertex.
    We call *h* the ***label*** of a vertex, and we say that *h* is a ***feasible
    vertex labeling*** of *G* if
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 等权子图取决于为每个顶点分配属性*h*。我们称*h*为顶点的***标记***，如果*h*是*G*的***可行顶点标记***，则称*h*是*G*的可行顶点标记。
- en: '*l*.*h* + *r*.*h* ≥ *w*(*l*, *r*) for all *l* ∈ *L* and *r* ∈ *R*.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '*l*.*h* + *r*.*h* ≥ *w*(*l*, *r*)对于所有*l* ∈ *L*和*r* ∈ *R*成立。'
- en: A feasible vertex labeling always exists, such as the ***default vertex labeling***
    given by
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 总是存在一个可行的顶点标记，比如由以下给出的***默认顶点标记***。
- en: '![art](images/Art_P807.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P807.jpg)'
- en: Given a feasible vertex labeling *h*, the ***equality subgraph*** *G*[*h*] =
    (*V*, *E*[*h*]) of *G* consists of the same vertices as *G* and the subset of
    edges
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 给定可行的顶点标记*h*，*G*的***等权子图*** *G*[*h*] = (*V*, *E*[*h*])由与*G*相同的顶点和边的子集组成
- en: '*E*[*h*] = {(*l*, *r*) ∈ *E* : *l*.*h* + *r*.*h* = *w*(*l*, *r*)}.'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*E*[*h*] = {(*l*, *r*) ∈ *E* : *l*.*h* + *r*.*h* = *w*(*l*, *r*)}.'
- en: The following theorem ties together a perfect matching in an equality subgraph
    and an optimal solution to the assignment problem.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的定理将完美匹配与等权子图联系在一起，并与分配问题的最优解相关联。
- en: '***Theorem 25.14***'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理25.14***'
- en: Let *G* = (*V*, *E*), where *V* = *L* ∪ *R*, be a complete bipartite graph where
    each edge (*l*, *r*) ∈ *E* has weight *w*(*l*, *r*). Let *h* be a feasible vertex
    labeling of *G* and *G*[*h*] be the equality subgraph of *G*. If *G*[*h*] contains
    a perfect matching *M**, then *M** is an optimal solution to the assignment problem
    on *G*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 设*G* = (*V*, *E*), 其中*V* = *L* ∪ *R*，是一个完全二分图，其中每条边(*l*, *r*) ∈ *E*的权重为*w*(*l*,
    *r*)。设*h*是*G*的可行顶点标记，*G*[*h*]是*G*的等权子图。如果*G*[*h*]包含一个完美匹配*M*，那么*M*是*G*上分配问题的最优解。
- en: '***Proof***   If *G*[*h*] contains a perfect matching *M**, then because *G*[*h*]
    and *G* have the same sets of vertices, *M** is also a perfect matching in *G*.
    Because each edge of *M** belongs to *G*[*h*] and each vertex has exactly one
    incident edge from any perfect matching, we have'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   如果*G*[*h*]包含一个完美匹配*M*，那么因为*G*[*h*]和*G*具有相同的顶点集，*M*也是*G*中的完美匹配。因为*M*的每条边属于*G*[*h*]，每个顶点都恰好有一条来自任何完美匹配的关联边，我们有'
- en: '![art](images/Art_P808.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P808.jpg)'
- en: Letting *M* be any perfect matching in *G*, we have
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 让*M*是*G*中的���意完美匹配，我们有
- en: '![art](images/Art_P809.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P809.jpg)'
- en: Thus, we have
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有
- en: '![art](images/Art_P810.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P810.jpg)'
- en: so that *M** is a maximum-weight perfect matching in *G*.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 以至于*M*是*G*中的最大权重完美匹配。
- en: ▪
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: The goal now becomes finding a perfect matching in an equality subgraph. Which
    equality subgraph? It does not matter! We have free rein to not only choose an
    equality subgraph, but to change which equality subgraph we choose as we go along.
    We just need to find *some* perfect matching in *some* equality subgraph.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的目标是在一个等权子图中找到一个完美匹配。哪个等权子图？无所谓！我们可以自由选择一个等权子图，甚至在进行过程中改变选择的等权子图。我们只需要在*某个*等权子图中找到*某个*完美匹配。
- en: 'To understand the equality subgraph better, consider again the proof of Theorem
    25.14 and, in the second half, let *M* be any matching. The proof is still valid,
    in particular, inequality (25.3): the weight of any matching is always at most
    the sum of the vertex labels. If we choose any set of vertex labels that define
    an equality subgraph, then a maximum-cardinality matching in this equality subgraph
    has total value at most the sum of the vertex labels. If the set of vertex labels
    is the “right” one, then it will have total value equal to *w*(*M**), and a maximum-cardinality
    matching in the equality subgraph is also a maximum-weight perfect matching. The
    Hungarian algorithm repeatedly modifies the matching and the vertex labels in
    order to achieve this goal.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解等权子图，再次考虑定理25.14的证明，在后半部分，让*M*是任意匹配。证明仍然有效，特别是不等式(25.3)：任意匹配的权重始终不超过顶点标记的总和。如果我们选择任何定义等权子图的顶点标记集合，那么这个等权子图中的最大基数匹配的总值最多等于顶点标记的总和。如果顶点标记集合是“正确”的，那么它的总值将等于*w*(*M*)，而等权子图中的最大基数匹配也是最大权重完美匹配。匈牙利算法反复修改匹配和顶点标记，以实现这个目标。
- en: The Hungarian algorithm starts with any feasible vertex labeling *h* and any
    matching *M* in the equality subgraph *G*[*h*]. It repeatedly finds an *M*-augmenting
    path *P* in *G*[*h*] and, using Lemma 25.1, updates the matching to be *M* ⊕ *P*,
    thereby incrementing the size of the matching. As long as there is some equality
    subgraph that contains an *M*-augmenting path, the size of the matching can increase,
    until a perfect matching is achieved.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 匈牙利算法从等权子图*G*[*h*]中的任意可行顶点标记*h*和任意匹配*M*开始。它反复在*G*[*h*]中找到一个*M*-增广路径*P*，并使用引理25.1更新匹配为*M*
    ⊕ *P*，从而增加匹配的大小。只要存在包含*M*-增广路径的等权子图，匹配的大小就可以增加，直到达到完美匹配。
- en: 'Four questions arise:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 四个问题出现：
- en: 'What initial feasible vertex labeling should the algorithm start with? Answer:
    the default vertex labeling given by equations (25.1) and (25.2).'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法应该从哪个初始可行顶点标记开始？答案：由方程(25.1)和(25.2)给出的默认顶点标记。
- en: 'What initial matching in *G*[*h*] should the algorithm start with? Short answer:
    any matching, even an empty matching, but a greedy maximal matching works well.'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 算法应该从*G*[*h*]中的哪个初始匹配开始？简短答案：任何匹配，甚至是空匹配，但贪婪最大匹配效果很好。
- en: 'If an *M*-augmenting path exists in *G*[*h*], how to find it? Short answer:
    use a variant of breadth-first search similar to the second phase of the procedure
    used in the Hopcroft-Karp algorithm to find a maximal set of shortest *M*-augmenting
    paths.'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在*G*[*h*]中存在*M*增广路径，如何找到它？简短答案：使用类似于Hopcroft-Karp算法中用于找到一组最短*M*增广路径的过程的第二阶段的变体的广度优先搜索。
- en: 'What if the search for an *M*-augmenting path fails? Short answer: update the
    feasible vertex labeling to bring in at least one new edge.'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在有向相等子图*G*[*M.h*]中搜索*M*增广路径失败怎么办？简短答案：更新可行顶点标记以引入至少一条新边。
- en: We’ll elaborate on the short answers using the example that starts in [Figure
    25.4](chapter025.xhtml#Fig_25-4). Here, *L* = {*l*[1], *l*[2], … , *l*[7]} and
    *R* = {*r*[1], *r*[2], … , *r*[7]}. The edge weights appear in the matrix shown
    in part (a), where the weight *w*(*l*[*i*], *r*[*j*]) appears in row *i* and column
    *j*. The feasible vertex labels, given by the default vertex labeling, appear
    to the left of and above the matrix. Matrix entries in red indicate edges (*l*[*i*],
    *r*[*j*]) for which *l*[*i*].*h* + *r*[*j*].*h* = *w*(*l*[*i*], r[*j*]), that
    is, edges in the equality subgraph *G*[*h*] appearing in part (b) of the figure.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用从[图25.4](chapter025.xhtml#Fig_25-4)开始的示例详细说明简短答案。这里，*L* = {*l*[1], *l*[2],
    … , *l*[7]}，*R* = {*r*[1], *r*[2], … , *r*[7]}。边权重显示在部分(a)中的矩阵中，其中权重*w*(*l*[i],
    *r*[j])显示在第*i*行和第*j*列。通过默认顶点标记给出的可行顶点标签显示在矩阵的左侧和上方。红色矩阵条目表示边(*l*[i], *r*[j])，其中*l*[i].*h*
    + *r*[j].*h* = *w*(*l*[i], r[j])，即在图中的相等子图*G*[*h*]中出现在图的部分(b)中的边。
- en: '**Greedy maximal bipartite matching**'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**贪婪最大二分匹配**'
- en: There are several ways to implement a greedy method to find a maximal bipartite
    matching. The procedure GREEDY-BIPARTITE-MATCHING shows one. Edges in [Figure
    25.4(b)](chapter025.xhtml#Fig_25-4) highlighted in blue indicate the initial greedy
    maximal matching in *G*[*h*]. Exercise 25.3-2 asks you to show that the GREEDY-BIPARTITE-MATCHING
    procedure returns a matching that is at least half the size of a maximum matching.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种实现贪婪方法以找到最大二分匹配的方法。GREEDY-BIPARTITE-MATCHING过程展示了其中一种。在[图25.4(b)](chapter025.xhtml#Fig_25-4)中用蓝色标出的边表示*G*[*h*]中初始贪婪最大匹配。练习25.3-2要求你证明GREEDY-BIPARTITE-MATCHING过程返回的匹配至少是最大匹配大小的一半。
- en: GREEDY-BIPARTITE-MATCHING (*G*)
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: GREEDY-BIPARTITE-MATCHING (*G*)
- en: '| 1 | *M* = Ø |'
  id: totrans-262
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *M* = Ø |'
- en: '| 2 | **for** each vertex *l* ∈ *L* |'
  id: totrans-263
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **对于** 每个顶点 *l* ∈ *L* |'
- en: '| 3 | **if** *l* has an unmatched neighbor in *R* |'
  id: totrans-264
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **如果** *l* 在*R*中有一个未匹配的邻居 |'
- en: '| 4 | choose any such unmatched neighbor *r* ∈ *R* |'
  id: totrans-265
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 选择任何这样的未匹配邻居 *r* ∈ *R* |'
- en: '| 5 | *M* = *M* ∪ {(*l*, *r*)} |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 5 | *M* = *M* ∪ {(*l*, *r*)} |'
- en: '| 6 | **return** *M* |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 6 | **返回** *M* |'
- en: '![art](images/Art_P811.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P811.jpg)'
- en: '**Figure 25.4** The start of the Hungarian algorithm. **(a)** The matrix of
    edge weights for a bipartite graph with *L* = {*l*[1], *l*[2], … , *l*[7]}. The
    value in row *i* and column *j* indicates *w*(*l*[*i*], *r*[*j*]). Feasible vertex
    labels appear above and next to the matrix. Red entries correspond to edges in
    the equality subgraph. **(b)** The equality subgraph *G*[*h*]. Edges highlighted
    in blue belong to the initial greedy maximal matching *M*. Blue vertices are matched,
    and tan vertices are unmatched. **(c)** The directed equality subgraph *G*[*M,h*]
    created from *G*[*h*] by directing edges in *M* from *R* to *L* and all other
    edges from *L* to *R*.'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**图25.4** 匈牙利算法的开始。**(a)** 二分图的边权重矩阵，其中*L* = {*l*[1], *l*[2], … , *l*[7]}。第*i*行和第*j*列中的值表示*w*(*l*[i],
    *r*[j])。可行顶点标签出现在矩阵的上方和旁边。红色条目对应于相等子图中的边。**(b)** 相等子图*G*[*h*]。蓝色突出显示的边属于初始贪婪最大匹配*M*。蓝色顶点已匹配，棕色顶点未匹配。**(c)**
    从图的部分(b)中的匹配*M*创建的有向相等子图*G*[*M,h*]。'
- en: '**Finding an *M*-augmenting path in *G[h]***'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '**在*G[h]*中找到*M*增广路径**'
- en: To find an *M*-augmenting path in the equality subgraph *G*[*h*] with a matching
    *M*, the Hungarian algorithm first creates the ***directed equality subgraph*** *G*[*M,h*]
    from *G*[*h*], just as the Hopcroft-Karp algorithm creates *G*[*M*] from *G*.
    As in the Hopcroft-Karp algorithm, you can think of an *M*-augmenting path as
    starting from an unmatched vertex in *L*, ending at an unmatched vertex in *R*,
    taking unmatched edges from *L* to *R*, and taking matched edges from *R* to *L*.
    Thus, *G*[*M,h*] = (*V*, *E*[*M,h*]), where
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 要在具有匹配*M*的相等子图*G*[*h*]中找到*M*增���路径，匈牙利算法首先从*G*[*h*]创建***有向相等子图*** *G*[*M,h*]，就像Hopcroft-Karp算法从*G*创建*G*[*M*]一样。与Hopcroft-Karp算法类似，你可以将*M*增广路径视为从未匹配的顶点开始，以未匹配的顶点结束，从*L*到*R*取未匹配的边，从*R*到*L*取匹配的边。因此，*G*[*M,h*]
    = (*V*, *E*[*M,h*])，其中
- en: '| *E*[*M,h*] | = | {(*l*, *r*) : *l* ∈ *L*, *r* ∈ *R*, and (*l*, *r*) ∈ *E*[*h*]
    − *M* } | (edges from *L* to *R*) |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| *E*[*M,h*] | = | {(*l*, *r*) : *l* ∈ *L*, *r* ∈ *R*, 且(*l*, *r*) ∈ *E*[*h*]
    − *M* } | (从*L*到*R*的边) |'
- en: '|  |  | ∪ {(*r*, *l*) : *r* ∈ *R*, *l* ∈ *L*, and (*l*, *r*) ∈ *M* } | (edges
    from *R* to *L*). |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '|  |  | ∪ {(*r*, *l*) : *r* ∈ *R*, *l* ∈ *L*, 且(*l*, *r*) ∈ *M* } | (从*R*到*L*的边)
    |'
- en: Because an *M*-augmenting path in the directed equality subgraph *G*[*M.h*]
    is also an *M*-augmenting path in the equality subgraph *G*[*h*], it suffices
    to find *M*-augmenting paths in *G*[*M.h*]. [Figure 25.4(c)](chapter025.xhtml#Fig_25-4)
    shows the directed equality subgraph *G*[*M,h*] corresponding to the equality
    subgraph *G*[*h*] and matching *M* from part (b) of the figure.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 因为在有向相等子图*G*[*M.h*]中的*M*增广路径也是在相等子图*G*[*h*]中的*M*增广路径，所以只需在*G*[*M.h*]中找到*M*增广路径即可。[图25.4(c)](chapter025.xhtml#Fig_25-4)展示了对应于图中部分(b)的相等子图*G*[*h*]和匹配*M*的有向相等子图*G*[*M,h*]。
- en: With the directed equality subgraph *G*[*M,h*] in hand, the Hungarian algorithm
    searches for an *M*-augmenting path from any unmatched vertex in *L* to any unmatched
    vertex in *R*. Any exhaustive graph-search method suffices. Here, we’ll use breadth-first
    search, starting from all the unmatched vertices in *L* (just as the Hopcroft-Karp
    algorithm does when creating the dag *H*), but stopping upon first discovering
    some unmatched vertex in *R*. [Figure 25.5](chapter025.xhtml#Fig_25-5) shows the
    idea. To start from all the unmatched vertices in *L*, initialize the first-in,
    first-out queue with all the unmatched vertices in *L*, rather than just one source
    vertex. Unlike the dag *H* in the Hopcroft-Karp algorithm, here each vertex needs
    just one predecessor, so that the breadth-first search creates a ***breadth-first
    forest*** *F* = (*V*[*F*], *E*[*F*]). Each unmatched vertex in *L* is a root in
    *F*.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 有了有向相等子图*G*[*M,h*]，匈牙利算法从*L*中的任何未匹配顶点到*R*中的任何未匹配顶点搜索*M*增广路径。任何穷举图搜索方法都可以。这里，我们将使用广度优先搜索，从所有未匹配的*L*中的顶点开始（就像Hopcroft-Karp算法在创建dag
    *H*时所做的那样），但在首次发现*R*中的某个未匹配顶点时停止。[图 25.5](chapter025.xhtml#Fig_25-5)展示了这个想法。为了从所有未匹配的*L*中的顶点开始，初始化先进先出队列，其中包含所有未匹配的*L*中的顶点，而不仅仅是一个源顶点。与Hopcroft-Karp算法中的dag
    *H*不同，这里每个顶点只需要一个前驱，因此广度优先搜索创建一个***广度优先森林*** *F* = (*V*[*F*], *E*[*F*])。每个未匹配的*L*中的顶点都是*F*中的根。
- en: In [Figure 25.5(g)](chapter025.xhtml#Fig_25-5), the breadth-first search has
    found the *M*-augmenting path 〈(*l*[4], *r*[2]), (*r*[2], *l*[1]), (*l*[1], *r*[3]),
    (*r*[3], *l*[6]), (*l*[6], *r*[5])〉. [Figure 25.6(a)](chapter025.xhtml#Fig_25-6)
    shows the new matching created by taking the symmetric difference of the matching
    *M* in [Figure 25.5(a)](chapter025.xhtml#Fig_25-5) with this *M*-augmenting path.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 25.5(g)](chapter025.xhtml#Fig_25-5)中，广度优先搜索找到了*M*增广路径 〈(*l*[4], *r*[2]),
    (*r*[2], *l*[1]), (*l*[1], *r*[3]), (*r*[3], *l*[6]), (*l*[6], *r*[5])〉。[图 25.6(a)](chapter025.xhtml#Fig_25-6)展示了通过将匹配*M*与这个*M*增广路径在[图
    25.5(a)](chapter025.xhtml#Fig_25-5)中的对称差创建的新匹配。
- en: '**When the search for an *M*-augmenting path fails**'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '**当寻找*M*增广路径失败时**'
- en: Having updated the matching *M* from an *M*-augmenting path, the Hungarian algorithm
    updates the directed equality subgraph *G*[*M,h*] according to the new matching
    and then starts a new breadth-first search from all the unmatched vertices in
    *L*. [Figure 25.6](chapter025.xhtml#Fig_25-6) shows the start of this process,
    picking up from [Figure 25.5](chapter025.xhtml#Fig_25-5).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在从*M*增广路径更新匹配*M*后，匈牙利算法根据新匹配更新有向相等子图*G*[*M,h*]，然后从所有未匹配的*L*中的顶点开始新的广度优先搜索。[图
    25.6](chapter025.xhtml#Fig_25-6)展示了这个过程的开始，从[图 25.5](chapter025.xhtml#Fig_25-5)接续。
- en: In [Figure 25.6(d)](chapter025.xhtml#Fig_25-6), the queue contains vertices
    *l*[4] and *l*[3]. Neither of these vertices has an edge that leaves it, however,
    so that once these vertices are removed from the queue, the queue becomes empty.
    The search terminates at this point, before discovering an unmatched vertex in
    *R* to yield an *M*-augmenting path. Whenever this situation occurs, the most
    recently discovered vertices must belong to *L*. Why? Whenever an unmatched vertex
    in *R* is discovered, the search has found an *M*-augmenting path, and when a
    matched vertex in *R* is discovered, it has an unvisited neighbor in *L*, which
    the search can then discover.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 25.6(d)](chapter025.xhtml#Fig_25-6)中，队列包含顶点*l*[4]和*l*[3]。然而，这些顶点都没有边离开它们，因此一旦这些顶点从队列中移除，队列就变为空。搜索在此时终止，未能发现*R*中的未匹配顶点以产生*M*增广路径。每当出现这种情况时，最近发现的顶点必定属于*L*。为什么？每当发现*R*中的未匹配顶点时，搜索已经找到了*M*增广路径，而当发现*R*中的匹配顶点时，它有一个未访问的邻居在*L*中，搜索随后可以发现。
- en: 'Recall that we have the freedom to work with any equality subgraph. We can
    change the directed equality subgraph “on the fly,” as long we do not counteract
    the work already done. The Hungarian algorithm updates the feasible vertex labeling
    *h* to fulfill the following criteria:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，我们有自由选择任何相等子图的权利。我们可以“即兴”更改有向相等子图，只要我们不抵消已经完成的工作。匈牙利算法更新可行的顶点标记*h*以满足以下标准：
- en: No edge in the breadth-first forest *F* leaves the directed equality subgraph.
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 广度优先森林*F*中没有边离开有向相等子图。
- en: No edge in the matching *M* leaves the directed equality subgraph.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 匹配*M*中没有边离开有向相等子图。
- en: At least one edge (*l*, *r*), where *l* ∈ *L* ∩ *V*[*F*] and *r* ∈ *R* − *V*[*F*]
    goes into *E*[*h*], and hence into *E*[*M,h*]. Therefore, at least one vertex
    in *R* will be newly discovered.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 至少有一条边(*l*, *r*)，其中*l* ∈ *L* ∩ *V*[*F*]且*r* ∈ *R* − *V*[*F*]进入*E*[*h*]，因此进入*E*[*M,h*]。因此，至少有一个*R*中的顶点将被新发现。
- en: Thus, at least one new edge enters the directed equality subgraph, and any edge
    that leaves the directed equality subgraph belongs to neither the matching *M*
    nor the breadth-first forest *F*. Newly discovered vertices in *R* are enqueued,
    but their distances are not necessarily 1 greater than the distances of the most
    recently discovered vertices in *L*.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，至少有一条新边进入有向相等子图，任何离开有向相等子图的边都不属于匹配*M*或广度优先森林*F*。在*R*中新发现的顶点被入队，但它们的距离不一定比*L*中最近发现的顶点的距离大1。
- en: '![art](images/Art_P812.jpg)'
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P812.jpg)'
- en: '**Figure 25.5** Finding an *M*-augmenting path in *G*[*M,h*] by breadth-first
    search. **(a)** The directed equality subgraph *G*[*M,h*] from [Figure 25.4(c)](chapter025.xhtml#Fig_25-4).
    **(b)–(g)** Successive versions of the breadth-first forest *F*, shown as the
    vertices at each distance from the roots—the unmatched vertices in *L*—are discovered.
    In parts (b)–(f), the layer of vertices closest to the bottom of the figure are
    those in the first-in, first-out queue. For example, in part (b), the queue contains
    the roots 〈*l*[4], *l*[5], *l*[7]〉, and in part (e), the queue contains 〈*r*[3],
    *r*[4]〉, at distance 3 from the roots. In part (g), the unmatched vertex *r*[5]
    is discovered, so the breadth-first search terminates. The path 〈(*l*[4], *r*[2]),
    (*r*[2], *l*[1]), (*l*[1], *r*[3]), (*r*[3], *l*[6]), (*l*[6], *r*[5])〉, highlighted
    in orange in parts (a) and (g), is an *M*-augmenting path. Taking its symmetric
    difference with the matching *M* yields a new matching with one more edge than
    *M*.'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 25.5** 通过广度优先搜索在*G*[M,h]中找到一个*M*增广路径。**(a)** 来自[图 25.4(c)](chapter025.xhtml#Fig_25-4)的有向相等子图*G*[M,h]。**(b)–(g)**
    广度优先森林*F*的连续版本，显示了每个距离根节点的顶点——*L*中的未匹配顶点。在(b)–(f)部分，最靠近图底部的顶点层是先进先出队列中的顶点。例如，在(b)部分，队列包含根节点〈*l*[4],
    *l*[5], *l*[7]〉，在(e)部分，队列包含距离根节点3的顶点〈*r*[3], *r*[4]〉。在(g)部分，发现了未匹配顶点*r*[5]，因此广度优先搜索终止。路径〈(*l*[4],
    *r*[2]), (*r*[2], *l*[1]), (*l*[1], *r*[3]), (*r*[3], *l*[6]), (*l*[6], *r*[5])〉，在(a)和(g)部分以橙色突出显示，是一个*M*增广路径。将其与匹配*M*的对称差集产生一个比*M*多一条边的新匹配。'
- en: '![art](images/Art_P813.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P813.jpg)'
- en: '**Figure 25.6 (a)** The new matching *M* and the new directed equality subgraph
    *G*[*M.h*] after updating the matching in [Figure 25.5(a)](chapter025.xhtml#Fig_25-5)
    with the *M*-augmenting path in [Figure 25.5(g)](chapter025.xhtml#Fig_25-5). **(b)–(d)**
    Successive versions of the breadth-first forest *F* in a new breadth-first search
    with roots *l*[5] and *l*[7]. After the vertices *l*[4] and *l*[3] in part (d)
    have been removed from the queue, the queue becomes empty before the search can
    discover an unmatched vertex in *R*.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 25.6 (a)** 在使用[M图](chapter025.xhtml#Fig_25-5)中的*M*增广路径更新匹配后，新匹配*M*和新的有向相等子图*G*[M.h]。**(b)–(d)**
    在以根*l*[5]和*l*[7]进行新的广度优先搜索时，广度优先森林*F*的连续版本。在(d)部分中，当顶点*l*[4]和*l*[3]从队列中移除后，在搜索发现*R*中的未匹配顶点之前，队列变为空。'
- en: To update the feasible vertex labeling, the Hungarian algorithm first computes
    the value
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更新可行顶点标记，匈牙利算法首先计算值
- en: '![art](images/Art_P814.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P814.jpg)'
- en: 'where *F*[*L*] = *L* ∩ *V*[*F*] and *F*[*R*] = *R* ∩ *V*[*F*] denote the vertices
    in the breadth-first forest *F* that belong to *L* and *R*, respectively. That
    is, *δ* is the smallest difference by which an edge incident on a vertex in *F*[*L*]
    missed being in the current equality subgraph *G*[*h*]. The Hungarian algorithm
    then creates a new feasible vertex labeling, say *h*′, by subtracting *δ* from
    *l*.*h* for all vertices *l* ∈ *F*[*L*] and adding *δ* to *r*.*h* for all vertices
    *r* ∈ *F*[*R*]:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*F*[L] = *L* ∩ *V*[F]和*F*[R] = *R* ∩ *V*[F]分别表示属于*F*中的*L*和*R*的广度优先森林中的顶点。也就是说，*δ*是边缘在当前相等子图*G*[h]中未包含的顶点上的最小差值。然后，匈牙利算法通过为所有属于*F*[L]的顶点*l*减去*δ*，并为所有属于*F*[R]的顶点*r*添加*δ*，创建一个新的可行顶点标记，称为*h*′：
- en: '![art](images/Art_P815.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P815.jpg)'
- en: The following lemma shows that these changes achieve the three criteria above.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 以下引理显示了这些更改实现了上述三个标准。
- en: '***Lemma 25.15***'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 25.15***'
- en: 'Let *h* be a feasible vertex labeling for the complete bipartite graph *G*
    with equality subgraph *G*[*h*], and let *M* be a matching for *G*[*h*] and *F*
    be a breadth-first forest being constructed for the directed equality subgraph
    *G*[*M,h*]. Then, the labeling *h*′ in equation (25.5) is a feasible vertex labeling
    for *G* with the following properties:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 让*h*是完全二部图*G*的可行顶点标记，具有相等子图*G*[h]，*M*是*G*[h]的匹配，*F*是为有向相等子图*G*[M,h]构建的广度优先森林。那么，方程(25.5)中的标记*h*′是*G*的可行顶点标记，具有以下属性：
- en: If (*u*, *v*) is an edge in the breadth-first forest *F* for *G*[*M,h*], then
    (*u*, *v*) ∈ *E*[*M,h′*].
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果(*u*, *v*)是用于*G*[M,h]的广度优先森林*F*中的边，则(*u*, *v*) ∈ *E*[M,h′]。
- en: If (*l*, *r*) belongs to the matching *M* for *G*[*h*], then (*r*, *l*) ∈ *E*[*M,h′*].
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果(*l*, *r*)属于*G*[h]的匹配*M*，则(*r*, *l*) ∈ *E*[M,h′]。
- en: There exist vertices *l* ∈ *F*[*L*] and *r* ∈ *R* − *F*[*R*] such that (*l*,
    *r*) ∉ *E*[*M,h*] but (*l*, *r*) ∈ *E*[*M,h′*].
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在顶点*l* ∈ *F*[L]和*r* ∈ *R* − *F*[R]，使得(*l*, *r*) ∉ *E*[M,h]但(*l*, *r*) ∈ *E*[M,h′]。
- en: '***Proof***   We first show that *h*′ is a feasible vertex labeling for *G*.
    Because *h* is a feasible vertex labeling, we have *l*.*h* + *r*.*h* ≥ *w*(*l*,
    *r*) for all *l* ∈ *L* and *r* ∈ *R*. In order for *h*′ to not be a feasible vertex
    labeling, we would need *l*.*h*′ + *r*.*h*′ < *l*.*h* + *r*.*h* for some *l* ∈
    *L* and *r* ∈ *R*. The only way this could occur would be for some *l* ∈ *F*[*L*]
    and *r* ∈ *R* − *F*[*R*]. In this instance, the amount of the decrease equals
    *δ*, so that *l*.*h*′ + *r*.*h*′ = *l*.*h* − *δ* + *r*.*h*. By equation (25.4),
    we have that *l*.*h*−*δ*+*r*.*h* ≥ *w*(*l*, *r*) for any *l* ∈ *F*[*L*] and *r*
    ∈ *R*−*F*[*R*], so that *l*.*h*′+*r*.*h*′ ≥ *w*(*l*, *r*). For all other edges,
    we have *l*.*h*′ + *r*.*h*′ ≥ *l*.*h*+*r*.*h* ≥ *w*(*l*, *r*). Thus, *h*′ is a
    feasible vertex labeling.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 我们首先证明*h*′是*G*的可行顶点标记。因为*h*是一个可行顶点标记，对于所有*l* ∈ *L*和*r* ∈ *R*，我们有*l*.*h*
    + *r*.*h* ≥ *w*(*l*, *r*)。为了使*h*′不是一个可行顶点标记，我们需要找到一些*l* ∈ *L*和*r* ∈ *R*，使得*l*.*h*′
    + *r*.*h*′ < *l*.*h* + *r*.*h*。这种情况只会发生在一些*l* ∈ *F*[L]和*r* ∈ *R* − *F*[R]。在这种情况下，减少的量等于*δ*，因此*l*.*h*′
    + *r*.*h*′ = *l*.*h* − *δ* + *r*.*h*。根据方程(25.4)，我们有*l*.*h*−*δ*+*r*.*h* ≥ *w*(*l*,
    *r*)，对于任何*l* ∈ *F*[L]和*r* ∈ *R*−*F*[R]，所以*l*.*h*′+*r*.*h*′ ≥ *w*(*l*, *r*)。对于所有其他边，我们有*l*.*h*′
    + *r*.*h*′ ≥ *l*.*h*+*r*.*h* ≥ *w*(*l*, *r*)。因此，*h*′是一个可行顶点标记。'
- en: 'Now we show that each of the three desired properties holds:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们证明三个期望属性都成立：
- en: If *l* ∈ *F*[*L*] and *r* ∈ *F*[*R*], then we have *l*.*h*′+*r*.*h*′ = *l*.*h*+*r*.*h*
    because *δ* is added to the label of *l* and subtracted from the label of *r*.
    Therefore, if an edge belongs to *F* for the directed graph *G*[*M,h*], it also
    belongs to *G*[*M,h*]′.
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*l* ∈ *F*[*L*]且*r* ∈ *F*[*R*]，那么我们有*l*.*h*′+*r*.*h*′ = *l*.*h*+*r*.*h*，因为*δ*被加到*l*的标记上并从*r*的标记中减去。因此，如果一条边属于有��图*G*[*M,h*]的*F*，那么它也属于*G*[*M,h*]′。
- en: We claim that at the time the Hungarian algorithm computes the new feasible
    vertex labeling *h*′, for every edge (*l*, *r*) ∈ *M*, we have *l* ∈ *F*[*L*]
    if and only if *r* ∈ *F*[*R*]. To see why, consider a matched vertex *r* and let
    (*l*, *r*) ∈ *M*. First suppose that *r* ∈ *F*[*R*], so that the search discovered
    *r* and enqueued it. When *r* was removed from the queue, *l* was discovered,
    so *l* ∈ *F*[*L*]. Now suppose that *r* ∉ *F*[*R*], so *r* is undiscovered. We
    will show that *l* ∉ *F*[*L*]. The only edge in *G*[*M,h*] that enters *l* is
    (*r*, *l*), and since *r* is undiscovered, the search has not taken this edge;
    if *l* ∈ *F*[*L*], it is not because of the edge (*r*, *l*). The only other way
    that a vertex in *L* can be in *F*[*L*] is if it is a root of the search, but
    only unmatched vertices in *L* are roots and *l* is matched. Thus, *l* ∉ *F*[*L*],
    and the claim is proved.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们声称在匈牙利算法计算新的可行顶点标记*h*′时，对于每条边(*l*, *r*) ∈ *M*，当且仅当*l* ∈ *F*[*L*]时，*r* ∈ *F*[*R*]。为了理解原因，考虑一个匹配的顶点*r*，并且让(*l*,
    *r*) ∈ *M*。首先假设*r* ∈ *F*[*R*]，这样搜索就会发现*r*并将其入队。当*r*从队列中移除时，*l*被发现，因此*l* ∈ *F*[*L*]。现在假设*r*
    ∉ *F*[*R*]，因此*r*未被发现。我们将展示*l* ∉ *F*[*L*]。进入*l*的唯一边是(*r*, *l*)，由于*r*未被发现，搜索尚未经过此边；如果*l*
    ∈ *F*[*L*]，那不是因为边(*r*, *l*)。*L*中的顶点能够在*F*[*L*]中的唯一其他方式是它是搜索的根，但只有未匹配的顶点在*L*中是根，而*l*是匹配的。因此，*l*
    ∉ *F*[*L*]，声称得证。
- en: We already saw that *l* ∈ *F*[*L*] and *r* ∈ *F*[*R*] implies *l*.*h*′ + *r*.*h*′
    = *l*.*h* + *r*.*h*. For the opposite case, when *l* ∈ *L* − *F*[*L*] and *R*
    ∈ *R* − *F*[*R*], we have that *l*.*h*′ = *l*.*h* and *r*.*h*′ = *r*.*h*, so that
    again *l*.*h*′ + *r*.*h*′ = *l*.*h* + *r*.*h*. Thus, if edge (*l*, *r*) is in
    the matching *M* for the equality graph *G*[*h*], then (*r*, *l*) ∈ *E*[*M,h*′].
  id: totrans-303
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们已经看到*l* ∈ *F*[*L*]且*r* ∈ *F*[*R*]意味着*l*.*h*′ + *r*.*h*′ = *l*.*h* + *r*.*h*。对于相反的情况，当*l*
    ∈ *L* − *F*[*L*]且*r* ∈ *R* − *F*[*R*]时，我们有*l*.*h*′ = *l*.*h*和*r*.*h*′ = *r*.*h*，因此再次*l*.*h*′
    + *r*.*h*′ = *l*.*h* + *r*.*h*。因此，如果边(*l*, *r*)在相等图*G*[*h*]的匹配*M*中，那么(*r*, *l*)
    ∈ *E*[*M,h*′]。
- en: Let (*l*, *r*) be an edge not in *E*[*h*] such that *l* ∈ *F*[*L*], *r* ∈ *R*
    − *F*[*R*], and *δ* = *l*.*h* + *r*.*h* − *w*(*l*, *r*). By the definition of
    *δ*, there is at least one such edge. Then, we have
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设(*l*, *r*)是一条不在*E*[*h*]中的边，使得*l* ∈ *F*[*L*]，*r* ∈ *R* − *F*[*R*]，且*δ* = *l*.*h*
    + *r*.*h* − *w*(*l*, *r*)。根据*δ*的定义，至少有一条这样的边。那么，我们有
- en: '| *l*.*h*′ + *r*.*h*′ | = | *l*.*h* − *δ* + *r*.*h* |'
  id: totrans-305
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| *l*.*h*′ + *r*.*h*′ | = | *l*.*h* − *δ* + *r*.*h* |'
- en: '|  | = | *l*.*h* − (*l*.*h* + *r*.*h* − *w*(*l*, *r*)) + *r*.*h* |'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | *l*.*h* − (*l*.*h* + *r*.*h* − *w*(*l*, *r*)) + *r*.*h* |'
- en: '|  | = | *w*(*l*, *r*), |'
  id: totrans-307
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | *w*(*l*, *r*), |'
- en: and thus (*l*, *r*) ∈ *E*[*h*′]. Since (*l*, *r*) is not in *E*[*h*], it is
    not in the matching *M*, so that in *E*[*M,h*′] it must be directed from *L* to
    *R*. Thus, (*l*, *r*) ∈ *E*[*M,h*′].
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 因此，(*l*, *r*) ∈ *E*[*h*′]。由于(*l*, *r*)不在*E*[*h*]中，所以它不在匹配*M*中，因此在*E*[*M,h*′]中必须从*L*指向*R*。因此，(*l*,
    *r*) ∈ *E*[*M,h*′]。
- en: ▪
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ▪
- en: It is possible for an edge to belong to *E*[*M,h*] but not to *E*[*M,h*′]. By
    Lemma 25.15, any such edge belongs neither to the matching *M* nor to the breadth-first
    forest *F* at the time that the new feasible vertex labeling *h*′ is computed.
    (See Exercise 25.3-3.)
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 一个边可能属于*E*[*M,h*]但不属于*E*[*M,h*′]。根据引理25.15，任何这样的边在计算新的可行顶点标记*h*′时既不属于匹配*M*也不属于广度优先森林*F*。（参见练习25.3-3。）
- en: 'Going back to [Figure 25.6(d)](chapter025.xhtml#Fig_25-6), the queue became
    empty before an *M*-augmenting path was found. [Figure 25.7](chapter025.xhtml#Fig_25-7)
    shows the next steps taken by the algorithm. The value of *δ* = 1 is achieved
    by the edge (*l*[5], *r*[3]) because in [Figure 25.4(a)](chapter025.xhtml#Fig_25-4),
    *l*[5].*h* + *r*[3].*h* − *w*(*l*[5], *r*[3]) = 6 + 0 − 5 = 1\. In [Figure 25.7(a)](chapter025.xhtml#Fig_25-7),
    the values of *l*[3].*h*, *l*[4].*h*, *l*[5].*h*, and *l*[7].*h* have decreased
    by 1 and the values of *r*[2].*h* and *r*[7].*h* have increased by 1 because these
    vertices are in *F*. As a result, the edges (*l*[1], *r*[2]) and (*l*[6], *r*[7])
    leave *G*[*M,h*] and the edge (*l*[5], *r*[3]) enters. [Figure 25.7(b)](chapter025.xhtml#Fig_25-7)
    shows the new directed equality subgraph *G*[*M,h*]. With edge (*l*[5], *r*[3])
    now in *G*[*M,h*], [Figure 25.7(c)](chapter025.xhtml#Fig_25-7) shows that this
    edge is added to the breadth-first forest *F*, and *r*[3] is added to the queue.
    Parts (c)–(f) show the breadth-first forest continuing to be built until in part
    (f), the queue once again becomes empty after vertex *l*[2], which has no edges
    leaving, is removed. Again, the algorithm must update the feasible vertex labeling
    and the directed equality subgraph. Now the value of *δ* = 1 is achieved by three
    edges: (*l*[1], *r*[6]), (*l*[5], *r*[6]), and (*l*[7], *r*[6]).'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 回到[图25.6(d)](chapter025.xhtml#Fig_25-6)，在找到*M*增广路径之前，队列变为空。[图25.7](chapter025.xhtml#Fig_25-7)展示了算法接下来的步骤。边(*l*[5],
    *r*[3])的值为*δ* = 1，因为在[图25.4(a)](chapter025.xhtml#Fig_25-4)中，*l*[5].*h* + *r*[3].*h*
    − *w*(*l*[5], *r*[3]) = 6 + 0 − 5 = 1。在[图25.7(a)](chapter025.xhtml#Fig_25-7)中，*l*[3].*h*、*l*[4].*h*、*l*[5].*h*和*l*[7].*h*的值减少了1，*r*[2].*h*和*r*[7].*h*的值增加了1，因为这些顶点在*F*中。因此，边(*l*[1],
    *r*[2])和(*l*[6], *r*[7])离开*G*[*M,h*]，边(*l*[5], *r*[3])进入。[图25.7(b)](chapter025.xhtml#Fig_25-7)展示了新的有向相等子图*G*[*M,h*]。现在，边(*l*[5],
    *r*[3])在*G*[*M,h*]中，[图25.7(c)](chapter025.xhtml#Fig_25-7)展示了这条边被添加到广度优先森林*F*中，*r*[3]被添加到队列中。部分(c)–(f)展示了广度优先森林继续构建，直到在部分(f)中，队列再次在移除没有离开的边的顶点*l*[2]后变为空。再次，算法必须更新可行顶点标记和有向相等子图。现在，三条边(*l*[1],
    *r*[6])、(*l*[5], *r*[6])和(*l*[7], *r*[6])实现了*δ* = 1的值。
- en: As [Figure 25.8](chapter025.xhtml#Fig_25-8) shows in parts (a) and (b), these
    edges enter *G*[*M,h*], and edge (*l*[6], *r*[3]) leaves. Part (c) shows that
    edge (*l*[1], *r*[6]) is added to the breadth-first forest. (Either of edges (*l*[5],
    *r*[6]) or (*l*[7], *r*[6]) could have been added instead.) Because *r*[6] is
    unmatched, the search has found the *M*-augmenting path 〈(*l*[5], *r*[3]), (*r*[3],
    *l*[1]), (*l*[1], *r*[6])〉, highlighted in orange.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图 25.8](chapter025.xhtml#Fig_25-8)在部分(a)和(b)中展示的那样，这些边进入*G*[M,h]，边(*l*[6],
    *r*[3])离开。部分(c)展示了边(*l*[1], *r*[6])添加到广度优先森林中。（也可以选择添加边(*l*[5], *r*[6])或(*l*[7],
    *r*[6)中的任意一条。）由于*r*[6]是未匹配的，搜索找到*M*增广路径〈(*l*[5], *r*[3])，(*r*[3], *l*[1])，(*l*[1],
    *r*[6])〉，用橙色标出。
- en: '[Figure 25.9(a)](chapter025.xhtml#Fig_25-9) shows *G*[*M,h*] after the matching
    *M* has been updated by taking its symmetric difference with the *M*-augmenting
    path. The Hungarian algorithm starts its last breadth-first search, with vertex
    *l*[7] as the only root. The search proceeds as shown in parts (b)–(h) of the
    figure, until the queue becomes empty after removing *l*[4]. This time, we find
    that *δ* = 2, achieved by the five edges (*l*[2], *r*[5]), (*l*[3], *r*[1]), (*l*[4],
    *r*[5]), (*l*[5], *r*[1]), and (*l*[5], *r*[5]), each of which enters *G*[*M,h*].
    [Figure 25.10(a)](chapter025.xhtml#Fig_25-10) shows the results of decreasing
    the feasible vertex label of each vertex in *F*[*L*] by 2 and increasing the feasible
    vertex label of each vertex in *F*[R] by 2, and [Figure 25.10(b)](chapter025.xhtml#Fig_25-10)
    shows the resulting directed equality subgraph *G*[*M,h*]. Part (c) shows that
    edge (*l*[3], *r*[1]) is added to the breadth-first forest. Since *r*[1] is an
    unmatched vertex, the search terminates, having found the *M*-augmenting path
    〈(*l*[7], *r*[7]), (*r*[7], *l*[3]), (*l*[3], *r*[1])〉, highlighted in orange.
    If *r*[1] had been matched, vertex *r*[5] would also have been added to the breadth-first
    forest, with any of *l*[2], *l*[4], or *l*[5] as its parent.'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 25.9(a)](chapter025.xhtml#Fig_25-9)展示了在匹配*M*通过取其与*M*增广路径的对称差更新后的*G*[M,h]。匈牙利算法以顶点*l*[7]作为唯一根开始其最后的广度优先搜索。搜索进行如图中的(b)–(h)部分所示，直到在移除*l*[4]后队列变为空。这次，我们发现*δ*
    = 2，通过五条边(*l*[2], *r*[5])、(*l*[3], *r*[1])、(*l*[4], *r*[5])、(*l*[5], *r*[1])和(*l*[5],
    *r*[5])实现，每条边进入*G*[M,h]。[图 25.10(a)](chapter025.xhtml#Fig_25-10)展示了将*F*[L]中每个顶点的可行顶点标记减少2，将*F*[R]中每个顶点的可行顶点标记增加2的结果，[图
    25.10(b)](chapter025.xhtml#Fig_25-10)展示了得到的有向等式子图*G*[M,h]。部分(c)展示了边(*l*[3], *r*[1])添加到广度优先森林中。由于*r*[1]是未匹配的顶点，搜索终止，找到*M*增广路径〈(*l*[7],
    *r*[7])，(*r*[7], *l*[3])，(*l*[3], *r*[1])〉，用橙色标出。如果*r*[1]已匹配，顶点*r*[5]也将被添加到广度优先森林中，其父节点可以是*l*[2]、*l*[4]或*l*[5]中的任意一个。'
- en: '![art](images/Art_P816.jpg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P816.jpg)'
- en: '**Figure 25.7** Updating the feasible vertex labeling and the directed equality
    subgraph *G*[*M,h*] when the queue becomes empty before finding an *M*-augmenting
    path. **(a)** With *δ* = 1, the values of *l*[3].*h*, *l*[4].*h*, *l*[5].*h*,
    and *l*[7].*h* decreased by 1 and *r*[2].*h* and *r*[7].*h* increased by 1\. Edges
    (*l*[1], *r*[2]) and (*l*[6], *r*[7]) leave *G*[*M,h*], and edge (*l*[5], *r*[3])
    enters. These changes are highlighted in yellow. **(b)** The resulting directed
    equality subgraph *G*[*M,h*]. **(c)–(f)** With edge (*l*[5], *r*[3]) added to
    the breadth-first forest and *r*[3] added to the queue, the breadth-first search
    continues until the queue once again becomes empty in part (f).'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 25.7** 在队列在找到*M*增广路径之前变为空时更新可行顶点标记和有向等式子图*G*[M,h]。**(a)** 当*δ* = 1时，*l*[3].*h*、*l*[4].*h*、*l*[5].*h*和*l*[7].*h*的值减少1，*r*[2].*h*和*r*[7].*h*增加1。边(*l*[1],
    *r*[2])和(*l*[6], *r*[7])离开*G*[M,h]，边(*l*[5], *r*[3])进入。这些变化用黄色标出。**(b)** 结果得到的有向等式子图*G*[M,h]。**(c)–(f)**
    边(*l*[5], *r*[3])添加到广度优先森林中，*r*[3]添加到队列中，广度优先搜索继续直到队列再次在部分(f)变为空。'
- en: After updating the matching *M*, the algorithm arrives at the perfect matching
    shown for the equality subgraph *G*[*h*] in [Figure 25.11](chapter025.xhtml#Fig_25-11).
    By Theorem 25.14, the edges in *M* form an optimal solution to the original assignment
    problem given in the matrix. Here, the weights of edges (*l*[1], *r*[6]), (*l*[2],
    *r*[4]), (*l*[3], *r*[1]), (*l*[4], *r*[2]), (*l*[5], *r*[3]), (*l*[6], *r*[5]),
    and (*l*[7], *r*[7]) sum to 65, which is the maximum weight of any matching.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新匹配*M*后，算法得到了在[图 25.11](chapter025.xhtml#Fig_25-11)中展示的等式子图*G*[h]的完美匹配。根据定理25.14，*M*中的边形成了给定矩阵中原始分配问题的最优解。这里，边(*l*[1],
    *r*[6])、(*l*[2], *r*[4])、(*l*[3], *r*[1])、(*l*[4], *r*[2])、(*l*[5], *r*[3])、(*l*[6],
    *r*[5])和(*l*[7], *r*[7])的权重总和为65，这是任何匹配的最大权重。
- en: The weight of the maximum-weight matching equals the sum of all the feasible
    vertex labels. These problems—maximizing the weight of a matching and minimizing
    the sum of the feasible vertex labels—are “duals” of each other, in a similar
    vein to how the value of a maximum flow equals the capacity of a minimum cut.
    [Section 29.3](chapter029.xhtml#Sec_29.3) explores duality in more depth.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 最大权重匹配的权重等于所有可行顶点标记的总和。这些问题——最大化匹配的权重和最小化可行顶点标记的总和——彼此是“对偶”的，类似于最大流的值等于最小割的容量。[第29.3节](chapter029.xhtml#Sec_29.3)更深入地探讨了对偶性。
- en: '![art](images/Art_P817.jpg)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P817.jpg)'
- en: '**Figure 25.8** Another update to the feasible vertex labeling and directed
    equality subgraph *G*[*M,h*] because the queue became empty before finding an
    *M*-augmenting path. **(a)** With *δ* = 1, the values of *l*[1].*h*, *l*[2].*h*,
    *l*[3].*h*, *l*[4].*h*, *l*[5].*h*, and *l*[7].*h* decrease by 1, and *r*[2].*h*,
    *r*[3].*h*, *r*[4].*h*, and *r*[7].*h* increase by 1\. Edge (*l*[6], *r*[3]) leaves
    *G*[*M,h*], and edges (*l*[1], *r*[6]), (*l*[5], *r*[6]) and (*l*[7], *r*[6])
    enter. **(b)** The resulting directed equality subgraph *G*[*M,h*]. **(c)** With
    edge (*l*[1], *r*[6]) added to the breadth-first forest and *r*[6] unmatched,
    the search terminates, having found the *M*-augmenting path 〈(*l*[5], *r*[3]),
    (*r*[3], *l*[1]), (*l*[1], *r*[6])〉, highlighted in orange in parts (b) and (c).'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**图25.8** 可行顶点标记和有向相等子图*G*[*M,h*]的另一个更新，因为在找到*M*增广路径之前队列变为空了。**(a)** 当*δ* =
    1时，*l*[1].*h*、*l*[2].*h*、*l*[3].*h*、*l*[4].*h*、*l*[5].*h*和*l*[7].*h*的值减少1，*r*[2].*h*、*r*[3].*h*、*r*[4].*h*和*r*[7].*h*增加1。边(*l*[6],
    *r*[3])离开*G*[*M,h*]，边(*l*[1], *r*[6])、(*l*[5], *r*[6])和(*l*[7], *r*[6])进入。**(b)**
    结果得到的有向相等子图*G*[*M,h*]。**(c)** 添加边(*l*[1], *r*[6])到广度优先树中，*r*[6]未匹配，搜索终止，找到*M*增广路径〈(*l*[5],
    *r*[3]), (*r*[3], *l*[1]), (*l*[1], *r*[6])〉，在(b)和(c)部分用橙色突出显示。'
- en: '**The Hungarian algorithm**'
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: '**匈牙利算法**'
- en: The procedure HUNGARIAN on page 737 and its subroutine FIND-AUGMENTING-PATH
    on page 738 follow the steps we have just seen. The third property in Lemma 25.15
    ensures that in line 23 of FIND-AUGMENTING-PATH the queue *Q* is nonempty. The
    pseudocode uses the attribute *π* to indicate predecessor vertices in the breadth-first
    forest. Instead of coloring vertices, as in the BFS procedure on page 556, the
    search puts the discovered vertices into the sets *F*[*L*] and *F*[*R*]. Because
    the Hungarian algorithm does not need breadth-first distances, the pseudocode
    omits the *d* attribute computed by the BFS procedure.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在第737页的HUNGARIAN过程及其第738页的FIND-AUGMENTING-PATH子程序遵循我们刚刚看到的步骤。引理25.15中的第三个属性确保在FIND-AUGMENTING-PATH的第23行中队列*Q*非空。伪代码使用属性*π*指示广度优先树中的前驱顶点。与第556页的BFS过程中着色顶点不同，搜索将发现的顶点放入集合*F*[*L*]和*F*[*R*]中。由于匈牙利算法不需要广度优先距离，伪代码省略了BFS过程计算的*d*属性。
- en: '![art](images/Art_P818.jpg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P818.jpg)'
- en: '**Figure 25.9 (a)** The new matching *M* and the new directed equality subgraph
    *G*[*M,h*] after updating the matching in [Figure 25.8](chapter025.xhtml#Fig_25-8)
    with the *M*-augmenting path in [Figure 25.8](chapter025.xhtml#Fig_25-8) parts
    (b) and (c). **(b)–(h)** Successive versions of the breadth-first forest *F* in
    a new breadth-first search with root *l*[7]. After the vertex *l*[4] in part (h)
    has been removed from the queue, the queue becomes empty before the search discovers
    an unmatched vertex in *R*.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '**图25.9 (a)** 新匹配*M*和新的有向相等子图*G*[*M,h*]在使用[图25.8](chapter025.xhtml#Fig_25-8)中的*M*增广路径更新匹配后的情况。**(b)-(h)**
    以根为*l*[7]进行新的广度优先搜索的连续版本的广度优先树*F*。在(h)部分中移除了顶点*l*[4]后，队列在搜索发现*R*中未匹配顶点之前变为空。'
- en: Now, let’s see why the Hungarian algorithm runs in *O*(*n*⁴) time, where |*V*|
    = *n*/2 and |*E*| = *n*² in the original graph *G*. (Below we outline how to reduce
    the running time to *O*(*n*³).) You can go through the pseudocode of HUNGARIAN
    to verify that lines 1–6 and 11 take *O*(*n*²) time. The **while** loop of lines
    7–10 iterates at most *n* times, since each iteration increases the size of the
    matching *M* by 1\. Each test in line 7 can take constant time by just checking
    whether |*M*| < *n*, each update of *M* in line 9 takes *O*(*n*) time, and the
    updates in line 10 take *O*(*n*²) time.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看匈牙利算法为什么在*O*(*n*⁴)时间内运行，其中|*V*| = *n*/2，|*E*| = *n*²在原始图*G*中。（下面我们概述如何将运行时间减少到*O*(*n*³)。）您可以查看HUNGARIAN的伪代码，以验证第1-6行和第11行需要*O*(*n*²)时间。第7-10行的**while**循环最多迭代*n*次，因为每次迭代都会将匹配*M*的大小增加1。第7行的每个测试只需检查|*M*|
    < *n*，每次在第9行更新*M*需要*O*(*n*)时间，第10行的更新需要*O*(*n*²)时间。
- en: To achieve the *O*(*n*⁴) time bound, it remains to show that each call of FIND-AUGMENTING-PATH
    runs in *O*(*n*³) time. Let’s call each execution of lines 10–22 a ***growth step***.
    Ignoring the growth steps, you can verify that FIND-AUGMENTING-PATH is a breadth-first
    search. With the sets *F*[*L*] and *F*[*R*] represented appropriately, the breadth-first
    search takes *O*(*V* + *E*) = *O*(*n*²) time. Within a call of FIND-AUGMENTING-PATH,
    at most *n* growth steps can occur, since each growth step is guaranteed to discover
    at least one vertex in *R*. Since there are at most *n*² edges in *G*[*M,h*],
    the **for** loop of lines 16–22 iterates at most *n*² times per call of FIND-AUGMENTING-PATH.
    The bottleneck is lines 10 and 15, which take *O*(*n*²) time, so that FIND-AUGMENTING-PATH
    takes *O*(*n*³) time.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现*O*(*n*⁴)时间界限，仍需展示每次调用FIND-AUGMENTING-PATH在*O*(*n*³)时间内运行。让我们将第10-22行的每次执行称为***增长步骤***。忽略增长步骤，您可以验证FIND-AUGMENTING-PATH是一种广度优先搜索。通过适当表示*F*[*L*]和*F*[*R*]集合，广度优先搜索需要*O*(*V*
    + *E*) = *O*(*n*²)时间。在FIND-AUGMENTING-PATH的每次调用中，最多可以发生*n*个增长步骤，因为每个增长步骤都保证至少发现一个*R*中的顶点。由于*G*[*M,h*]中最多有*n*²条边，第16-22行的**for**循环在每次调用FIND-AUGMENTING-PATH时最多迭代*n*²次。瓶颈在于第10行和第15行，需要*O*(*n*²)时间，因此FIND-AUGMENTING-PATH需要*O*(*n*³)时间。
- en: '![art](images/Art_P819.jpg)'
  id: totrans-326
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P819.jpg)'
- en: '**Figure 25.10** Updating the feasible vertex labeling and directed equality
    subgraph *G*[*M,h*]. **(a)** Here, *δ* = 2, so the values of *l*[1].*h*, *l*[2].*h*,
    *l*[3].*h*, *l*[4].*h*, *l*[5].*h*, and *l*[7].*h* decreased by 2, and the values
    of *r*[2].*h*, *r*[3].*h*, *r*[4].*h*, *r*[6].*h*, and *r*[7].*h* increased by
    2\. Edges (*l*[2], *r*[5]), (*l*[3], *r*[1]), (*l*[4], *r*[5]), (*l*[5], *r*[1]),
    and (*l*[5], *r*[5]) enter *G*[*M,h*]. **(b)** The resulting directed graph *G*[*M,h*].
    **(c)** With edge (*l*[3], *r*[1]) added to the breadth-first forest and *r*[1]
    unmatched, the search terminates, having found the *M*-augmenting path 〈(*l*[7],
    *r*[7]), (*r*[7], *l*[3]), (*l*[3], *r*[1])〉, highlighted in orange in parts (b)
    and (c).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 25.10** 更新可行顶点标记和有向相等子图 *G*[*M,h*]。 **(a)** 这里，*δ* = 2，因此 *l*[1].*h*、*l*[2].*h*、*l*[3].*h*、*l*[4].*h*、*l*[5].*h*
    和 *l*[7].*h* 的值减少了 2，*r*[2].*h*、*r*[3].*h*、*r*[4].*h*、*r*[6].*h* 和 *r*[7].*h*
    的值增加了 2。 边 (*l*[2], *r*[5])、(*l*[3], *r*[1])、(*l*[4], *r*[5])、(*l*[5], *r*[1])
    和 (*l*[5], *r*[5]) 进入 *G*[*M,h*]。 **(b)** 结果得到的有向图 *G*[*M,h*]。 **(c)** 将边 (*l*[3],
    *r*[1]) 添加到广度优先树中，且 *r*[1] 未匹配，搜索终止，找到了 *M* 增广路径 〈(*l*[7], *r*[7]), (*r*[7], *l*[3]),
    (*l*[3], *r*[1])〉，在部分 (b) 和 (c) 中用橙色突出显示。'
- en: Exercise 25.3-5 asks you to show that reconstructing the directed equality subgraph
    *G*[*M,h*] in line 15 is actually unnecessary, so that its cost can be eliminated.
    Reducing the cost of computing *δ* in line 10 to *O*(*n*) takes a little more
    effort and is the subject of Problem 25-2\. With these changes, each call of FIND-AUGMENTING-PATH
    takes *O*(*n*²) time, so that the Hungarian algorithm runs in *O*(*n*³) time.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 25.3-5 要求你展示，在第 15 行重建有向相等子图 *G*[*M,h*] 实际上是不必要的，因此其成本可以被消除。将第 10 行中计算 *δ*
    的成本降低到 *O*(*n*) 需要更多的努力，这是问题 25-2 的主题。通过这些改变，每次调用 FIND-AUGMENTING-PATH 需要 *O*(*n*²)
    的时间，因此匈牙利算法的运行时间为 *O*(*n*³)。
- en: '![art](images/Art_P820.jpg)'
  id: totrans-329
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P820.jpg)'
- en: '**Figure 25.11** The final matching, shown for the equality subgraph *G*[*h*]
    with blue edges and blue entries in the matrix. The weights of the edges in the
    matching sum to 65, which is the maximum for any matching in the original complete
    bipartite graph *G*, as well as the sum of all the final feasible vertex labels.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 25.11** 最终匹配，显示了具有蓝色边和矩阵中蓝色条目的相等子图 *G*[*h*]。 匹配中边的权重总和为 65，这是原始完全二部图 *G*
    中任何匹配的最大值，也是所有最终可行顶点标签的总和。'
- en: HUNGARIAN (*G*)
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 匈牙利算法 (*G*)
- en: '|   1 | **for** each vertex *l* ∈ *L* |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '|   1 | **对于** 每个顶点 *l* ∈ *L*'
- en: '|   2 | *l*.*h* = max {*w*(*l*, *r*) : *r* ∈ *R*} | **//** from equation (25.1)
    |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '|   2 | *l*.*h* = max {*w*(*l*, *r*) : *r* ∈ *R*} | **//** 来自方程式（25.1）'
- en: '|   3 | **for** each vertex *r* ∈ *R* |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '|   3 | **对于** 每个顶点 *r* ∈ *R*'
- en: '|   4 | *r*.*h* = 0 | **//** from equation (25.2) |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '|   4 | *r*.*h* = 0 | **//** 来自方程式（25.2）'
- en: '|   5 | let *M* be any matching in *G*[*h*] (such as the matching returned
    by |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '|   5 | 让 *M* 成为 *G*[*h*] 中的任意匹配（例如由图 25.11 返回的匹配）'
- en: '|  | GREEDY-BIPARTITE-MATCHING) |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '|  | 贪婪二部图匹配）'
- en: '|   6 | from *G*, *M*, and *h*, form the equality subgraph *G*[*h*] |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '|   6 | 从 *G*、*M* 和 *h* 中，形成相等子图 *G*[*h*]'
- en: '|  | and the directed equality subgraph *G*[*M,h*] |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '|  | 以及有向相等子图 *G*[*M,h*] '
- en: '|   7 | **while** *M* is not a perfect matching in *G*[*h*] |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '|   7 | **当** *M* 不是 *G*[*h*] 中的完美匹配时'
- en: '|   8 | *P* = FIND-AUGMENTING-PATH (*G*[*M,h*]) |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '|   8 | *P* = FIND-AUGMENTING-PATH (*G*[*M,h*])'
- en: '|   9 | *M* = *M* ⊕ *P* |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '|   9 | *M* = *M* ⊕ *P* '
- en: '| 10 | update the equality subgraph *G*[*h*] |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 更新相等子图 *G*[*h*]'
- en: '|  | and the directed equality subgraph *G*[*M,h*] |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '|  | 以及有向相等子图 *G*[*M,h*]'
- en: '| 11 | **return** *M* |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 11 | **返回** *M*'
- en: FIND-AUGMENTING-PATH (*G*[*M,h*])
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: FIND-AUGMENTING-PATH (*G*[*M,h*])
- en: '|   1 | *Q* = Ø |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '|   1 | *Q* = Ø '
- en: '|   2 | *F*[*L*] = Ø |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '|   2 | *F*[*L*] = Ø '
- en: '|   3 | *F*[*R*] = Ø |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '|   3 | *F*[*R*] = Ø '
- en: '|   4 | **for** each unmatched vertex *l* ∈ *L* |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '|   4 | **对于** 每个未匹配的顶点 *l* ∈ *L*'
- en: '|   5 | *l*.*π* = NIL |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '|   5 | *l*.*π* = NIL '
- en: '|   6 | ENQUEUE (*Q*, *l*) |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|   6 | 入队 (*Q*, *l*) '
- en: '|   7 | *F*[*L*] = *F*[*L*] ∪ {*l*} | **//** forest *F* starts with unmatched
    vertices in *L* |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '|   7 | *F*[*L*] = *F*[*L*] ∪ {*l*} | **//** 森林 *F* 从 *L* 中未匹配的顶点开始'
- en: '|   8 | **repeat** |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '|   8 | **重复**'
- en: '|   9 | **if** *Q* is empty | **//** ran out of vertices to search from? |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '|   9 | **如果** *Q* 为空 | **//** 已经没有顶点可以搜索了？'
- en: '| 10 | *δ* = min {*l*.*h* + *r*.*h* − *w*(*l*, *r*) : *l* ∈ *F*[*L*] and *r*
    ∈ *R* − *F*[*R*]} |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| 10 | *δ* = min {*l*.*h* + *r*.*h* − *w*(*l*, *r*) : *l* ∈ *F*[*L*] and *r*
    ∈ *R* − *F*[*R*]}'
- en: '| 11 | **for** each vertex *l* ∈ *F*[*L*] |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| 11 | **对于** 每个顶点 *l* ∈ *F*[*L*]'
- en: '| 12 | *l*.*h* = *l*.*h* − *δ* | **//** relabel according to equation (25.5)
    |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| 12 | *l*.*h* = *l*.*h* − *δ* | **//** 根据方程式（25.5）重新标记'
- en: '| 13 | **for** each vertex *r* ∈ *F*[*R*] |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| 13 | **对于** 每个顶点 *r* ∈ *F*[*R*]'
- en: '| 14 | *r*.*h* = *r*.*h* + *δ* | **//** relabel according to equation (25.5)
    |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| 14 | *r*.*h* = *r*.*h* + *δ* | **//** 根据方程式（25.5）重新标记'
- en: '| 15 | from *G*, *M*, and *h*, form a new directed equality graph *G*[*M,h*]
    |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| 15 | 从 *G*、*M* 和 *h* 中，形成一个新的有向相等图 *G*[*M,h*]'
- en: '| 16 | **for** each new edge (*l*, *r*) in *G*[*M,h*] | **//** continue search
    with new edges |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| 16 | **对于** 每条新边 (*l*, *r*) 在 *G*[*M,h*] 中 | **//** 继续搜索新边'
- en: '| 17 | **if** *r* ∉ *F*[*R*] |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| 17 | **如果** *r* ∉ *F*[*R*]'
- en: '| 18 | *r*.*π* = *l* | **//** discover *r*, add it to F |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| 18 | *r*.*π* = *l* | **//** 发现 *r*，将其加入到 F 中 '
- en: '| 19 | **if** *r* is unmatched |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| 19 | **如果** *r* 未匹配'
- en: '| 20 | an *M*-augmenting path has been found |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| 20 | 找到了一条 *M* 增广路径 '
- en: '| 20 | (exit the **repeat** loop) |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| 20 | （退出 **repeat** 循环）'
- en: '| 21 | **else** ENQUEUE (*Q*, *r*) | **//** can search from *r* later |'
  id: totrans-368
  prefs: []
  type: TYPE_TB
  zh: '| 21 | **否则** 入队 (*Q*, *r*) | **//** 以后可以从 *r* 开始搜索 '
- en: '| 22 | *F[R]* = *F*[*R*] ∪ {*r*} |'
  id: totrans-369
  prefs: []
  type: TYPE_TB
  zh: '| 22 | *F[R]* = *F*[*R*] ∪ {*r*}'
- en: '| 23 | *u* = DEQUEUE (*Q*) | **//** search from *u* |'
  id: totrans-370
  prefs: []
  type: TYPE_TB
  zh: '| 23 | *u* = 出队 (*Q*) | **//** 从 *u* 开始搜索'
- en: '| 24 | **for** each neighbor *v* of *u* in *G*[*M,h*] |'
  id: totrans-371
  prefs: []
  type: TYPE_TB
  zh: '| 24 | **对于** *u* 在 *G*[*M,h*] 中的每个邻居 *v*'
- en: '| 25 | **if** *v* ∈ *L* |'
  id: totrans-372
  prefs: []
  type: TYPE_TB
  zh: '| 25 | **如果** *v* ∈ *L*'
- en: '| 26 | *v.π* = *u* |'
  id: totrans-373
  prefs: []
  type: TYPE_TB
  zh: '| 26 | *v.π* = *u*'
- en: '| 27 | *F*[*L*] = *F*[*L*] ∪ {*v*} | **//** discover *v*, add it to *F* |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| 27 | *F*[*L*] = *F*[*L*] ∪ {*v*} | **//** 发现 *v*，将其加入到 *F* 中'
- en: '| 28 | ENQUEUE (*Q*, *v*) | **//** can search from *v* later |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '| 28 | 入队 (*Q*, *v*) | **//** 以后可以从 *v* 开始搜索'
- en: '| 29 | **elseif** *v* ∉ *F*[*R*] | **//** *v* ∈ *R*, do same as lines 18–22
    |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '| 29 | **否则如果** *v* ∉ *F*[*R*] | **//** *v* ∈ *R*，执行与第 18–22 行相同的操作'
- en: '| 30 | *v.π* = *u* |'
  id: totrans-377
  prefs: []
  type: TYPE_TB
  zh: '| 30 | *v.π* = *u*'
- en: '| 31 | **if** *v* is unmatched |'
  id: totrans-378
  prefs: []
  type: TYPE_TB
  zh: '| 31 | **如果** *v* 未匹配 '
- en: '| 32 | an *M*-augmenting path has been found |'
  id: totrans-379
  prefs: []
  type: TYPE_TB
  zh: '| 32 | 找到了一条 *M* 增广路径 '
- en: '|  | (exit the **repeat** loop) |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '|  | （退出 **repeat** 循环）'
- en: '| 33 | **else** ENQUEUE (*Q*, *v*) |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '| 33 | **否则** 入队 (*Q*, *v*) |'
- en: '| 34 | *F[R]* = *F*[*R*] ∪ {*v*} |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| 34 | *F[R]* = *F*[*R*] ∪ {*v*} |'
- en: '| 35 | **until** an *M*-augmenting path has been found |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '| 35 | **直到** 找到一个 *M*-增广路径为止 |'
- en: '| 36 | using the predecessor attributes *π*, construct an *M*-augmenting path
    *P* by tracing back from the unmatched vertex in *R* |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '| 36 | 使用前驱属性 *π*，从 *R* 中未匹配的顶点开始回溯构建一个 *M*-增广路径 *P* |'
- en: '| 37 | **return** *P* |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '| 37 | **返回** *P* |'
- en: '**Exercises**'
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***25.3-1***'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: '***25.3-1***'
- en: The FIND-AUGMENTING-PATH procedure checks in two places (lines 19 and 31) whether
    a vertex it discovers in *R* is unmatched. Show how to rewrite the pseudocode
    so that it checks for an unmatched vertex in *R* in only one place. What is the
    downside of doing so?
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: FIND-AUGMENTING-PATH过程在两个地方（第19行和第31行）检查它在 *R* 中发现的顶点是否未匹配。展示如何重写伪代码，以便只在一个地方检查
    *R* 中的未匹配顶点。这样做的缺点是什么？
- en: '***25.3-2***'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '***25.3-2***'
- en: Show that for any bipartite graph, the GREEDY-BIPARTITE-MATCHING procedure on
    page 726 returns a matching at least half the size of a maximum matching.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 证明对于任何二分图，第726页的GREEDY-BIPARTITE-MATCHING过程返回的匹配至少是最大匹配大小的一半。
- en: '***25.3-3***'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '***25.3-3***'
- en: Show that if an edge (*l*, *r*) belongs to the directed equality subgraph *G*[*M,h*]
    but is not a member of *G*[*M,h*′], where *h*′ is given by equation (25.5), then
    *l* ∈ *L* − *F*[*L*] and *r* ∈ *F*[*R*] at the time that *h*′ is computed.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 证明如果一条边 (*l*, *r*) 属于有向等权子图 *G*[*M,h*] 但不是 *G*[*M,h*′] 的成员，其中 *h*′ 由方程(25.5)给出，则在计算
    *h*′ 时，*l* ∈ *L* − *F*[*L*] 且 *r* ∈ *F*[*R*]。
- en: '***25.3-4***'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '***25.3-4***'
- en: At line 29 in the FIND-AUGMENTING-PATH procedure, it has already been established
    that *v* ∈ *R*. This line checks to see whether *v* is already discovered by testing
    whether *v* ∈ *F*[*R*]. Why doesn’t the procedure need to check whether *v* is
    already discovered for the case when *v* ∈ *L*, in lines 26–28?
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 在FIND-AUGMENTING-PATH过程的第29行，已经确定 *v* ∈ *R*。这一行检查 *v* 是否已被发现，通过测试 *v* 是否 ∈ *F*[*R*]。为什么该过程在
    *v* ∈ *L* 的情况下不需要检查 *v* 是否已被发现，即在第26-28行？
- en: '***25.3-5***'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '***25.3-5***'
- en: Professor Hrabosky asserts that the directed equality subgraph *G*[*M,h*] must
    be constructed and maintained by the Hungarian algorithm, so that line 6 of HUNGARIAN
    and line 15 of FIND-AUGMENTING-PATH are required. Argue that the professor is
    incorrect by showing how to determine whether an edge belongs to *E*[*M,h*] without
    explicitly constructing *G*[*M,h*].
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: Hrabosky教授断言匈牙利算法必须构建和维护有向等权子图 *G*[*M,h*]，因此HUNGARIAN的第6行和FIND-AUGMENTING-PATH的第15行是必需的。通过展示如何确定一条边是否属于
    *E*[*M,h*] 而无需显式构建 *G*[*M,h*]，来证明教授是错误的。
- en: '***25.3-6***'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '***25.3-6***'
- en: How can you modify the Hungarian algorithm to find a matching of vertices in
    *L* to vertices in *R* that minimizes, rather than maximizes, the sum of the edge
    weights in the matching?
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 如何修改匈牙利算法以找到将 *L* 中的顶点与 *R* 中的顶点匹配的匹配，使得匹配中边权重的总和最小，而不是最大？
- en: '***25.3-7***'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: '***25.3-7***'
- en: How can an assignment problem with |*L*| ≠ |*R*| be modified so that the Hungarian
    algorithm solves it?
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 如何修改一个具有 |*L*| ≠ |*R*| 的分配问题，以便匈牙利算法解决它？
- en: '**Problems**'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '***25-1     Perfect matchings in a regular bipartite graph***'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '***25-1     正则二分图中的完美匹配***'
- en: '***a.*** Problem 20-3 asked about Euler tours in directed graphs. Prove that
    a connected, *undirected* graph *G* = (*V*, *E*) has an Euler tour—a cycle traversing
    each edge exactly once, though it may visit a vertex multiple times—if and only
    if the degree of every vertex in *V* is even.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 问题20-3询问了有向图中的欧拉路径。证明一个连通的、*无向*图 *G* = (*V*, *E*) 有一个欧拉路径——一个遍历每条边恰好一次的循环，尽管它可能多次访问一个顶点——当且仅当
    *V* 中每个顶点的度数都是偶数。'
- en: '***b.*** Assuming that *G* is connected, undirected, and every vertex in *V*
    has even degree, give an *O*(*E*)-time algorithm to find an Euler tour of *G*,
    as in Problem 20-3(b).'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 假设 *G* 是连通的、无向的，并且 *V* 中的每个顶点度数都是偶数，给出一个在 *O*(*E*) 时间内找到 *G* 的欧拉路径的算法，如问题20-3(b)中所述。'
- en: '***c.*** Exercise 25.1-6 states that if *G* = (*V*, *E*) is a *d*-regular bipartite
    graph, then it contains *d* disjoint perfect matchings. Suppose that *d* is an
    exact power of 2\. Give an algorithm to find all *d* disjoint perfect matchings
    in a *d*-regular bipartite graph in Θ(*E* lg *d*) time.'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 练习25.1-6指出，如果 *G* = (*V*, *E*) 是一个 *d*-正则二分图，则它包含 *d* 个不相交的完美匹配。假设
    *d* 是2的幂。给出一个算法，在Θ(*E* lg *d*)时间内找到 *d* 个不相交的完美匹配。'
- en: '***25-2     Reducing the running time of the Hungarian algorithm to O*(*n*³)**'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '***25-2     将匈牙利算法的运行时间降至 *O*(*n*³)***'
- en: In this problem, you will show how to reduce the running time of the Hungarian
    algorithm from *O*(*n*⁴) to *O*(*n*³) by showing how to reduce the running time
    of the FIND-AUGMENTING-PATH procedure from *O*(*n*³) to *O*(*n*²). Exercise 25.3-5
    demonstrates that line 6 of HUNGARIAN and line 15 of FIND-AUGMENTING-PATH are
    unnecessary. Now you will show how to reduce the running time of each execution
    of line 10 in FIND-AUGMENTING-PATH to *O*(*n*).
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，您将展示如何通过将FIND-AUGMENTING-PATH过程的运行时间从 *O*(*n*³) 减少到 *O*(*n*²) 来将匈牙利算法的运行时间从
    *O*(*n*⁴) 减少到 *O*(*n*³)。练习25.3-5证明了HUNGARIAN的第6行和FIND-AUGMENTING-PATH的第15行是不必要的。现在您将展示如何将FIND-AUGMENTING-PATH的第10行的每次执行的运行时间减少到
    *O*(*n*)。
- en: For each vertex *r* ∈ *R* − *F*[*R*], define a new attribute *r.σ* where
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个 *r* ∈ *R* − *F*[*R*]，定义一个新属性 *r.σ*，其中
- en: '*r.σ* = min {*l*.*h* + *r*.*h* − *w*(*l*, *r*) : *l* ∈ *F*[*L*]}.'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: '*r.σ* = min {*l*.*h* + *r*.*h* − *w*(*l*, *r*) : *l* ∈ *F*[*L*]}。'
- en: That is, *r.σ* indicates how close *r* is to being adjacent to some vertex *l*
    ∈ *F*[*L*] in the directed equality subgraph *G*[*m,h*]. Initially, before placing
    any vertices into *F*[*L*], set *r.σ* to ∞ for all *r* ∈ *R*.
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: ���句话说，*r.σ* 表示 *r* 距离有向等权子图 *G*[*m,h*] 中的某个顶点 *l* ∈ *F*[*L*] 有多近。最初，在将任何顶点放入
    *F*[*L*] 之前，对所有 *r* ∈ *R* 将 *r.σ* 设置为 ∞。
- en: '***a.*** Show how to compute *δ* in line 10 in *O*(*n*) time, based on the
    *σ* attribute.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 展示如何基于 *σ* 属性在第10行中在 *O*(*n*)时间内计算 *δ*。'
- en: '***b.*** Show how to update all the *σ* attributes in *O*(*n*) time after *δ*
    has been computed.'
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 展示如何在计算完 *δ* 后，在 *O*(*n*)时间内更新所有 *σ* 属性。'
- en: '***c.*** Show that updating all the *σ* attributes when *F*[*L*] changes takes
    *O*(*n*²) time per call of FIND-AUGMENTING-PATH.'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 显示当 *F*[*L*] 改变时更新所有 *σ* 属性每次调用 FIND-AUGMENTING-PATH 需要 *O*(*n*²)
    的时间。'
- en: '***d.*** Conclude that the HUNGARIAN procedure can be implemented to run in
    *O*(*n*³) time.'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 得出结论，匈牙利程序可以实现在 *O*(*n*³) 的时间内运行。'
- en: '***25-3     Other matching problems***'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '***25-3     其他匹配问题***'
- en: The Hungarian algorithm finds a maximum-weight perfect matching in a complete
    bipartite graph. It is possible to use the Hungarian algorithm to solve problems
    in other graphs by modifying the input graph, running the Hungarian algorithm,
    and then possibly modifying the output. Show how to solve the following matching
    problems in this manner.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 匈牙利算法在完全二分图中找到最大权重完美匹配。可以通过修改输入图形，运行匈牙利算法，然后可能修改输出来解决其他图形中的问题。展示如何以这种方式解决以下匹配问题。
- en: '***a.*** Give an algorithm to find a maximum-weight matching in a weighted
    bipartite graph that is not necessarily complete and with all edge weights positive.'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 给出一个算法，在不一定完全且所有边权重为正的加权二分图中找到最大权重匹配。'
- en: '***b.*** Redo part (a), but with edge weights allowed to also be 0 or negative.'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 重新进行（a）部分，但允许边权重也可以为0或负数。'
- en: '***c.*** A ***cycle cover*** in a directed graph, not necessarily bipartite,
    is a set of edge-disjoint directed cycles such that each vertex lies on at most
    one cycle. Given nonnegative edge weights *w*(*u*, *v*), let *C* be the set of
    edges in a cycle cover, and define *w*(*C*) = ∑[(*u,v*)∈*C*] *w*(*u, v*) to be
    the weight of the cycle cover. Give an algorithm to find a maximum-weight cycle
    cover.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 在有向图中定义一个***循环覆盖***，不一定是二分的，是一组边不相交的有向循环，使得每个顶点最多位于一个循环上。给定非负边权重 *w*(*u*,
    *v*)，让 *C* 是循环覆盖中的边的集合，并定义 *w*(*C*) = ∑[(*u,v*)∈*C*] *w*(*u, v*) 为循环覆盖的权重。给出一个找到最大权重循环覆盖的算法。'
- en: '***25-4     Fractional matchings***'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '***25-4     分数匹配***'
- en: 'It is possible to define a ***fractional matching***. Given a graph *G* = (*V*,
    *E*), we define a fractional matching *x* as a function *x* : *E* → [0, 1] (real
    numbers between 0 and 1, inclusive) such that for every vertex *u* ∈ *V*, we have
    ∑[(*u,v*)∈*E*] *x*(*u, v*) ≤ 1\. The value of a fractional matching is ∑[(*u,
    v*)∈*E*] *x*(*u, v*). The definition of a fractional matching is identical to
    that of a matching, except that a matching has the additional constraint that
    *x*(*u*, *v*) ∈ {0, 1} for all edges (*u*, *v*) ∈ *E*. Given a graph, we let *M**
    denote a maximum matching and *x** denote a fractional matching with maximum value.'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '可以定义一个***分数匹配***。给定一个图 *G* = (*V*, *E*)，我们将分数匹配 *x* 定义为一个函数 *x* : *E* → [0,
    1]（0到1之间的实数，包括0和1），使得对于���个顶点 *u* ∈ *V*，我们有 ∑[(*u,v*)∈*E*] *x*(*u, v*) ≤ 1。分数匹配的值是
    ∑[(*u, v*)∈*E*] *x*(*u, v*)。分数匹配的定义与匹配的定义相同，只是匹配有额外的约束条件，即对于所有边 (*u*, *v*) ∈ *E*，*x*(*u*,
    *v*) ∈ {0, 1}。给定一个图形，让 *M** 表示最大匹配，*x** 表示具有最大值的分数匹配。'
- en: '***a.*** Argue that, for any bipartite graph, we must have ∑[(*u, v*)∈*E*] *x**(*u,
    v*) ≥ |*M*|.*'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 论证对于任意二分图，我们必须有 ∑[(*u, v*)∈*E*] *x**(*u, v*) ≥ |*M*|.*'
- en: '***b.*** Prove that, for any bipartite graph, we must have ∑[(*u, v*)∈*E*] *x**(*e*)
    ≤ |*M*|.* (*Hint:* Give an algorithm that converts a fractional matching with
    an integer value to a matching.) Conclude that the maximum value of a fractional
    matching in a bipartite graph is the same as the size of the maximum cardinality
    matching.'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 证明对于任意二分图，我们必须有 ∑[(*u, v*)∈*E*] *x**(*e*) ≤ |*M*|.*（提示：给出一个算法，将具有整数值的分数匹配转换为匹配。）得出结论：二分图中分数匹配的最大值与最大基数匹配的大小相同。'
- en: '***c.*** We can define a fractional matching in a weighted graph in the same
    manner: the value of the matching is now ∑[(*u, v*)∈*E*] *w*(*u, v*) *x*(*u, v*).
    Extend the results of the previous parts to show that in a weighted bipartite
    graph, the maximum value of a weighted fractional matching is equal to the value
    of a maximum weighted matching.'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 我们可以以相同方式在加权图中定义分数匹配：匹配的值现在是 ∑[(*u, v*)∈*E*] *w*(*u, v*) *x*(*u, v*)。扩展先前部分的结果，以显示在加权二分图中，加权分数匹配的最大值等于最大加权匹配的值。'
- en: '***d.*** In a general graph, the analogous results do not necessarily hold.
    Give an example of a small graph that is not bipartite for which the fractional
    matching with maximum value is not a maximum matching.'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 在一般图中，类似的结果不一定成立。给出一个不是二分的小图的例子，其中最大值的分数匹配不是最大匹配。'
- en: '***25-5     Computing vertex labels***'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: '***25-5     计算顶点标签***'
- en: You are given a complete bipartite graph *G* = (*V*, *E*) with edge weights
    *w*(*l*, *r*) for all (*l*, *r*) ∈ *E*. You are also given a maximum-weight perfect
    matching *M** for *G*. You wish to compute a feasible vertex labeling *h* such
    that *M** is a perfect matching in the equality subgraph *G*[*h*]. That is, you
    want to compute a labeling *h* of vertices such that
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个完全二分图 *G* = (*V*, *E*)，对于所有 (*l*, *r*) ∈ *E*，边权重为 *w*(*l*, *r*)。还给定了 *G*
    的最大权重完美匹配 *M**。您希望计算一个可行的顶点标记 *h*，使得 *M** 是等式子图 *G*[*h*] 中的完美匹配。也就是说，您想要计算一个顶点的标记
    *h*，使得
- en: '![art](images/Art_P821.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P821.jpg)'
- en: (Requirement (25.6) holds for all edges, and the stronger requirement (25.7)
    holds for all edges in *M**.) Give an algorithm to compute the feasible vertex
    labeling *h*, and prove that it is correct. (*Hint:* Use the similarity between
    conditions (25.6) and (25.7) and some of the properties of shortest paths proved
    in [Chapter 22](chapter022.xhtml), in particular the triangle inequality (Lemma
    22.10) and the convergence property (Lemma 22.14.))
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: （对于所有边，要求 (25.6) 成立，并且对于 *M** 中的所有边，更强的要求 (25.7) 成立。）给出一个计算可行顶点标记 *h* 的算法，并证明其正确性。（提示：使用条件
    (25.6) 与 (25.7) 之间的相似性以及[第22章](chapter022.xhtml)中证明的最短路径的一些性质，特别是三角不等式（引理22.10）和收敛性质（引理22.14）。）
- en: '**Chapter notes**'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节注释**'
- en: Matching algorithms have a long history and have been central to many breakthroughs
    in algorithm design and analysis. The book by Lovász and Plummer [[306](bibliography001.xhtml#endnote_306)]
    is an excellent reference on matching problems, and the chapter on matching in
    the book by Ahuja, Magnanti and Orlin [[10](bibliography001.xhtml#endnote_10)]
    also has extensive references.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配算法有着悠久的历史，并且在算法设计和分析的许多突破中起着核心作用。Lovász和Plummer的书籍[[306](bibliography001.xhtml#endnote_306)]是匹配问题的优秀参考资料，而Ahuja、Magnanti和Orlin的书中关于匹配的章节[[10](bibliography001.xhtml#endnote_10)]也有大量参考资料。
- en: The Hopcroft-Karp algorithm is by Hopcroft and Karp [[224](bibliography001.xhtml#endnote_224)].
    Madry [[308](bibliography001.xhtml#endnote_308)] gave an *Õ*(*E*^(10/7))-time
    algorithm, which is asymptotically faster than Hopcroft-Karp for sparse graphs.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: Hopcroft-Karp算法由Hopcroft和Karp[[224](bibliography001.xhtml#endnote_224)]提出。Madry[[308](bibliography001.xhtml#endnote_308)]提出了一个*Õ*(*E*^(10/7))-时间算法，对于稀疏图而言，在渐近意义上比Hopcroft-Karp更快。
- en: Corollary 25.4 is due to Berge [[53](bibliography001.xhtml#endnote_53)], and
    it also holds in graphs that are not bipartite. Matching in general graphs requires
    more complicated algorithms. The first polynomial-time algorithm, running in *O*(*V* ⁴)
    time, is due to Edmonds [[130](bibliography001.xhtml#endnote_130)] (in a paper
    that also introduced the notion of a polynomial-time algorithm). Like the bipartite
    case, this algorithm also uses augmenting paths, although the algorithm for finding
    augmenting paths in general graphs is more involved than the one for bipartite
    graphs. Subsequently, several ![art](images/Art_P822.jpg)-time algorithms appeared,
    including ones by Gabow and Tarjan [[168](bibliography001.xhtml#endnote_168)]
    as part of an algorithm for weighted matching and a simpler one by Gabow [[164](bibliography001.xhtml#endnote_164)].
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 推论25.4归功于Berge[[53](bibliography001.xhtml#endnote_53)]，并且在非二分图中也成立。在一般图中进行匹配需要更复杂的算法。第一个多项式时间算法，运行时间为*O*(*V* ⁴)，归功于Edmonds[[130](bibliography001.xhtml#endnote_130)]（在一篇也引入了多项式时间算法概念的论文中）。与二分图情况类似，该算法也使用增广路径，尽管在一般图中寻找增广路径的算法比二分图的更为复杂。随后出现了几个![art](images/Art_P822.jpg)时间的算法，包括Gabow和Tarjan[[168](bibliography001.xhtml#endnote_168)]作为加权匹配算法的一部分以及Gabow[[164](bibliography001.xhtml#endnote_164)]提供的更简单的算法。
- en: The Hungarian algorithm is described in the book by Bondy and Murty [[67](bibliography001.xhtml#endnote_67)]
    and is based on work by Kuhn [[273](bibliography001.xhtml#endnote_273)] and Munkres
    [[337](bibliography001.xhtml#endnote_337)]. Kuhn adopted the name “Hungarian algorithm”
    because the algorithm derived from work by the Hungarian mathematicians D. Kőnig
    and J. Egervéry. The algorithm is an early example of a primal-dual algorithm.
    A faster algorithm that runs in ![art](images/Art_P823.jpg) time, where the edge
    weights are integers from 0 to *W*, was given by Gabow and Tarjan [[167](bibliography001.xhtml#endnote_167)],
    and an algorithm with the same time bound for maximum-weight matching in general
    graphs was given by Duan, Pettie, and Su [[127](bibliography001.xhtml#endnote_127)].
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 匈牙利算法在Bondy和Murty的书中有描述[[67](bibliography001.xhtml#endnote_67)]，并且基于Kuhn[[273](bibliography001.xhtml#endnote_273)]和Munkres[[337](bibliography001.xhtml#endnote_337)]的工作。Kuhn采用“匈牙利算法”这个名称，因为该算法源自匈牙利数学家D.
    Kőnig和J. Egervéry的工作。该算法是原始对偶算法的早期示例。Gabow和Tarjan提供了一个更快的算法，运行时间为![art](images/Art_P823.jpg)，其中边权重为0到*W*的整数[[167](bibliography001.xhtml#endnote_167)]，以及一个在一般图中具有相同时间界限的最大权重匹配算法，由Duan、Pettie和Su提供[[127](bibliography001.xhtml#endnote_127)]。
- en: The stable-marriage problem was first defined and analyzed by Gale and Shapley
    [[169](bibliography001.xhtml#endnote_169)]. The stable-marriage problem has numerous
    variants. The books by Gusfield and Irving [[203](bibliography001.xhtml#endnote_203)],
    Knuth [[266](bibliography001.xhtml#endnote_266)], and Manlove [[313](bibliography001.xhtml#endnote_313)]
    serve as excellent sources for cataloging and solving them.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 稳定婚姻问题首次由Gale和Shapley[[169](bibliography001.xhtml#endnote_169)]定义和分析。稳定婚姻问题有许多变体。Gusfield和Irving[[203](bibliography001.xhtml#endnote_203)]、Knuth[[266](bibliography001.xhtml#endnote_266)]和Manlove[[313](bibliography001.xhtml#endnote_313)]的书籍是归类和解决这些问题的优秀来源。
- en: '[¹](#footnote_ref_1) The definition of a complete bipartite graph differs from
    the definition of complete graph given on page 1167 because in a bipartite graph,
    there are no edges between vertices in *L* and no edges between vertices in *R*.'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: '[¹](#footnote_ref_1) 完全二分图的定义与第1167页给出的完全图的定义不同，因为在二分图中，*L*中的顶点之间没有边，*R*中的顶点之间也没有边。'
- en: '[²](#footnote_ref_2) Although marriage norms are changing, it’s traditional
    to view the stable-marriage problem through the lens of heterosexual marriage.'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: '[²](#footnote_ref_2) 尽管婚姻规范正在改变，但传统上通过异性婚姻的视角来看待稳定婚姻问题。'
