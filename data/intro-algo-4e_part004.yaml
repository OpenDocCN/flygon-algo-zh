- en: '[***Part IV    Advanced Design and Analysis Techniques***](toc.xhtml#part-4)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[***第四部分    高级设计和分析技术***](toc.xhtml#part-4)'
- en: '[**Introduction**](toc.xhtml#Rh1-80)'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '[**介绍**](toc.xhtml#Rh1-80)'
- en: 'This part covers three important techniques used in designing and analyzing
    efficient algorithms: dynamic programming ([Chapter 14](chapter014.xhtml)), greedy
    algorithms ([Chapter 15](chapter015.xhtml)), and amortized analysis ([Chapter
    16](chapter016.xhtml)). Earlier parts have presented other widely applicable techniques,
    such as divide-and-conquer, randomization, and how to solve recurrences. The techniques
    in this part are somewhat more sophisticated, but you will be able to use them
    solve many computational problems. The themes introduced in this part will recur
    later in this book.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本部分涵盖了设计和分析高效算法中使用的三种重要技术：动态规划（[第14章](chapter014.xhtml)）、贪婪算法（[第15章](chapter015.xhtml)）和摊销分析（[第16章](chapter016.xhtml)）。之前的部分介绍了其他广泛适用的技术，如分治、随机化以及如何解决递归关系。本部分的技术略微复杂，但你将能够使用它们解决许多计算问题。本部分介绍的主题将在本书的后续部分再次出现。
- en: Dynamic programming typically applies to optimization problems in which you
    make a set of choices in order to arrive at an optimal solution, each choice generates
    subproblems of the same form as the original problem, and the same subproblems
    arise repeatedly. The key strategy is to store the solution to each such subproblem
    rather than recompute it. [Chapter 14](chapter014.xhtml) shows how this simple
    idea can sometimes transform exponential-time algorithms into polynomial-time
    algorithms.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 动态规划通常适用于优化问题，其中您需要做一系列选择以得到最优解，每个选择生成与原始问题相同形式的子问题，并且相同的子问题会反复出现。关键策略是存储每个这种子问题的解，而不是重新计算它。[第14章](chapter014.xhtml)展示了这个简单思想有时可以将指数时间算法转化为多项式时间算法。
- en: Like dynamic-programming algorithms, greedy algorithms typically apply to optimization
    problems in which you make a set of choices in order to arrive at an optimal solution.
    The idea of a greedy algorithm is to make each choice in a locally optimal manner,
    resulting in a faster algorithm than you get with dynamic programming. [Chapter
    15](chapter015.xhtml) will help you determine when the greedy approach works.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 贪婪算法通常适用于优化问题，其中您需要做一系列选择以得到最优解。贪婪算法的思想是以局部最优的方式做出每个选择，从而比动态规划得到更快的算法。[第15章](chapter015.xhtml)将帮助您确定何时使用贪婪方法。
- en: The technique of amortized analysis applies to certain algorithms that perform
    a sequence of similar operations. Instead of bounding the cost of the sequence
    of operations by bounding the actual cost of each operation separately, an amortized
    analysis provides a worst-case bound on the actual cost of the entire sequence.
    One advantage of this approach is that although some operations might be expensive,
    many others might be cheap. You can use amortized analysis when designing algorithms,
    since the design of an algorithm and the analysis of its running time are often
    closely intertwined. [Chapter 16](chapter016.xhtml) introduces three ways to perform
    an amortized analysis of an algorithm.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 摊销分析技术适用于执行一系列类似操作的某些算法。与单独限制每个操作的实际成本不同，摊销分析提供了整个序列的实际成本的最坏情况界限。这种方法的一个优势是，尽管某些操作可能很昂贵，但许多其他操作可能很便宜。在设计算法时，您可以使用摊销分析，因为算法的设计和运行时间分析通常紧密相连。[第16章](chapter016.xhtml)介绍了对算法进行摊销分析的三种方法。
