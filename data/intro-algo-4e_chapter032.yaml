- en: '[**32        String Matching**](toc.xhtml#chap-32)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[**32        字符串匹配**](toc.xhtml#chap-32)'
- en: Text-editing programs frequently need to find all occurrences of a pattern in
    the text. Typically, the text is a document being edited, and the pattern searched
    for is a particular word supplied by the user. Efficient algorithms for this problem—called
    “string matching”—can greatly aid the responsiveness of the text-editing program.
    Among their many other applications, string-matching algorithms search for particular
    patterns in DNA sequences. Internet search engines also use them to find web pages
    relevant to queries.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 文本编辑程序经常需要在文本中查找模式的所有出现。通常，文本是正在编辑的文档，而要搜索的模式是用户提供的特定单词。对于这个问题的高效算法——称为“字符串匹配”——可以极大地帮助文本编辑程序的响应速度。在许多其他应用中，字符串匹配算法用于在DNA序列中搜索特定模式。互联网搜索引擎也使用它们来查找与查询相关的网页。
- en: 'The string-matching problem can be stated formally as follows. The text is
    given as an array *T*[1 : *n*] of length *n*, and the pattern is an array *P*[1
    : *m*] of length *m* ≤ *n*. The elements of *P* and *T* are characters drawn from
    an alphabet ∑, which is a finite set of characters. For example, ∑ could be the
    set {0, 1}, or it could be the set {a, b, …, z}. The character arrays *P* and
    *T* are often called ***strings*** of characters.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '字符串匹配问题可以正式陈述如下。文本被给定为长度为 *n* 的数组 *T*[1 : *n*]，模式是长度为 *m* ≤ *n* 的数组 *P*[1 :
    *m*]。*P* 和 *T* 的元素是从字母表 ∑ 中提取的字符，∑ 是一个有限字符集。例如，∑ 可以是集合{0, 1}，或者可以是集合{a, b, …,
    z}。字符数组 *P* 和 *T* 通常被称为字符的***字符串***。'
- en: As [Figure 32.1](chapter032.xhtml#Fig_32-1) shows, pattern *P* ***occurs with
    shift s*** in text *T* (or, equivalently, that pattern *P* ***occurs beginning
    at position s* + 1** in text *T*) if 0 ≤ *s* ≤ *n* – *m* and *T*[*s* + 1:*s* +
    *m*] = *P*[1:*m*], that is, if *T*[*s* + *j*] = *P*[*j*], for 1 ≤ *j* ≤ *m*. If
    *P* occurs with shift *s* in *T*, then *s* is a ***valid shift***, and otherwise,
    *s* is an ***invalid shift***. The ***string-matching problem*** is the problem
    of finding all valid shifts with which a given pattern *P* occurs in a given text
    *T*.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图32.1](chapter032.xhtml#Fig_32-1)所示，模式 *P* 在文本 *T* 中以移位 *s* 的方式出现（或者等效地，模式
    *P* 从位置 *s* + 1 开始在文本 *T* 中出现），如果 0 ≤ *s* ≤ *n* – *m* 且 *T*[*s* + 1:*s* + *m*]
    = *P*[1:*m*]，即如果 *T*[*s* + *j*] = *P*[*j*]，对于 1 ≤ *j* ≤ *m*。如果 *P* 在 *T* 中以移位
    *s* 出现，则 *s* 是一个***有效移位***，否则，*s* 是一个***无效移位***。***字符串匹配问题***是在给定文本 *T* 中找到给定模式
    *P* 的所有有效移位的问题。
- en: '![art](images/Art_P1288.jpg)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1288.jpg)'
- en: '**Figure 32.1** An example of the string-matching problem to find all occurrences
    of the pattern *P* = abaa in the text *T* = abcabaabcabac. The pattern occurs
    only once in the text, at shift *s* = 3, which is a valid shift. A vertical line
    connects each character of the pattern to its matching character in the text,
    and all matched characters are shaded blue.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**图32.1** 字符串匹配问题的一个示例，查找模式 *P* = abaa 在文本 *T* = abcabaabcabac 中的所有出现。模式在文本中只出现一次，位移
    *s* = 3，这是一个有效移位。垂直线连接模式的每个字符与文本中匹配的字符，并且所有匹配的字符都被着蓝色。'
- en: 'Except for the naive brute-force algorithm in [Section 32.1](chapter032.xhtml#Sec_32.1),
    each string-matching algorithm in this chapter performs some preprocessing based
    on the pattern and then finds all valid shifts. We call this latter phase “matching.”
    Here are the preprocessing and matching times for each of the string-matching
    algorithms in this chapter. The total running time of each algorithm is the sum
    of the preprocessing and matching times:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 除了[第32.1节](chapter032.xhtml#Sec_32.1)中的朴素暴力算法外，本章中的每个字符串匹配算法都执行基于模式的一些预处理，然后找到所有有效的移位。我们将这后一阶段称为“匹配”。以下是本章中每个字符串匹配算法的预处理和匹配时间。每个算法的总运行时间是预处理时间和匹配时间的总和：
- en: '| Algorithm | Preprocessing time | Matching time |'
  id: totrans-7
  prefs: []
  type: TYPE_TB
  zh: '| 算法 | 预处理时间 | 匹配时间 |'
- en: '| Naive | 0 | *O*((*n* – *m* + 1)*m*) |'
  id: totrans-8
  prefs: []
  type: TYPE_TB
  zh: '| 朴素算法 | 0 | *O*((*n* – *m* + 1)*m*) |'
- en: '| Rabin-Karp | Θ(*m*) | *O*((*n* – *m* + 1)*m*) |'
  id: totrans-9
  prefs: []
  type: TYPE_TB
  zh: '| Rabin-Karp | Θ(*m*) | *O*((*n* – *m* + 1)*m*) |'
- en: '| Finite automaton | *O*(*m* &#124;∑&#124;) | Θ(*n*) |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 有限自动机 | *O*(*m* &#124;∑&#124;) | Θ(*n*) |'
- en: '| Knuth-Morris-Pratt | Θ(*m*) | Θ(*n*) |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| Knuth-Morris-Pratt | Θ(*m*) | Θ(*n*) |'
- en: '| Suffix array^([1](#footnote_1)) | *O*(*n* 1g *n*) | *O*(*m* 1g *n* + *km*)
    |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 后缀数组^([1](#footnote_1)) | *O*(*n* 1g *n*) | *O*(*m* 1g *n* + *km*) |'
- en: '[Section 32.2](chapter032.xhtml#Sec_32.2) presents an interesting string-matching
    algorithm, due to Rabin and Karp. Although the Θ((*n* – *m* + 1)*m*) worst-case
    running time of this algorithm is no better than that of the naive method, it
    works much better on average and in practice. It also generalizes nicely to other
    pattern-matching problems. [Section 32.3](chapter032.xhtml#Sec_32.3) then describes
    a string-matching algorithm that begins by constructing a finite automaton specifically
    designed to search for occurrences of the given pattern *P* in a text. This algorithm
    takes *O*(*m* |∑|) preprocessing time, but only Θ(*n*) matching time. [Section
    32.4](chapter032.xhtml#Sec_32.4) presents the similar, but much cleverer, Knuth-Morris-Pratt
    (or KMP) algorithm, which has the same Θ(*n*) matching time, but it reduces the
    preprocessing time to only Θ(*m*).'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[第32.2节](chapter032.xhtml#Sec_32.2)介绍了一个有趣的字符串匹配算法，由 Rabin 和 Karp 提出。尽管该算法的最坏情况运行时间Θ((*n*
    – *m* + 1)*m*)不比朴素方法好，但在平均情况和实践中效果要好得多。它还可以很好地推广到其他模式匹配问题。[第32.3节](chapter032.xhtml#Sec_32.3)描述了一种字符串匹配算法，该算法首先构造一个有限自动机，专门设计用于在文本中搜索给定模式
    *P* 的出现。该算法需要*O*(*m* |∑|)的预处理时间，但只需要Θ(*n*)的匹配时间。[第32.4节](chapter032.xhtml#Sec_32.4)介绍了类似但更聪明的
    Knuth-Morris-Pratt（或KMP）算法，它具有相同的Θ(*n*)匹配时间，但将预处理时间减少到Θ(*m*)。'
- en: A completely different approach appears in [Section 32.5](chapter032.xhtml#Sec_32.5),
    which examines suffix arrays and the longest common prefix array. You can use
    these arrays not only to find a pattern in a text, but also to answer other questions,
    such as what is the longest repeated substring in the text and what is the longest
    common substring between two texts. The algorithm to form the suffix array in
    [Section 32.5](chapter032.xhtml#Sec_32.5) takes *O*(*n* 1g *n*) time and, given
    the suffix array, the section shows how to compute the longest common prefix array
    in *O*(*n*) time.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[第 32.5 节](chapter032.xhtml#Sec_32.5)中出现了一种完全不同的方法，它研究后缀数组和最长公共前缀数组。您不仅可以使用这些数组在文本中查找模式，还可以回答其他问题，例如文本中最长重复子串是什么，以及两个文本之间最长的公共子串是什么。[第
    32.5 节](chapter032.xhtml#Sec_32.5)中形成后缀数组的算法需要 *O*(*n* 1g *n*) 时间，并且在给定后缀数组的情况下，该部分展示了如何在
    *O*(*n*) 时间内计算最长公共前缀数组。'
- en: '**Notation and terminology**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**符号和术语**'
- en: We denote by ∑* (read “sigma-star”) the set of all finite-length strings formed
    using characters from the alphabet ∑. This chapter considers only finite-length
    strings. The 0-length ***empty string***, denoted *ϵ*, also belongs to ∑*. The
    length of a string *x* is denoted |*x*|. The ***concatenation*** of two strings
    *x* and *y*, denoted *xy*, has length |*x*| + |*y*| and consists of the characters
    from *x* followed by the characters from *y*.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们用 ∑*（读作“sigma-star”）表示由字母表 ∑ 中的字符组成的所有有限长度字符串的集合。本章仅考虑有限长度字符串。长度为 0 的***空字符串***，表示为
    *ϵ*，也属于 ∑*。字符串 *x* 的长度表示为 |*x*|。两个字符串 *x* 和 *y* 的***连接***，表示为 *xy*，长度为 |*x*| +
    |*y*|，由 *x* 中的字符后跟 *y* 中的字符组成。
- en: '![art](images/Art_P1289.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1289.jpg)'
- en: '**Figure 32.2** A graphical proof of Lemma 32.1\. Suppose that *x* ⊐ *z* and
    *y* ⊐ *z*. The three parts of the figure illustrate the three cases of the lemma.
    Vertical lines connect matching regions (shown in blue) of the strings. **(a)**
    If |*x*| ≤ |*y*|, then *x* ⊐ *y*. **(b)** If |*x*| ≥ |*y*|, then *y* ⊐ *x*. **(c)**
    If |*x*| = |*y*|, then *x* = *y*.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 32.2** 引理 32.1 的图形证明。假设 *x* ⊐ *z* 且 *y* ⊐ *z*。图的三部分说明了引理的三种情况。垂直线连接字符串的匹配区域（蓝色显示）。**(a)**
    如果 |*x*| ≤ |*y*|，则 *x* ⊐ *y*。**(b)** 如果 |*x*| ≥ |*y*|，则 *y* ⊐ *x*。**(c)** 如果 |*x*|
    = |*y*|，则 *x* = *y*。'
- en: A string *w* is a ***prefix*** of a string *x*, denoted *w* ⊏ *x*, if *x* =
    *wy* for some string *y* ∈ ∑*. Note that if *w* ⊏ *x*, then |*w*| ≤ |*x*|. Similarly,
    a string *w* is a ***suffix*** of a string *x*, denoted *w* ⊐ *x*, if *x* = *yw*
    for some *y* ∈ ∑*. As with a prefix, *w* ⊐ *x* implies |*w*| ≤ |*x*|. For example,
    ab ⊏ abcca and cca ⊐ abcca. A string *w* is a ***proper prefix*** of *x* if *w*
    ⊏ *x* and |*w*| < |*x*|, and likewise for a ***proper suffix***. The empty string
    *ϵ* is both a suffix and a prefix of every string. For any strings *x* and *y*
    and any character *a*, we have *x* ⊐ *y* if and only if *xa* ⊐ *ya*. The ⊏ and
    ⊐ relations are transitive. The following lemma will be useful later.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *x* = *wy* 对于某��字符串 *y* ∈ ∑*，则字符串 *w* 是字符串 *x* 的***前缀***，表示为 *w* ⊏ *x*。请注意，如果
    *w* ⊏ *x*，则 |*w*| ≤ |*x*|。类似地，如果 *x* = *yw* 对于某个 *y* ∈ ∑*，则字符串 *w* 是字符串 *x* 的***后缀***，表示为
    *w* ⊐ *x*。与前缀一样，*w* ⊐ *x* 意味着 |*w*| ≤ |*x*|。例如，ab ⊏ abcca，cca ⊐ abcca。如果 *w* ⊏
    *x* 且 |*w*| < |*x*|，则字符串 *w* 是字符串 *x* 的***真前缀***，后缀同理。空字符串 *ϵ* 是每个字符串的前缀和后缀。对于任何字符串
    *x* 和 *y* 以及任何字符 *a*，当且仅当 *xa* ⊐ *ya* 时，我们有 *x* ⊐ *y*。关系 ⊏ 和 ⊐ 是传递的。后面的引理将在以后有用。
- en: '***Lemma 32.1 (Overlapping-suffix lemma)***'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 32.1（重叠后缀引理）***'
- en: Suppose that *x*, *y*, and *z* are strings such that *x* ⊐ *z* and *y* ⊐ *z*.
    If |*x*| ≤ |*y*|, then *x* ⊐ *y*. If |*x*| ≥ |*y*|, then *y* ⊐ *x*. If |*x*| =
    |*y*|, then *x* = *y*.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 *x*、*y* 和 *z* 是字符串，使得 *x* ⊐ *z* 且 *y* ⊐ *z*。如果 |*x*| ≤ |*y*|，则 *x* ⊐ *y*。如果
    |*x*| ≥ |*y*|，则 *y* ⊐ *x*。如果 |*x*| = |*y*|，则 *x* = *y*。
- en: '***Proof***   See [Figure 32.2](chapter032.xhtml#Fig_32-2) for a graphical
    proof.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   参见[图 32.2](chapter032.xhtml#Fig_32-2)以获得图形证明。'
- en: ▪
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: For convenience, denote the *k*-character prefix *P*[1:*k*] of the pattern *P*[1:*m*]
    by *P*[:*k*]. Thus, we can write *P*[:0] = *ϵ* and *P*[:*m*] = *P* = *P*[1:*m*].
    Similarly, denote the *k*-character prefix of the text *T* by *T*[:*k*]. Using
    this notation, we can state the string-matching problem as that of finding all
    shifts *s* in the range 0 ≤ *s* ≤ *n* – *m* such that *P* ⊐ *T*[:*s* + *m*].
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为方便起见，将模式 *P*[1:*m*] 的 *k* 字符前缀 *P*[1:*k*] 表示为 *P*[:*k*]。因此，我们可以写成 *P*[:0] =
    *ϵ* 和 *P*[:*m*] = *P* = *P*[1:*m*]。类似地，将文本 *T* 的 *k* 字符前缀表示为 *T*[:*k*]。利用这种表示法，我们可以将字符串匹配问题陈述为找到所有偏移量
    *s*，其中 0 ≤ *s* ≤ *n* – *m*，使得 *P* ⊐ *T*[:*s* + *m*]。
- en: Our pseudocode allows two equal-length strings to be compared for equality as
    a primitive operation. If the strings are compared from left to right and the
    comparison stops when a mismatch is discovered, we assume that the time taken
    by such a test is a linear function of the number of matching characters discovered.
    To be precise, the test “*x* == *y*” is assumed to take Θ(*t*) time, where *t*
    is the length of the longest string *z* such that *z* ⊏ *x* and *z* ⊏ *y*.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的伪代码允许将两个等长字符串作为基本操作进行比较。如果从左到右比较字符串，并且在发现不匹配时停止比较，我们假设这样的测试所需的时间是匹配字符数量的线性函数。准确地说，“*x*
    == *y*” 测试被假定需要 Θ(*t*) 时间，其中 *t* 是最长字符串 *z* 的长度，使得 *z* ⊏ *x* 且 *z* ⊏ *y*。
- en: '[**32.1    The naive string-matching algorithm**](toc.xhtml#Rh1-187)'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '[**32.1    朴素字符串匹配算法**](toc.xhtml#Rh1-187)'
- en: The NAIVE-STRING-MATCHER procedure finds all valid shifts using a loop that
    checks the condition *P*[1:*m*] = *T*[*s*+1:*s*+*m*] for each of the *n*−*m*+1
    possible values of *s*.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: NAIVE-STRING-MATCHER 程序使用循环找到所有有效的偏移量，检查条件 *P*[1:*m*] = *T*[*s*+1:*s*+*m*] 对于
    *n*−*m*+1 个可能的 *s* 值。
- en: NAIVE-STRING-MATCHER(*T*, *P*, *n*, *m*)
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: NAIVE-STRING-MATCHER(*T*, *P*, *n*, *m*)
- en: '| 1 | **for** *s* = 0 **to** *n* – *m* |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **对于** *s* = 0 **到** *n* – *m* |'
- en: '| 2 | **if** *P*[1:*m*] == *T*[*s* + 1:*s* + *m*] |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **如果** *P*[1:*m*] == *T*[*s* + 1:*s* + *m*] |'
- en: '| 3 | print “Pattern occurs with shift” *s* |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 打印 “Pattern occurs with shift” *s* |'
- en: '[Figure 32.3](chapter032.xhtml#Fig_32-3) portrays the naive string-matching
    procedure as sliding a “template” containing the pattern over the text, noting
    for which shifts all of the characters on the template equal the corresponding
    characters in the text. The **for** loop of lines 1–3 considers each possible
    shift explicitly. The test in line 2 determines whether the current shift is valid.
    This test implicitly loops to check corresponding character positions until all
    positions match successfully or a mismatch is found. Line 3 prints out each valid
    shift *s*.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 32.3](chapter032.xhtml#Fig_32-3) 描绘了天真字符串匹配过程，将包含模式的“模板”滑动到文本上，注意哪些移位上模板上的所有字符与文本中的相应字符相等。第
    1–3 行的 **for** 循环明确考虑每个可能的移位。第 2 行的测��确定当前移位是否有效。这个测试隐式循环检查相应的字符位置，直到所有位置成功匹配或找到不匹配。第
    3 行打印出每个有效的移位 *s*。'
- en: Procedure NAIVE-STRING-MATCHER takes *O*((*n* – *m* + 1)*m*) time, and this
    bound is tight in the worst case. For example, consider the text string a^(*n*)
    (a string of *n*a’s) and the pattern a^(*m*). For each of the *n*−*m*+1 possible
    values of the shift *s*, the implicit loop on line 2 to compare corresponding
    characters must execute *m* times to validate the shift. The worst-case running
    time is thus Θ((*n* − *m* + 1)*m*), which is Θ(*n*²) if *m* = ⌊*n*/2⌋. Because
    it requires no preprocessing, NAIVE-STRING-MATCHER’s running time equals its matching
    time.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: NAIVE-STRING-MATCHER 程序需要 *O*((*n* – *m* + 1)*m*) 的时间，这个界限在最坏情况下是紧的。例如，考虑文本字符串
    a^(*n*)（*n* 个 a 的字符串）和模式 a^(*m*)。对于 *n*−*m*+1 个可能的移位 *s* 的每一个值，第 2 行的隐式循环比较相应字符必须执行
    *m* 次以验证移位。因此，最坏情况运行时间是 Θ((*n* − *m* + 1)*m*)，如果 *m* = ⌊*n*/2⌋，则为 Θ(*n*²)。因为它不需要预处理，NAIVE-STRING-MATCHER
    的运行时间等于匹配时间。
- en: NAIVE-STRING-MATCHER is far from an optimal procedure for this problem. Indeed,
    this chapter will show that the Knuth-Morris-Pratt algorithm is much better in
    the worst case. The naive string-matcher is inefficient because it entirely ignores
    information gained about the text for one value of *s* when it considers other
    values of *s*. Such information can be quite valuable, however. For example, if
    *P* = aaab and *s* = 0 is valid, then none of the shifts 1, 2, or 3 are valid,
    since *T*[4] = b. The following sections examine several ways to make effective
    use of this sort of information.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: NAIVE-STRING-MATCHER 远非这个问题的最佳解决方案。实际上，本章将展示 Knuth-Morris-Pratt 算法在最坏情况下要好得多。天真的字符串匹配器效率低下，因为在考虑其他值
    *s* 时，它完全忽略了对文本某个值 *s* 获得的信息。然而，这种信息可能非常有价值。例如，如果 *P* = aaab，*s* = 0 是有效的，那么移位
    1、2 或 3 都是无效的，因为 *T*[4] = b。接下来的几节将探讨几种有效利用这种信息的方法。
- en: '![art](images/Art_P1290.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1290.jpg)'
- en: '**Figure 32.3** The operation of the NAIVE-STRING-MATCHER procedure for the
    pattern *P* = aab and the text *T* = acaabc. Imagine the pattern *P* as a template
    that slides next to the text. **(a)–(d)** The four successive alignments tried
    by the naive string matcher. In each part, vertical lines connect corresponding
    regions found to match (shown in blue), and a red jagged line connects the first
    mismatched character found, if any. The algorithm finds one occurrence of the
    pattern, at shift *s* = 2, shown in part (c).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 32.3** NAIVE-STRING-MATCHER 程序对模式 *P* = aab 和文本 *T* = acaabc 的操作。想象模式 *P*
    就像一个模板，滑动到文本旁边。**(a)–(d)** 天真字符串匹配器尝试的四个连续对齐。在每个部分中，垂直线连接找到匹配的相应区域（显示为蓝色），红色锯齿线连接找到的第一个不匹配字符，如果有的话。算法在移位
    *s* = 2 处找到模式的一个出现，如图 (c) 所示。'
- en: '**Exercises**'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***32.1-1***'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.1-1***'
- en: Show the comparisons the naive string matcher makes for the pattern *P* = 0001
    in the text *T* = 000010001010001.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 展示天真字符串匹配器在文本 *T* = 000010001010001 中对模式 *P* = 0001 进行的比较。
- en: '***32.1-2***'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.1-2***'
- en: Suppose that all characters in the pattern *P* are different. Show how to accelerate
    NAIVE-STRING-MATCHER to run in *O*(*n*) time on an *n*-character text *T*.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设模式 *P* 中的所有字符都不同。展示如何加速 NAIVE-STRING-MATCHER，在 *n* 字符文本 *T* 上运行时间为 *O*(*n*)。
- en: '***32.1-3***'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.1-3***'
- en: Suppose that pattern *P* and text *T* are *randomly* chosen strings of length
    *m* and *n*, respectively, from the *d*-ary alphabet ∑[*d*] = {0, 1, …, *d* –
    1}, where *d* ≥ 2\. Show that the *expected* number of character-to-character
    comparisons made by the implicit loop in line 2 of the naive algorithm is
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 假设模式 *P* 和文本 *T* 是长度分别为 *m* 和 *n* 的*随机*选择的字符串，分别来自 *d* 进制字母表 ∑[*d*] = {0, 1,
    …, *d* – 1}，其中 *d* ≥ 2。展示隐式循环第 2 行中天真算法进行的字符比较的*期望*次数是
- en: '![art](images/Art_P1291.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1291.jpg)'
- en: over all executions of this loop. (Assume that the naive algorithm stops comparing
    characters for a given shift once it finds a mismatch or matches the entire pattern.)
    Thus, for randomly chosen strings, the naive algorithm is quite efficient.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个循环的所有执行中。 （假设天真算法在找到不匹配或匹配整个模式时停止比较字符。）因此，对于随机选择的字符串，天真算法是非常有效的。
- en: '***32.1-4***'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.1-4***'
- en: Suppose that the pattern *P* may contain occurrences of a ***gap character***
    ♢ that can match an *arbitrary* string of characters (even one of 0 length). For
    example, the pattern ab♢ba♢c occurs in the text cabccbacbacab as
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 假设模式 *P* 可能包含一个***间隔字符*** ♢，它可以匹配一个*任意*长度的字符串（甚至长度为 0 的字符串）。例如，模式 ab♢ba♢c 在文本
    cabccbacbacab 中出现如下
- en: '![art](images/Art_P1292.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1292.jpg)'
- en: and as
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 作为
- en: '![art](images/Art_P1293.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1293.jpg)'
- en: The gap character may occur an arbitrary number of times in the pattern but
    not at all in the text. Give a polynomial-time algorithm to determine whether
    such a pattern *P* occurs in a given text *T*, and analyze the running time of
    your algorithm.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 间隔字符可能在模式中出现任意次数，但在文本中完全不出现。给出一个多项式时间算法，以确定这样一个模式 *P* 是否出现在给定的文本 *T* 中，并分析算法的运行时间。
- en: '[**32.2    The Rabin-Karp algorithm**](toc.xhtml#Rh1-188)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[**32.2    Rabin-Karp 算法**](toc.xhtml#Rh1-188)'
- en: Rabin and Karp proposed a string-matching algorithm that performs well in practice
    and that also generalizes to other algorithms for related problems, such as two-dimensional
    pattern matching. The Rabin-Karp algorithm uses Θ(*m*) preprocessing time, and
    its worst-case running time is Θ((*n*−*m*+1)*m*). Based on certain assumptions,
    however, its average-case running time is better.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Rabin和Karp提出了一个字符串匹配算法，在实践中表现良好，并且也可以推广到其他相关问题的算法，比如二维模式匹配。Rabin-Karp算法使用Θ(*m*)的预处理时间，其最坏情况运行时间为Θ((*n*−*m*+1)*m*)。然而，根据某些假设，其平均情况运行时间更好。
- en: This algorithm makes use of elementary number-theoretic notions such as the
    equivalence of two numbers modulo a third number. You might want to refer to [Section
    31.1](chapter031.xhtml#Sec_31.1) for the relevant definitions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法利用了基本的数论概念，比如两个数对第三个数的同余性。你可能需要参考[第31.1节](chapter031.xhtml#Sec_31.1)中的相关定义。
- en: For expository purposes, let’s assume that ∑ = {0, 1, 2, …, 9}, so that each
    character is a decimal digit. (In the general case, you can assume that each character
    is a digit in radix-*d* notation, so that it has a numerical value in the range
    0 to *d* – 1, where *d* = |∑|.) You can then view a string of *k* consecutive
    characters as representing a length-*k* decimal number. For example, the character
    string 31415 corresponds to the decimal number 31,415\. Because we interpret the
    input characters as both graphical symbols and digits, it will be convenient in
    this section to denote them as digits in standard text font.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明，让我们假设∑ = {0, 1, 2, …, 9}，这样每个字符都是一个十进制数字。（在一般情况下，你可以假设每个字符是基数-*d*表示法中的一个数字，因此它在0到*d*
    – 1的范围内具有数值，其中*d* = |∑|。）然后，你可以将一个连续的*k*个字符视为表示长度为*k*的十进制数。例如，字符串31415对应于十进制数31,415。因为我们将输入字符解释为图形符号和数字，所以在本节中将它们表示为标准文本字体中的数字会更方便。
- en: Given a pattern *P*[1:*m*], let *p* denote its corresponding decimal value.
    In a similar manner, given a text *T*[1:*n*], let *t*[*s*] denote the decimal
    value of the length-*m* substring *T*[*s* + 1:*s* + *m*], for *s* = 0, 1, …, *n*
    – *m*. Certainly, *t*[*s*] = *p* if and only if *T* [*s* + 1:*s* + *m*] = *P*[1:*m*],
    and thus, *s* is a valid shift if and only if *t*[*s*] = *p*. If you could compute
    *p* in Θ(*m*) time and all the *t*[*s*] values in a total of Θ(*n* – *m* + 1)
    time,^([2](#footnote_2)) then you could determine all valid shifts *s* in Θ(*m*)+Θ(*n*
    − *m* + 1) = Θ(*n*) time by comparing *p* with each of the *t*[*s*] values. (For
    the moment, let’s not worry about the possibility that *p* and the *t*[*s*] values
    might be very large numbers.)
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个模式*P*[1:*m*]，让*p*表示其对应的十进制值。类似地，给定一个文本*T*[1:*n*]，让*t*[*s*]表示长度为*m*的子字符串*T*[*s*
    + 1:*s* + *m*]的十进制值，其中*s* = 0, 1, …, *n* – *m*。显然，当且仅当*t*[*s*] = *p*时，*T* [*s*
    + 1:*s* + *m*] = *P*[1:*m*]，因此，*s*是一个有效的偏移量当且仅当*t*[*s*] = *p*。如果你可以在Θ(*m*)时间内计算*p*和所有*t*[*s*]值总共在Θ(*n*
    – *m* + 1)时间内^([2](#footnote_2))，那么通过将*p*与每个*t*[*s*]值进行比较，你可以在Θ(*m*)+Θ(*n* − *m*
    + 1) = Θ(*n*)时间内确定所有有效的偏移量*s*。（暂时不要担心*p*和*t*[*s*]值可能非常大的可能性。）
- en: 'Indeed, you can compute *p* in Θ(*m*) time using Horner’s rule (see Problem
    2-3):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，你可以使用霍纳法则在Θ(*m*)时间内计算*p*（参见问题2-3）：
- en: '![art](images/Art_P1294.jpg)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1294.jpg)'
- en: Similarly, you can compute *t*[0] from *T*[1:*m*] in Θ(*m*) time.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，你可以在Θ(*m*)时间内从*T*[1:*m*]计算出*t*[0]。
- en: To compute the remaining values *t*[1], *t*[2], …, *t*[*n*–*m*] in Θ(*n* – *m*)
    time, observe that you can compute *t*[*s*+1] from *t*[*s*] in constant time,
    since
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Θ(*n* – *m*)时间内计算剩余的值*t*[1]、*t*[2]、…、*t*[*n*–*m*]，观察到你可以在常数时间内从*t*[*s*]计算出*t*[*s*+1]，因为
- en: '![art](images/Art_P1295.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1295.jpg)'
- en: Subtracting 10^(*m*−1)*T* [*s* + 1] removes the high-order digit from *t*[*s*],
    multiplying the result by 10 shifts the number left by one digit position, and
    adding *T*[*s* + *m* + 1] brings in the appropriate low-order digit. For example,
    suppose that *m* = 5, *t*[*s*] = 31415, and the new low-order digit is *T*[*s*
    + 5 + 1] = 2\. The high-order digit to remove is *T*[*s* + 1] = 3, and so
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 从*t*[*s*]中减去10^(*m*−1)*T* [*s* + 1]可以去除*t*[*s*]的高阶位，将结果乘以10可以将数字左移一位，再加上*T*[*s*
    + *m* + 1]可以带入适当的低阶位。例如，假设*m* = 5，*t*[*s*] = 31415，新的低阶位为*T*[*s* + 5 + 1] = 2。要去除的高阶位是*T*[*s*
    + 1] = 3，因此
- en: '| *t*[*s*+1] | = | 10 (31415 − 10000 · 3) + 2 |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| *t*[*s*+1] | = | 10 (31415 − 10000 · 3) + 2 |'
- en: '|  | = | 14152. |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 14152. |'
- en: 'If you precompute the constant 10^(*m*−1) (which you can do in *O*(1g *m*)
    time using the techniques of [Section 31.6](chapter031.xhtml#Sec_31.6), although
    for this application a straightforward *O*(*m*)-time method suffices), then each
    execution of equation (32.1) takes a constant number of arithmetic operations.
    Thus, you can compute *p* in Θ(*m*) time, and you can compute all of *t*[0], *t*[1],
    …, *t*[*n*−*m*] in Θ(*n* − *m* + 1) time. Therefore, you can find all occurrences
    of the pattern *P*[1:*m*] in the text *T*[1: *n*] with Θ(*m*) preprocessing time
    and Θ(*n* − *m* + 1) matching time.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你预先计算常数10^(*m*−1)（可以使用[第31.6节](chapter031.xhtml#Sec_31.6)的技术在*O*(1g *m*)时间内完成，尽管对于这个应用程序，一个直接的*O*(*m*)时间方法就足够了），那么每次执行方程式(32.1)都需要恒定数量的算术运算。因此，你可以在Θ(*m*)时间内计算*p*，并且可以在Θ(*n*
    − *m* + 1)时间内计算所有*t*[0]、*t*[1]、…、*t*[*n*−*m*]。因此，你可以在Θ(*m*)的预处理时间和Θ(*n* − *m*
    + 1)的匹配时间内找到文本*T*[1: *n*]中模式*P*[1:*m*]的所有出现。'
- en: 'This scheme works well if *P* is short enough and the alphabet ∑ is small enough
    that arithmetic operations on *p* and *t*[*s*] take constant time. But what if
    *P* is long, or if the size of ∑ means that instead of powers of 10 in equation
    (32.1) you have to use powers of a larger number (such as powers of 256 for the
    extended ASCII character set)? Then the values of *p* and *t*[*s*] might be too
    large to work with in constant time. Fortunately, this problem can be solved,
    as [Figure 32.4](chapter032.xhtml#Fig_32-4) shows: compute *p* and the *t*[*s*]
    values modulo a suitable modulus *q*. You can compute *p* modulo *q* in Θ(*m*)
    time and all the *t*[*s*] values modulo *q* in Θ(*n* − *m* + 1) time. With |∑|
    = 10, if you choose the modulus *q* as a prime such that 10*q* just fits within
    one computer word, then you can perform all the necessary computations with single-precision
    arithmetic. In general, with a *d*-ary alphabet {0, 1, …, *d* – 1}, choose *q*
    so that *dq* fits within a computer word and adjust the recurrence equation (32.1)
    to work modulo *q*, so that it becomes'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*P*足够短，且字母表∑足够小，使得对*p*和*t*[*s*]的算术运算需要常数时间，那么这个方案就很有效。但是如果*P*很长，或者∑的大小意味着在方程(32.1)中你必须使用一个更大的数字的幂（比如对于扩展ASCII字符集使用256的幂），那么*p*和*t*[*s*]的值可能太大，无法在常数时间内处理。幸运的是，这个问题可以通过[图32.4](chapter032.xhtml#Fig_32-4)解决：对*p*和*t*[*s*]的值按适当的模数*q*进行计算。你可以在Θ(*m*)时间内计算*p*
    mod *q*，并在Θ(*n* − *m* + 1)时间内计算所有*t*[*s*] mod *q*的值。对于|∑| = 10，如果选择一个素数*q*，使得10*q*刚好适合一个计算机字，那么你可以用单精度算术执行所有必要的计算。一般来说，对于一个*d*进制字母表{0,
    1, …, *d* – 1}，选择*q*使得*dq*适合一个计算机字，并调整递推方程(32.1)以按*q*取模运行，这样它就变成了
- en: '![art](images/Art_P1296.jpg)'
  id: totrans-67
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1296.jpg)'
- en: '![art](images/Art_P1297.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1297.jpg)'
- en: '**Figure 32.4** The Rabin-Karp algorithm. Each character is a decimal digit.
    Values are computed modulo 13\. **(a)** A text string. A window of length 5 is
    shaded blue. The numerical value of the blue number, computed modulo 13, yields
    the value 7\. **(b)** The same text string with values computed modulo 13 for
    each possible position of a length-5 window. Assuming the pattern *P* = 31415,
    look for windows whose value modulo 13 is 7, since 31415 = 7 (mod 13). The algorithm
    finds two such windows, shaded blue in the figure. The first, beginning at text
    position 7, is indeed an occurrence of the pattern. The second window, beginning
    at text position 13, is a spurious hit. **(c)** How to compute the value for a
    window in constant time, given the value for the previous window. The first window
    has value 31415\. Dropping the high-order digit 3, shifting left (multiplying
    by 10), and then adding in the low-order digit 2 gives the new value 14152\. Because
    all computations are performed modulo 13, the value for the first window is 7,
    and the value for the new window is 8.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '**图32.4** Rabin-Karp算法。每个字符都是十进制数字。值按13取模计算。**(a)** 一个文本字符串。长度为5的窗口被标记为蓝色。蓝色数字的数值，按13取模计算，得到数值7。**(b)**
    相同的文本字符串，对每个长度为5的窗口位置按13取模计算值。假设模式*P* = 31415，寻找数值按13取模为7的窗口，因为31415 = 7 (mod
    13)。算法找到两个这样的窗口，在图中标记为蓝色。第一个从文本位置7开始的窗口确实是模式的一个出现。第二个窗口，从文本位置13开始，是一个虚假命中。**(c)**
    如何在常数时间内计算窗口的值，给定前一个窗口的值。第一个窗口的值为31415。去掉高位数字3，左移（乘以10），然后加上低位数字2，得到新值14152。因为所有计算都是按13取模进行的，第一个窗口的值为7，新窗口的值为8。'
- en: where *h* = *d*^(*m*−1) mod *q* is the value of the digit “1” in the high-order
    position of an *m*-digit text window.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*h* = *d*^(*m*−1) mod *q*是*m*位文本窗口中高位位置的数字“1”的值。
- en: 'The solution of working modulo *q* is not perfect, however: *t*[*s*] = *p*
    (mod *q*) does not automatically mean that *t*[*s*] = *p*. On the other hand,
    if *t*[*s*] ≠ *p* (mod *q*), then you definitely know that *t*[*s*] ≠ *p*, so
    that shift *s* is invalid. Thus you can use the test *t*[*s*] = *p* (mod *q*)
    as a fast heuristic test to rule out invalid shifts. If *t*[*s*] = *p* (mod *q*)—a
    ***hit***—then you need to test further to see whether *s* is really valid or
    you just have a ***spurious hit***. This additional test explicitly checks the
    condition *P*[1:*m*] = *T*[*s* + 1:*s* + *m*]. If *q* is large enough, then you
    would hope that spurious hits occur infrequently enough that the cost of the extra
    checking is low.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 按*q*取模的解决方案并不完美：*t*[*s*] = *p* (mod *q*)并不自动意味着*t*[*s*] = *p*。另一方面，如果*t*[*s*]
    ≠ *p* (mod *q*)，那么你肯定知道*t*[*s*] ≠ *p*，因此移位*s*是无效的。因此，你可以使用*t*[*s*] = *p* (mod
    *q*)作为快速启发式测试来排除无效的移位。如果*t*[*s*] = *p* (mod *q*)—一个***命中***—那么你需要进一步测试，看看*s*是否真的有效，或者你只是有一个***虚假命中***。这个额外的测试明确检查条件*P*[1:*m*]
    = *T*[*s* + 1:*s* + *m*]。如果*q*足够大，那么你希望虚假命中发生的频率足够低，以至于额外检查的成本很低。
- en: 'The procedure RABIN-KARP-MATCHER on the next page makes these ideas precise.
    The inputs to the procedure are the text *T*, the pattern *P*, their lengths *n*
    and *m*, the radix *d* to use (which is typically taken to be |∑|), and the prime
    *q* to use. The procedure works as follows. All characters are interpreted as
    radix-*d* digits. The subscripts on *t* are provided only for clarity: the procedure
    works correctly if all the subscripts are dropped. Line 1 initializes *h* to the
    value of the high-order digit position of an *m*-digit window. Lines 2–6 compute
    *p* as the value of *P*[1:*m*] mod *q* and *t*[0] as the value of *T*[1:*m*] mod
    *q*. The **for** loop of lines 7–12 iterates through all possible shifts *s*,
    maintaining the following invariant:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一页的RABIN-KARP-MATCHER过程将这些想法具体化。过程的输入是文本*T*，模式*P*，它们的长度*n*和*m*，要使用的基数*d*（通常取为|∑|），以及要使用的素数*q*。该过程的工作方式如下。所有字符都被解释为基数*d*的数字。*t*上的下标仅供清晰起见：如果去掉所有下标，过程仍然可以正确工作。第1行将*h*初始化为*m*位窗口中高位数字位置的值。第2-6行计算*p*作为*P*[1:*m*]
    mod *q*的值，*t*[0]作为*T*[1:*m*] mod *q*的值。第7-12行的**for**循环遍历所有可能的移位*s*，保持以下不变性：
- en: Whenever line 8 is executed, *t*[*s*] = *T*[*s* + 1:*s* + *m*] mod *q*.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 每当执行第8行时，*t*[*s*] = *T*[*s* + 1:*s* + *m*] mod *q*。
- en: If a hit occurs because *p* = *t*[*s*] in line 8, then line 9 determines whether
    *s* is a valid shift or the hit was spurious via the test *P*[1:*m*] == *T*[*s*
    +1:*s* +*m*]. Line 10 prints out any valid shifts that are found. If *s* < *n*
    – *m* (checked in line 11), then the **for** loop will iterate at least one more
    time, and so line 12 first executes to ensure that the loop invariant holds upon
    the next iteration. Line 12 computes the value of *t*[*s*+1] mod *q* from the
    value of *t*[*s*] mod *q* in constant time using equation (32.2) directly.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果命中发生是因为*p* = *t*[*s*]在第8行，那么第9行确定了*s*是一个有效的移动还是命中是虚假的，通过测试*P*[1:*m*] == *T*[*s*
    +1:*s* +*m*]。第10行打印出找到的任何有效移动。如果*s* < *n* – *m*（在第11行检查），那么**for**循环将至少再迭代一次，因此第12行首先执行以确保在下一次迭代时保持循环不变式。第12行使用方程（32.2）直接在常数时间内计算出*t*[*s*+1]
    mod *q*的值，从*t*[*s*] mod *q*的值。
- en: RABIN-KARP-MATCHER takes Θ(*m*) preprocessing time, and its matching time is
    Θ((*n* − *m* + 1)*m*) in the worst case, since (like the naive string-matching
    algorithm) the Rabin-Karp algorithm explicitly verifies every valid shift. If
    *P* = a^(*m*) and *T* = a^(*n*), then verifying takes Θ((*n*−*m*+1)*m*) time,
    since each of the *n*−*m*+1 possible shifts is valid.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: RABIN-KARP-MATCHER需要Θ(*m*)的预处理时间，在最坏情况下，其匹配时间为Θ((*n* − *m* + 1)*m*), 因为（就像朴素字符串匹配算法一样）拉宾-卡普算法明确验证每个有效移动。如果*P*
    = a^(*m*)且*T* = a^(*n*), 那么验证需要Θ((*n*−*m*+1)*m*)的时间，因为*n*−*m*+1个可能的移动都是有效的。
- en: In many applications, you expect few valid shifts—perhaps some constant *c*
    of them. In such applications, the expected matching time of the algorithm is
    only *O*((*n*−*m*+1)+*cm*) = *O*(*n*+*m*), plus the time required to process spurious
    hits. We can base a heuristic analysis on the assumption that reducing values
    modulo *q* acts like a random mapping from ∑* to ℤ[*q*]. The expected number of
    spurious hits is then *O*(*n*/*q*), because we can estimate the chance that an
    arbitrary *t*[*s*] will be equivalent to *p*, modulo *q*, as 1/*q*. Since there
    are *O*(*n*) positions at which the test of line 8 fails (actually, at most *n*
    − *m* + 1 positions) and checking each hit takes *O*(*m*) time in line 9, the
    expected matching time taken by the Rabin-Karp algorithm is
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多应用中，您期望很少的有效移动，也许只有一些常数*c*。在这种应用中，算法的预期匹配时间仅为*O*((*n*−*m*+1)+*cm*) = *O*(*n*+*m*),
    再加上处理虚假命中所需的时间。我们可以基于将值减少到模*q*的假设进行启发式分析，这就像是从∑*到ℤ[*q*]的随机映射。那么虚假命中的预期数量就是*O*(*n*/*q*),
    因为我们可以估计任意*t*[*s*]等于*p*模*q*的机会为1/*q*。由于有*O*(*n*)个位置在第8行的测试失败（实际上，最多有*n*−*m*+1个位置），并且在第9行检查每个命中需要*O*(*m*)的时间，因此拉宾-卡普算法所需的预期匹配时间为
- en: RABIN-KARP-MATCHER(*T*, *P*, *n*, *m*, *d*, *q*)
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: RABIN-KARP-MATCHER(*T*, *P*, *n*, *m*, *d*, *q*)
- en: '|   1 | *h* = *d*^(*m*−1) mod *q* |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '|   1 | *h* = *d*^(*m*−1) mod *q* |'
- en: '|   2 | *p* = 0 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '|   2 | *p* = 0 |'
- en: '|   3 | *t*[0] = 0 |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '|   3 | *t*[0] = 0 |'
- en: '|   4 | **for** *i* = 1 **to** *m* | **//** preprocessing |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '|   4 | **for** *i* = 1 **to** *m* | **//** 预处理 |'
- en: '|   5 | *p* = (*dp* + *P*[*i*]) mod *q* |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '|   5 | *p* = (*dp* + *P*[*i*]) mod *q* |'
- en: '|   6 | *t*[0] = (*dt*[0] + *T*[*i*]) mod *q* |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '|   6 | *t*[0] = (*dt*[0] + *T*[*i*]) mod *q* |'
- en: '|   7 | **for** *s* = 0 **to** *n* – *m* | **//** matching—try all possible
    shifts |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '|   7 | **for** *s* = 0 **to** *n* – *m* | **//** 匹配—尝试所有可能的移动 |'
- en: '|   8 | **if** *p* == *t*[*s*] | **//** a hit? |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '|   8 | **if** *p* == *t*[*s*] | **//** 命中？ |'
- en: '|   9 | **if** *P*[1:*m*] == *T*[*s* + 1:*s* + *m*] | **//** valid shift? |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '|   9 | **if** *P*[1:*m*] == *T*[*s* + 1:*s* + *m*] | **//** 有效的移动？ |'
- en: '| 10 | print “Pattern occurs with shift” *s* |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 打印“模式出现的移动” *s* |'
- en: '| 11 | **if** *s* < *n* – *m* |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| 11 | **if** *s* < *n* – *m* |'
- en: '| 12 | ![art](images/Art_P1298.jpg) |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| 12 | ![art](images/Art_P1298.jpg) |'
- en: '*O*(*n*) + *O*(*m*(*v* + *n*/*q*)),'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*O*(*n*) + *O*(*m*(*v* + *n*/*q*)),'
- en: where *v* is the number of valid shifts. This running time is *O*(*n*) if *v*
    = *O*(1) and you choose *q* ≥ *m*. That is, if the expected number of valid shifts
    is small (*O*(1)) and you choose the prime *q* to be larger than the length of
    the pattern, then you can expect the Rabin-Karp procedure to use only *O*(*n*
    + *m*) matching time. Since *m* ≤ *n*, this expected matching time is *O*(*n*).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*v*是有效移动的数量。如果*v* = *O*(1)且选择*q* ≥ *m*，则该运行时间为*O*(*n*)。也就是说，如果有效移动的预期数量很小（*O*(1)）并且选择素���*q*大于模式的长度，则可以期望拉宾-卡普过程仅使用*O*(*n*
    + *m*)的匹配时间。由于*m* ≤ *n*，这个预期匹配时间是*O*(*n*)。
- en: '**Exercises**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***32.2-1***'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.2-1***'
- en: Working modulo *q* = 11, how many spurious hits does the Rabin-Karp matcher
    encounter in the text *T* = 3141592653589793 when looking for the pattern *P*
    = 26?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在模*q* = 11下工作时，拉宾-卡普匹配器在查找模式*P* = 26时会遇到多少虚假命中？
- en: '***32.2-2***'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.2-2***'
- en: Describe how to extend the Rabin-Karp method to the problem of searching a text
    string for an occurrence of any one of a given set of *k* patterns. Start by assuming
    that all *k* patterns have the same length. Then generalize your solution to allow
    the patterns to have different lengths.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 描述如何扩展拉宾-卡普方法以解决在文本字符串中搜索给定一组*k*个模式中的任何一个的问题。首先假设所有*k*个模式具有相同的长度。然后将您的解决方案推广到允许模式具有不同长度。
- en: '***32.2-3***'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.2-3***'
- en: Show how to extend the Rabin-Karp method to handle the problem of looking for
    a given *m* × *m* pattern in an *n* × *n* array of characters. (The pattern may
    be shifted vertically and horizontally, but it may not be rotated.)
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何扩展拉宾-卡普方法以处理在*n*×*n*字符数组中查找给定的*m*×*m*模式的问题。（模式可以在垂直和水平方向上移动，但不能旋转。）
- en: '***32.2-4***'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.2-4***'
- en: Alice has a copy of a long *n*-bit file *A* = 〈*a*[*n*–1], *a*[*n*–2], …, *a*[0]〉,
    and Bob similarly has an *n*-bit file *B* = 〈*b*[*n*–1], *b*[*n*–2], …, *b*[0]〉.
    Alice and Bob wish to know if their files are identical. To avoid transmitting
    all of *A* or *B*, they use the following fast probabilistic check. Together,
    they select a prime *q* > 1000*n* and randomly select an integer *x* from {0,
    1, …, *q* – 1}. Letting
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 爱丽丝有一个长*n*位文件*A* = 〈*a*[*n*–1], *a*[*n*–2], …, *a*[0]〉，鲍勃同样有一个*n*位文件*B* = 〈*b*[*n*–1],
    *b*[*n*–2], …, *b*[0]〉。爱丽丝和鲍勃希望知道他们的文件是否相同。为了避免传输整个*A*或*B*，他们使用以下快速概率检查。他们一起选择一个素数*q*
    > 1000*n*，并从{0, 1, …, *q* – 1}中随机选择一个整数*x*。让
- en: '![art](images/Art_P1299.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1299.jpg)'
- en: Alice evaluates *A*(*x*) and Bob evaluates *B*(*x*). Prove that if *A* ≠ *B*,
    there is at most one chance in 1000 that *A*(*x*) = *B*(*x*), whereas if the two
    files are the same, *A*(*x*) is necessarily the same as *B*(*x*). (*Hint:* See
    Exercise 31.4-4.)
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Alice评估 *A*(*x*)，Bob评估 *B*(*x*)。证明如果 *A* ≠ *B*，那么 *A*(*x*) = *B*(*x*) 的可能性最多为1000分之一，而如果两个文件相同，*A*(*x*)必然与*B*(*x*)相同。(*提示:*
    参见练习31.4-4。)
- en: '[**32.3    String matching with finite automata**](toc.xhtml#Rh1-189)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '[**32.3    使用有限自动机进行字符串匹配**](toc.xhtml#Rh1-189)'
- en: 'Many string-matching algorithms build a finite automaton—a simple machine for
    processing information—that scans the text string *T* for all occurrences of the
    pattern *P*. This section presents a method for building such an automaton. These
    string-matching automata are efficient: they examine each text character *exactly
    once*, taking constant time per text character. The matching time used—after preprocessing
    the pattern to build the automaton—is therefore Θ(*n*). The time to build the
    automaton, however, can be large if ∑ is large. [Section 32.4](chapter032.xhtml#Sec_32.4)
    describes a clever way around this problem.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 许多字符串匹配算法构建一个有限自动机——一个用于处理信息的简单机器，它扫描文本字符串 *T* 中模式 *P* 的所有出现。本节介绍了构建这种自动机的方法。这些字符串匹配自动机是高效的：它们仅检查每个文本字符*一次*，每个文本字符花费恒定的时间。匹配所用的时间——在预处理模式以构建自动机之后——因此为Θ(*n*)。然而，构建自动机的时间可能很长，如果
    ∑ 很大的话。[第32.4节](chapter032.xhtml#Sec_32.4)描述了解决这个问题的一个巧妙方法。
- en: We begin this section with the definition of a finite automaton. We then examine
    a special string-matching automaton and show how to use it to find occurrences
    of a pattern in a text. Finally, we’ll see how to construct the string-matching
    automaton for a given input pattern.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从有限自动机的定义开始这一部分。然后我们研究一个特殊的字符串匹配自动机，并展示如何使用它在文本中找到模式的出现。最后，我们将看到如何为给定的输入模式构造字符串匹配自动机。
- en: '**Finite automata**'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**有限自动机**'
- en: A ***finite automaton*** *M*, illustrated in [Figure 32.5](chapter032.xhtml#Fig_32-5),
    is a 5-tuple (*Q*, *q*[0], *A*, ∑, *δ*), where
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有限自动机 *M*，如[图32.5](chapter032.xhtml#Fig_32-5)所示，是一个5元组 (*Q*, *q*[0], *A*,
    ∑, *δ*), 其中
- en: '*Q* is a finite set of ***states***,'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Q* 是一个有限集合的***状态***，'
- en: '*q*[0] ∈ *Q* is the ***start state***,'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*q*[0] ∈ *Q* 是***起始状态***，'
- en: '*A* ⊆ *Q* is a distinguished set of ***accepting states***,'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A* ⊆ *Q* 是一个特殊的***��受状态***集合，'
- en: ∑ is a finite ***input alphabet***,
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ∑ 是一个有限的***输入字母表***，
- en: '*δ* is a function from *Q* × ∑ into *Q*, called the ***transition function***
    of *M*.'
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*δ* 是从 *Q* × ∑ 到 *Q* 的函数，称为 *M* 的***转移函数***。'
- en: '![art](images/Art_P1300.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1300.jpg)'
- en: '**Figure 32.5** A simple two-state finite automaton with state set *Q* = {0,
    1}, start state *q*[0] = 0, and input alphabet ∑ = {a, b}. **(a)** A tabular representation
    of the transition function *δ*. **(b)** An equivalent state-transition diagram.
    State 1, in orange, is the only accepting state. Directed edges represent transitions.
    For example, the edge from state 1 to state 0 labeled b indicates that *δ*(1,
    b) = 0\. This automaton accepts those strings that end in an odd number of a’s.
    More precisely, it accepts a string *x* if and only if *x* = *yz*, where *y* =
    *ϵ* or *y* ends with a b, and *z* = a^(*k*), where *k* is odd. For example, on
    input abaaa, including the start state, this automaton enters the sequence of
    states 〈0, 1, 0, 1, 0, 1〉, and so it accepts this input. For input abbaa, it enters
    the sequence of states 〈0, 1, 0, 0, 1, 0〉, and so it rejects this input.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '**图32.5** 一个简单的两状态有限自动机，状态集合 *Q* = {0, 1}，起始状态 *q*[0] = 0，输入字母表 ∑ = {a, b}。
    **(a)** 转移函数 *δ* 的表格表示。 **(b)** 等效的状态转移图。橙色的状态1是唯一的接受状态。有向边表示转移。例如，从状态1到状态0标记为b的边表示
    *δ*(1, b) = 0。这个自动机接受以奇数个a结尾的字符串。更准确地说，它接受一个字符串 *x* 当且仅当 *x* = *yz*，其中 *y* = *ϵ*
    或 *y* 以b结尾，而 *z* = a^(*k*)，其中 *k* 是奇数。例如，对于输入abaaa，包括起始状态，这个自动机进入状态序列 〈0, 1, 0,
    1, 0, 1〉，因此接受这个输入。对于输入abbaa，它进入状态序列 〈0, 1, 0, 0, 1, 0〉，因此拒绝这个输入。'
- en: The finite automaton begins in state *q*[0] and reads the characters of its
    input string one at a time. If the automaton is in state *q* and reads input character
    *a*, it moves (“makes a transition”) from state *q* to state *δ*(*q*, *a*). Whenever
    its current state *q* is a member of *A*, the machine *M* has ***accepted*** the
    string read so far. An input that is not accepted is ***rejected***.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 有限自动机从状态 *q*[0] 开始，并逐个读取其输入字符串的字符。如果自动机处于状态 *q* 并读取输入字符 *a*，它会从状态 *q* 移动（“进行转移”）到状态
    *δ*(*q*, *a*)。每当当前状态 *q* 是 *A* 的成员时，机器 *M* 已经***接受***了到目前为止读取的字符串。未被接受的输入被***拒绝***。
- en: 'A finite automaton *M* induces a function *ϕ*, called the ***final-state function***,
    from ∑* to *Q* such that *ϕ*(*w*) is the state *M* ends up in after reading the
    string *w*. Thus, *M* accepts a string *w* if and only if *ϕ*(*w*) ∈ *A*. We define
    the function *ϕ* recursively, using the transition function:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 一个有限自动机 *M* 引出一个函数 *ϕ*，称为***最终状态函数***，从 ∑* 到 *Q*，使得读取字符串 *w* 后 *M* 最终停留在状态 *ϕ*(*w*)。因此，当且仅当
    *ϕ*(*w*) ∈ *A* 时，*M* 接受字符串 *w*。我们使用转移函数递归地定义函数 *ϕ*：
- en: '| *ϕ*(*ϵ*) | = | *q*[0], |  |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| *ϕ*(*ϵ*) | = | *q*[0], |  |'
- en: '| *ϕ*(*wa*) | = | *δ*(*ϕ*(*w*), *a*) | for *w* ∈ ∑*, *a* ∈ ∑. |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| *ϕ*(*wa*) | = | *δ*(*ϕ*(*w*), *a*) | 对于 *w* ∈ ∑*, *a* ∈ ∑. |'
- en: '**String-matching automata**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串匹配自动机**'
- en: For a given pattern *P*, a preprocessing step constructs a string-matching automaton
    specific to *P*. The automaton then searches the text string for occurrences of
    *P*. [Figure 32.6](chapter032.xhtml#Fig_32-6) illustrates the automaton for the
    pattern *P* = ababaca. From now on, let’s assume that *P* is fixed, and for brevity,
    we won’t bother to indicate the dependence upon *P* in our notation.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 对于给定的模式 *P*，预处理步骤构建了一个特定于 *P* 的字符串匹配自动机。然后自动机搜索文本字符串中 *P* 的出现。[图32.6](chapter032.xhtml#Fig_32-6)展示了模式
    *P* = ababaca 的自动机。从现在开始，让我们假设 *P* 是固定的，并且为简洁起见，我们不会在符号中指示对 *P* 的依赖。
- en: 'In order to specify the string-matching automaton corresponding to a given
    pattern *P*[1:*m*], we first define an auxiliary function *σ*, called the ***suffix
    function*** corresponding to the pattern *P*. The function *σ* maps ∑* to {0,
    1, …, *m*} such that *σ*(*x*) is the length of the longest prefix of *P* that
    is also a suffix of *x*:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 为了指定与给定模式*P*[1:*m*]对应的字符串匹配自动机，我们首先定义一个辅助函数*σ*，称为与模式*P*对应的***后缀函数***。函数*σ*将∑*映射到{0,
    1, …, *m*}，使得*σ*(*x*)是*P*的最长前缀，同时也是*x*的后缀的长度：
- en: '![art](images/Art_P1301.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1301.jpg)'
- en: '![art](images/Art_P1302.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1302.jpg)'
- en: '**Figure 32.6 (a)** A state-transition diagram for the string-matching automaton
    that accepts all strings ending in the string ababaca. State 0 is the start state,
    and state 7 (in orange) is the only accepting state. The transition function *δ*
    is defined by equation (32.4), and a directed edge from state *i* to state *j*
    labeled *a* represents *δ*(*i*, *a*) = *j*. The right-going edges forming the
    “spine” of the automaton, shown in blue, correspond to successful matches between
    pattern and input characters. Except for the edges from state 7 to states 1 and
    2, the left-going edges correspond to mismatches. Some edges corresponding to
    mismatches are omitted: by convention, if a state *i* has no outgoing edge labeled
    *a* for some *a* ∈ ∑, then *δ*(*i*, *a*) = 0\. **(b)** The corresponding transition
    function *δ*, and the pattern string *P* = ababaca. The entries corresponding
    to successful matches between pattern and input characters are shown in blue.
    **(c)** The operation of the automaton on the text *T* = abababacaba. Under each
    text character *T*[*i*] appears the state *ϕ*(*T*[:*i*]) that the automaton is
    in after processing the prefix *T*[:*i*]. The substring of the pattern that occurs
    in the text is highlighted in blue. The automaton finds this one occurrence of
    the pattern, ending in position 9.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**图32.6（a）** 接受以字符串ababaca结尾的所有字符串的字符串匹配自动机的状态转移图。状态0是起始状态，状态7（橙色）是唯一的接受状态。过渡函数*δ*由方程（32.4）定义，从状态*i*到标记为*a*的状态*j*的有向边表示*δ*(*i*,
    *a*) = *j*。形成自动机“脊柱”的右向边，显示为蓝色，对应于模式和输入字符之间的成功匹配。除了从状态7到状态1和2的边之外，左向边对应于不匹配。一些对应于不匹配的边被省略：按照惯例，如果状态*i*没有标记为*a*的出边，其中*a*
    ∈ ∑，则*δ*(*i*, *a*) = 0。**(b)** 相应的过渡函数*δ*，以及模式字符串*P* = ababaca。显示了模式和输入字符之间的成功匹配的条目为蓝色。**(c)**
    自动机在文本*T* = abababacaba上的操作。在每个文本字符*T*[*i*]下方显示了自动机在处理前缀*T*[:*i*]后所处的状态*ϕ*(*T*[:*i*])。文本中出现的模式子串用蓝色突出显示。自动机找到了这个在位置9结束的模式的一次出现。'
- en: The suffix function *σ* is well defined since the empty string *P*[:0] = *ϵ*
    is a suffix of every string. As examples, for the pattern *P* = ab, we have *σ*(*ε*)
    = 0, *σ*(ccaca) = 1, and *σ*(ccab) = 2\. For a pattern *P* of length *m*, we have
    *σ*(*x*) = *m* if and only if *P* ⊐ *x*. From the definition of the suffix function,
    *x* ⊐ *y* implies *σ*(*x*) ≤ *σ*(*y*) (see Exercise 32.3-4).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀函数*σ*是有定义的，因为空字符串*P*[:0] = *ϵ*是每个字符串的后缀。例如，对于模式*P* = ab，我们有*σ*(*ε*) = 0，*σ*(ccaca)
    = 1，*σ*(ccab) = 2。对于长度为*m*的模式*P*，当且仅当*P* ⊐ *x*时，我们有*σ*(*x*) = *m*。根据后缀函数的定义，*x*
    ⊐ *y*意味着*σ*(*x*) ≤ *σ*(*y*)（参见练习32.3-4）。
- en: 'We are now ready to define the string-matching automaton that corresponds to
    a given pattern *P*[1:*m*]:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备定义与给定模式*P*[1:*m*]对应的字符串匹配自动机：
- en: The state set *Q* is {0, 1, …, *m*}. The start state *q*[0] is state 0, and
    state *m* is the only accepting state.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态集*Q*为{0, 1, …, *m*}。起始状态*q*[0]为状态0，状态*m*是唯一的接受状态。
- en: The transition function *δ* is defined, for any state *q* and character *a*,
    by
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过渡函数*δ*对于任何状态*q*和字符*a*定义如下
- en: '![art](images/Art_P1303.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1303.jpg)'
- en: As the automaton consumes characters of the text *T*, it is trying to build
    a match of the pattern *P* against the most recently seen characters of *T*. At
    any time, the state number *q* gives the length of the longest prefix of *P* that
    matches the most recently seen text characters. Whenever the automaton reaches
    state *m*, the *m* most recently seen text characters match the first *m* characters
    of *P*. Since *P* has length *m*, reaching state *m* means that the *m* most recently
    seen text characters match the entire pattern, so that the automaton has found
    a match.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 当自动机消耗文本*T*的字符时，它试图构建模式*P*与最近看到的*T*字符的匹配。在任何时候，状态编号*q*给出了与最近看到的文本字符匹配的*P*的最长前缀的长度。每当自动机达到状态*m*时，最近看到的*T*字符的*m*个字符与*P*的前*m*个字符匹配。由于*P*的长度为*m*，达到状态*m*意味着最近看到的*T*字符匹配整个模式，因此自动机找到了一个匹配。
- en: 'With this intuition behind the design of the automaton, here is the reasoning
    behind defining *δ*(*q*, *a*) = *σ*(*P*[:*q*]*a*). Suppose that the automaton
    is in state *q* after reading the first *i* characters of the text, that is, *q*
    = *ϕ*(*T*[:*i*]). The intuitive idea then says that *q* also equals the length
    of the longest prefix of *P* that matches a suffix of *T*[:*i*] or, equivalently,
    that *q* = *σ*(*T*[:*i*]). Thus, since *ϕ*(*T*[:*i*]) and *σ*(*T*[:*i*]) both
    equal *q*, we will see (in Theorem 32.4 on page 973) that the automaton maintains
    the following invariant:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计自动机背后的这种直觉下，这里是定义*δ*(*q*, *a*) = *σ*(*P*[:*q*]*a*) 的推理。假设在读取文本的前*i*个字符后，自动机处于状态*q*，即*q*
    = *ϕ*(*T*[:*i*])。直观的想法是*q*也等于*P*的最长前缀与*T*[:*i*]的后缀匹配的长度，或者等价地，*q* = *σ*(*T*[:*i*])。因此，由于*ϕ*(*T*[:*i*])和*σ*(*T*[:*i*])都等于*q*，我们将看到（在第973页的定理32.4中）自动机保持以下不变性：
- en: '![art](images/Art_P1304.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1304.jpg)'
- en: If the automaton is in state *q* and reads the next character *T*[*i* + 1] =
    *a*, then the transition should lead to the state corresponding to the longest
    prefix of *P* that is a suffix of *T*[:*i*]*a*. That state is *σ*(*T*[:*i*]*a*),
    and equation (32.5) gives *ϕ*(*T*[:*i*]*a*) = *σ*(*T*[:*i*]*a*). Because *P*[:*q*]
    is the longest prefix of *P* that is a suffix of *T*[:*i*], the longest prefix
    of *P* that is a suffix of *T*[:*i*]*a* has length not only *σ*(*T*[:*i*]*a*),
    but also *σ*(*P*[:*q*]*a*), and so *ϕ*(*T*[:*i*]*a*) = *σ*(*P*[:*q*]*a*). (Lemma
    32.3 on page 972 will prove that *σ*(*T*[:*i*]*a*) = *σ*(*P*[:*q*]*a*).) Thus,
    when the automaton is in state *q*, the transition function *δ* on character *a*
    should take the automaton to state *δ*(*q*, *a*) = *δ*(*ϕ*(*T*[:*i*]), *a*) =
    *ϕ*(*T*[:*i*]*a*) = *σ*(*P*[:*q*]*a*) (with the last equality following from equation
    (32.5)).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如果自动机处于状态*q*并读取下一个字符*T*[*i* + 1] = *a*，则转移应导致到达*P*的最长前缀，该前缀是*T*[:*i*]*a*的后缀的状态。该状态为*σ*(*T*[:*i*]*a*)，方程(32.5)给出*ϕ*(*T*[:*i*]*a*)
    = *σ*(*T*[:*i*]*a*)。因为*P*[:*q*]是*P*的最长前缀，该前缀是*T*[:*i*]的后缀，因此*P*的最长前缀，该���缀是*T*[:*i*]*a*的后缀，长度不仅为*σ*(*T*[:*i*]*a*)，还为*σ*(*P*[:*q*]*a*)，因此*ϕ*(*T*[:*i*]*a*)
    = *σ*(*P*[:*q*]*a*)（最后一个等式是根据方程(32.5)得出的）。
- en: There are two cases to consider, depending on whether the next character continues
    to match the pattern. In the first case, *a* = *P*[*q* + 1], so that the character
    *a* continues to match the pattern. In this case, because *δ*(*q*, *a*) = *q*
    + 1, the transition continues to go along the “spine” of the automaton (the blue
    edges in [Figure 32.6(a)](chapter032.xhtml#Fig_32-6)). In the second case, *a*
    ≠ *P*[*q* + 1], so that *a* does not extend the match being built. In this case,
    we need to find the longest prefix of *P* that is also a suffix of *T*[:*i*]*a*,
    which will have length at most *q*. The preprocessing step matches the pattern
    against itself when creating the string-matching automaton, so that the transition
    function can quickly identify the longest such smaller prefix of *P*.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 需要考虑两种情况，取决于下一个字符是否继续匹配模式。在第一种情况下，*a* = *P*[*q* + 1]，这样字符*a*就继续匹配模式。在这种情况下，因为*δ*(*q*,
    *a*) = *q* + 1，转移继续沿着自动机的“脊柱”进行（[图32.6(a)](chapter032.xhtml#Fig_32-6)中的蓝色边缘）。在第二种情况下，*a*
    ≠ *P*[*q* + 1]，因此*a*不会延伸到正在构建的匹配。在这种情况下，我们需要找到*P*的最长前缀，该前缀也是*T*[:*i*]*a*的后缀，其长度最多为*q*。在创建字符串匹配自动机时，预处理步骤将模式与自身进行匹配，以便转移函数可以快速识别*P*的最长较小前缀。
- en: Let’s look at an example. Consider state 5 in the string-matching automaton
    of [Figure 32.6](chapter032.xhtml#Fig_32-6). In state 5, the five most recently
    read characters of *T* are ababa, the characters along the spine of the automaton
    that reach state 5\. If the next character of *T* is c, then the most recently
    read characters of *T* are ababac, which is the prefix of *P* with length 6\.
    The automaton should continue along the spine to state 6\. This is the first case,
    in which the match continues, and *δ*(5, c) = 6\. To illustrate the second case,
    suppose that in state 5, the next character of *T* is b, so the most recently
    read characters of *T* are ababab. Here, the longest prefix of *P* that matches
    the most recently read characters of *T*—that is, a suffix of the portion of *T*
    read so far—is abab, with length 4, so *δ*(5, b) = 4.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个例子。考虑[图32.6](chapter032.xhtml#Fig_32-6)中字符串匹配自动机的状态5。在状态5中，*T*的最近读取的五个字符是ababa，这些字符沿着达到状态5的自动机的脊柱。如果*T*的下一个字符是c，则*T*的最近读取的字符是ababac，这是长度为6的*P*的前缀。自动机应该继续沿着脊柱到状态6。这是第一种情况，即匹配继续，*δ*(5,
    c) = 6。为了说明第二种情况，假设在状态5中，*T*的下一个字符是b，则*T*的最近读取的字符是ababab。在这里，与*T*的最近读取的字符匹配的*P*的最长前缀是abab，长度为4，因此*δ*(5,
    b) = 4。
- en: To clarify the operation of a string-matching automaton, the simple and efficient
    procedure FINITE-AUTOMATON-MATCHER simulates the behavior of such an automaton
    (represented by its transition function *δ*) in finding occurrences of a pattern
    *P* of length *m* in an input text *T*[1:*n*]. As for any string-matching automaton
    for a pattern of length *m*, the state set *Q* is {0, 1, …, *m*}, the start state
    is 0, and the only accepting state is state *m*. From the simple loop structure
    of FINITE-AUTOMATON-MATCHER, you can see that its matching time on a text string
    of length *n* is Θ(*n*), assuming that each lookup of the transition function
    *δ* takes constant time. This matching time, however, does not include the preprocessing
    time required to compute the transition function. We address this problem later,
    after first proving that the procedure FINITE-AUTOMATON-MATCHER operates correctly.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 为了澄清字符串匹配自动机的操作，简单而高效的过程FINITE-AUTOMATON-MATCHER模拟了这种自动机（由其转移函数*δ*表示）在输入文本*T*[1:*n*]中查找长度为*m*的模式*P*的出现的行为。对于任何长度为*m*的模式的字符串匹配自动机，状态集*Q*为{0,
    1, …, *m*}，起始状态为0，唯一的接受状态为状态*m*。从FINITE-AUTOMATON-MATCHER的简单循环结构中，您可以看到其在长度为*n*的文本字符串上的匹配时间为Θ(*n*)，假设每次查找转移函数*δ*都需要恒定时间。然而，这种匹配时间不包括计算转移函数所需的预处理时间。我们将在稍后解决这个问题，在首先证明过程FINITE-AUTOMATON-MATCHER的正确操作之后。
- en: FINITE-AUTOMATON-MATCHER(*T*, *δ*, *n*, *m*)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: FINITE-AUTOMATON-MATCHER(*T*, *δ*, *n*, *m*)
- en: '| 1 | *q* = 0 |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *q* = 0 |'
- en: '| 2 | **for** *i* = 1 **to** *n* |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **对于** *i* = 1 **到** *n* |'
- en: '| 3 | *q* = *δ*(*q*, *T*[*i*]) |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *q* = *δ*(*q*, *T*[*i*]) |'
- en: '| 4 | **if** *q* == *m* |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **如果** *q* == *m* |'
- en: '| 5 | print “Pattern occurs with shift” *i* – *m* |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 打印“模式出现的偏移量” *i* – *m* |'
- en: Let’s examine how the automaton operates on an input text *T*[1:*n*]. We will
    prove that the automaton is in state *σ*(*T*[:*i*]) after reading character *T*[*i*].
    Since *σ*(*T*[:*i*]) = *m* if and only if *P* ⊐ *T*[:*i*], the machine is in the
    accepting state *m* if and only if it has just read the pattern *P*. We start
    with two lemmas about the suffix function *σ*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看自动机如何在输入文本*T*[1:*n*]上运行。我们将证明，在读取字符*T*[*i*]后，自动机处于状态*σ*(*T*[:*i*])。由于*σ*(*T*[:*i*])
    = *m*当且仅当*P* ⊐ *T*[:*i*]，当且仅当它刚刚读取模式*P*时，机器处于接受状态*m*。我们从关于后缀函数*σ*的两个引理开始。
- en: '***Lemma 32.2 (Suffix-function inequality)***'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理32.2（后缀函数不等式）***'
- en: For any string *x* and character *a*, we have *σ*(*xa*) ≤ *σ*(*x*) + 1.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意字符串*x*和字符*a*，我们有*σ*(*xa*) ≤ *σ*(*x*) + 1。
- en: '![art](images/Art_P1305.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1305.jpg)'
- en: '**Figure 32.7** An illustration for the proof of Lemma 32.2\. The figure shows
    that *r* ≤ *σ*(*x*) + 1, where *r* = *σ*(*xa*).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**图32.7** 证明引理32.2的插图。图表明*r* ≤ *σ*(*x*) + 1，其中*r* = *σ*(*xa*)。'
- en: '![art](images/Art_P1306.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1306.jpg)'
- en: '**Figure 32.8** An illustration for the proof of Lemma 32.3\. The figure shows
    that *r* = *σ*(*P*[:*q*]*a*), where *q* = *σ*(*x*) and *r* = *σ*(*xa*).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**图32.8** 证明引理32.3的插图。图表明*r* = *σ*(*P*[:*q*]*a*)，其中*q* = *σ*(*x*)，*r* = *σ*(*xa*)。'
- en: '***Proof***   Referring to [Figure 32.7](chapter032.xhtml#Fig_32-7), let *r*
    = *σ*(*xa*). If *r* = 0, then the conclusion *σ*(*xa*) = *r* ≤ *σ*(*x*)+1 is trivially
    satisfied since *σ*(*x*) is nonnegative. Now assume that *r* > 0\. Then, *P*[:*r*]
    ⊐ *xa*, by the definition of *σ*. Thus, *P*[:*r* − 1] ⊐ *x*, by dropping the *a*
    from both the end of *P*[:*r*] and the end of *xa*. Therefore, *r* – 1 ≤ *σ*(*x*),
    since *σ*(*x*) is the largest *k* such that *P*[:*k*] ⊐ *x*, and thus *σ*(*xa*)
    = *r* ≤ *σ*(*x*) + 1.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 参考[图32.7](chapter032.xhtml#Fig_32-7)，设*r* = *σ*(*xa*)。如果*r* = 0，则结论*σ*(*xa*)
    = *r* ≤ *σ*(*x*)+1显然成立，因为*σ*(*x*)是非负的。现在假设*r* > 0。那么，根据*σ*的定义，*P*[:*r*] ⊐ *xa*。因此，通过从*P*[:*r*]和*xa*的末尾删除*a*，得到*P*[:*r*
    − 1] ⊐ *x*。因此，*r* – 1 ≤ *σ*(*x*)，因为*σ*(*x*)是最大的*k*，使得*P*[:*k*] ⊐ *x*，因此*σ*(*xa*)
    = *r* ≤ *σ*(*x*) + 1。'
- en: ▪
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Lemma 32.3 (Suffix-function recursion lemma)***'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理32.3（后缀函数递归引理）***'
- en: For any string *x* and character *a*, if *q* = *σ*(*x*), then *σ*(*xa*) = *σ*(*P*[:*q*]*a*).
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意字符串*x*和字符*a*，如果*q* = *σ*(*x*)，那么*σ*(*xa*) = *σ*(*P*[:*q*]*a*)。
- en: '***Proof***   The definition of *σ* gives that *P*[:*q*] ⊐ *x*. As [Figure
    32.8](chapter032.xhtml#Fig_32-8) shows, we also have *P*[:*q*]*a* ⊐ *xa*. Let
    *r* = *σ*(*xa*). Then *P*[:*r*] ⊐ *xa* and, by Lemma 32.2, *r* ≤ *q* + 1\. Thus,
    we have |*P*[:*r*]| = *r* ≤ *q* + 1 = |*P*[:*q*]*a*|. Since *P*[:*q*]*a* ⊐ *xa*,
    *P*[:*r*] ⊐ *xa*, and |*P*[:*r*]| ≤ |*P*[:*q*]*a*|, Lemma 32.1 on page 959 implies
    that *P*[:*r*] ⊐ *P*[:*q*]*a*. Therefore, *r* ≤ (*P*[:*q*]*a*), that is, *σ*(*xa*)
    ≤ *σ*(*P*[:*q*]*a*). But we also have *σ*(*P*[:*q*]*a*) ≤ *σ*(*xa*), since *P*[:*q*]*a*
    ⊐ *xa*. Thus, *σ*(*xa*) = *σ*(*P*[:*q*]*a*).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 根据*σ*的定义，*P*[:*q*] ⊐ *x*。如[图32.8](chapter032.xhtml#Fig_32-8)所示，我们还有*P*[:*q*]*a*
    ⊐ *xa*。设*r* = *σ*(*xa*)。那么*P*[:*r*] ⊐ *xa*，根据引理32.2，*r* ≤ *q* + 1。因此，我们有|*P*[:*r*]|
    = *r* ≤ *q* + 1 = |*P*[:*q*]*a*|。由于*P*[:*q*]*a* ⊐ *xa*，*P*[:*r*] ⊐ *xa*，且|*P*[:*r*]|
    ≤ |*P*[:*q*]*a*|，根据第959页的引理32.1，*P*[:*r*] ⊐ *P*[:*q*]*a*。因此，*r* ≤ (*P*[:*q*]*a*)，即*σ*(*xa*)
    ≤ *σ*(*P*[:*q*]*a*)。但我们还有*σ*(*P*[:*q*]*a*) ≤ *σ*(*xa*)，因为*P*[:*q*]*a* ⊐ *xa*。因此，*σ*(*xa*)
    = *σ*(*P*[:*q*]*a*)。'
- en: ▪
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: We are now ready to prove the main theorem characterizing the behavior of a
    string-matching automaton on a given input text. As noted above, this theorem
    shows that the automaton is merely keeping track, at each step, of the longest
    prefix of the pattern that is a suffix of what has been read so far. In other
    words, the automaton maintains the invariant (32.5).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备证明关于给定输入文本上字符串匹配自动机行为的主要定理。如上所述，该定理表明自动机在每一步仅仅跟踪模式的最长前缀，该前缀是迄今为止已读取的后缀。换句话说，自动机保持不变式（32.5）。
- en: '***Theorem 32.4***'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理32.4***'
- en: If *ϕ* is the final-state function of a string-matching automaton for a given
    pattern *P* and *T*[1:*n*] is an input text for the automaton, then
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*ϕ*是给定模式*P*的字符串匹配自动机的最终状态函数，*T*[1:*n*]是自动机的输入文本，则
- en: '*ϕ*(*T*[:*i*]) = *σ*(*T*[:*i*])'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '*ϕ*(*T*[:*i*]) = *σ*(*T*[:*i*])'
- en: for *i* = 0, 1, …, *n*.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*i* = 0, 1, …, *n*。
- en: '***Proof***   The proof is by induction on *i*. For *i* = 0, the theorem is
    trivially true, since *T*[:0] = *ε*. Thus, *ϕ*(*T*[:0]) = 0 = *σ*(*T*[:0]).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 通过对*i*进行归纳证明。对于*i* = 0，定理显然成立，因为*T*[:0] = *ε*。因此，*ϕ*(*T*[:0]) = 0
    = *σ*(*T*[:0])。'
- en: Now assume that *ϕ*(*T*[:*i*]) = *σ*(*T*[:*i*]). We will prove that *ϕ*(*T*[:*i*
    + 1]) = *σ*(*T*[:*i* + 1]). Let *q* denote *ϕ*(*T*[:*i*]), so that *q* = *σ*(*T*[:*i*]),
    and let *a* denote *T*[*i* + 1]. Then,
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设*ϕ*(*T*[:*i*]) = *σ*(*T*[:*i*])。我们将证明*ϕ*(*T*[:*i* + 1]) = *σ*(*T*[:*i* +
    1])。设*q*表示*ϕ*(*T*[:*i*])，因此*q* = *σ*(*T*[:*i*])，*a*表示*T*[*i* + 1]。那么，
- en: '| *ϕ*(*T*[:*i* + 1]) | = | *ϕ*(*T*[:*i*]*a*) | (by the definitions of *T*[:*i*
    + 1] and *a*) |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| *ϕ*(*T*[:*i* + 1]) | = | *ϕ*(*T*[:*i*]*a*) |（根据*T*[:*i* + 1]和*a*的定义）|'
- en: '|  | = | *δ*(*ϕ*(*T*[:*i*]), *a*) | (by the definition of *ϕ*) |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *δ*(*ϕ*(*T*[:*i*]), *a*) |（根据*ϕ*的定义）|'
- en: '|  | = | *δ*(*q*, *a*) | (by the definition of *q*) |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *δ*(*q*, *a*) |（根据*q*的定义）|'
- en: '|  | = | *σ*(*P*[:*q*]*a*) | (by the definition (32.4) of *δ*) |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *σ*(*P*[:*q*]*a*) |（根据*δ*的定义（32.4））|'
- en: '|  | = | *σ*(*T*[:*i*]*a*) | (by Lemma 32.3) |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *σ*(*T*[:*i*]*a*) |（根据引理32.3）|'
- en: '|  | = | (*T*[:*i* + 1]) | (by the definition of *T*[:*i* + 1]). |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '|  | = | (*T*[:*i* + 1]) |（根据*T*[:*i* + 1]的定义）|'
- en: ▪
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: By Theorem 32.4, if the machine enters state *q* on line 3, then *q* is the
    largest value such that *P*[:*q*] ⊐ *T*[:*i*]. Thus, in line 4, *q* = *m* if and
    only if the machine has just read an occurrence of the pattern *P*. Therefore,
    FINITE-AUTOMATON-MATCHER operates correctly.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定理32.4，如果机器在第3行进入状态*q*，那么*q*是最大的值，使得*P*[:*q*] ⊐ *T*[:*i*]。因此，在第4行，当且仅当机器刚刚读取模式*P*的出现时，*q*
    = *m*。因此，FINITE-AUTOMATON-MATCHER操作正确。
- en: '**Computing the transition function**'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算转移函数**'
- en: The procedure COMPUTE-TRANSITION-FUNCTION on the following page computes the
    transition function *δ* from a given pattern *P*[1:*m*]. It computes *δ*(*q*,
    *a*) in a straightforward manner according to its definition in equation (32.4).
    The nested loops beginning on lines 1 and 2 consider all states *q* and all characters
    *a*, and lines 3–6 set *δ*(*q*, *a*) to be the largest *k* such that *P*[:*k*]
    ⊐ *P*[:*q*]*a*. The code starts with the largest conceivable value of *k*, which
    is *q*+1, unless *q* = *m*, in which case *k* cannot be larger than *m*. It then
    decreases *k* until *P*[:*k*] is a suffix of *P*[:*q*]*a*, which must eventually
    occur, since *P*[:0] = *ε* is a suffix of every string.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一页上的COMPUTE-TRANSITION-FUNCTION过程计算给定模式 *P*[1:*m*] 的转移函数 *δ*。根据方程（32.4）中的定义，它以直接的方式计算
    *δ*(*q*, *a*)。从第1行和第2行开始的嵌套循环考虑所有状态 *q* 和所有字符 *a*，第3至第6行将 *δ*(*q*, *a*) 设置为最大的
    *k*，使得 *P*[:*k*] ⊐ *P*[:*q*]*a*。代码从可能的最大值 *k* 开始，即 *q*+1，除非 *q* = *m*，在这种情况下，*k*
    不能大于 *m*。然后，它减少 *k* 直到 *P*[:*k*] 是 *P*[:*q*]*a* 的后缀，这最终必然会发生，因为 *P*[:0] = *ε*
    是每个字符串的后缀。
- en: COMPUTE-TRANSITION-FUNCTION(*P*, ∑, *m*)
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: COMPUTE-TRANSITION-FUNCTION(*P*, ∑, *m*)
- en: '| 1 | **for** *q* = 0 **to** *m* |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **对于** *q* = 0 **到** *m* |'
- en: '| 2 | **for** each character *a* ∈ ∑ |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **对于** 每个字符 *a* ∈ ∑ |'
- en: '| 3 | *k* = min {*m*, *q* + 1} |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *k* = min {*m*, *q* + 1} |'
- en: '| 4 | **while** *P*[:*k*] is not a suffix of *P*[:*q*]*a* |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **当** *P*[:*k*] 不是 *P*[:*q*]*a* 的后缀时 |'
- en: '| 5 | *k* = *k* – 1 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 5 | *k* = *k* – 1 |'
- en: '| 6 | *δ*(*q*, *a*) = *k* |'
  id: totrans-179
  prefs: []
  type: TYPE_TB
  zh: '| 6 | *δ*(*q*, *a*) = *k* |'
- en: '| 7 | **return** *δ* |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| 7 | **返回** *δ* |'
- en: The running time of COMPUTE-TRANSITION-FUNCTION is *O*(*m*³ |∑|), because the
    outer loops contribute a factor of *m* |∑|, the inner **while** loop can run at
    most *m* + 1 times, and the test for whether *P*[:*k*] is a suffix of *P*[:*q*]*a*
    on line 4 can require comparing up to *m* characters. Much faster procedures exist.
    By utilizing some cleverly computed information about the pattern *P* (see Exercise
    32.4-8), the time required to compute *δ* from *P* improves to *O*(*m* |∑|). This
    improved procedure for computing *δ* provides a way to find all occurrences of
    a length-*m* pattern in a length-*n* text over an alphabet ∑ with *O*(*m* |∑|)
    preprocessing time and Θ(*n*) matching time.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: COMPUTE-TRANSITION-FUNCTION的运行时间为*O*(*m*³ |∑|)，因为外部循环贡献了一个因子 *m* |∑|，内部的**while**循环最多可以运行
    *m* + 1 次，而第4行对于 *P*[:*k*] 是否是 *P*[:*q*]*a* 的后缀可能需要比较多达 *m* 个字符。存在更快的过程。通过利用关于模式
    *P* 的一些巧妙计算的信息（参见练习32.4-8），从 *P* 计算 *δ* 所需的时间改进为*O*(*m* |∑|)。这种改进的计算 *δ* 的过程提供了一种在字母表
    ∑ 上对长度为 *n* 的文本中长度为 *m* 的模式的所有出现进行查找的方法，预处理时间为*O*(*m* |∑|)，匹配时间为Θ(*n*)。
- en: '**Exercises**'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***32.3-1***'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.3-1***'
- en: Draw a state-transition diagram for the string-matching automaton for the pattern
    *P* = aabab over the alphabet ∑ = {a, b} and illustrate its operation on the text
    string *T* = aaababaabaababaab.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 为模式 *P* = aabab 在字母表 ∑ = {a, b} 上绘制一个状态转移图，并说明它在文本字符串 *T* = aaababaabaababaab
    上的操作。
- en: '***32.3-2***'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.3-2***'
- en: Draw a state-transition diagram for the string-matching automaton for the pattern
    *P* = ababbabbababbababbabb over the alphabet ∑ = {a, b}.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 为模式 *P* = ababbabbababbababbabb 在字母表 ∑ = {a, b} 上绘制��个状态转移图。
- en: '***32.3-3***'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.3-3***'
- en: A pattern *P* is ***nonoverlappable*** if *P*[:*k*] ⊐ *P*[:*q*] implies *k*
    = 0 or *k* = *q*. Describe the state-transition diagram of the string-matching
    automaton for a nonoverlappable pattern.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 如果模式 *P*[:*k*] ⊐ *P*[:*q*] 意味着 *k* = 0 或 *k* = *q*，则模式 *P* 是***不重叠***的。描述一个非重叠模式的字符串匹配自动机的状态转移图。
- en: '***32.3-4***'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.3-4***'
- en: Let *x* and *y* be prefixes of the pattern *P*. Prove that *x* ⊐ *y* implies
    *σ*(*x*) ≤ *σ*(*y*).
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 设 *x* 和 *y* 是模式 *P* 的前缀。证明 *x* ⊐ *y* 意味着 *σ*(*x*) ≤ *σ*(*y*)。
- en: ★ ***32.3-5***
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***32.3-5***
- en: Given two patterns *P* and *P*′, describe how to construct a finite automaton
    that determines all occurrences of *either* pattern. Try to minimize the number
    of states in your automaton.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个模式 *P* 和 *P*′，描述如何构建一个确定所有出现的有限自动机 *P*。尝试最小化自动机中的状态数。
- en: '***32.3-6***'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.3-6***'
- en: Given a pattern *P* containing gap characters (see Exercise 32.1-4), show how
    to build a finite automaton that can find an occurrence of *P* in a text *T* in
    *O*(*n*) matching time, where *n* = |*T*|.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 给定包含间隙字符的模式 *P*（参见练习32.1-4），展示如何构建一个有限自动机，可以在*O*(*n*)的匹配时间内在文本 *T* 中找到 *P* 的出现，其中
    *n* = |*T*|。
- en: '[★ **32.4 The Knuth-Morris-Pratt algorithm**](toc.xhtml#Rh1-190)'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '[★ **32.4 康扎-莫里斯-普拉特算法**](toc.xhtml#Rh1-190)'
- en: Knuth, Morris, and Pratt developed a linear-time string matching algorithm that
    avoids computing the transition function *δ* altogether. Instead, the KMP algorithm
    uses an auxiliary function *π*, which it precomputes from the pattern in Θ(*m*)
    time and stores in an array *π*[1:*m*]. The array *π* allows the algorithm to
    compute the transition function *δ* efficiently (in an amortized sense) “on the
    fly” as needed. Loosely speaking, for any state *q* = 0, 1, …, *m* and any character
    *a* ∈ ∑, the value *π*[*q*] contains the information needed to compute *δ*(*q*,
    *a*) but that does not depend on *a*. Since the array *π* has only *m* entries,
    whereas *δ* has Θ(*m* |∑|) entries, the KMP algorithm saves a factor of |∑| in
    the preprocessing time by computing *π* rather than *δ*. Like the procedure FINITE-AUTOMATON-MATCHER,
    once preprocessing has completed, the KMP algorithm uses Θ(*n*) matching time.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Knuth、Morris 和 Pratt 开发了一种线性时间的字符串匹配算法，避免了完全计算转移函数 *δ*。相反，KMP算法使用一个辅助函数 *π*，它从模式中预先计算出来，并在Θ(*m*)的时间内存储在数组
    *π*[1:*m*] 中。数组 *π* 允许算法有效地（就平摊而言）“按需”计算转移函数 *δ*。粗略地说，对于任意状态 *q* = 0, 1, …, *m*
    和任意字符 *a* ∈ ∑，值 *π*[*q*] 包含计算 *δ*(*q*, *a*) 所需的信息，但不依赖于 *a*。由于数组 *π* 只有 *m* 个条目，而
    *δ* 有 Θ(*m* |∑|) 个条目，KMP算法通过计算 *π* 而不是 *δ* 在预处理时间中节省了一个 |∑| 的因子。与过程FINITE-AUTOMATON-MATCHER类似，一旦预处理完成，KMP算法使用Θ(*n*)的匹配时间。
- en: '**The prefix function for a pattern**'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '**用于模式的前缀函数**'
- en: The prefix function *π* for a pattern encapsulates knowledge about how the pattern
    matches against shifts of itself. The KMP algorithm takes advantage of this information
    to avoid testing useless shifts in the naive pattern-matching algorithm and to
    avoid precomputing the full transition function *δ* for a string-matching automaton.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个模式的前缀函数*π*封装了关于模式如何与自身的偏移匹配的知识。KMP算法利用这些信息来避免在朴素模式匹配算法中测试无用的偏移，并避免为字符串匹配自动机预先计算完整的转移函数*δ*。
- en: Consider the operation of the naive string matcher. [Figure 32.9(a)](chapter032.xhtml#Fig_32-9)
    shows a particular shift *s* of a template containing the pattern *P* = ababaca
    against a text *T*. For this example, *q* = 5 of the characters have matched successfully,
    but the 6th pattern character fails to match the corresponding text character.
    The information that *q* characters have matched successfully determines the corresponding
    text characters. Because these *q* text characters match, certain shifts must
    be invalid. In the example of the figure, the shift *s* + 1 is necessarily invalid,
    since the first pattern character (a) would be aligned with a text character that
    does not match the first pattern character, but does match the second pattern
    character (b). The shift *s*′ = *s* + 2 shown in part (b) of the figure, however,
    aligns the first three pattern characters with three text characters that necessarily
    match.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑朴素字符串匹配器的操作。[图32.9(a)](chapter032.xhtml#Fig_32-9)展示了一��包含模式*P* = ababaca的模板的特定偏移*s*与文本*T*的匹配情况。对于这个例子，成功匹配了5个字符，但第6个模式字符未能与相应的文本字符匹配。成功匹配了*q*个字符的信息决定了相应的文本字符。因为这些*q*个文本字符匹配，某些偏移必须是无效的。在图中的例子中，偏移*s*
    + 1必然是无效的，因为第一个模式字符(a)将与一个不匹配第一个模式字符但匹配第二个模式字符(b)的文本字符对齐。然而，图中(b)部分显示的偏移*s*′ =
    *s* + 2，将前三个模式字符与必然匹配的三个文本字符对齐。
- en: 'More generally, suppose that you know that *P*[:*q*] ⊐ *T*[:*s* + *q*] or,
    equivalently, that *P*[1:*q*] = *T*[*s* + 1:*s* + *q*]. You want to shift *P*
    so that some shorter prefix *P*[:*k*] of *P* matches a suffix of *T*[:*s* +*q*],
    if possible. You might have more than one choice for how much to shift, however.
    In [Figure 32.9(b)](chapter032.xhtml#Fig_32-9), shifting *P* by 2 positions works,
    so that *P*[:3] ⊐ *T*[:*s* + *q*], but so does shifting *P* by 4 positions, so
    that *P*[:1] ⊐ *T*[:*s* +*q*] in [Figure 32.9(c)](chapter032.xhtml#Fig_32-9).
    If more than one shift amount works, you should choose the smallest shift amount
    so that you do not miss any potential matches. Put more precisely, you want to
    answer this question:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，假设你知道*P*[:*q*] ⊐ *T*[:*s* + *q*]或者等价地，*P*[1:*q*] = *T*[*s* + 1:*s* + *q*]。你想要移动*P*，以便某个更短的前缀*P*[:*k*]与*T*[:*s*
    + *q*]的后缀匹配，如果可能的话。然而，你可能有多个移动选择。在[图32.9(b)](chapter032.xhtml#Fig_32-9)中，将*P*移动2个位置有效，使得*P*[:3]
    ⊐ *T*[:*s* + *q*]，但将*P*移动4个位置也有效，使得*P*[:1] ⊐ *T*[:*s* + *q*]在[图32.9(c)](chapter032.xhtml#Fig_32-9)中。如果有多个移动量有效，你应该选择最小的移动量，以便不会错过任何潜在的匹配。更准确地说，你想要回答这个问题：
- en: Given that pattern characters *P*[1:*q*] match text characters *T*[*s* + 1:*s*
    + *q*] (that is, *P*[:*q*] ⊐ *T*[:*s* + *q*]), what is the least shift *s*′ >
    *s* such that for some *k* < *q*,
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 假设模式字符*P*[1:*q*]与文本字符*T*[*s* + 1:*s* + *q*]匹配（即，*P*[:*q*] ⊐ *T*[:*s* + *q*]），那么对于某个*k*
    < *q*，最小的偏移*s*′ > *s*是多少？
- en: '![art](images/Art_P1307.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1307.jpg)'
- en: (that is, *P*[:*k*] ⊐ *T*[:*s*′ + *k*]), where *s*′ + *k* = *s* + *q*?
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: （即，*P*[:*k*] ⊐ *T*[:*s*′ + *k*]），其中*s*′ + *k* = *s* + *q*？
- en: Here’s another way to look at this question. If you know *P*[:*q*] ⊐ *T*[:*s*
    + *q*], then how do you find the longest proper prefix *P*[:*k*] of *P*[:*q*]
    that is also a suffix of *T*[:*s* + *q*]? These questions are equivalent because
    given *s* and *q*, requiring *s*′ + *k* = *s* + *q* means that finding the smallest
    shift *s*′ (2 in [Figure 32.9(b)](chapter032.xhtml#Fig_32-9)) is tantamount to
    finding the longest prefix length *k* (3 in [Figure 32.9(b)](chapter032.xhtml#Fig_32-9)).
    If you add the difference *q* – *k* in the lengths of these prefixes of *P* to
    the shift *s*, you get the new shift *s*′, so that *s*′ = *s* + (*q* – *k*). In
    the best case, *k* = 0, so that *s*′ = *s* + *q*, immediately ruling out shifts
    *s* + 1, *s* + 2, …, *s* + *q* − 1\. In any case, at the new shift *s*′, it is
    redundant to compare the first *k* characters of *P* with the corresponding characters
    of *T*, since equation (32.6) guarantees that they match.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有另一种看待这个问题的方式。如果你知道*P*[:*q*] ⊐ *T*[:*s* + *q*]，那么如何找到*P*[:*q*]的最长合适前缀*P*[:*k*]，它也是*T*[:*s*
    + *q*]的后缀？这些问题是等价的，因为给定*s*和*q*，要求*s*′ + *k* = *s* + *q*意味着找到最小的偏移*s*′（[图32.9(b)](chapter032.xhtml#Fig_32-9)中为2）等同于找到最长前缀长度*k*（[图32.9(b)](chapter032.xhtml#Fig_32-9)中为3）。如果将这些*P*的前缀的长度差*q*
    – *k*加到偏移*s*中，你就得到了新的偏移*s*′，所以*s*′ = *s* + (*q* – *k*)。在最佳情况下，*k* = 0，所以*s*′ =
    *s* + *q*，立即排除偏移*s* + 1，*s* + 2，…，*s* + *q* − 1。无论如何，在新的偏移*s*′处，将*P*的前*k*个字符与*T*的相应字符进行比较是多余的，因为方程(32.6)保证它们匹配。
- en: As [Figure 32.9(d)](chapter032.xhtml#Fig_32-9) demonstrates, you can precompute
    the necessary information by comparing the pattern against itself. Since *T*[*s*′
    + 1:*s*′ + *k*] is part of the matched portion of the text, it is a suffix of
    the string *P*[:*q*]. Therefore, think of equation (32.6) as asking for the greatest
    *k* < *q* such that *P*[:*k*] ⊐ *P*[:*q*]. Then, the new shift *s*′ = *s* + (*q*
    – *k*) is the next potentially valid shift. It will be convenient to store, for
    each value of *q*, the number *k* of matching characters at the new shift *s*′,
    rather than storing, say, the amount *s*′ – *s* to shift by.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图32.9(d)](chapter032.xhtml#Fig_32-9)所示，你可以通过将模式与自身进行比较来预先计算必要的信息。由于*T*[*s*′
    + 1:*s*′ + *k*]是文本匹配部分的一部分，它是字符串*P*[:*q*]的后缀。因此，将方程(32.6)视为寻找最大的*k* < *q*，使得*P*[:*k*]
    ⊐ *P*[:*q*]。然后，新的偏移*s*′ = *s* + (*q* – *k*)是下一个可能有效的偏移。对于每个*q*的值，存储在新偏移*s*′处匹配字符数*k*会更方便，而不是存储例如偏移量*s*′
    – *s*。
- en: 'Let’s look at the precomputed information a little more formally. For a given
    pattern *P*[1:*m*], the ***prefix function*** for *P* is the function *π* : {1,
    2, …, *m*} → {0, 1, …, *m* –} such that'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更正式地看一下预先计算的信息。对于给定的模式*P*[1:*m*]，*P*的***前缀函数***是函数*π*：{1, 2, …, *m*} → {0,
    1, …, *m* –}，使得
- en: '*π*[*q*] = max{*k* : *k* < *q* and *P*[:*k*] ⊐ *P*[:*q*]}.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '*π*[*q*] = max{*k* : *k* < *q* and *P*[:*k*] ⊐ *P*[:*q*]}。'
- en: 'That is, *π*[*q*] is the length of the longest prefix of *P* that is a proper
    suffix of *P*[:*q*]. Here is the complete prefix function *π* for the pattern
    ababaca:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 也就是说，*π*[*q*]是*P*的最长前缀，也是*P*[:*q*]的一个合适后缀的长度。这是模式ababaca的完整前缀函数*π*：
- en: '![art](images/Art_P1308.jpg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1308.jpg)'
- en: '**Figure 32.9** The prefix function *π*. **(a)** The pattern *P* = ababaca
    aligns with a text *T* so that the first *q* = 5 characters match. Matching characters,
    in blue, are connected by blue lines. **(b)** Knowing these particular 5 matched
    characters (*P*[:5]) suffices to deduce that a shift of *s* + 1 is invalid, but
    that a shift of *s*′ = *s* + 2 is consistent with everything known about the text
    and therefore is potentially valid. The prefix *P*[:*k*], where *k* = 3, aligns
    with the text seen so far. **(c)** A shift of *s* + 4 is also potentially valid,
    but it leaves only the prefix *P*[:1] aligned with the text seen so far. **(d)**
    To precompute useful information for such deductions, compare the pattern with
    itself. Here, the longest prefix of *P* that is also a proper suffix of *P*[:5]
    is *P*[:3]. The array *π* represents this precomputed information, so that *π*[5]
    = 3\. Given that *q* characters have matched successfully at shift *s*, the next
    potentially valid shift is at *s*′ = *s* + (*q* – *π*[*q*]) as shown in part (b).'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**图32.9** 前缀函数*π*。**(a)** 模式*P* = ababaca与文本*T*对齐，使得前*q* = 5个字符匹配。匹配的字符用蓝色表示，并用蓝色线连接。**(b)**
    知道这5个特定匹配的字符(*P*[:5])足以推断出* s* + 1的移位是无效的，但* s*′ = *s* + 2与已知的文本一切一致，因此可能是有效的。前缀*P*[:*k*]，其中*k*
    = 3，与迄今为止看到的文本对齐。**(c)** *s* + 4的移位也可能有效，但它只留下前缀*P*[:1]与迄今为止看到的文本对齐。**(d)** 为了预先计算这些推断的有用信息，将模式与自身进行比较。在这里，*P*的最长前缀，也是*P*[:5]的一个合适后缀，是*P*[:3]。数组*π*表示这些预先计算的信息，因此*π*[5]
    = 3。假设在移位*s*成功匹配*q*个字符后，下一个可能有效的移位是*s*′ = *s* + (*q* – *π*[*q*])，如(b)部分所示。'
- en: '![art](images/Art_P1308a.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1308a.jpg)'
- en: 'The procedure KMP-MATCHER on the following page gives the Knuth-Morris-Pratt
    matching algorithm. The procedure follows from FINITE-AUTOMATON-MATCHER for the
    most part. To compute *π*, KMP-MATCHER calls the auxiliary procedure COMPUTE-PREFIX-FUNCTION.
    These two procedures have much in common, because both match a string against
    the pattern *P*: KMP-MATCHER matches the text *T* against *P*, and COMPUTE-PREFIX-FUNCTION
    matches *P* against itself.'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的页面上的KMP-MATCHER过程提供了Knuth-Morris-Pratt匹配算法。该过程在很大程度上源自FINITE-AUTOMATON-MATCHER。为了计算*π*，KMP-MATCHER调用辅助过程COMPUTE-PREFIX-FUNCTION。这两个过程有很多共同之处，因为它们都将一个字符串与模式*P*进行匹配：KMP-MATCHER将文本*T*与*P*进行匹配，而COMPUTE-PREFIX-FUNCTION将*P*与自身进行匹配。
- en: Next, let’s analyze the running times of these procedures. Then we’ll prove
    them correct, which will be more complicated.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们分析这些过程的运行时间。然后我们将证明它们的正确性，这将更加复杂。
- en: '**Running-time analysis**'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行时间分析**'
- en: The running time of COMPUTE-PREFIX-FUNCTION is Θ(*m*), which we show by using
    the aggregate method of amortized analysis (see [Section 16.1](chapter016.xhtml#Sec_16.1)).
    The only tricky part is showing that the **while** loop of lines 5–6 executes
    *O*(*m*) times altogether. Starting with some observations about *k*, we’ll show
    that it makes at most *m*–1 iterations. First, line 3 starts *k* at 0, and the
    only way that *k* increases is by the increment operation in line 8, which executes
    at most once per iteration of the **for** loop of lines 4–9\. Thus, the total
    increase in *k* is at most *m*–1\. Second, since *k* < *q* upon entering the **for**
    loop and each iteration of the loop increments *q*, we always have *k* < *q*.
    Therefore, the assignments in lines 2 and 9 ensure that *π*[*q*] < *q* for all
    *q* = 1, 2, …, *m*, which means that each iteration of the **while** loop decreases
    *k*. Third, *k* never becomes negative. Putting these facts together, we see that
    the total decrease in *k* from the **while** loop is bounded from above by the
    total increase in *k* over all iterations of the **for** loop, which is *m* –
    1\. Thus, the **while** loop iterates at most *m* – 1 times in all, and COMPUTE-PREFIX-FUNCTION
    runs in Θ(*m*) time.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: COMPUTE-PREFIX-FUNCTION的运行时间为Θ(*m*)，我们通过摊销分析的集合方法（见[第16.1节](chapter016.xhtml#Sec_16.1)）来展示这一点。唯一棘手的部分是展示第5-6行的**while**循环总共执行*O*(*m*)次。从一些关于*k*的观察开始，我们将展示它最多进行*m*-1次迭代。首先，第3行将*k*初始化为0，而*k*增加的唯一方式是在第8行的增量操作中执行，该操作每次在第4-9行的**for**循环的迭代中最多执行一次。因此，*k*的总增加量最多为*m*-1。其次，由于在进入**for**循环时*k*
    < *q*，并且循环的每次迭代都会增加*q*，我们始终有*k* < *q*。因此，第2行和第9行的赋值确保对于所有*q* = 1, 2, …, *m*，*π*[*q*]
    < *q*，这意味着**while**循环的每次迭代都会减少*k*。第三，*k*永远不会变为负数。综合这些事实，我们可以看到**while**循环中*k*的总减少量上界为**for**循环的所有迭代中*k*的总增加量，即*m*
    – 1。因此，**while**循环总共最多迭代*m* – 1次，COMPUTE-PREFIX-FUNCTION的运行时间为Θ(*m*)。
- en: KMP-MATCHER(*T*, *P*, *n*, *m*)
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: KMP-MATCHER(*T*, *P*, *n*, *m*)
- en: '|   1 | *π* = COMPUTE-PREFIX-FUNCTION(*P*, *m*) |'
  id: totrans-217
  prefs: []
  type: TYPE_TB
  zh: '|   1 | *π* = COMPUTE-PREFIX-FUNCTION(*P*, *m*) |'
- en: '|   2 | *q* = 0 | **//** number of characters matched |'
  id: totrans-218
  prefs: []
  type: TYPE_TB
  zh: '|   2 | *q* = 0 | **//** 匹配的字符数 |'
- en: '|   3 | **for** *i* = 1 **to** *n* | **//** scan the text from left to right
    |'
  id: totrans-219
  prefs: []
  type: TYPE_TB
  zh: '|   3 | **for** *i* = 1 **to** *n* | **//** 从左到右扫描文本 |'
- en: '|   4 | **while** *q* > 0 and *P*[*q* + 1] ≠ *T*[*i*] |'
  id: totrans-220
  prefs: []
  type: TYPE_TB
  zh: '|   4 | **while** *q* > 0 and *P*[*q* + 1] ≠ *T*[*i*] |'
- en: '|   5 | *q* = *π*[*q*] | **//** next character does not match |'
  id: totrans-221
  prefs: []
  type: TYPE_TB
  zh: '|   5 | *q* = *π*[*q*] | **//** 下一个字符不匹配 |'
- en: '|   6 | **if** *P*[*q* + 1] == *T*[*i*] |'
  id: totrans-222
  prefs: []
  type: TYPE_TB
  zh: '|   6 | **if** *P*[*q* + 1] == *T*[*i*] |'
- en: '|   7 | *q* = *q* + 1 | **//** next character matches |'
  id: totrans-223
  prefs: []
  type: TYPE_TB
  zh: '|   7 | *q* = *q* + 1 | **//** 下一个字符匹配 |'
- en: '|   8 | **if** *q* == *m* | **//** is all of *P* matched? |'
  id: totrans-224
  prefs: []
  type: TYPE_TB
  zh: '|   8 | **if** *q* == *m* | **//** 是否所有*P*都匹配了？ |'
- en: '|   9 | print “Pattern occurs with shift” *i* – *m* |'
  id: totrans-225
  prefs: []
  type: TYPE_TB
  zh: '|   9 | 输出“模式出现在移位” *i* – *m* |'
- en: '| 10 | *q* = *π*[*q*] | **//** look for the next match |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| 10 | *q* = *π*[*q*] | **//** 寻找下一个匹配 |'
- en: '| COMPUTE-PREFIX-FUNCTION(*P*, *m*) |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: 计算前缀函数(*P*, *m*) |
- en: '|   1 | let *π*[1:*m*] be a new array |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|   1 | 令 *π*[1:*m*] 为一个新数组 |'
- en: '|   2 | *π*[1] = 0 |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
  zh: '|   2 | *π*[1] = 0 |'
- en: '|   3 | *k* = 0 |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '|   3 | *k* = 0 |'
- en: '|   4 | **for** *q* = 2 **to** *m* |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '|   4 | **对于** *q* = 2 **到** *m* |'
- en: '|   5 | **while** *k* > 0 and *P*[*k* + 1] ≠ *P*[*q*] |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
  zh: '|   5 | **当** *k* > 0 且 *P*[*k* + 1] ≠ *P*[*q*] **时** |'
- en: '|   6 | *k* = *π*[*k*] |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '|   6 | *k* = *π*[*k*] |'
- en: '|   7 | **if** *P*[*k* + 1] == *P*[*q*] |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|   7 | **如果** *P*[*k* + 1] == *P*[*q*] |'
- en: '|   8 | *k* = *k* + 1 |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|   8 | *k* = *k* + 1 |'
- en: '|   9 | *π*[*q*] = *k* |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '|   9 | *π*[*q*] = *k* |'
- en: '| 10 | **return** *π* |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 10 | **返回** *π* |'
- en: Exercise 32.4-4 asks you to show, by a similar aggregate analysis, that the
    matching time of KMP-MATCHER is Θ(*n*).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 32.4-4 要求您通过类似的聚合分析展示 KMP-MATCHER 的匹配时间为 Θ(*n*)。
- en: '![art](images/Art_P1309.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1309.jpg)'
- en: '**Figure 32.10** An illustration of Lemma 32.5 for the pattern *P* = ababaca
    and *q* = 5\. **(a)** The *π* function for the given pattern. Since *π*[5] = 3,
    *π*[3] = 1, and *π*[1]= 0, iterating *π* gives *π**[5] = {3, 1, 0}. **(b)** Sliding
    the template containing the pattern *P* to the right and noting when some prefix
    *P*[:*k*] of *P* matches up with some proper suffix of *P*[:5]. Matches occur
    when *k* = 3, 1, and 0\. In the figure, the first row gives *P*, and the vertical
    red line is drawn just after *P*[:5]. Successive rows show all the shifts of *P*
    that cause some prefix *P*[:*k*] of *P* to match some suffix of *P*[:5]. Successfully
    matched characters are shown in blue. Blue lines connect aligned matching characters.
    Thus, {*k* : *k* < 5 and *P*[:*k*] ⊐ *P*[:5]} = {3, 1, 0}. Lemma 32.5 claims that
    *π**[*q*] = {*k* : *k* < *q* and *P*[:*k*] ⊐ *P*[:*q*]} for all *q*.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 32.10** 用于模式 *P* = ababaca 和 *q* = 5 的引理 32.5 的示例。**(a)** 给定模式的 *π* 函数。由于
    *π*[5] = 3，*π*[3] = 1，和 *π*[1]= 0，迭代 *π* 得到 *π**[5] = {3, 1, 0}。**(b)** 将包含模式
    *P* 的模板向右滑动，并注意当某个前缀 *P*[:*k*] 与 *P*[:5] 的某个合适后缀匹配时。当 *k* = 3, 1, 和 0 时发生匹配。在图中，第一行给出
    *P*，垂直红线绘制在 *P*[:5] 之后。连续的行显示导致某个前缀 *P*[:*k*] 与 *P*[:5] 的某个后缀匹配的所有 *P* 的移位。成功匹配的字符以蓝色显示。蓝色线连接对齐的匹配字符。因此，{*k*
    : *k* < 5 and *P*[:*k*] ⊐ *P*[:5]} = {3, 1, 0}。引理 32.5 声称对于所有 *q*，*π**[*q*] =
    {*k* : *k* < *q* and *P*[:*k*] ⊐ *P*[:*q*]}。'
- en: Compared with FINITE-AUTOMATON-MATCHER, by using *π* rather than *δ*, the KMP
    algorithm reduces the time for preprocessing the pattern from *O*(*m* |∑|) to
    Θ(*m*), while keeping the actual matching time bounded by Θ(*n*).
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 与有限自动机匹配器相比，使用 *π* 而不是 *δ*，KMP 算法将模式的预处理时间从 *O*(*m* |∑|) 减少到 Θ(*m*)，同时保持实际匹配时间受到
    Θ(*n*) 的限制。
- en: '**Correctness of the prefix-function computation**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**前缀函数计算的正确性**'
- en: We’ll see a little later that the prefix function *π* helps to simulate the
    transition function *δ* in a string-matching automaton. But first, we need to
    prove that the procedure COMPUTE-PREFIX-FUNCTION does indeed compute the prefix
    function correctly. Doing so requires finding all prefixes *P*[:*k*] that are
    proper suffixes of a given prefix *P*[:*q*]. The value of *π*[*q*] gives us the
    length of the longest such prefix, but the following lemma, illustrated in [Figure
    32.10](chapter032.xhtml#Fig_32-10), shows that iterating the prefix function *π*
    generates all the prefixes *P*[:*k*] that are proper suffixes of *P*[:*q*]. Let
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 我们稍后将看到，前缀函数 *π* 有助于模拟字符串匹配自动机中的转移函数 *δ*。但首先，我们需要证明过程 COMPUTE-PREFIX-FUNCTION
    确实正确计算了前缀函数。这需要找到所有是给定前缀 *P*[:*q*] 的合适后缀的前缀 *P*[:*k*]。*π*[*q*] 给出了最长前缀的长度，但下面的引理，在
    [图 32.10](chapter032.xhtml#Fig_32-10) 中有所说明，表明迭代前缀函数 *π* 生成了所有是 *P*[:*q*] 的合适后缀的前缀
    *P*[:*k*]。让
- en: '*π**[*q*] = {*π*[*q*], *π*^((2))[*q*], *π*^((3))[*q*], …, *π*^((*t*))[*q*]},'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '*π**[*q*] = {*π*[*q*], *π*^((2))[*q*], *π*^((3))[*q*], …, *π*^((*t*))[*q*]},'
- en: where *π*^((*i*))[*q*] is defined in terms of functional iteration, so that
    *π*^((0))[*q*] = *q* and *π*^((*i*))[*q*] = *π*[*π*^((*i*−1))[*q*]] for *i* ≥
    1 (so that *π*[*q*] = *π*^((1))[*q*]), and where the sequence in *π**[*q*] stops
    upon reaching *π*^((*t*))[*q*] = 0 for some *t* ≥ 1.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *π*^((*i*))[*q*] 是根据函数迭代定义的，使得 *π*^((0))[*q*] = *q* 和 *π*^((*i*))[*q*] =
    *π*[*π*^((*i*−1))[*q*]] 对于 *i* ≥ 1（这样 *π*[*q*] = *π*^((1))[*q*），并且当某个 *t* ≥ 1
    时，*π**[*q*] 中的序列在达到 *π*^((*t*))[*q*] = 0 时停止。
- en: '***Lemma 32.5 (Prefix-function iteration lemma)***'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 32.5（前缀函数迭代引理）***'
- en: 'Let *P* be a pattern of length *m* with prefix function *π*. Then, for *q*
    = 1, 2, …, *m*, we have *π**[*q*] = {*k* : *k* < *q* and *P*[:*k*] ⊐ *P*[:*q*]}.'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '令 *P* 为长度为 *m* 的模式，具有前缀函数 *π*。那么，对于 *q* = 1, 2, …, *m*，我们有 *π**[*q*] = {*k*
    : *k* < *q* and *P*[:*k*] ⊐ *P*[:*q*]}。'
- en: '***Proof***   We first prove that *π**[*q*] ⊆ {*k* : *k* < *q* and *P*[:*k*]
    ⊐ *P*[:*q*]} or, equivalently,'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 我们首先证明 *π**[*q*] ⊆ {*k* : *k* < *q* and *P*[:*k*] ⊐ *P*[:*q*]} 或者等价地，'
- en: '![art](images/Art_P1310.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1310.jpg)'
- en: 'If *i* ∈ *π**[*q*], then *i* = *π*^((*u*))[*q*] for some *u* > 0\. We prove
    equation (32.7) by induction on *u*. For *u* = 1, we have *i* = *π*[*q*], and
    the claim follows since *i* < *q* and *P*[:*π*[*q*]] ⊐ *P*[:*q*] by the definition
    of *π*. Now consider some *u* ≥ 1 such that both *π*^((*u*))[*q*] and *π*^((*u*+1))[*q*]
    belong to *π**[*q*]. Let *i* = *π*^((*u*))[*q*], so that *π*[*i*] = *π*^((*u*+1))[*q*].
    The inductive hypothesis is that *P*[:*i*] ⊐ *P*[:*q*]. Because the relations
    < and ⊐ are transitive, we have *π*[*i*] < *i* < *q* and *P*[:*π*[*i*]] ⊐ *P*[:*i*]
    ⊐ *P*[:*q*], which establishes equation (32.7) for all *i* in *π**[*q*]. Therefore,
    *π**[*q*] ⊆ {*k* : *k* < *q* and *P*[:*k*] ⊐ *P*[:*q*]}.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 *i* ∈ *π**[*q*]，那么 *i* = *π*^((*u*))[*q*] 对于某个 *u* > 0。我们通过对 *u* 进行归纳证明方程式
    (32.7)。对于 *u* = 1，我们有 *i* = *π*[*q*]，并且由于 *i* < *q* 且根据 *π* 的定义 *P*[:*π*[*q*]]
    ⊐ *P*[:*q*]，所以结论成立。现在考虑某个 *u* ≥ 1，使得 *π*^((*u*))[*q*] 和 *π*^((*u*+1))[*q*] 都属于
    *π**[*q*]。令 *i* = *π*^((*u*))[*q*]，所以 *π*[*i*] = *π*^((*u*+1))[*q*]。归纳假设是 *P*[:*i*]
    ⊐ *P*[:*q*]。由于关系 < 和 ⊐ 是传递的，我们有 *π*[*i*] < *i* < *q* 且 *P*[:*π*[*i*]] ⊐ *P*[:*i*]
    ⊐ *P*[:*q*]，这为所有 *i* 在 *π**[*q*] 中建立了方程式 (32.7)。因此，*π**[*q*] ⊆ {*k* : *k* < *q*
    and *P*[:*k*] ⊐ *P*[:*q*]}。'
- en: 'We now prove that {*k* : *k* < *q* and *P*[:*k*] ⊐ *P*[:*q*]} ⊆ *π**[*q*] by
    contradiction. Suppose to the contrary that the set {*k* : *k* < *q* and *P*[:*k*]
    ⊐ *P*[:*q*]} – *π**[*q*] is nonempty, and let *j* be the largest number in the
    set. Because *π*[*q*] is the largest value in {*k* : *k* < *q* and *P*[:*k*] ⊐
    *P*[:*q*]} and *π**[*q*] ∈ *π**[*q*], it must be the case that *j* < [*q*]. Having
    established that *π**[*q*] contains at least one integer greater than *j*, let
    *j*′ denote the smallest such integer. (We can choose *j*′ = *π*[*q*] if no other
    number in *π**[*q*] is greater than *j*.) We have *P*[:*j*] ⊐ *P*[:*q*] because
    *j* ∈ {*k* : *k* < *q* and *P*[:*k*] ⊐ *P*[:*q*]}, and from *j*′ ∈ *π**[*q*] and
    equation (32.7), we have *P*[:*j*′] ⊐ *P*[:*q*]. Thus, *P*[:*j*] ⊐ *P*[:*j*′]
    by Lemma 32.1, and *j* is the largest value less than *j*′ with this property.
    Therefore, we must have *π*[*j*′] = *j* and, since *j*′ ∈ *π**[*q*], we must have
    *j* ∈ *π**[*q*] as well. This contradiction proves the lemma.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们通过反证法证明 {*k* : *k* < *q* and *P*[:*k*] ⊐ *P*[:*q*]} ⊆ *π**[*q*]。假设相反，集合
    {*k* : *k* < *q* and *P*[:*k*] ⊐ *P*[:*q*]} – *π**[*q*] 非空，并且设 *j* 是集合中的最大数。因为
    *π*[*q*] 是 {*k* : *k* < *q* and *P*[:*k*] ⊐ *P*[:*q*]} 中的最大值，且 *π**[*q*] ∈ *π**[*q*]，所以必须有
    *j* < [*q*]。已经确定 *π**[*q*] 包含至少一个大于 *j* 的整数，让 *j*′ 表示最小的这样的整数。（如果 *π**[*q*] 中没有比
    *j* 大的数，则可以选择 *j*′ = *π*[*q*。）由于 *j* ∈ {*k* : *k* < *q* and *P*[:*k*] ⊐ *P*[:*q*]}，以及
    *j*′ ∈ *π**[*q*] 和方程式 (32.7)，我们有 *P*[:*j*] ⊐ *P*[:*q*]。因此，根据引理 32.1，*P*[:*j*]
    ⊐ *P*[:*j*′]，且 *j* 是小于 *j*′ 且具有此属性的最大值。因此，必须有 *π*[*j*′] = *j*，且由于 *j*′ ∈ *��**[*q*]，我们也必须有
    *j* ∈ *π**[*q*]。这个矛盾证明了引理。'
- en: ▪
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: The algorithm COMPUTE-PREFIX-FUNCTION computes *π*[*q*], in order, for *q* =
    1, 2, …, *m*. Setting *π*[1] to 0 in line 2 of COMPUTE-PREFIX-FUNCTION is certainly
    correct, since *π*[*q*] < *q* for all *q*. We’ll use the following lemma and its
    corollary to prove that COMPUTE-PREFIX-FUNCTION computes *π*[*q*] correctly for
    *q* > 1.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 算法 COMPUTE-PREFIX-FUNCTION 按顺序计算 *q* = 1, 2, …, *m* 的 *π*[*q*]。在 COMPUTE-PREFIX-FUNCTION
    的第 2 行将 *π*[1] 设为 0 是正确的，因为对于所有 *q*，*π*[*q*] < *q*。我们将使用以下引理及其推论来证明 COMPUTE-PREFIX-FUNCTION
    正确计算 *q* > 1 的 *π*[*q*]。
- en: '***Lemma 32.6***'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 32.6***'
- en: Let *P* be a pattern of length *m*, and let *π* be the prefix function for *P*.
    For *q* = 1, 2, …, *m*, if *π*[*q*] > 0, then *π*[*q*] – 1 ∈ *π**[*q* – 1].
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 设 *P* 是长度为 *m* 的模式，*π* 是 *P* 的前缀函数。对于 *q* = 1, 2, …, *m*，如果 *π*[*q*] > 0，则 *π*[*q*]
    – 1 ∈ *π**[*q* – 1]。
- en: '***Proof***   Let *r* = *π*[*q*] > 0, so that *r* < *q* and *P*[:*r*] ⊐ *P*[:*q*],
    and thus, *r* – 1 < *q* – 1 and *P*[:*r* – 1] ⊐ *P*[:*q* – 1] (by dropping the
    last character from *P*[:*r*] and *P*[:*q*], which we can do because *r* > 0).
    By Lemma 32.5, therefore, *r* – 1 ∈ *π**[*q* – 1]. Thus, we have *π*[*q*] – 1
    = *r* – 1 ∈ *π**[*q* – 1].'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   设 *r* = *π*[*q*] > 0，因此 *r* < *q* 且 *P*[:*r*] ⊐ *P*[:*q*]，因此，*r*
    – 1 < *q* – 1 且 *P*[:*r* – 1] ⊐ *P*[:*q* – 1]（通过从 *P*[:*r*] 和 *P*[:*q*] 中去掉最后一个字符，因为
    *r* > 0）。因此，根据引理 32.5，*r* – 1 ∈ *π**[*q* – 1]。因此，我们有 *π*[*q*] – 1 = *r* – 1 ∈
    *π**[*q* – 1]。'
- en: ▪
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: For *q* = 2, 3, …, *m*, define the subset *E*[*q*–1] ⊆ *π**[*q* – 1] by
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *q* = 2, 3, …, *m*，定义子集 *E*[*q*–1] ⊆ *π**[*q* – 1] 为
- en: '| *E*[*q*–1] | = | {*k* ∈ *π**[*q* – 1]: *P*[*k* + 1] = *P*[*q*]} |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| *E*[*q*–1] | = | {*k* ∈ *π**[*q* – 1]: *P*[*k* + 1] = *P*[*q*]} |'
- en: '|  | = | {*k* : *k* < *q* – 1 and *P*[:*k*] ⊐ *P*[:*q* – 1] and *P*[*k* + 1]
    = *P*[*q*]}(by Lemma 32.5) |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '|  | = | {*k* : *k* < *q* – 1 and *P*[:*k*] ⊐ *P*[:*q* – 1] and *P*[*k* + 1]
    = *P*[*q*]}(根据引理 32.5) |'
- en: '|  | = | {*k* : *k* < *q* – 1 and *P*[:*k* + 1] ⊐ *P*[:*q*]}. |'
  id: totrans-261
  prefs: []
  type: TYPE_TB
  zh: '|  | = | {*k* : *k* < *q* – 1 and *P*[:*k* + 1] ⊐ *P*[:*q*]}. |'
- en: The set *E*[*q*–1] consists of the values *k* < *q* – 1 for which *P*[:*k*]
    ⊐ *P*[:*q* – 1] and for which, because *P*[*k* + 1] = *P*[*q*], we have *P*[:*k*
    + 1] ⊐ *P*[:*q*]. Thus, *E*[*q*–1] consists of those values *k* ∈ *π**[*q* – 1]
    such that extending *P*[:*k*] to *P*[:*k* + 1] produces a proper suffix of *P*[:*q*].
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 集合 *E*[*q*–1] 包括那些 *k* < *q* – 1 的值，满足 *P*[:*k*] ⊐ *P*[:*q* – 1]，并且因为 *P*[*k*
    + 1] = *P*[*q*]，我们有 *P*[:*k* + 1] ⊐ *P*[:*q*]。因此，*E*[*q*–1] 包括那些 *k* ∈ *π**[*q*
    – 1] 的值，使得将 *P*[:*k*] 扩展为 *P*[:*k* + 1] 产生 *P*[:*q*] 的一个合适后缀。
- en: '***Corollary 32.7***'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论 32.7***'
- en: Let *P* be a pattern of length *m*, and let *π* be the prefix function for *P*.
    Then, for *q* = 2, 3, …, *m*,
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 设 *P* 是长度为 *m* 的模式，*π* 是 *P* 的前缀函数。那么，对于 *q* = 2, 3, …, *m*，
- en: '![art](images/Art_P1311.jpg)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1311.jpg)'
- en: '***Proof***   If *E*[*q*–1] is empty, there is no *k* ∈ *π**[*q* – 1] (including
    *k* = 0) such that extending *P*[:*k*] to *P*[:*k* + 1] produces a proper suffix
    of *P*[:*q*]. Therefore, *π*[*q*]= 0.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   如果 *E*[*q*–1] 为空，则不存在 *k* ∈ *π**[*q* – 1]（包括 *k* = 0）使得将 *P*[:*k*]
    扩展为 *P*[:*k* + 1] 产生 *P*[:*q*] 的一个合适后缀。因此，*π*[*q*]= 0。'
- en: If, instead, *E*[*q*–1] is nonempty, then for each *k* ∈ *E*[*q*–1], we have
    *k* + 1 < *q* and *P*[:*k* + 1] ⊐ *P*[:*q*]. Therefore, the definition of *π*[*q*]
    gives
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *E*[*q*–1] 非空，则对于每个 *k* ∈ *E*[*q*–1]，我们有 *k* + 1 < *q* 且 *P*[:*k* + 1] ⊐
    *P*[:*q*]。因此，根据 *π*[*q*] 的定义，
- en: '![art](images/Art_P1312.jpg)'
  id: totrans-268
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1312.jpg)'
- en: Note that *π*[*q*] > 0\. Let *r* = *π*[*q*] – 1, so that *r* + 1 = *π*[*q*]
    > 0, and therefore *P*[:*r* + 1] ⊐ *P*[:*q*]. If a nonempty string is a suffix
    of another, then the two strings must have the same last character. Since *r*
    + 1 > 0, the prefix *P*[:*r* + 1] is nonempty, and so *P*[*r* + 1] = *P*[*q*].
    Furthermore, *r* ∈ *π**[*q* – 1] by Lemma 32.6\. Therefore, *r* ∈ *E*[*q*–1],
    and so *π*[*q*] – 1 = *r* ≤ max *E*[*q*–1] or, equivalently,
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 *π*[*q*] > 0。设 *r* = *π*[*q*] – 1，因此 *r* + 1 = *π*[*q*] > 0，因此 *P*[:*r* +
    1] ⊐ *P*[:*q*]。如果一个非空字符串是另一个字符串的后缀，则这两个字符串必须具有相同的最后一个字符。由于 *r* + 1 > 0，前缀 *P*[:*r*
    + 1] 是非空的，因此 *P*[*r* + 1] = *P*[*q*]。此外，根据引理 32.6，*r* ∈ *π**[*q* – 1]。因此，*r* ∈
    *E*[*q*–1]，因此 *π*[*q*] – 1 = *r* ≤ max *E*[*q*–1] 或者等价地，
- en: '![art](images/Art_P1313.jpg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1313.jpg)'
- en: Combining equations (32.8) and (32.9) completes the proof.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 结合方程式 (32.8) 和 (32.9) 完成证明。
- en: ▪
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: We now finish the proof that COMPUTE-PREFIX-FUNCTION computes *π* correctly.
    The key is to combine the definition of *E*[*q*–1] with the statement of Corollary
    32.7, so that *π*[*q*] equals 1 plus the greatest value of *k* in *π**[*q* – 1]
    such that *P*[*k* + 1] = *P*[*q*]. First, in COMPUTE-PREFIX-FUNCTION, *k* = *π*[*q*
    – 1] at the start of each iteration of the **for** loop of lines 4–9\. This condition
    is enforced by lines 2 and 3 when the loop is first entered, and it remains true
    in each successive iteration because of line 9\. Lines 5–8 adjust *k* so that
    it becomes the correct value of *π*[*q*]. The **while** loop of lines 5–6 searches
    through all values *k* ∈ *π**[*q* – 1] in decreasing order to find the value of
    *π*[*q*]. The loop terminates either because *k* reaches 0 or *P*[*k* + 1] = *P*[*q*].
    Because the “and” operator short-circuits, if the loop terminates because *P*[*k*
    + 1] = *P*[*q*], then *k* must have also been positive, and so *k* is the greatest
    value in *E*[*q*–1]. In this case, lines 7–9 set *π*[*q*] to *k* + 1, according
    to Corollary 32.7\. If, instead, the **while** loop terminates because *k* = 0,
    then there are two possibilities. If *P*[1] = *P*[*q*], then *E*[*q*–1] = {0},
    and lines 7–9 set both *k* and *π*[*q*] to 1\. If *k* = 0 and *P*[1] ≠ *P*[*q*],
    however, then *E*[*q*–1] = ø;. In this case, line 9 sets *π*[*q*] to 0, again
    according to Corollary 32.7, which completes the proof of the correctness of COMPUTE-PREFIX-FUNCTION.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们完成了证明 COMPUTE-PREFIX-FUNCTION 正确计算 *π* 的过程。关键在于将 *E*[*q*–1] 的定义与推论 32.7
    的陈述结合起来，使得 *π*[*q*] 等于 *π**[*q* – 1] 中 *k* 的最大值加 1，使得 *P*[*k* + 1] = *P*[*q*]。首先，在
    COMPUTE-PREFIX-FUNCTION 中，*k* = *π*[*q* – 1] 在第 4-9 行的 **for** 循环的每次迭代开始时。这个条件在第一次进入循环时由第
    2 和第 3 行强制执行，并且由于第 9 行的原因，在每次迭代中保持为真。第 5-8 行调整 *k*，使其成为 *π*[*q*] 的正确值。第 5-6 行的
    **while** 循环按递减顺序搜索所有值 *k* ∈ *π**[*q* – 1]，以找到 *π*[*q*] 的��。循环终止的条件是 *k* 达到 0
    或 *P*[*k* + 1] = *P*[*q*]。由于“and”运算符短路，如果循环是因为 *P*[*k* + 1] = *P*[*q*] 而终止的，那么
    *k* 必须也是正数，因此 *k* 是 *E*[*q*–1] 中的最大值。在这种情况下，第 7-9 行根据推论 32.7 将 *π*[*q*] 设置为 *k*
    + 1。相反，如果 **while** 循环是因为 *k* = 0 而终止的，那么有两种可能性。如果 *P*[1] = *P*[*q*]，那么 *E*[*q*–1]
    = {0}，第 7-9 行将 *k* 和 *π*[*q*] 都设置为 1。然而，如果 *k* = 0 且 *P*[1] ≠ *P*[*q*]，那么 *E*[*q*–1]
    = ø;。在这种情况下，第 9 行根据推论 32.7 将 *π*[*q*] 设置为 0，这完成了 COMPUTE-PREFIX-FUNCTION 正确性的证明。
- en: '**Correctness of the Knuth-Morris-Pratt algorithm**'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '**Knuth-Morris-Pratt 算法的正确性**'
- en: You can think of the procedure KMP-MATCHER as a reimplemented version of the
    procedure FINITE-AUTOMATON-MATCHER, but using the prefix function *π* to compute
    state transitions. Specifically, we’ll prove that in the *i*th iteration of the
    **for** loops of both KMP-MATCHER and FINITE-AUTOMATON-MATCHER, the state *q*
    has the same value upon testing for equality with *m* (at line 8 in KMP-MATCHER
    and at line 4 in FINITE-AUTOMATON-MATCHER). Once we have argued that KMP-MATCHER
    simulates the behavior of FINITE-AUTOMATON-MATCHER, the correctness of KMP-MATCHER
    follows from the correctness of FINITE-AUTOMATON-MATCHER (though we’ll see a little
    later why line 10 in KMP-MATCHER is necessary).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将 KMP-MATCHER 过程视为重新实现的 FINITE-AUTOMATON-MATCHER 过程，但使用前缀函数 *π* 来计算状态转换。具体来说，在
    KMP-MATCHER 和 FINITE-AUTOMATON-MATCHER 的 **for** 循环的第 *i* 次迭代中，状态 *q* 在与 *m* 进行相等性测试时具有相同的值（在
    KMP-MATCHER 的第 8 行和 FINITE-AUTOMATON-MATCHER 的第 4 行）。一旦我们证明了 KMP-MATCHER 模拟了 FINITE-AUTOMATON-MATCHER
    的行为，那么 KMP-MATCHER 的正确性就可以从 FINITE-AUTOMATON-MATCHER 的正确性中得出结论（尽管稍后我们会看到为什么 KMP-MATCHER
    的第 10 行是必要的）。
- en: 'Before formally proving that KMP-MATCHER correctly simulates FINITE-AUTOMATON-MATCHER,
    let’s take a moment to understand how the prefix function *π* replaces the *δ*
    transition function. Recall that when a string-matching automaton is in state
    *q* and it scans a character *a* = *T*[*i*], it moves to a new state *δ*(*q*,
    *a*). If *a* = *P*[*q* + 1], so that *a* continues to match the pattern, then
    the state number is incremented: *δ*(*q*, *a*) = *q* + 1\. Otherwise, *a* ≠ *P*[*q*
    + 1], so that *a* does not continue to match the pattern, and the state number
    does not increase: 0 ≤ *δ*(*q*, *a*) ≤ *q*. In the first case, when *a* continues
    to match, KMP-MATCHER moves to state *q* + 1 without referring to the *π* function:
    the **while** loop test in line 4 immediately comes up false, the test in line
    6 comes up true, and line 7 increments *q*.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在正式证明 KMP-MATCHER 正确模拟 FINITE-AUTOMATON-MATCHER 之前，让我们花一点时间了解前缀函数 *π* 如何替换 *δ*
    转换函数。回想一下，当字符串匹配自动机处于状态 *q* 且扫描字符 *a* = *T*[*i*] 时，它会移动到新状态 *δ*(*q*, *a*)。如果 *a*
    = *P*[*q* + 1]，使得 *a* 继续匹配模式，那么状态编号会递增：*δ*(*q*, *a*) = *q* + 1。否则，*a* ≠ *P*[*q*
    + 1]，使得 *a* 不再匹配模式，状态编号不会增加：0 ≤ *δ*(*q*, *a*) ≤ *q*。在第一种情况下，当 *a* 继续匹配时，KMP-MATCHER
    在不引用 *π* 函数的情况下移动到状态 *q* + 1：第 4 行的 **while** 循环测试立即失败，第 6 行的测试成功，第 7 行递增 *q*。
- en: The *π* function comes into play when the character *a* does not continue to
    match the pattern, so that the new state *δ*(*q*, *a*) is either *q* or to the
    left of *q* along the spine of the automaton. The **while** loop of lines 4–5
    in KMP-MATCHER iterates through the states in *π**[*q*], stopping either when
    it arrives in a state, say *q*′, such that *a* matches *P*[*q*′ + 1] or *q*′ has
    gone all the way down to 0\. If *a* matches *P*[*q*′ + 1], then line 7 sets the
    new state to *q*′+1, which should equal *δ*(*q*, *a*) for the simulation to work
    correctly. In other words, the new state *δ*(*q*, *a*) should be either state
    0 or a state numbered 1 more than some state in *π**[*q*].
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 当字符 *a* 不再匹配模式时，*π* 函数发挥作用，使得新状态 *δ*(*q*, *a*) 要么是 *q*，要么在自动机的脊柱上向左移动到 *q* 的位置。KMP-MATCHER
    的第 4-5 行的 **while** 循环在 *π**[*q*] 中的状态之间迭代，直到到达一个状态为止，比如 *q*′，使得 *a* 匹配 *P*[*q*′
    + 1]，或者 *q*′ 已经降至 0。如果 *a* 匹配 *P*[*q*′ + 1]，那么第 7 行将新状态设置为 *q*′+1，这应该等于模拟工作正确所需的
    *δ*(*q*, *a*)。换句话说，新状态 *δ*(*q*, *a*) 应该是状态 0 或者 *π**[*q*] 中某个状态编号加 1。
- en: Let’s look at the example in [Figures 32.6](#Fig_32-6) and [32.10](#Fig_32-10),
    which are for the pattern *P* = ababaca. Suppose that the automaton is in state
    *q* = 5, having matched ababa. The states in *π**[5] are, in descending order,
    3, 1, and 0\. If the next character scanned is c, then you can see that the automaton
    moves to state *δ*(5, c) = 6 in both FINITE-AUTOMATON-MATCHER (line 3) and KMP-MATCHER
    (line 7). Now suppose that the next character scanned is instead b, so that the
    automaton should move to state *δ*(5, b) = 4\. The **while** loop in KMP-MATCHER
    exits after executing line 5 once, and the automaton arrives in state *q*′ = *π*[5]
    = 3\. Since *P*[*q*′ + 1] = *P*[4] = b, the test in line 6 comes up true, and
    the automaton moves to the new state *q*′ + 1 = 4 = *δ*(5, b). Finally, suppose
    that the next character scanned is instead a, so that the automaton should move
    to state *δ*(5, a) = 1\. The first three times that the test in line 4 executes,
    the test comes up true. The first time finds that *P*[6] = c ≠ a, and the automaton
    moves to state *π*[5] = 3 (the first state in *π**[5]). The second time finds
    that *P*[4] = b ≠ a, and the automaton moves to state *π*[3] = 1 (the second state
    in *π**[5]). The third time finds that *P*[2] = b ≠ a, and the automaton moves
    to state *π*[1] = 0 (the last state in *π**[5]). The **while** loop exits once
    it arrives in state *q*′ = 0\. Now line 6 finds that *P*[*q*′ + 1] = *P*[1] =
    a, and line 7 moves the automaton to the new state *q*′ + 1 = 1 = *δ*(5, a).
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一下 [图 32.6](#Fig_32-6) 和 [32.10](#Fig_32-10) 中的示例，这是用于模式 *P* = ababaca。假设自动机处于状态
    *q* = 5，已匹配 ababa。*π*[5] 中的状态，按降序排列，为 3、1 和 0。如果下一个扫描的字符是 c，则可以看到自动机在 FINITE-AUTOMATON-MATCHER（第
    3 行）和 KMP-MATCHER（第 7 行）中都移动到状态 *δ*(5, c) = 6。现在假设下一个扫描的字符是 b，使得自动机应该移动到状态 *δ*(5,
    b) = 4。KMP-MATCHER 中的 **while** 循环在执行第 5 行后退出一次，自动机到达状态 *q*′ = *π*[5] = 3。由于 *P*[*q*′
    + 1] = *P*[4] = b，因此第 6 行的测试结果为真，自动机移动到新状态 *q*′ + 1 = 4 = *δ*(5, b)。最后，假设下一个扫描的字符是
    a，使得自动机应该移动到状态 *δ*(5, a) = 1。第一次执行第 4 行的测试时，测试结果为真。第一次发现 *P*[6] = c ≠ a，自动机移动到状态
    *π*[5] = 3（*π*[5] 中的第一个状态）。第二次发现 *P*[4] = b ≠ a，自动机移动到状态 *π*[3] = 1（*π*[5] 中的第二个状态）。第三次发现
    *P*[2] = b ≠ a，自动机移动到状态 *π*[1] = 0（*π*[5] 中的最后一个状态）。**while** 循环在到达状态 *q*′ = 0
    后退出。现在第 6 行发现 *P*[*q*′ + 1] = *P*[1] = a，第 7 行将自动机移动到新状态 *q*′ + 1 = 1 = *δ*(5,
    a)。
- en: Thus, the intuition is that KMP-MATCHER iterates through the states in *π**[*q*]
    in decreasing order, stopping at some state *q*′ and then possibly moving to state
    *q*′+1\. Although that might seem like a lot of work just to simulate computing
    *δ*(*q*, *a*), bear in mind that asymptotically, KMP-MATCHER is no slower than
    FINITE-AUTOMATON-MATCHER.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，直觉是 KMP-MATCHER 按照 *π**[*q*] 中的状态以递减顺序迭代，停在某个状态 *q*′，然后可能移动到状态 *q*′+1。尽管仿真计算
    *δ*(*q*, *a*) 看起来可能需要很多工作，但从渐近的角度来看，KMP-MATCHER 的速度不会比 FINITE-AUTOMATON-MATCHER
    慢。
- en: We are now ready to formally prove the correctness of the Knuth-Morris-Pratt
    algorithm. By Theorem 32.4, we have that *q* = *σ*(*T*[:*i*]) after each time
    line 3 of FINITE-AUTOMATON-MATCHER executes. Therefore, it suffices to show that
    the same property holds with regard to the **for** loop in KMP-MATCHER. The proof
    proceeds by induction on the number of loop iterations. Initially, both procedures
    set *q* to 0 as they enter their respective **for** loops for the first time.
    Consider iteration *i* of the **for** loop in KMP-MATCHER. By the inductive hypothesis,
    the state number *q* equals *σ*(*T*[:*i* – 1]) at the start of the loop iteration.
    We need to show that when line 8 is reached, the new value of *q* is *σ*(*T*[:*i*]).
    (Again, we’ll handle line 10 separately.)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备正式证明 Knuth-Morris-Pratt 算法的正确性。根据定理 32.4，我们知道在 FINITE-AUTOMATON-MATCHER
    的第 3 行执行后，*q* = *σ*(*T*[:*i*])。因此，我们需要证明 KMP-MATCHER 中的 **for** 循环也具有相同的性质。证明通过对循环迭代次数进行归纳进行。最初，两个过程在首次进入各自的
    **for** 循环时都将 *q* 设置为 0。考虑 KMP-MATCHER 中 **for** 循环的第 *i* 次迭代。根据归纳假设，循环迭代开始时状态编号
    *q* 等于 *σ*(*T*[:*i* – 1])。我们需要展示当到达第 8 行时，*q* 的新值为 *σ*(*T*[:*i*])。（再次，我们将单独处理第
    10 行。）
- en: Considering *q* to be the state number at the start of the **for** loop iteration,
    when KMP-MATCHER considers the character *T*[*i*], the longest prefix of *P* that
    is a suffix of *T*[:*i*] is either *P*[:*q* + 1] (if *P*[*q* + 1] = *T*[*i*])
    or some prefix (not necessarily proper, and possibly empty) of *P*[:*q*]. We consider
    separately the three cases in which *σ*(*T*[:*i*]) = 0, *σ*(*T*[:*i*]) = *q* +
    1, and 0 < *σ*(*T*[:*i*]) ≤ *q*.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *q* 视为 **for** 循环迭代开始时的状态编号，当 KMP-MATCHER 考虑字符 *T*[*i*] 时，*P* 的最长前缀，同时也是 *T*[:*i*]
    的后缀，要么是 *P*[:*q* + 1]（如果 *P*[*q* + 1] = *T*[*i*]），要么是 *P*[:*q*] 的某个前缀（不一定是真前缀，可能为空）。我们分别考虑
    *σ*(*T*[:*i*]) = 0，*σ*(*T*[:*i*]) = *q* + 1 和 0 < *σ*(*T*[:*i*]) ≤ *q* 这三种情况。
- en: If *σ*(*T*[:*i*]) = 0, then *P*[:0] = *ϵ* is the only prefix of *P* that is
    a suffix of *T*[:*i*]. The **while** loop of lines 4–5 iterates through each value
    *q*′ in *π**[*q*], but although *P*[:*q*′] ⊐ *P*[:*q*] ⊐ *T*[:*i* – 1] for every
    *q*′ ∈ *π**[*q*] (because < are ⊐ are transitive relations), the loop never finds
    a *q*′ such that *P*[*q*′ + 1] = *T*[*i*]. The loop terminates when *q* reaches
    0, and of course line 7 does not execute. Therefore, *q* = 0 at line 8, so that
    now *q* = *σ*(*T*[:*i*]).
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *σ*(*T*[:*i*]) = 0，则 *P*[:0] = *ϵ* 是 *T*[:*i*] 的唯一后缀。行 4–5 的 **while** 循环遍历
    *π**[*q*] 中的每个值 *q*′，但是尽管对于每个 *q*′ ∈ *π**[*q*] 都有 *P*[:*q*′] ⊐ *P*[:*q*] ⊐ *T*[:*i*
    – 1]（因为 < 是 ⊐ 的传递关系），但循环永远找不到一个 *q*′，使得 *P*[*q*′ + 1] = *T*[*i*]。循环在 *q* 达到 0
    时终止，当然第 7 行不会执行。因此，此时 *q* = 0，所以现在 *q* = *σ*(*T*[:*i*])。
- en: If *σ*(*T*[:*i*]) = *q*+1, then *P*[*q*+1] = *T*[*i*], and the **while** loop
    test in line 4 fails the first time through. Line 7 executes, incrementing the
    state number to *q* + 1, which equals *σ*(*T*[:*i*]).
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 *σ*(*T*[:*i*]) = *q*+1，则 *P*[*q*+1] = *T*[*i*]，并且第一次通过行 4 中的 **while** 循环测试失败。第
    7 行执行，将状态编号增加到 *q* + 1，这等于 *σ*(*T*[:*i*])。
- en: If 0 < *σ*(*T*[:*i*]) ≤ *q*′, then the **while** loop of lines 4–5 iterates
    at least once, checking in decreasing order each value in *π**[*q*] until it stops
    at some *q*′ < *q*. Thus, *P*[:*q*′] is the longest prefix of *P*[:*q*] for which
    *P*[*q*′ + 1] = *T*[*i*], so that when the **while** loop terminates, *q*′ + 1
    = *σ*(*P*[:*q*]*T*[*i*]). Since *q* = *σ*(*T*[:*i* – 1]), Lemma 32.3 implies that
    *σ*(*T*[:*i* – 1]*T*[*i*]) = *σ*(*P*[:*q*]*T*[*i*]). Thus we have
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果 0 < *σ*(*T*[:*i*]) ≤ *q*′，那么第 4-5 行的 **while** 循环至少迭代一次，按递减顺序检查 *π**[*q*]
    中的每个值，直到停在某个 *q*′ < *q*。因此，*P*[:*q*′] 是 *P*[:*q*] 的最长前缀，其中 *P*[*q*′ + 1] = *T*[*i*]，因此当
    **while** 循环终止时，*q*′ + 1 = *σ*(*P*[:*q*]*T*[*i*])。由于 *q* = *σ*(*T*[:*i* – 1])，根据引理
    32.3，得出 *σ*(*T*[:*i* – 1]*T*[*i*]) = *σ*(*P*[:*q*]*T*[*i*])。因此我们有
- en: '| *q*′ + 1 | = | *σ*(*P*[:*q*]*T*[*i*]) |'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '| *q*′ + 1 | = | *σ*(*P*[:*q*]*T*[*i*]) |'
- en: '|  | = | *σ*(*T*[:*i* – 1]*T*[*i*]) |'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | *σ*(*T*[:*i* – 1]*T*[*i*]) |'
- en: '|  | = | *σ*(*T*[:*i*]) |'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_TB
  zh: '|  | = | *σ*(*T*[:*i*]) |'
- en: when the **while** loop terminates. After line 7 increments *q*, the new state
    number *q* equals *σ*(*T*[:*i*]).
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当 **while** 循环终止时。第 7 行增加 *q* 后，新状态号 *q* 等于 *σ*(*T*[:*i*])。
- en: 'Line 10 is necessary in KMP-MATCHER, because otherwise, line 4 might try to
    reference *P*[*m* + 1] after finding an occurrence of *P*. (The argument that
    *q* = *σ*(*T*[:*i* – 1]) upon the next execution of line 4 remains valid by the
    hint given in Exercise 32.4-8: that *δ*(*m*, *a*) = *δ*(*π*[*m*], *a*) or, equivalently,
    *σ*(*Pa*) = *σ*(*P*[:*π*[*m*]]*a*) for any *a* ∈ ∑.) The remaining argument for
    the correctness of the Knuth-Morris-Pratt algorithm follows from the correctness
    of FINITE-AUTOMATON-MATCHER, since we have shown that KMP-MATCHER simulates the
    behavior of FINITE-AUTOMATON-MATCHER.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: KMP-MATCHER 中的第 10 行是必要的，否则，第 4 行在找到 *P* 的出现后可能会尝试引用 *P*[*m* + 1]。（根据练习 32.4-8
    中给出的提示，即 *δ*(*m*, *a*) = *δ*(*π*[*m*], *a*) 或者等价地，*σ*(*Pa*) = *σ*(*P*[:*π*[*m*]]*a*)
    对于任意 *a* ∈ ∑。）Knuth-Morris-Pratt 算法的正确性的其余论证源自 FINITE-AUTOMATON-MATCHER 的正确性，因为我们已经证明
    KMP-MATCHER 模拟了 FINITE-AUTOMATON-MATCHER 的行为。
- en: '**Exercises**'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***32.4-1***'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.4-1***'
- en: Compute the prefix function *π* for the pattern ababbabbabbababbabb.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 计算模式 ababbabbabbababbabb 的前缀函数 *π*。
- en: '***32.4-2***'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.4-2***'
- en: Give an upper bound on the size of *π**[*q*] as a function of *q*. Give an example
    to show that your bound is tight.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 给出 *π**[*q*] 的大小作为 *q* 的函数的上界。给出一个示例以表明你的上界是紧密的。
- en: '***32.4-3***'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.4-3***'
- en: Explain how to determine the occurrences of pattern *P* in the text *T* by examining
    the *π* function for the string *PT* (the string of length *m*+*n* that is the
    concatenation of *P* and *T*).
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 解释如何通过检查字符串 *PT*（长度为 *m*+*n* 的串，是 *P* 和 *T* 的连接）的 *π* 函数来确定文本 *T* 中模式 *P* 的出现。
- en: '***32.4-4***'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.4-4***'
- en: Use an aggregate analysis to show that the running time of KMP-MATCHER is Θ(*n*).
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 使用聚合分析来展示 KMP-MATCHER 的运行时间是 Θ(*n*)。
- en: '***32.4-5***'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.4-5***'
- en: Use a potential function to show that the running time of KMP-MATCHER is Θ(*n*).
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 使用一个潜在函数来展示 KMP-MATCHER 的运行时间是 Θ(*n*)。
- en: '***32.4-6***'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.4-6***'
- en: Show how to improve KMP-MATCHER by replacing the occurrence of *π* in line 5
    (but not line 10) by *π*′, where *π*′ is defined recursively for *q* = 1, 2, …,
    *m* – 1 by the equation
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何通过将第 5 行中 *π* 的出现（但不是第 10 行）替换为 *π*′ 来改进 KMP-MATCHER，其中 *π*′ 通过以下递归定义：对于
    *q* = 1, 2, …, *m* – 1，有方程
- en: '![art](images/Art_P1314.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1314.jpg)'
- en: Explain why the modified algorithm is correct, and explain in what sense this
    change constitutes an improvement.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 解释修改后的算法为何是正确的，并解释这种改变在什么意义上构成了改进。
- en: '***32.4-7***'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.4-7***'
- en: Give a linear-time algorithm to determine whether a text *T* is a cyclic rotation
    of another string *T*′. For example, braze and zebra are cyclic rotations of each
    other.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个线性时间算法，确定文本 *T* 是否是另一个字符串 *T*′ 的循环旋转。例如，braze 和 zebra 是彼此的循环旋转。
- en: ★ ***32.4-8***
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***32.4-8***
- en: Give an *O*(*m* |∑|)-time algorithm for computing the transition function *δ*
    for the string-matching automaton corresponding to a given pattern *P*. (*Hint:*
    Prove that *δ*(*q*, *a*) = *δ*(*π*[*q*], *a*) if *q* = *m* or *P*[*q* + 1] ≠ *a*.)
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个 *O*(*m* |∑|) 时间复杂度的算法，计算与给定模式 *P* 对应的字符串匹配自动机的转移函数 *δ*。（*提示：* 证明如果 *q*
    = *m* 或者 *P*[*q* + 1] ≠ *a*，则 *δ*(*q*, *a*) = *δ*(*π*[*q*], *a*)。）
- en: '[**32.5    Suffix arrays**](toc.xhtml#Rh1-191)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '[**32.5    后缀数组**](toc.xhtml#Rh1-191)'
- en: The algorithms we have seen thus far in this chapter can efficiently find all
    occurrences of a pattern in a text. That is, however, all they can do. This section
    presents a different approach—suffix arrays—with which you can find all occurrences
    of a pattern in a text, but also quite a bit more. A suffix array won’t find all
    occurrences of a pattern as quickly as, say, the Knuth-Morris-Pratt algorithm,
    but its additional flexibility makes it well worth studying.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们迄今为止看到的算法可以高效地在文本中找到模式的所有出现。然而，这就是它们能做的全部。本节介绍了一种不同的方法——后缀数组——通过它，你可以找到文本中模式的所有出现，但还有更多。后缀数组不会像
    Knuth-Morris-Pratt 算法那样快速地找到模式的所有出现，但其额外的灵活性使其值得学习。
- en: '![art](images/Art_P1315.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1315.jpg)'
- en: '**Figure 32.11** The suffix array *SA*, rank array *rank*, longest common prefix
    array *LCP*, and lexicographically sorted suffixes of the text *T* = ratatat with
    length *n* = 7\. The value of *rank*[*i*] indicates the position of the suffix
    *T*[*i*:] in the lexicographically sorted order: *rank*[*SA*[*i*]] = *i* for *i*
    = 1, 2, …, *n*. The *rank* array is used to compute the *LCP* array.'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 32.11** 后缀数组 *SA*，秩数组 *rank*，最长公共前缀数组 *LCP*，以及文本 *T* = ratatat 的长度为 *n*
    = 7 的词。*rank*[*i*] 的值表示后缀 *T*[*i*: ] 在字典序排序中的位置：*rank*[*SA*[*i*]] = *i* 对于 *i*
    = 1, 2, …, *n*。*rank* 数组用于计算 *LCP* 数组。'
- en: A suffix array is simply a compact way to represent the lexicographically sorted
    order of all *n* suffixes of a length-*n* text. Given a text *T*[1:*n*], let *T*[*i*:]
    denote the suffix *T*[*i*:*n*]. The ***suffix array*** *SA*[1:*n*] of *T* is defined
    such that if *SA*[*i*] = *j*, then *T*[*j*:] is the *i*th suffix of *T* in lexicographic
    order.^([3](#footnote_3)) That is, the *i*th suffix of *T* in lexicographic order
    is *T*[*SA*[*i*]:]. Along with the suffix array, another useful array is the ***longest
    common prefix array*** *LCPOE*[1:*n*]. The entry *LCP*[*i*] gives the length of
    the longest common prefix between the *i*th and (*i* – 1)st suffixes in the sorted
    order (with *LCP*[*SA*[1]] defined to be 0, since there is no prefix lexicographically
    smaller than *T*[*SA*[1]:]). [Figure 32.11](chapter032.xhtml#Fig_32-11) shows
    the suffix array and longest common prefix array for the 7-character text ratatat.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 后缀数组只是一种紧凑表示长度为*n*文本的所有*n*个后缀按字典顺序排序的方法。给定文本*T*[1:*n*]，让*T*[*i*:]*表示后缀*T*[*i*:*n*]。文本*T*的***后缀数组*** *SA*[1:*n*]定义为如果*SA*[*i*]
    = *j*，则*T*[*j*:]是*T*在字典顺序中的第*i*个后缀。也就是说，文本*T*在字典顺序中的第*i*个后缀是*T*[*SA*[*i*]:]。除了后缀数组，另一个有用的数组是***最长公共前缀数组*** *LCPOE*[1:*n*]。条目*LCP*[*i*]给出了排序后第*i*个和第(*i*
    – 1)个后缀之间的最长公共前缀的长度（其中*LCP*[*SA*[1]]定义为0，因为没有比*T*[*SA*[1]:]字典顺序更小的前缀）。[图32.11](chapter032.xhtml#Fig_32-11)展示了7个字符文本ratatat的后缀数组和最长公共前缀数组。
- en: Given the suffix array for a text, you can search for a pattern via binary search
    on the suffix array. Each occurrence of a pattern in the text starts some suffix
    of the text, and because the suffix array is in lexicographically sorted order,
    all occurrences of a pattern will appear at the start of consecutive entries of
    the suffix array. For example, in [Figure 32.11](chapter032.xhtml#Fig_32-11),
    the three occurrences of at in ratatat appear in entries 1 through 3 of the suffix
    array. If you find the length-*m* pattern in the length-*n* suffix array via binary
    search (taking *O*(*m* 1g *n*) time because each comparison takes *O*(*m*) time),
    then you can find all occurrences of the pattern in the text by searching backward
    and forward from that spot until you find a suffix that does not start with the
    pattern (or you go beyond the bounds of the suffix array). If the pattern occurs
    *k* times, then the time to find all *k* occurrences is *O*(*m* 1g *n* + *km*).
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 给定文本的后缀数组，可以通过在后缀数组上进行二分查找来搜索模式。文本中模式的每次出现都以文本的某个后缀开头，由于后缀数组按字典顺序排序，所有模式的出现都将出现在后缀数组的连续条目开头。例如，在[图32.11](chapter032.xhtml#Fig_32-11)中，ratatat中at的三次出现分别在后缀数组的第1到第3个条目中。如果通过二分查找在长度为*n*的后缀数组中找到长度为*m*的模式（每次比较需要*O*(*m*)时间，因此总时间为*O*(*m*
    1g *n*)），那么可以通过从该位置向前向后搜索直到找到一个不以该模式开头的后缀（或者超出后缀数组的边界）来找到文本中模式的所有出现。如果模式出现*k*次，则找到所有*k*次出现的时间为*O*(*m*
    1g *n* + *km*)。
- en: 'With the longest common prefix array, you can find a longest repeated substring,
    that is, the longest substring that occurs more than once in the text. If *LCP*[*i*]
    contains a maximum value in the *LCP* array, then a longest repeated substring
    appears in *T*[*SA*[*i*]:*SA*[*i*] + *LCP*[*i*] – 1]. In the example of [Figure
    32.11](chapter032.xhtml#Fig_32-11), the *LCP* array has one maximum value: *LCP*[3]
    = 4\. Therefore, since *SA*[3] = 2, the longest repeated substring is *T*[2:5]
    = atat. Exercise 32.5-3 asks you to use the suffix array and longest common prefix
    array to find the longest common substrings between two texts. Next, we’ll see
    how to compute the suffix array for an *n*-character text in *O*(*n* 1g *n*) time
    and, given the suffix array and the text, how to compute the longest common prefix
    array in Θ(*n*) time.'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 利用最长公共前缀数组，可以找到最长重复子串，即在文本中出现多次的最长子串。如果*LCP*[*i*]在*LCP*数组中包含最大值，则最长重复子串出现在*T*[*SA*[*i*]:*SA*[*i*]
    + *LCP*[*i*] – 1]。在[图32.11](chapter032.xhtml#Fig_32-11)的例子中，*LCP*数组有一个最大值：*LCP*[3]
    = 4。因此，由于*SA*[3] = 2，最长重复子串是*T*[2:5] = atat。练习32.5-3要求您使用后缀数组和最长公共前缀数组找��两个文本之间的最长公共子串。接下来，我们将看到如何在*O*(*n*
    1g *n*)时间内为*n*字符文本计算后缀数组，并且在给定后缀数组和文本的情况下，如何在Θ(*n*)时间内计算最长公共前缀数组。
- en: '**Computing the suffix array**'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算后缀数组**'
- en: There are several algorithms to compute the suffix array of a length-*n* text.
    Some run in linear time, but are rather complicated. One such algorithm is given
    in Problem 32-2\. Here we’ll explore a simpler algorithm that runs in Θ(*n* 1g
    *n*) time.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 有几种算法可以计算长度为*n*的文本的后缀数组。有些算法在线性时间内运行，但相当复杂。其中一种算法在问题32-2中给出。在这里，我们将探讨一种在Θ(*n*
    1g *n*)时间内运行的更简单的算法。
- en: The idea behind the *O*(*n* 1g *n*)-time procedure COMPUTE-SUFFIX-ARRAY on the
    following page is to lexicographically sort substrings of the text with increasing
    lengths. The procedure makes several passes over the text, with the substring
    length doubling each time. By the ⌈1g *n*⌉th pass, the procedure is sorting all
    the suffixes, thereby gaining the information needed to construct the suffix array.
    The key to attaining an *O*(*n* 1g *n*)-time algorithm will be to have each pass
    after the first sort in linear time, which will indeed be possible by using radix
    sort.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '*O*(*n* 1g *n*)时间复杂度的计算后缀数组的方法COMPUTE-SUFFIX-ARRAY的思想是按照递增长度对文本的子串进行字典排序。该方法在文本上进行多次遍历，每次子串长度加倍。到第⌈1g
    *n*⌉次遍历时，该方法已经对所有后缀进行排序，从而获得构建后缀数组所需的信息。实现*O*(*n* 1g *n*)时间复杂度算法的关键在于使得第一次排序后的每次遍历都能在线性时间内完成，这可以通过使用基数排序来实现。'
- en: Let’s start with a simple observation. Consider any two strings, *s*[1] and
    *s*[2]. Decompose *s*[1] into ![art](images/Art_sprime1.jpg) and ![art](images/Art_sdprime1.jpg),
    so that *s*[1] is ![art](images/Art_sprime1.jpg) concatenated with ![art](images/Art_sdprime1.jpg).
    Likewise, let *s*[2] be ![art](images/Art_sprime2.jpg) concatenated with ![art](images/Art_sdprime2.jpg).
    Now, suppose that ![art](images/Art_sprime1.jpg) is lexicographically smaller
    than ![art](images/Art_sprime2.jpg). Then, regardless of ![art](images/Art_sdprime1.jpg)
    and ![art](images/Art_sdprime2.jpg), it must be the case that *s*[1] is lexicographically
    smaller than *s*[2]. For example, let *s*[1] = aaz and *s*[2] = aba, and decompose
    *s*[1] into ![art](images/Art_P1316.jpg) and ![art](images/Art_P1317.jpg) and
    *s*[2] into ![art](images/Art_P1318.jpg) and ![art](images/Art_P1319.jpg). Because
    ![art](images/Art_sprime1.jpg) is lexicographically smaller than ![art](images/Art_sprime2.jpg),
    it follows that *s*[1] is lexicographically smaller than *s*[2], even though ![art](images/Art_sdprime2.jpg)
    is lexicographically smaller than ![art](images/Art_sdprime1.jpg).
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个简单的观察开始。考虑任意两个字符串，*s*[1] 和 *s*[2]。将 *s*[1] 分解为 ![art](images/Art_sprime1.jpg)
    和 ![art](images/Art_sdprime1.jpg)，使得 *s*[1] 是 ![art](images/Art_sprime1.jpg) 与
    ![art](images/Art_sdprime1.jpg) 连接。��样，让 *s*[2] 为 ![art](images/Art_sprime2.jpg)
    连接 ![art](images/Art_sdprime2.jpg)。现在，假设 ![art](images/Art_sprime1.jpg) 在字典顺序上小于
    ![art](images/Art_sprime2.jpg)。那么，无论 ![art](images/Art_sdprime1.jpg) 和 ![art](images/Art_sdprime2.jpg)
    如何，都必须是 *s*[1] 在字典顺序上小于 *s*[2]。例如，让 *s*[1] = aaz 和 *s*[2] = aba，并将 *s*[1] 分解为
    ![art](images/Art_P1316.jpg) 和 ![art](images/Art_P1317.jpg)，*s*[2] 分解为 ![art](images/Art_P1318.jpg)
    和 ![art](images/Art_P1319.jpg)。因为 ![art](images/Art_sprime1.jpg) 在字典顺序上小于 ![art](images/Art_sprime2.jpg)，所以
    *s*[1] 在字典顺序上小于 *s*[2]，即使 ![art](images/Art_sdprime2.jpg) 在字典顺序上小于 ![art](images/Art_sdprime1.jpg)。
- en: Instead of comparing substrings directly, COMPUTE-SUFFIX-ARRAY represents substrings
    of the text with integer ***ranks***. Ranks have the simple property that one
    substring is lexicographically smaller then another if and only if it has a smaller
    rank. Identical substrings have equal ranks.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 不直接比较子字符串，而是用整数***排名***表示文本的子字符串。 排名具有简单的属性，即一个子字符串在字典顺序上小于另一个子字符串当且仅当它的排名较小。
    相同的子字符串具有相同的排名。
- en: Where do these ranks come from? Initially, the substrings being considered are
    just single characters from the text. Assume that, as in many programming languages,
    there is a function, ord, that maps a character to its underlying encoding, which
    is a positive integer. The ord function could be the ASCII or Unicode encodings
    or any other function that produces a relative ordering of the characters. For
    example if all the characters are known to be lowercase letters, then ord(a) =
    1, ord(b) = 2, …, ord(z) = 26 would work. Once the substrings being considered
    contain multiple characters, their ranks will be positive integers less than or
    equal to *n*, coming from their relative order after being sorted. An empty substring
    always has rank 0, since it is lexicographically less than any nonempty substring.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 这些排名是从哪里来的？最初，被考虑的子字符串只是文本中的单个字符。 假设，与许多编程语言一样，存在一个函数 ord，将字符映射到其底层编码，这是一个正整数。
    ord 函数可以是 ASCII 或 Unicode 编码或任何产生字符相对顺序的函数。 例如，如果所有字符都是小写字母，则 ord(a) = 1，ord(b)
    = 2，…，ord(z) = 26 将起作用。 一旦被考虑的子字符串包含多个字符，它们的排名将是正整数，小于或等于 *n*，来自它们在排序后的相对顺序。 空子字符串的排名始终为
    0，因为它在字典顺序上小于任何非空子字符串。
- en: COMPUTE-SUFFIX-ARRAY(*T*, *n*)
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 计算后缀数组(*T*, *n*)
- en: '|   1 | allocate arrays *substr-rank*[1:*n*], *rank*[1:*n*], and *SA*[1:*n*]
    |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '|   1 | 分配数组 *substr-rank*[1:*n*], *rank*[1:*n*] 和 *SA*[1:*n*] |'
- en: '|   2 | **for** *i* = 1 **to** *n* |'
  id: totrans-324
  prefs: []
  type: TYPE_TB
  zh: '|   2 | **for** *i* = 1 **to** *n* |'
- en: '|   3 | *substr-rank*[*i*].*left-rank* = ord(*T*[*i*]) |'
  id: totrans-325
  prefs: []
  type: TYPE_TB
  zh: '|   3 | *substr-rank*[*i*].*left-rank* = ord(*T*[*i*]) |'
- en: '|   4 | **if** *i* < *n* |'
  id: totrans-326
  prefs: []
  type: TYPE_TB
  zh: '|   4 | **if** *i* < *n* |'
- en: '|   5 | *substr-rank*[*i*].*right-rank* = ord(*T*[*i* + 1]) |'
  id: totrans-327
  prefs: []
  type: TYPE_TB
  zh: '|   5 | *substr-rank*[*i*].*right-rank* = ord(*T*[*i* + 1]) |'
- en: '|   6 | **else** *substr-rank*[*i*].*right-rank* = 0 |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '|   6 | **else** *substr-rank*[*i*].*right-rank* = 0 |'
- en: '|   7 | *substr-rank*[*i*].*index* = *i* |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '|   7 | *substr-rank*[*i*].*index* = *i* |'
- en: '|   8 | sort the array *substr-rank* into monotonically increasing order based
    on the *left-rank* attributes, using the *right-rank* attributes to break ties;
    if still a tie, the order does not matter |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
  zh: '|   8 | 根据 *left-rank* 属性将数组 *substr-rank* 按照单调递增的顺序排序，使用 *right-rank* 属性来打破平局；如果仍然平局，则顺序无关紧要
    |'
- en: '|   9 | *l* = 2 |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '|   9 | *l* = 2 |'
- en: '| 10 | **while** *l* < *n* |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| 10 | **while** *l* < *n* |'
- en: '| 11 | MAKE-RANKS(*substr-rank*, *rank*, *n*) |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| 11 | 生成排名(*substr-rank*, *rank*, *n*) |'
- en: '| 12 | **for** *i* = 1 **to** *n* |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| 12 | **for** *i* = 1 **to** *n* |'
- en: '| 13 | *substr-rank*[*i*].*left-rank* = *rank*[*i*] |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| 13 | *substr-rank*[*i*].*left-rank* = *rank*[*i*] |'
- en: '| 14 | **if** *i* + *l* ≤ *n* |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| 14 | **if** *i* + *l* ≤ *n* |'
- en: '| 15 | *substr-rank*[*i*].*right-rank* = *rank*[*i* + *l*] |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| 15 | *substr-rank*[*i*].*right-rank* = *rank*[*i* + *l*] |'
- en: '| 16 | **else** *substr-rank*[*i*].*right-rank* = 0 |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| 16 | **else** *substr-rank*[*i*].*right-rank* = 0 |'
- en: '| 17 | *substr-rank*[*i*].*index* = *i* |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| 17 | *substr-rank*[*i*].*index* = *i* |'
- en: '| 18 | sort the array *substr-rank* into monotonically increasing order based
    on the *left-rank* attributes, using the *right-rank* attributes to break ties;
    if still a tie, the order does not matter |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| 18 | 根据 *left-rank* 属性将数组 *substr-rank* 按照单调递增的顺序排序，使用 *right-rank* 属性来打破平局；如果仍然平局，则顺序无关紧要
    |'
- en: '| 19 | *l* = 2*l* |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| 19 | *l* = 2*l* |'
- en: '| 20 | **for** *i* = 1 **to** *n* |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| 20 | **for** *i* = 1 **to** *n* |'
- en: '| 21 | *SA*[*i*] = *substr-rank*[*i*].*index* |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| 21 | *SA*[*i*] = *substr-rank*[*i*].*index* |'
- en: '| 22 | **return** *SA* |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| 22 | **return** *SA* |'
- en: '| MAKE-RANKS(*substr-rank*, *rank*, *n*) |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| 生成排名(*substr-rank*, *rank*, *n*) |'
- en: '|   1 | *r* = 1 |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '|   1 | *r* = 1 |'
- en: '|   2 | *rank*[*substr-rank*[1].*index*] = *r* |'
  id: totrans-347
  prefs: []
  type: TYPE_TB
  zh: '|   2 | *rank*[*substr-rank*[1].*index*] = *r* |'
- en: '|   3 | **for** *i* = 2 **to** *n* |'
  id: totrans-348
  prefs: []
  type: TYPE_TB
  zh: '|   3 | **for** *i* = 2 **to** *n* |'
- en: '|   4 | **if** *substr-rank*[*i*].*left-rank* ≠ *substr-rank*[*i* – 1].*left-rank*
    |'
  id: totrans-349
  prefs: []
  type: TYPE_TB
  zh: '|   4 | **if** *substr-rank*[*i*].*left-rank* ≠ *substr-rank*[*i* – 1].*left-rank*
    |'
- en: '|    | or *substr-rank*[*i*].*right-rank* ≠ *substr-rank*[*i* – 1].*right-rank*
    |'
  id: totrans-350
  prefs: []
  type: TYPE_TB
  zh: '|    | 或 *substr-rank*[*i*].*right-rank* ≠ *substr-rank*[*i* – 1].*right-rank*
    |'
- en: '|   5 | *r* = *r* + 1 |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '|   5 | *r* = *r* + 1 |'
- en: '|   6 | *rank*[*substr-rank*[*i*].*index*] = *r* |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|   6 | *rank*[*substr-rank*[*i*].*index*] = *r* |'
- en: '![art](images/Art_P1320.jpg)'
  id: totrans-353
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1320.jpg)'
- en: '**Figure 32.12** The *substr-rank* array for indices *i* = 1, 2, …, 7 after
    the **for** loop of lines 2–7 and after the sorting step in line 8 for input string
    *T* = ratatat.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 32.12** 在行 2–7 的 **for** 循环和行 8 的排序步骤之后，对于输入字符串 *T* = ratatat，索引 *i* =
    1, 2, …, 7 的 *substr-rank* 数组。'
- en: 'The COMPUTE-SUFFIX-ARRAY procedure uses objects internally to keep track of
    the relative ordering of the substrings according to their ranks. When considering
    substrings of a given length, the procedure creates and sorts an array *substr-rank*[1:*n*]
    of *n* objects, each with the following attributes:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: COMPUTE-SUFFIX-ARRAY 过程在内部使用对象来跟踪子字符串根据其排名的相对顺序。在考虑给定长度的子字符串时，该过程创建并排序一个包含 *n*
    个对象的数组 *substr-rank*[1:*n*]，每个对象具有以下属性：
- en: '*left-rank* contains the rank of the left part of the substring.'
  id: totrans-356
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*left-rank* 包含子字符串左侧的排名。'
- en: '*right-rank* contains the rank of the right part of the substring.'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*right-rank* 包含子字符串右侧的排名。'
- en: '*index* contains the index into the text *T* of where the substring starts.'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*index* 包含子字符串开始的文本 *T* 中的索引。'
- en: Before delving into the details of how the procedure works, let’s look at how
    it operates on the input text ratatat, with *n* = 7\. Assuming that the ord function
    returns the ASCII code for a character, [Figure 32.12](chapter032.xhtml#Fig_32-12)
    shows the *substr-rank* array after the **for** loop of lines 2–7 and then after
    the sorting step in line 8\. The *left-rank* and *right-rank* values after lines
    2–7 are the ranks of length-1 substrings in positions *i* and *i* + 1, for *i*
    = 1, 2, …, *n*. These initial ranks are the ASCII values of the characters. At
    this point, the *left-rank* and *right-rank* values give the ranks of the left
    and right part of each substring of length 2\. Because the substring starting
    at index 7 consists of only one character, its right part is empty and so its
    *right-rank* is 0\. After the sorting step in line 8, the *substr-rank* array
    gives the relative lexicographic order of all the substrings of length 2, with
    starting points of these substrings in the *index* attribute. For example, the
    lexicographically smallest length-2 substring is at, which starts at position
    *substr-rank*[1].*index*, which equals 2\. This substring also occurs at positions
    *substr-rank*[2].*index* = 4 and *substr-rank*[3].*index* = 6.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解过程如何运作的细节之前，让我们看看它如何在输入文本 ratatat 上运行，其中 *n* = 7。假设 ord 函数返回一个字符的 ASCII
    码，[图 32.12](chapter032.xhtml#Fig_32-12) 展示了在行 2–7 的 **for** 循环之后以及在行 8 的排序步骤之后的
    *substr-rank* 数组。在行 2–7 后的 *left-rank* 和 *right-rank* 值是位置 *i* 和 *i* + 1 处长度为
    1 的子字符串的排名，对于 *i* = 1, 2, …, *n*。这些初始排名是字符的 ASCII 值。此时，*left-rank* 和 *right-rank*
    值给出了每个长度为 2 的子字符串的左侧和右侧部分的排名。因为从索引 7 开始的子字符串只包含一个字符，所以其右侧部分为空，因此其 *right-rank*
    为 0。在第 8 行的排序步骤之后，*substr-rank* 数组给出了所有长度为 2 的子字符串的词典顺序，这些子字符串的起始点在 *index* 属性中。例如，字典顺序最小的长度为
    2 的子字符串是 at，它从位置 *substr-rank*[1].*index* = 2 开始。这个子字符串还出现在位置 *substr-rank*[2].*index*
    = 4 和 *substr-rank*[3].*index* = 6。
- en: The procedure then enters the **while** loop of lines 10–19\. The loop variable
    *l* gives an upper bound on the length of substrings that have been sorted thus
    far. Entering the **while** loop, therefore, the substrings of length at most
    *l* = 2 are sorted. The call of MAKE-RANKS in line 11 gives each of these substrings
    its rank in the sorted order, from 1 up to the number of unique length-2 substrings,
    based on the values it finds in the *substr-rank* array. With *l* = 2, MAKE-RANKS
    sets *rank*[*i*] to be the rank of the length-2 substring *T*[*i*:*i* + 1]. [Figure
    32.13](chapter032.xhtml#Fig_32-13) shows these new ranks, which are not necessarily
    unique. For example, since the length-2 substring at occurs at positions 2, 4,
    and 6, MAKE-RANKS finds that *substr-rank*[1], *substr-rank*[2], and *substr-rank*[3]
    have equal values in *left-rank* and in *right-rank*. Since *substr-rank*[1].*index*
    = 2, *substr-rank*[2].*index* = 4, and *substr-rank*[3].*index* = 6, and since
    at is the smallest substring in lexicographic order, MAKE-RANKS sets *rank*[2]
    = *rank*[4] = *rank*[6] = 1.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 然后过程进入行 10–19 的 **while** 循环。循环变量 *l* 给出了迄今为止已排序子字符串长度的上限。因此，进入 **while** 循环时，长度最多为
    *l* = 2 的子字符串被排序。在第 11 行调用 MAKE-RANKS 为这些子字符串中的每一个根据 *substr-rank* 数组中的值从 1 到唯一长度为
    2 的子字符串数量设置其在排序顺序中的排名。对于 *l* = 2，MAKE-RANKS 将 *rank*[*i*] 设置为长度为 2 的子字符串 *T*[*i*:*i*
    + 1] 的排名。[图 32.13](chapter032.xhtml#Fig_32-13) 展示了这些新的排名，这些排名不一定是唯一的。例如，由于长度为
    2 的子字符串 at 出现在位置 2、4 和 6，MAKE-RANKS 发现 *substr-rank*[1]、*substr-rank*[2] 和 *substr-rank*[3]
    在 *left-rank* 和 *right-rank* 中具有相等的值。由于 *substr-rank*[1].*index* = 2，*substr-rank*[2].*index*
    = 4，*substr-rank*[3].*index* = 6，且由于 at 是字典顺序中最小的子字符串，MAKE-RANKS 将 *rank*[2] =
    *rank*[4] = *rank*[6] = 1。
- en: '![art](images/Art_P1321.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1321.jpg)'
- en: '**Figure 32.13** The *rank* array after line 11 and the *substr-rank* array
    after lines 12–17 and after line 18 in the first iteration of the **while** loop
    of lines 10–19, where *l* = 2.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 32.13** 在第一次 **while** 循环的行 10–19 中的行 11 后以及行 12–17 和行 18 后的 *substr-rank*
    数组，其中 *l* = 2 时的 *rank* 数组。'
- en: This iteration of the **while** loop will sort the substrings of length at most
    4 based on the ranks from sorting the substrings of length at most 2\. The **for**
    loop of lines 12–17 reconstitutes the *substr-rank* array, with *substr-rank*[*i*].*left-rank*
    based on *rank*[*i*] (the rank of the length-2 substring *T*[*i*:*i*+1]) and *substr-rank*[*i*].*right-rank*
    based on *rank*[*i* + 2] (the rank of the length-2 substring *T*[*i* + 2:*i* +
    3], which is 0 if this substring starts beyond the end of the length-*n* text).
    Together, these two ranks give the relative rank of the length-4 substring *T*[*i*:*i*
    + 3]. [Figure 32.13](chapter032.xhtml#Fig_32-13) shows the effect of lines 12–17\.
    The figure also shows the result of sorting the *substr-rank* array in line 18,
    based on the *left-rank* attribute, and using the *right-rank* attribute to break
    ties. Now *substr-rank* gives the lexicographically sorted order of all substrings
    with length at most 4.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 这次**while**循环将基于排序长度不超过2的子字符串的排名，对长度不超过4的子字符串进行排序。第12-17行的**for**循环重建了*substr-rank*数组，其中*substr-rank*[*i*].*left-rank*基于*rank*[*i*]（长度为2的子字符串*T*[*i*:*i*+1]的排名）和*substr-rank*[*i*].*right-rank*基于*rank*[*i*
    + 2]（长度为2的子字符串*T*[*i* + 2:*i* + 3]的排名，如果此子字符串��长度为*n*的文本的末尾开始，则为0）。这两个排名共同给出了长度为4的子字符串*T*[*i*:*i*
    + 3]的相对排名。[图32.13](chapter032.xhtml#Fig_32-13)展示了第12-17行的效果。该图还展示了根据*left-rank*属性对*substr-rank*数组进行排序的结果，并使用*right-rank*属性来打破平局。现在*substr-rank*给出了所有长度不超过4的子字符串的词典排序顺序。
- en: The next iteration of the **while** loop, with *l* = 4, sorts the substrings
    of length at most 8 based on the ranks from sorting the substrings of length at
    most^([4](#footnote_4)) 4\. [Figure 32.14](chapter032.xhtml#Fig_32-14) shows the
    ranks of the length-4 substrings and the *substr-rank* array before and after
    sorting. This iteration is the final one, since with the length *n* of the text
    equaling 7, the procedure has sorted all substrings.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个**while**循环的迭代，当*l* = 4时，基于排序长度不超过8的子字符串的排名，这些排名是根据排序长度不超过^([4](#footnote_4))
    4的子字符串而得到的。[图32.14](chapter032.xhtml#Fig_32-14)展示了长度为4的子字符串的排名以及排序前后的*substr-rank*数组。这次迭代是最后一次，因为文本的长度*n*等于7，该过程已经对所有子字符串进行了排序。
- en: '![art](images/Art_P1322.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1322.jpg)'
- en: '**Figure 32.14** The *rank* array after line 11 and the *substr-rank* array
    after lines 12–17 and after line 18 in the second—and final—iteration of the **while**
    loop of lines 10–19, where *l* = 4.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '**图32.14** 第11行后的*rank*数组和第12-17行后以及第18行后的*substr-rank*数组，第二次也是最后一次迭代的**while**循环，其中*l*
    = 4。'
- en: In general, as the loop variable *l* increases, more and more of the right parts
    of the substrings are empty. Therefore, more of the *right-rank* values are 0\.
    Because *i* is at most *n* within the loop of lines 12–17, the left part of each
    substring is always nonempty, and so all *left-rank* values are always positive.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 一般来说，随着循环变量*l*的增加，越来越多的子字符串的右部为空。因此，越来越多的*right-rank*值为0。由于在第12-17行的循环中*i*最多为*n*，每个子字符串的左部始终不为空，因此所有*left-rank*值始终为正数。
- en: This example illuminates why the COMPUTE-SUFFIX-ARRAY procedure works. The initial
    ranks established in lines 2–7 are simply the ord values of the characters in
    the text, and so when line 8 sorts the *substr-rank* array, its ordering corresponds
    to the lexicographic ordering of the length-2 substrings. Each iteration of the
    **while** loop of lines 10–19 takes sorted substrings of length *l* and produces
    sorted substrings of length 2*l*. Once *l* reaches or exceeds *n*, all substrings
    have been sorted.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子阐明了COMPUTE-SUFFIX-ARRAY过程的工作原理。在第2-7行建立的初始排名只是文本中字符的ord值，因此当第8行对*substr-rank*数组进行排序时，其排序对应于长度为2的子字符串的词典顺序。第10-19行的**while**循环的每次迭代都将长度为*l*的已排序子字符串转换为长度为2*l*的已排序子字符串。一旦*l*达到或超过*n*，所有子字符串都已排序。
- en: Within an iteration of the **while** loop, the MAKE-RANKS procedure “re-ranks”
    the substrings that were sorted, either by line 8 before the first iteration or
    by line 18 in the previous iteration. MAKE-RANKS takes a *substr-rank* array,
    which has been sorted, and fills in an array *rank*[1:*n*] so that *rank*[*i*]
    is the rank of the *i*th substring represented in the *substr-rank* array. Each
    rank is a positive integer, starting from 1, and going up to the number of unique
    substrings of length 2*l*. Substrings with equal values of *left-rank* and *right-rank*
    receive the same rank. Otherwise, a substring that is lexicographically smaller
    than another appears earlier in the *substr-rank* array, and it receives a smaller
    rank. Once the substrings of length 2*l* are re-ranked, line 18 sorts them by
    rank, preparing for the next iteration of the **while** loop.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 在**while**循环的一次迭代中，MAKE-RANKS过程“重新排名”了已排序的子字符串，无论是在第一次迭代之前的第8行还是在上一次迭代的第18行。MAKE-RANKS接受一个已排序的*substr-rank*数组，并填充一个数组*rank*[1:*n*]，使得*rank*[*i*]是在*substr-rank*数组中表示的第*i*个子字符串的排名。每个排名都是一个正整数，从1开始，直到长度为2*l*的唯一子字符串的数量。具有相等*left-rank*和*right-rank*值的子字符串获得相同的排名。否则，词典顺序较小的子字符串出现在*substr-rank*数组中较早，并获得较小的排名。一旦长度为2*l*的子字符串重新排名，第18行按排名对它们进行排序，为下一次**while**循环做准备。
- en: Once *l* reaches or exceeds *n* and all substrings are sorted, the values in
    the *index* attributes give the starting positions of the sorted substrings. These
    indices are precisely the values that constitute the suffix array.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦*l*达到或超过*n*并且所有子字符串都已排序，*index*属性中的值将给出已排序子字符串的起始位置。这些索引恰好构成后缀数组。
- en: Let’s analyze the running time of COMPUTE-SUFFIX-ARRAY. Lines 1–7 take Θ(*n*)
    time. Line 8 takes *O*(*n* 1g *n*) time, using either merge sort (see [Section
    2.3.1](chapter002.xhtml#Sec_2.3.1)) or heapsort (see [Chapter 6](chapter006.xhtml)).
    Because the value of *l* doubles in each iteration of the **while** loop of lines
    10–19, this loop makes ⌈1g *n*⌉ – 1 iterations. Within each iteration, the call
    of MAKE-RANKS takes Θ(*n*) time, as does the **for** loop of lines 12–17\. Line
    18, like line 8, takes *O*(*n* 1g *n*) time, using either merge sort or heapsort.
    Finally, the **for** loop of lines 20–21 takes Θ(*n*) time. The total time works
    out to *O*(*n* 1g² *n*).
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析 COMPUTE-SUFFIX-ARRAY 的运行时间。第 1-7 行需要 Θ(*n*) 时间。第 8 行需要 *O*(*n* 1g *n*)
    时间，使用合并排序（参见 [第 2.3.1 节](chapter002.xhtml#Sec_2.3.1)）或堆排序（参见 [第 6 章](chapter006.xhtml)）。因为
    *l* 的值在第 10-19 行的**while**循环的每次迭代中翻倍，这个循环进行 ⌈1g *n*⌉ – 1 次迭代。在每次迭代中，MAKE-RANKS
    的调用需要 Θ(*n*) 时间，就像第 12-17 行的**for**循环一样。第 18 行，就像第 8 行一样，需要 *O*(*n* 1g *n*) 时间，使用合并排序或堆排序。最后，第
    20-21 行的**for**循环需要 Θ(*n*) 时间。总时间为 *O*(*n* 1g² *n*)。
- en: A simple observation allows us to reduce the running time to Θ(*n* 1g *n*).
    The values of *left-rank* and *right-rank* being sorted in line 18 are always
    integers in the range 0 to *n*. Therefore, radix sort can sort the *substr-rank*
    array in Θ(*n*) time by first running counting sort (see [Chapter 8](chapter008.xhtml))
    based on *right-rank* and then running counting sort based on *left-rank*. Now
    each iteration of the **while** loop of lines 10–19 takes only Θ(*n*) time, giving
    a total time of Θ(*n* 1g *n*).
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的观察让我们将运行时间降低到 Θ(*n* 1g *n*)。在第18行中排序的 *left-rank* 和 *right-rank* 的值始终是范围在
    0 到 *n* 的整数。因此，基数排序可以通过首先基于 *right-rank* 运行计数排序（参见 [第 8 章](chapter008.xhtml)）然后基于
    *left-rank* 运行计数排序，在 Θ(*n*) 时间内对 *substr-rank* 数组进行排序。现在，第10-19行的**while**循环的每次迭代仅需要
    Θ(*n*) 时间，总时间为 Θ(*n* 1g *n*)。
- en: Exercise 32.5-2 asks you to make a simple modification to COMPUTE-SUFFIX-ARRAY
    that allows the **while** loop of lines 10–19 to iterate fewer than ⌈1g *n*⌉ –
    1 times for certain inputs.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 32.5-2 要求您对 COMPUTE-SUFFIX-ARRAY 进行简单修改，使得第10-19行的**while**循环对于某些输入少于 ⌈1g
    *n*⌉ – 1 次迭代。
- en: '**Computing the *LCP* array**'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '**计算 *LCP* 数组**'
- en: Recall that *LCP*[*i*] is defined as the length of the longest common prefix
    of the (*i* – 1)st and *i*th lexicographically smallest suffixes *T*[*SA*[*i*
    – 1]:] and *T*[*SA*[*i*]:]. Because *T*[*SA*[1]:] is the lexicographically smallest
    suffix, we define *LCP*[1] to be 0.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，*LCP*[*i*] 定义为(*i* – 1)st 和 *i*th 字典序最小后缀 *T*[*SA*[*i* – 1]:] 和 *T*[*SA*[*i*]:]
    的最长公共前缀的长度。因为 *T*[*SA*[1]:] 是字典序最小的后缀，我们将 *LCP*[1] 定义为 0。
- en: 'In order to compute the *LCP* array, we need an array *rank* that is the inverse
    of the *SA* array, just like the final *rank* array in COMPUTE-SUFFIX-ARRAY: if
    *SA*[*i*] = *j*, then *rank*[*j*] = *i*. That is, we have *rank*[*SA*[*i*]] =
    *i* for *i* = 1, 2, …, *n*. For a suffix *T*[*i*:], the value of *rank*[*i*] gives
    the position of this suffix in the lexicographically sorted order. [Figure 32.11](chapter032.xhtml#Fig_32-11)
    includes the *rank* array for the ratatat example. For example, the suffix tat
    is *T*[5:]. To find this suffix’s position in the sorted order, look up *rank*[5]
    = 6.'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算 *LCP* 数组，我们需要一个与 *SA* 数组相反的 *rank* 数组，就像 COMPUTE-SUFFIX-ARRAY 中的最终 *rank*
    数组一样：如果 *SA*[*i*] = *j*，那么 *rank*[*j*] = *i*。也就是说，对于 *T*[*i*:] 的后缀，*rank*[*i*]
    的值给出了这个后缀在字典序排序中的位置。[图 32.11](chapter032.xhtml#Fig_32-11) 包括了 ratatat 示例的 *rank*
    数组。例如，后缀 tat 是 *T*[5:]。要找到这个后缀在排序顺序中的位置，查找 *rank*[5] = 6。
- en: To compute the *LCP* array, we will need to determine where in the lexicographically
    sorted order a suffix appears, but with its first character removed. The *rank*
    array helps. Consider the *i*th smallest suffix, which is *T*[*SA*[*i*]:]. Dropping
    its first character gives the suffix *T*[*SA*[*i*] + 1:], that is, the suffix
    starting at position *SA*[*i*] + 1 in the text. The location of this suffix in
    the sorted order is given by *rank*[*SA*[*i*] + 1]. For example, for the suffix
    atat, let’s see where to find tat (atat with its first character removed) in the
    lexicographically sorted order. The suffix atat appears in position 2 of the suffix
    array, and *SA*[2] = 4\. Thus, *rank*[*SA*[2] + 1] = *rank*[5] = 6, and sure enough
    the suffix tat appears in location 6 in the sorted order.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算 *LCP* 数组，我们需要确定后缀在字典序排序中的位置，但去掉第一个字符。 *rank* 数组有助于此。考虑第 *i* 个最小的后缀，即 *T*[*SA*[*i*]:]。去掉第一个字符后得到后缀
    *T*[*SA*[*i*] + 1:]，即文本中位置 *SA*[*i*] + 1 开始的后缀。这个后缀在排序顺序中的位置由 *rank*[*SA*[*i*]
    + 1] 给出。例如，对于后缀 atat，让我们看看在字典序排序中如何找到 tat（去掉第一个字符的 atat）。后缀 atat 出现在后缀数组的位置 2，即
    *SA*[2] = 4。因此，*rank*[*SA*[2] + 1] = *rank*[5] = 6，确实后缀 tat 出现在排序顺序中的位置 6。
- en: The procedure COMPUTE-LCP on the next page produces the *LCP* array. The following
    lemma helps show that the procedure is correct.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 过程 COMPUTE-LCP 在下一页生成 *LCP* 数组。以下引理有助于证明该过程的正确性。
- en: COMPUTE-LCP(*T*, *SA*, *n*)
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 计算-LCP(*T*, *SA*, *n*)
- en: '|   1 | allocate arrays *rank*[1:*n*] and *LCP*[1:*n*] |'
  id: totrans-380
  prefs: []
  type: TYPE_TB
  zh: '|   1 | 分配数组 *rank*[1:*n*] 和 *LCP*[1:*n*] |'
- en: '|   2 | **for** *i* = 1 **to** *n* |'
  id: totrans-381
  prefs: []
  type: TYPE_TB
  zh: '|   2 | **对于** *i* = 1 **到** *n* |'
- en: '|   3 | *rank*[*SA*[*i*]] = *i* | **//** by definition |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '|   3 | *rank*[*SA*[*i*]] = *i* | **//** 根据定义 |'
- en: '|   4 | *LCP*[1] = 0 | **//** also by definition |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '|   4 | *LCP*[1] = 0 | **//** 也是根据定义 |'
- en: '|   5 | *l* = 0 | **//** initialize length of LCP |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '|   5 | *l* = 0 | **//** 初始化LCP长度 |'
- en: '|   6 | **for** *i* = 1 **to** *n* |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '|   6 | **对于** *i* = 1 **到** *n* |'
- en: '|   7 | **if** *rank*[*i*] > 1 |'
  id: totrans-386
  prefs: []
  type: TYPE_TB
  zh: '|   7 | **如果** *rank*[*i*] > 1 |'
- en: '|   8 | *j* = *SA*[*rank*[*i*] – 1] | **//** *T*[*j*:] precedes *T*[*i*:] lexicographically
    |'
  id: totrans-387
  prefs: []
  type: TYPE_TB
  zh: '|   8 | *j* = *SA*[*rank*[*i*] – 1] | **//** *T*[*j*:] 在字典序上位于 *T*[*i*:] 之前
    |'
- en: '|   9 | *m* = max {*i*, *j* } |'
  id: totrans-388
  prefs: []
  type: TYPE_TB
  zh: '|   9 | *m* = max {*i*, *j* } |'
- en: '| 10 | **while** *m* + *l* ≤ *n* and *T*[*i* + *l*] == *T*[*j* + *l*] |'
  id: totrans-389
  prefs: []
  type: TYPE_TB
  zh: '| 10 | **当** *m* + *l* ≤ *n* 且 *T*[*i* + *l*] == *T*[*j* + *l*] 时 |'
- en: '| 11 | *l* = *l* + 1 | **//** next character is in common prefix |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| 11 | *l* = *l* + 1 | **//** 公共前缀的下一个字符 |'
- en: '| 12 | *LCP*[*rank*[*i*]] = *l* | **//** length of LCP of *T*[*j*:] and *T*[*i*:]
    |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| 12 | *LCP*[*rank*[*i*]] = *l* | **//** *T*[*j*:] 和 *T*[*i*:] 的LCP长度 |'
- en: '| 13 | **if** *l* > 0 |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| 13 | **如果** *l* > 0 |'
- en: '| 14 | *l* = *l* – 1 | **//** peel off first character of common prefix |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| 14 | *l* = *l* – 1 | **//** 去掉公共前缀的第一个字符 |'
- en: '| 15 | **return** *LCP* |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 15 | **返回** *LCP* |'
- en: '***Lemma 32.8***'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 32.8***'
- en: Consider suffixes *T*[*i* – 1:] and *T*[*i*:], which appear at positions *rank*[*i*
    – 1] and *rank*[*i*], respectively, in the lexicographically sorted order of suffixes.
    If *LCP*[*rank*[*i* – 1]] = *l* > 1, then the suffix *T*[*i*:], which is *T*[*i*
    – 1:] with its first character removed, has *LCP*[*rank*[*i*]] ≥ *l* – 1.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑后缀 *T*[*i* – 1:] 和 *T*[*i*:]，它们在后缀的字典序排序中分别出现在位置 *rank*[*i* – 1] 和 *rank*[*i*]。如果
    *LCP*[*rank*[*i* – 1]] = *l* > 1，则后缀 *T*[*i*:]，即去掉其第一个字符的 *T*[*i* – 1:]，具有 *LCP*[*rank*[*i*]]
    ≥ *l* – 1。
- en: '***Proof***   The suffix *T*[*i* – 1:] appears at position *rank*[*i* – 1]
    in the lexicographically sorted order. The suffix immediately preceding it in
    the sorted order appears at position *rank*[*i* – 1] – 1 and is *T*[*SA*[*rank*[*i*
    – 1] – 1]:]. By assumption and the definition of the *LCP* array, these two suffixes,
    *T*[*SA*[*rank*[*i*–1]–1]:] and *T*[*i*–1:], have a longest common prefix of length
    *l* > 1\. Removing the first character from each of these suffixes gives the suffixes
    *T*[*SA*[*rank*[*i* – 1] – 1] + 1:] and *T*[*i*:], respectively. These suffixes
    have a longest common prefix of length *l* – 1\. If *T*[*SA*[*rank*[*i* – 1] –
    1] + 1:] immediately precedes *T*[*i*:] in the lexicographically sorted order
    (that is, if *rank*[*SA*[*rank*[*i* – 1] – 1] + 1] = *rank*[*i*] – 1), then the
    lemma is proven.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 后缀 *T*[*i* – 1:] 在字典序排序中出现在位置 *rank*[*i* – 1]。在排序顺序中紧随其后的后缀出现在位置 *rank*[*i*
    – 1] – 1，为 *T*[*SA*[*rank*[*i* – 1] – 1]:]。根据假设和 *LCP* 数组的定义，这两个后缀，*T*[*SA*[*rank*[*i*–1]–1]:]
    和 *T*[*i*–1:]，具有长度为 *l* > 1 的最长公共前缀。从这两个后缀中去掉第一个字符得到后缀 *T*[*SA*[*rank*[*i* – 1]
    – 1] + 1:] 和 *T*[*i*:]。这两个后缀具有长度为 *l* – 1 的最长公共前缀。如果 *T*[*SA*[*rank*[*i* – 1]
    – 1] + 1:] 紧随 *T*[*i*:] 在字典序排序中（即，如果 *rank*[*SA*[*rank*[*i* – 1] – 1] + 1] = *rank*[*i*]
    – 1），则引理得证。'
- en: So now assume that *T*[*SA*[*rank*[*i* – 1] – 1] + 1:] does not immediately
    precede *T*[*i*:] in the sorted order. Since *T*[*SA*[*rank*[*i* – 1] – 1]:] immediately
    precedes *T*[*i*–1:] and they have the same first *l* > 1 characters, *T*[*SA*[*rank*[*i*
    – 1] – 1] + 1:] must appear in the sorted order somewhere before *T*[*i*:], with
    one or more other suffixes intervening. Each of these suffixes must start with
    the same *l* – 1 characters as *T*[*SA*[*rank*[*i* – 1] – 1] + 1:] and *T*[*i*:],
    for otherwise it would appear either before *T*[*SA*[*rank*[*i* – 1] – 1] + 1:]
    or after *T*[*i*:]. Therefore, whichever suffix appears in position *rank*[*i*]
    – 1, immediately before *T*[*i*:], has at least its first *l* – 1 characters in
    common with *T*[*i*:]. Thus, *LCP*[*rank*[*i*]] ≥ *l* – 1.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设 *T*[*SA*[*rank*[*i* – 1] – 1] + 1:] 不紧随 *T*[*i*:] 在排序顺序中。由于 *T*[*SA*[*rank*[*i*
    – 1] – 1]:] 紧随 *T*[*i*–1:]，它们的前 *l* > 1 个字符相同，*T*[*SA*[*rank*[*i* – 1] – 1] +
    1:] 必须在排序顺序中在 *T*[*i*:] 之前的某个位置出现，中间可能有一个或多个其他后缀。这些后缀中的每一个必须以与 *T*[*SA*[*rank*[*i*
    – 1] – 1] + 1:] 和 *T*[*i*:] 相同的前 *l* – 1 个字符开头，否则它将出现在 *T*[*SA*[*rank*[*i* – 1]
    – 1] + 1:] 之前或 *T*[*i*:] 之后。因此，无论哪个后缀出现在位置 *rank*[*i*] – 1，紧随 *T*[*i*:] 之前，至少有其前
    *l* – 1 个字符与 *T*[*i*:] 相同。因此，*LCP*[*rank*[*i*]] ≥ *l* – 1。
- en: ▪
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: The COMPUTE-LCP procedure works as follows. After allocating the *rank* and
    *LCP* arrays in line 1, lines 2–3 fill in the *rank* array and line 4 pegs *LCP*[1]
    to 0, per the definition of the *LCP* array.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: COMPUTE-LCP 过程的工作方式如下。在第 1 行分配 *rank* 和 *LCP* 数组后，第 2–3 行填充 *rank* 数组，第 4 行根据
    *LCP* 数组的定义将 *LCP*[1] 设为 0。
- en: The **for** loop of lines 6–14 fills in the rest of the *LCP* array going by
    decreasing-length suffixes. That is, it fills the position of the *LCP* array
    in the order *rank*[1], *rank*[2], *rank*[3], …, *rank*[*n*], with the assignment
    occurring in line 12\. Upon considering a suffix *T*[*i*:], line 8 determines
    the suffix *T*[*j*:] that immediately precedes *T*[*i*:] in the lexicographically
    sorted order. At this point, the longest common prefix of *T*[*j*:] and *T*[*i*:]
    has length at least *l*. This property certainly holds upon the first iteration
    of the **for** loop, when *l* = 0\. Assuming that line 12 sets *LCP*[*rank*[*i*]]
    correctly, line 14 (which decrements *l* if it is positive) and Lemma 32.8 maintain
    this property for the next iteration. The longest common prefix of *T*[*j*:] and
    *T*[*i*:] might be even longer than the value of *l* at the start of the iteration,
    however. Lines 9–11 increment *l* for each additional character the prefixes have
    in common so that it achieves the length of the longest common prefix. The index
    *m* is set in line 9 and used in the test in line 10 to make sure that the test
    *T*[*i* + *l*] == *T*[*j* + *l*] for extending the longest common prefix does
    not run off the end of the text *T*. When the **while** loop of lines 10–11 terminates,
    *l* is the length of the longest common prefix of *T*[*j*:] and *T*[*i*:].
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 行 6–14 的 **for** 循环填充了 *LCP* 数组的其余部分，按照后缀长度递减的顺序进行。也就是说，它按照 *rank*[1]、*rank*[2]、*rank*[3]，…，*rank*[*n*]
    的顺序填充 *LCP* 数组的位置，赋值发生在第 12 行。在考虑后缀 *T*[*i*:] 时，第 8 行确定了在字典序排序中紧随 *T*[*i*:] 的后缀
    *T*[*j*:]。此时，*T*[*j*:] 和 *T*[*i*:] 的最长公共前缀长度至少为 *l*。这个属性在 **for** 循环的第一次迭代时肯定成立，当
    *l* = 0。假设第 12 行正确设置了 *LCP*[*rank*[*i*]]，第 14 行（如果 *l* 为正则递减 *l*）和引理 32.8 保持了下一次迭代的这个属性。然而，*T*[*j*:]
    和 *T*[*i*:] 的最长公共前缀可能比迭代开始时的 *l* 值更长。第 9–11 行为它们共同拥有的每个额外字符增加 *l*，使其达到最长公共前缀的长度。第
    9 行设置索引 *m*，并在第 10 行的测试中使用，以确保用于扩展最长公共前缀的测试 *T*[*i* + *l*] == *T*[*j* + *l*] 不会超出文本
    *T* 的末尾。当行 10–11 的 **while** 循环终止时，*l* 就是 *T*[*j*:] 和 *T*[*i*:] 的最长公共前缀的长度。
- en: As a simple aggregate analysis shows, the COMPUTE-LCP procedure runs in Θ(*n*)
    time. Each of the two **for** loops iterates *n* times, and so it remains only
    to bound the total number of iterations by the **while** loop of lines 10–11\.
    Each iteration increases *l* by 1, and the test *m* + *l* ≤ *n* ensures that *l*
    is always less than *n*. Because *l* has an initial value of 0 and decreases at
    most *n* – 1 times in line 14, line 11 increments *l* fewer than 2*n* times. Thus,
    COMPUTE-LCP takes Θ(*n*) time.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的聚合分析显示，COMPUTE-LCP过程运行时间为Θ(*n*)。两个**for**循环都迭代*n*次，因此只需限制总迭代次数不超过行10-11的**while**循环。每次迭代将*l*增加1，而测试*m*
    + *l* ≤ *n*确保*l*始终小于*n*。因为*l*的初始值为0，并且在第14行最多减少*n* - 1次，所以第11行增加*l*的次数少于2*n*次。因此，COMPUTE-LCP需要Θ(*n*)时间。
- en: '**Exercises**'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***32.5-1***'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.5-1***'
- en: Show the *substr-rank* and *rank* arrays before each iteration of the **while**
    loop of lines 10–19 and after the last iteration of the **while** loop, the suffix
    array *SA* returned, and the sorted suffixes when COMPUTE-SUFFIX-ARRAY is run
    on the text hippityhoppity. Use the position of each letter in the alphabet as
    its ord value, so that ord(b) = 2\. Then show the *LCP* array after each iteration
    of the **for** loop of lines 6–14 of COMPUTE-LCP given the text hippityhoppity
    and its suffix array.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 在行10-19的**while**循环的每次迭代之前显示*substr-rank*和*rank*数组，在**while**循环的最后一次迭代之后显示返回的后缀数组*SA*，以及在文本hippityhoppity上运行COMPUTE-SUFFIX-ARRAY时的排序后的后缀。使用每个字母在字母表中的位置作为其ord值，因此ord(b)
    = 2。然后展示给定文本hippityhoppity及其后缀数组时，在COMPUTE-LCP的行6-14的**for**循环的每次迭代之后的*LCP*数组。
- en: '***32.5-2***'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.5-2***'
- en: For some inputs, the COMPUTE-SUFFIX-ARRAY procedure can produce the correct
    result with fewer than ⌈1g *n*⌉ – 1 iterations of the **while** loop of lines
    10–19\. Modify COMPUTE-SUFFIX-ARRAY (and, if necessary, MAKE-RANKS) so that the
    procedure can stop before making all ⌈1g *n*⌉ – 1 iterations in some cases. Describe
    an input that allows the procedure to make *O*(1) iterations. Describe an input
    that forces the procedure to make the maximum number of iterations.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某些输入，COMPUTE-SUFFIX-ARRAY过程可以在行10-19的**while**循环中进行少于⌈1g *n*⌉ - 1次迭代就能产生正确结果。修改COMPUTE-SUFFIX-ARRAY（如果必要，还有MAKE-RANKS），使得该过程在某些情况下可以在进行所有⌈1g
    *n*⌉ - 1次迭代之前停止。描述一个允许该过程进行*O*(1)次迭代的输入。描述一个强制该过程进行最大迭代次数的输入。
- en: '***32.5-3***'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.5-3***'
- en: Given two texts, *T*[1] of length *n*[1] and *T*[2] of length *n*[2], show how
    to use the suffix array and longest common prefix array to find all of the ***longest
    common substrings***, that is, the longest substrings that appear in both *T*[1]
    and *T*[2]. Your algorithm should run in *O*(*n* 1g *n* + *kl*) time, where *n*
    = *n*[1] + *n*[2] and there are *k* such longest substrings, each with length
    *l*.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个长度分别为*n*[1]和*n*[2]的文本*T*[1]和*T*[2]，展示如何利用后缀数组和最长公共前缀数组找到所有***最长公共子串***，即出现在*T*[1]和*T*[2]中的最长子串。你的算法应该在*O*(*n*
    1g *n* + *kl*)时间内运行，其中*n* = *n*[1] + *n*[2]，有*k*个这样的最长子串，每个长度为*l*。
- en: '***32.5-4***'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '***32.5-4***'
- en: Professor Markram proposes the following method to find the longest palindromes
    in a string *T*[1:*n*] by using its suffix array and LCP array. (Recall from Problem
    14-2 that a palindrome is a nonempty string that reads the same forward and backward.)
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: Markram教授提出了以下方法，通过使用字符串*T*[1:*n*]的后缀数组和LCP数组来找到最长的回文串。（回顾问题14-2，回文是指从前往后读和从后往前读都一样的非空字符串。）
- en: Let @ be a character that does not appear in *T*. Construct the text *T*′ as
    the concatenation of *T*, @, and the reverse of *T*. Denote the length of *T*′
    by *n*′ = 2*n* + 1\. Create the suffix array *SA* and *LCP* array *LCP* for *T*′.
    Since the indices for a palindrome and its reverse appear in consecutive positions
    in the suffix array, find the entries with the maximum *LCP* value *LCP*[*i*]
    such that *SA*[*i* – 1] = *n*′ – *SA*[*i*] – *LCP*[*i*] + 2\. (This constraint
    prevents a substring—and its reverse—from being construed as a palindrome unless
    it really is one.) For each such index *i*, one of the longest palindromes is
    *T*′[*SA*[*i*]:*SA*[*i*] + *LCP*[*i*] – 1].
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 让@表示*T*中不存在的字符。构造文本*T*′为*T*、@和*T*的倒序的连接。将*T*′的长度记为*n*′ = 2*n* + 1。为*T*′创建后缀数组*SA*和*LCP*数组*LCP*。由于回文及其倒序的索引在后缀数组中出现在连续位置，找到具有最大*LCP*值*LCP*[*i*]的条目，使得*SA*[*i*
    - 1] = *n*′ - *SA*[*i*] - *LCP*[*i*] + 2。（此约束��止一个子串及其倒序被误认为是回文，除非它确实是回文。）对于每个这样的索引*i*，最长回文之一是*T*′[*SA*[*i*]:*SA*[*i*]
    + *LCP*[*i*] - 1]。
- en: 'For example, if the text *T* is unreferenced, with *n* = 12, then the text
    *T*′ is unreferenced@decnerefernu, with *n*′ = 25 and the following suffix array
    and LCP array:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果文本*T*是unreferenced，长度为12，则文本*T*′是unreferenced@decnerefernu，长度为25，后缀数组和LCP数组如下：
- en: '![art](images/Art_P1322a.jpg)'
  id: totrans-414
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1322a.jpg)'
- en: The maximum *LCP* value is achieved at *LCP*[21] = 5, and *SA*[20] = 3 = *n*′
    – *SA*[21] – *LCP*[21] + 2\. The suffixes of *T*′ starting at indices *SA*[20]
    and *SA*[21] are referenced@decnerefernu and refernu, both of which start with
    the length-5 palindrome refer.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 最大*LCP*值在*LCP*[21] = 5处达到，*SA*[20] = 3 = *n*′ - *SA*[21] - *LCP*[21] + 2。从索引*SA*[20]和*SA*[21]开始的*T*′的后缀分别是referenced@decnerefernu和refernu，两者都以长度为5的回文refer开头。
- en: Alas, this method is not foolproof. Give an input string *T* that causes this
    method to give results that are shorter than the longest palindrome contained
    within *T*, and explain why your input causes the method to fail.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 遗憾的是，这种方法并非百分之百可靠。给出一个输入字符串*T*，使得该方法给出的结果比*T*中包含的最长回文串要短，并解释为什么你的输入会导致该方法失败。
- en: '**Problems**'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '***32-1     String matching based on repetition factors***'
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '***32-1     基于重复因子的字符串匹配***'
- en: Let *y*^(*i*) denote the concatenation of string *y* with itself *i* times.
    For example, (ab)³ = ababab. We say that a string *x* ∈ ∑* has ***repetition factor*** *r*
    if *x* = *y*^(*r*) for some string *y* ∈ ∑* and some *r* > 0\. Let *ρ*(*x*) denote
    the largest *r* such that *x* has repetition factor *r*.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 让*y*^(*i*)表示字符串*y*重复*i*次的连接。例如，(ab)³ = ababab。如果*x* ∈ ∑*是具有***重复因子*** *r*的字符串，则我们说*x*
    = *y*^(*r*)，其中*y* ∈ ∑*且*r* > 0。让*ρ*(*x*)表示*x*具有的最大*r*，使得*x*具有重复因子*r*。
- en: '***a.*** Give an efficient algorithm that takes as input a pattern *P*[1:*m*]
    and computes the value *ρ*(*P*[:*i*]) for *i* = 1, 2, …, *m*. What is the running
    time of your algorithm?'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 给出一个有效的算法，该算法以模式*P*[1:*m*]作为输入并计算*i* = 1, 2, …, *m*的值*ρ*(*P*[:*i*])。您的算法的运行时间是多少？'
- en: '***b.*** For any pattern *P*[1:*m*], let *ρ**(*P*) be defined as max {*ρ*(*P*[:*i*])
    : 1 ≤ *i* ≤ *m*}. Prove that if the pattern *P* is chosen randomly from the set
    of all binary strings of length *m*, then the expected value of *ρ**(*P*) is *O*(1).'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 对于任意模式*P*[1:*m*]，让*ρ**(*P*)定义为max {*ρ*(*P*[:*i*]) : 1 ≤ *i* ≤ *m*}。证明如果模式*P*是从长度为*m*的所有二进制字符串集合中随机选择的，则*ρ**(*P*)的期望值是*O*(1)。'
- en: '***c.*** Argue that the procedure REPETITION-MATCHER correctly finds all occurrences
    of pattern *P*[1:*m*] in text *T*[1:*n*] in *O*(*ρ**(*P*)*n* + *m*) time. (This
    algorithm is due to Galil and Seiferas. By extending these ideas greatly, they
    obtained a linear-time string-matching algorithm that uses only *O*(1) storage
    beyond what is required for *P* and *T*.)'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 论证REPETITION-MATCHER过程在*O*(*ρ**(*P*)*n* + *m*)时间内正确找到文本*T*[1:*n*]中模式*P*[1:*m*]的所有出现。（这个算法归功于Galil和Seiferas。通过大大扩展这些想法，他们获得了一个仅使用*O*(1)存储空间的线性时间字符串匹配算法，该存储空间仅用于*P*和*T*所需的内容之外。）'
- en: REPETITION-MATCHER(*T*, *P*, *n*, *m*)
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: REPETITION-MATCHER(*T*, *P*, *n*, *m*)
- en: '|   1 | *k* = 1 + *ρ**(*P*) |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '|   1 | *k* = 1 + *ρ**(*P*) |'
- en: '|   2 | *q* = 0 |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '|   2 | *q* = 0 |'
- en: '|   3 | *s* = 0 |'
  id: totrans-426
  prefs: []
  type: TYPE_TB
  zh: '|   3 | *s* = 0 |'
- en: '|   4 | **while** *s* ≤ *n* – *m* |'
  id: totrans-427
  prefs: []
  type: TYPE_TB
  zh: '|   4 | **当** *s* ≤ *n* – *m* |'
- en: '|   5 | **if** *T*[*s* + *q* + 1] == *P*[*q* + 1] |'
  id: totrans-428
  prefs: []
  type: TYPE_TB
  zh: '|   5 | **如果** *T*[*s* + *q* + 1] == *P*[*q* + 1] |'
- en: '|   6 | *q* = *q* + 1 |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '|   6 | *q* = *q* + 1 |'
- en: '|   7 | **if** *q* == *m* |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '|   7 | **如果** *q* == *m* |'
- en: '|   8 | print “Pattern occurs with shift” *s* |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '|   8 | 打印“Pattern occurs with shift” *s* |'
- en: '|   9 | **if** *q* == *m* or *T*[*s* + *q* + 1] ≠ *P*[*q* + 1] |'
  id: totrans-432
  prefs: []
  type: TYPE_TB
  zh: '|   9 | **如果** *q* == *m* 或 *T*[*s* + *q* + 1] ≠ *P*[*q* + 1] |'
- en: '| 10 | *s* = *s* + max {1, ⌈*q*/*k*⌉} |'
  id: totrans-433
  prefs: []
  type: TYPE_TB
  zh: '| 10 | *s* = *s* + max {1, ⌈*q*/*k*⌉} |'
- en: '| 11 | *q* = 0 |'
  id: totrans-434
  prefs: []
  type: TYPE_TB
  zh: '| 11 | *q* = 0 |'
- en: '***32-2     A linear-time suffix-array algorithm***'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: '***32-2     一个线性时间后缀数组算法***'
- en: In this problem, you will develop and analyze a linear-time divide-and-conquer
    algorithm to compute the suffix array of a text *T*[1:*n*]. As in [Section 32.5](chapter032.xhtml#Sec_32.5),
    assume that each character in the text is represented by an underlying encoding,
    which is a positive integer.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，您将开发和分析一个线性时间的分治算法来计算文本*T*的后缀数组[1:*n*]。如[第32.5节](chapter032.xhtml#Sec_32.5)中所述，假设文本中的每个字符都由一个基础编码表示，这是一个正整数。
- en: The idea behind the linear-time algorithm is to compute the suffix array for
    the suffixes starting at 2/3 of the positions in the text, recursing as needed,
    use the resulting information to sort the suffixes starting at the remaining 1/3
    of the positions, and then merge the sorted information in linear time to produce
    the full suffix array.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 线性时间算法的思想是计算文本中从2/3位置开始的后缀数组，根据需要递归，使用得到的信息对剩余1/3位置开始的后缀进行排序，然后在线性时间内合并排序后的信息以生成完整的后缀数组。
- en: For *i* = 1, 2, …, *n*, if *i* mod 3 equals 1 or 2, then *i* is a ***sample
    position***, and the suffixes starting at such positions are ***sample suffixes***.
    Positions 3, 6, 9, … are ***nonsample positions***, and the suffixes starting
    at ***nonsample*** positions are ***nonsample suffixes***.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*i* = 1, 2, …, *n*，如果*i* mod 3等于1或2，则*i*是一个***样本位置***，并且从这些位置开始的后缀是***样本后缀***。位置3,
    6, 9, …是***非样本位置***，从***非样本位置***开始的后缀是***非样本后缀***。
- en: 'The algorithm sorts the sample suffixes, sorts the nonsample suffixes (aided
    by the result of sorting the sample suffixes), and merges the sorted sample and
    nonsample suffixes. Using the example text *T* = bippityboppityboo, here is the
    algorithm in detail, listing substeps of each of the above steps:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 该算法对样本后缀进行排序，对非样本后缀进行排序（借助对样本后缀进行排序的结果），并将排序后的样本和非样本后缀合并。使用示例文本*T* = bippityboppityboo，以下是详细算法，列出了上述步骤的每个子步骤：
- en: 1\. The sample suffixes comprise about 2/3 of the suffixes. Sort them by the
    following substeps, which work with a heavily modified version of *T* and may
    require recursion. In part (a) of this problem on page 999, you will show that
    the orders of the suffixes of *T* and the suffixes of the modified version of
    *T* are the same.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 1\. 样本后缀包括大约2/3的后缀。按照以下子步骤对它们进行排序，这些子步骤使用经过大幅修改的*T*版本并可能需要递归。在第999页的本问题的(a)部分中，您将展示*T*的后缀和*T*的修改版本的后缀的顺序是相同的。
- en: A. Construct two texts *P*[1] and *P*[2] made up of “metacharacters” that are
    actually substrings of three consecutive characters from *T*. We delimit each
    such metacharacter with parentheses. Construct
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: A. 构造两个由“元字符”组成的文本*P*[1]和*P*[2]，这些元字符实际上是来自*T*的三个连续字符的子字符串。我们用括号限定每个这样的元字符。构造
- en: '*P*[1] = (*T*[1:3])(*T*[4:6])(*T*[7:9]) ⋯ (*T*[*n*′:*n*′ + 2]),'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*[1] = (*T*[1:3])(*T*[4:6])(*T*[7:9]) ⋯ (*T*[*n*′:*n*′ + 2])，'
- en: where *n*′ is the largest integer congruent to 1, modulo 3, that is less than
    or equal to *n* and *T* is extended beyond position *n* with the special character
    Ø, with encoding 0\. With the example text *T* = bippityboppityboo, we get that
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*n*′是与1模3同余且小于等于*n*的最大整数，*T*在位置*n*之后用特殊字符Ø扩展，编码为0。对于示例文本*T* = bippityboppityboo，我们得到
- en: '*P*[1] = (bip) (pit) (ybo) (ppi) (tyb) (ooØ).'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*[1] = (bip) (pit) (ybo) (ppi) (tyb) (ooØ)。'
- en: Similarly, construct
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 同样地，构造
- en: '*P*[2] = (*T*[2:4])(*T*[5:7])(*T*[8:10]) ⋯ (*T*[*n*″:*n*″ + 2]),'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*[2] = (*T*[2:4])(*T*[5:7])(*T*[8:10]) ⋯ (*T*[*n*″:*n*″ + 2])，'
- en: where *n*″ is the largest integer congruent to 2, modulo 3, that is less than
    or equal to *n*. For our example, we have
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*n*″是与2模3同余且小于等于*n*的最大整数。对于我们的示例，我们有
- en: '*P*[2] = (ipp) (ity) (bop) (pit) (ybo) (oØØ).'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*[2] = (ipp) (ity) (bop) (pit) (ybo) (oØØ)。'
- en: '![art](images/Art_P1323.jpg)'
  id: totrans-449
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1323.jpg)'
- en: '**Figure 32.15** Computed values when sorting the sample suffixes of the linear-time
    suffix-array algorithm for the text *T* = bippityboppityboo.'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: '**图32.15** 在文本*T* = bippityboppityboo的线性时间后缀数组算法中对样本后缀进行排序时计算的值。'
- en: If *n* is a multiple of 3, append the metacharacter (ØØØ) to the end of *P*[1].
    In this way, *P*[1] is guaranteed to end with a metacharacter containing Ø. (This
    property helps in part (a) of this problem.) The text *P*[2] may or may not end
    with a metacharacter containing Ø.
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *n* 是 3 的倍数，则将元字符 (ØØØ) 附加到 *P*[1] 的末尾。这样，*P*[1] ���证以包含 Ø 的元字符结尾。（这个特性有助于解决这个问题的第一部分。）文本
    *P*[2] 可能以包含 Ø 的元字符结尾，也可能不是。
- en: B. Concatenate *P*[1] and *P*[2] to form a new text *P*. [Figure 32.15](chapter032.xhtml#Fig_32-15)
    shows *P* for our example, along with the corresponding positions of *T*.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 将 *P*[1] 和 *P*[2] 连接起来形成一个新的文本 *P*。[图 32.15](chapter032.xhtml#Fig_32-15) 展示了我们示例中的
    *P*，以及与 *T* 相应的位置。
- en: 'C. Sort and rank the unique metacharacters of *P*, with ranks starting from
    1\. In the example, *P* has 10 unique metacharacters: in sorted order, they are
    (bip), (bop), (ipp), (ity), (oØØ), (ooØ), (pit), (ppi), (tyb), (ybo). The metacharacters
    (pit) and (ybo) each appear twice.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 对 *P* 的唯一元字符进行排序和排名，排名从 1 开始。在示例中，*P* 有 10 个唯一元字符：按排序顺序分别为 (bip), (bop), (ipp),
    (ity), (oØØ), (ooØ), (pit), (ppi), (tyb), (ybo)。元字符 (pit) 和 (ybo) 每个出现两次。
- en: D. As [Figure 32.15](chapter032.xhtml#Fig_32-15) shows, construct a new “text”
    *P*′ by renaming each metacharacter in *P* by its rank. If *P* contains *k* unique
    metacharacters, then each “character” in *P*′ is an integer from 1 to *k*. The
    suffix arrays for *P* and *P*′ are identical.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [图 32.15](chapter032.xhtml#Fig_32-15) 所示，通过将 *P* 中的每个元字符重命名为其等级构造一个新的“文本”
    *P*′。如果 *P* 包含 *k* 个唯一元字符，则 *P*′ 中的每个“字符”是从 1 到 *k* 的整数。*P* 和 *P*′ 的后缀数组是相同的。
- en: E. Compute the suffix array *SA*[*P*′] of *P*′. If the characters of *P*′ (i.e.,
    the ranks of metacharacters in *P*) are unique, then you can compute its suffix
    array directly, since the ordering of the individual characters gives the suffix
    array. Otherwise, recurse to compute the suffix array of *P*′, treating the ranks
    in *P*′ as the input characters in the recursive call. [Figure 32.15](chapter032.xhtml#Fig_32-15)
    shows the suffix array *SA*[*P*′] for our example. Since the number of metacharacters
    in *P*, and hence the length of *P*′, is approximately 2*n*/3, this recursive
    subproblem is smaller than the current problem.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 计算 *P*′ 的后缀数组 *SA*[*P*′]。如果 *P*′ 的字符（即 *P* 中元字符的等级）是唯一的，那么你可以直接计算它的后缀数组，因为单个字符的顺序给出了后缀数组。否则，递归计算
    *P*′ 的后缀数组，将 *P*′ 中的等级视为递归调用中的输入字符。[图 32.15](chapter032.xhtml#Fig_32-15) 展示了我们示例中
    *P*′ 的后缀数组 *SA*[*P*′]。由于 *P* 中元字符的数量，因此 *P*′ 的长度约为 2*n*/3，这个递归子问题比当前问题更小。
- en: F. From *SA*[*P*′] and the positions in *T* corresponding to the sample positions,
    compute the list of positions of the sorted sample suffixes of the original text
    *T*. [Figure 32.15](chapter032.xhtml#Fig_32-15) shows the list of positions in
    *T* of the sorted sample suffixes in our example.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 从 *SA*[*P*′] 和与样本位置对应的 *T* 中的位置，计算原始文本 *T* 的排序样本后缀的位置列表。[图 32.15](chapter032.xhtml#Fig_32-15)
    展示了我们示例中 *T* 中排序样本后缀的位置列表。
- en: 2\. The nonsample suffixes comprise about 1/3 of the suffixes. Using the sorted
    sample suffixes, sort the nonsample suffixes by the following substeps.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 2\. 非样本后缀占大约后缀的 1/3。使用排序后缀样本，按以下子步骤对非样本后缀进行排序。
- en: '![art](images/Art_P1324.jpg)'
  id: totrans-458
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1324.jpg)'
- en: '**Figure 32.16** The ranks *r*[1] through *r*[*n*+3] for the text *T* = bippityboppityboo
    with *n* = 17.'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 32.16** 文本 *T* = bippityboppityboo，*n* = 17 时的等级 *r*[1] 到 *r*[*n*+3]。'
- en: G. Extending the text *T* by the two special characters ØØ, so that *T* now
    has *n* + 2 characters, consider each suffix *T*[*i*:] for *i* = 1, 2, …, *n*
    + 2\. Assign a rank *r*[*i*] to each suffix *T*[*i*:]. For the two special characters
    ØØ, set *r*[*n*+1] = *r*[*n*+2] = 0\. For the sample positions of *T*, base the
    rank on the list of sorted sample positions of *T*. The rank is currently undefined
    for the nonsample positions of *T*. For these positions, set *r*[*i*] = ☐. [Figure
    32.16](chapter032.xhtml#Fig_32-16) shows the ranks for *T* = bippityboppityboo
    with *n* = 17.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: '将文本 *T* 扩展为两个特殊字符 ØØ，使得 *T* 现在有 *n* + 2 个字符，考虑每个后缀 *T*[*i*: ]，其中 *i* = 1, 2,
    …, *n* + 2。为每个后缀 *T*[*i*: ] 分配一个等级 *r*[*i*]。对于两个特殊字符 ØØ，设置 *r*[*n*+1] = *r*[*n*+2]
    = 0。对于 *T* 的样本位置，基于 *T* 的排序样本位置列表确定等级。对于 *T* 的非样本位置，等级目前未定义。对于这些位置，设置 *r*[*i*]
    = ☐。[图 32.16](chapter032.xhtml#Fig_32-16) 展示了 *T* = bippityboppityboo，*n* = 17
    时的等级。'
- en: H. Sort the nonsample suffixes by comparing tuples (*T*[*i*], *r*[*i*+1]). In
    our example, we get *T*[15:] < *T*[12:] < *T*[9:] < *T*[3:] < *T*[6:] because
    (b, 6) < (i, 10) < (o, 9) < (p, 8) < (t, 12).
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 按照元组 (*T*[*i*], *r*[*i*+1]) 比较非样本后缀。在我们的示例中，我们得到 *T*[15:] < *T*[12:] < *T*[9:]
    < *T*[3:] < *T*[6:]，因为 (b, 6) < (i, 10) < (o, 9) < (p, 8) < (t, 12)。
- en: 3\. Merge the sorted sets of suffixes. From the sorted set of suffixes, determine
    the suffix array of *T*.
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 3\. 合并排序后缀集。从排序后缀集中确定 *T* 的后缀数组。
- en: This completes the description of a linear-time algorithm for computing suffix
    arrays. The following parts of this problem ask you to show that certain steps
    of this algorithm are correct and to analyze the algorithm’s running time.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 这完成了计算后缀数组的线性时间算法的描述。这个问题的后续部分要求你展示该算法的某些步骤是正确的，并分析算法的运行时间。
- en: '***a.*** Define a ***nonempty suffix*** at position *i* of the text *P* created
    in substep B as all metacharacters from position *i* of *P* up to and including
    the first metacharacter of *P* in which Ø appears or the end of *P*. In the example
    shown in [Figure 32.15](chapter032.xhtml#Fig_32-15), the nonempty suffixes of
    *P* starting at positions 1, 4, and 11 of *P* are (bip) (pit) (ybo) (ppi) (tyb)
    (ooØ), (ppi) (tyb) (ooØ), and (ybo) (oØØ), respectively. Prove that the order
    of suffixes of *P* is the same as the order of its nonempty suffixes. Conclude
    that the order of suffixes of *P* gives the order of the sample suffixes of *T*.
    (*Hint:* If *P* contains duplicate metacharacters, consider separately the cases
    in which two suffixes both start in *P*[1], both start in *P*[2], and one starts
    in *P*[1] and the other starts in *P*[2]. Use the property that Ø appears in the
    last metacharacter of *P*[1].)'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 将子步骤 B 中文本 *P* 的位置 *i* 处的 ***非空后缀*** 定义为从 *P* 的位置 *i* 开始到包括 *P* 中第一个出现
    Ø 的元字符或 *P* 结尾的所有元字符。在 [图 32.15](chapter032.xhtml#Fig_32-15) 中显示的示例中，从 *P* 的位置
    1、4 和 11 开始的 *P* 的非空后缀分别为 (bip) (pit) (ybo) (ppi) (tyb) (ooØ)、(ppi) (tyb) (ooØ)
    和 (ybo) (oØØ)。证明 *P* 的后缀顺序与其非空后缀的顺序相同。得出 *P* 的后缀顺序给出 *T* 的样本后缀的顺序。(*提示:* 如果 *P*
    包含重复的元字符，分别考虑两个后缀都从 *P*[1] 开始、两个后缀都从 *P*[2] 开始以及一个从 *P*[1] 开始另一个从 *P*[2] 开始��情况。使用
    Ø 出现在 *P*[1] 的最后一个元字符的属性。)'
- en: '***b.*** Show how to perform substep C in Θ(*n*) time, bearing in mind that
    in a recursive call, the characters in *T* are actually ranks in *P*′ in the caller.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 展示如何在 Θ(*n*) 时间内执行子步骤 C，要记住在递归调用中，*T* 中的字符实际上是调用者中 *P*′ 中的等级。'
- en: '***c.*** Argue that the tuples in substep H are unique. Then show how to perform
    this substep in Θ(*n*) time.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 论证子步骤 H 中的元组是唯一的。然后展示如何在 Θ(*n*) 时间内执行此子步骤。'
- en: '***d.*** Consider two suffixes *T*[*i*:] and *T*[*j*:], where *T*[*i*:] is
    a sample suffix and *T*[*j*:] is a nonsample suffix. Show how to determine in
    Θ(1) time whether *T*[*i*:] is lexicographically smaller than *T*[*j*:]. (*Hint:*
    Consider separately the cases in which *i* mod 3 = 1 and *i* mod 3 = 2\. Compare
    tuples whose elements are characters in *T* and ranks as shown in [Figure 32.16](chapter032.xhtml#Fig_32-16).
    The number of elements per tuple may depend on whether *i* mod 3 equals 1 or 2.)
    Conclude that step 3 can be performed in Θ(*n*) time.'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 考虑两个后缀 *T*[*i*: ] 和 *T*[*j*: ]，其中 *T*[*i*: ] 是一个样本后缀，*T*[*j*: ] 是一个非样本后缀。展示如何在
    Θ(1) 时间内确定 *T*[*i*: ] 是否在字典顺序上小于 *T*[*j*: ]。(*提示:* 分别考虑 *i* mod 3 = 1 和 *i* mod
    3 = 2 的情况。比较元组，元组的元素是 *T* 中的字符和 *P* 中显示的等级，如 [图 32.16](chapter032.xhtml#Fig_32-16)
    所示。元组中的元素数量可能取决于 *i* mod 3 是否等于 1 或 2。) 得出步骤 3 可以在 Θ(*n*) 时间内完成。'
- en: '***e.*** Justify the recurrence *T*(*n*) ≤ *T* (2*n*/3 + 2) + Θ(*n*) for the
    running time of the full algorithm, and show that its solution is *O*(*n*). Conclude
    that the algorithm runs in Θ(*n*) time.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** 证明全算法运行时间的递归 *T*(*n*) ≤ *T* (2*n*/3 + 2) + Θ(*n*) 的合理性，并展示其解为 *O*(*n*)。得出算法运行时间为
    Θ(*n*)。'
- en: '***32-3     Burrows-Wheeler transform***'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: '***32-3     Burrows-Wheeler 变换***'
- en: The ***Burrows-Wheeler transform***, or ***BWT***, for a text *T* is defined
    as follows. First, append a new character that compares as lexicographically less
    than every character of *T*, and denote this character by $ and the resulting
    string by *T*′. Letting *n* be the length of *T*′, create *n* rows of characters,
    where each row is one of the *n* cyclic rotations of *T*′. Next, sort the rows
    lexicographically. The BWT is then the string of *n* characters in the rightmost
    column, read top to bottom.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '***Burrows-Wheeler 变换***，或 ***BWT***，对于文本 *T* 的定义如下。首先，附加一个新字符，该字符在字典顺序上小于
    *T* 的每个字符，并将此字符表示为 $，将结果字符串表示为 *T*′。令 *n* 为 *T*′ 的长度，创建 *n* 行字符，其中每行是 *T*′ 的 *n*
    个循环旋转之一。接下来，按字典顺序对行进行排序。然后，BWT 是右侧列中的 *n* 个字符，从上到下读取。'
- en: For example, let *T* = rutabaga, so that *T*′ = rutabaga$. The cyclic rotations
    are
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，让 *T* = rutabaga，这样 *T*′ = rutabaga$。循环旋转是
- en: rutabaga$
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: rutabaga$
- en: utabaga$r
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: utabaga$r
- en: tabaga$ru
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: tabaga$ru
- en: abaga$rut
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: abaga$rut
- en: baga$ruta
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: baga$ruta
- en: aga$rutab
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: aga$rutab
- en: ga$rutaba
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: ga$rutaba
- en: a$rutabag
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: a$rutabag
- en: $rutabaga
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: $rutabaga
- en: Sorting the rows and numbering the sorted rows gives
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 对行进行排序并对排序后的行进行编号得到
- en: '| 1 | $rutabaga |'
  id: totrans-482
  prefs: []
  type: TYPE_TB
  zh: '| 1 | $rutabaga |'
- en: '| 2 | a$rutabag |'
  id: totrans-483
  prefs: []
  type: TYPE_TB
  zh: '| 2 | a$rutabag |'
- en: '| 3 | abaga$rut |'
  id: totrans-484
  prefs: []
  type: TYPE_TB
  zh: '| 3 | abaga$rut |'
- en: '| 4 | aga$rutab |'
  id: totrans-485
  prefs: []
  type: TYPE_TB
  zh: '| 4 | aga$rutab |'
- en: '| 5 | baga$ruta |'
  id: totrans-486
  prefs: []
  type: TYPE_TB
  zh: '| 5 | baga$ruta |'
- en: '| 6 | ga$rutaba |'
  id: totrans-487
  prefs: []
  type: TYPE_TB
  zh: '| 6 | ga$rutaba |'
- en: '| 7 | rutabaga$ |'
  id: totrans-488
  prefs: []
  type: TYPE_TB
  zh: '| 7 | rutabaga$ |'
- en: '| 8 | tabaga$ru |'
  id: totrans-489
  prefs: []
  type: TYPE_TB
  zh: '| 8 | tabaga$ru |'
- en: '| 9 | utabaga$r |'
  id: totrans-490
  prefs: []
  type: TYPE_TB
  zh: '| 9 | utabaga$r |'
- en: The BWT is the rightmost column, agtbaa$ur. (The row numbering will be helpful
    in understanding how to compute the inverse BWT.)
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: BWT 是右侧列，agtbaa$ur。（行号对于理解如何计算逆 BWT 很有帮助。）
- en: The BWT has applications in bioinformatics, and it can also be a step in text
    compression. That is because it tends to place identical characters together,
    as in the BWT of rutabaga, which places two of the instances of a together. When
    identical characters are placed together, or even nearby, additional means of
    compressing become available. Following the BWT, combinations of move-to-front
    encoding, run-length encoding, and Huffman coding (see [Section 15.3](chapter015.xhtml#Sec_15.3))
    can provide significant text compression. Compression ratios with the BWT tend
    improve as the text length increases.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: BWT 在生物信息学中有应用，并且也可以是文本压缩中的一步。这是因为它倾向于将相同的字符放在一起，就像 rutabaga 的 BWT 将两个 a 的实例放在一起。当相同的字符放在一起，甚至附近时，就会有额外的压缩手段可用。在
    BWT 之后，结合移至前编码、游程编码和霍夫曼编码（参见 [第 15.3 节](chapter015.xhtml#Sec_15.3)）可以提供显著的文本压缩。随着文本长度的增加，使用
    BWT 的压缩比 tend to improve。
- en: '***a.*** Given the suffix array for *T*′, show how to compute the BWT in Θ(*n*)
    time.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 给定 *T*′ 的后缀数组，展示如何在 Θ(*n*) 时间内计算 BWT。'
- en: 'In order to decompress, the BWT must be invertible. Assuming that the alphabet
    size is constant, the inverse BWT can be computed in Θ(*n*) time from the BWT.
    Let’s look at the BWT of rutabaga, denoting it by *BWT*[1:*n*]. Each character
    in the BWT has a unique lexicographic rank from 1 to *n*. Denote the rank of *BWT*[*i*]
    by *rank*[*i*]. If a character appears multiple times in the BWT, each instance
    of the character has a rank 1 greater than the previous instance of the character.
    Here are *BWT* and *rank* for rutabaga:'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解压，BWT必须是可逆的。假设字母表大小是恒定的，逆BWT可以从BWT中在Θ(*n*)时间内计算出来。让我们看看芜菁的BWT，用*BWT*[1:*n*]表示。BWT中的每个字符都有从1到*n*的唯一词典序排名。用*BWT*[*i*]的排名表示为*rank*[*i*]。如果一个字符在BWT中出现多次，那么该字符的每个实例的排名比前一个实例的排名高1。以下是芜菁的*BWT*和*rank*：
- en: '![art](images/Art_P1324a.jpg)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1324a.jpg)'
- en: 'For example, *rank*[1] = 2 because *BWT*[1] = a and the only character that
    precedes the first a lexicographically is $ (which we defined to precede all other
    characters, so that $ has rank 1). Next, we have *rank*[2] = 6 because *BWT*[2]
    = g and five characters in the BWT precede g lexicographically: $, the three instances
    of a, and b. Jumping ahead to *rank*[5] = 3, that is because *BWT*[5] = a, and
    because this a is the second instance of a in the BWT, its *rank* value is 1 greater
    than the *rank* value for the previous instance of a, in position 1.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，*rank*[1] = 2，因为*BWT*[1] = a，而按词典顺序排在第一个a之前的唯一字符是$（我们定义$在所有其他字符之前，因此$的排名为1）。接下来，我们有*rank*[2]
    = 6，因为*BWT*[2] = g，而在BWT中按词典顺序排在g之前的五个字符是$、三个a的实例和b。跳到*rank*[5] = 3，那是因为*BWT*[5]
    = a，而因为这个a是BWT中的第二个a实例，它的*rank*值比前一个a实例的*rank*值高1，位于位置1。
- en: There is enough information in *BWT* and *rank* to reconstruct *T*′ from back
    to front. Suppose that you know the rank *r* of a character *c* in *T*′. Then
    *c* is the first character in row *r* of the sorted cyclic rotations. The last
    character in row *r* must be the character that precedes *c* in *T*′. But you
    know which character is the last character in row *r*, because it is *BWT*[*r*].
    To reconstruct *T*′ from back to front, start with $, which you can find in *BWT*.
    Then work backward using *BWT* and *rank* to reconstruct *T*′.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: '*BWT*和*rank*中有足够的信息来从后往前重建*T*′。假设你知道*T*′中字符*c*的排名*r*。那么*c*是排序循环旋转的第*r*行的第一个字符。第*r*行的最后一个字符必须是在*T*′中*c*之前的字符。但你知道第*r*行的最后一个字符是哪个字符，因为它是*BWT*[*r*]。要从后往前重建*T*′，从$开始，你可以在*BWT*中找到它。然后使用*BWT*和*rank*向后工作以重建*T*′。'
- en: 'Let’s see how this strategy works for rutabaga. The last character of *T*′,
    $, appears in position 7 of *BWT*. Since *rank*[7] = 1, row 1 of the sorted cyclic
    rotations of *T*′ begins with $. The character that precedes $ in *T*′ is the
    last character in row 1, which is *BWT*[1]: a. Now we know that the last two characters
    of *T*′ are a$. Looking up *rank*[1], it equals 2, so that row 2 of the sorted
    cyclic rotations of *T*′ begins with a. The last character in row 2 precedes a
    in *T*′, and that character is *BWT*[2] = g. Now we know that the last three characters
    of *T*′ are ga$. Continuing on, we have *rank*[2] = 6, so that row 6 of the sorted
    cyclic rotations begins with g. The character preceding g in *T*′ is *BWT*[6]
    = a, and so the last four characters of *T*′ are aga$. Because *rank*[6] = 4,
    a begins row 4 of the sorted cyclic rotations of *T*′. The character preceding
    a in *T*′ is the last character in row 4, *BWT*[4] = b, and the last five characters
    of *T*′ are baga$. And so on, until all *n* characters of *T*′ have been identified,
    from back to front.'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个策略如何适用于芜菁。*T*′的最后一个字符$出现在*BWT*的第7个位置。由于*rank*[7] = 1，*T*′的排序循环旋转的第1行以$开头。在*T*′中紧随$之前的字符是第1行的最后一个字符，即*BWT*[1]：a。现在我们知道*T*′的最后两个字符是a$。查找*rank*[1]，它等于2，因此*T*′的排序循环旋转的第2行以a开头。第2行的最后一个字符在*T*′中位于a之前，该字符是*BWT*[2]
    = g。现在我们知道*T*′的最后三个字符是ga$。继续下去，我们有*rank*[2] = 6，因此*T*′的排序循环旋转的第6行以g开头。在*T*′中位于g之前的字符是*BWT*[6]
    = a，因此*T*′的最后四个字符是aga$。因为*rank*[6] = 4，a开始*T*′的排序循环旋转的第4行。在*T*′中位于a之前的字符是第4行的最后一个字符，*BWT*[4]
    = b，因此*T*′的最后五个字符是baga$。依此类推，直到*T*′的所有n个字符从后往前被识别出来。
- en: '***b.*** Given the array *BWT*[1:*n*], write pseudcode to compute the array
    *rank*[1:*n*] in Θ(*n*) time, assuming that the alphabet size is constant.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 给定数组*BWT*[1:*n*]，写出伪代码以在Θ(*n*)时间内计算数组*rank*[1:*n*]，假设字母表大小是恒定的。'
- en: '***c.*** Given the arrays *BWT*[1:*n*] and *rank*[1:*n*], write pseudocode
    to compute *T*′ in Θ(*n*) time.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 给定数组*BWT*[1:*n*]和*rank*[1:*n*]，���出伪代码以在Θ(*n*)时间内计算*T*′。'
- en: '**Chapter notes**'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节注释**'
- en: The relation of string matching to the theory of finite automata is discussed
    by Aho, Hopcroft, and Ullman [[5](bibliography001.xhtml#endnote_5)]. The Knuth-Morris-Pratt
    algorithm [[267](bibliography001.xhtml#endnote_267)] was invented independently
    by Knuth and Pratt and by Morris, but they published their work jointly. Matiyasevich
    [[317](bibliography001.xhtml#endnote_317)] earlier discovered a similar algorithm,
    which applied only to an alphabet with two characters and was specified for a
    Turing machine with a two-dimensional tape. Reingold, Urban, and Gries [[377](bibliography001.xhtml#endnote_377)]
    give an alternative treatment of the Knuth-Morris-Pratt algorithm. The Rabin-Karp
    algorithm was proposed by Karp and Rabin [[250](bibliography001.xhtml#endnote_250)].
    Galil and Seiferas [[173](bibliography001.xhtml#endnote_173)] give an interesting
    deterministic linear-time string-matching algorithm that uses only *O*(1) space
    beyond that required to store the pattern and text.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 与有限自动机理论的字符串匹配关系由Aho、Hopcroft和Ullman[[5](bibliography001.xhtml#endnote_5)]讨论。Knuth-Morris-Pratt算法[[267](bibliography001.xhtml#endnote_267)]由Knuth和Pratt以及Morris独立发明，但他们共同发表了他们的工作。Matiyasevich[[317](bibliography001.xhtml#endnote_317)]早先发现了一种类似的算法，仅适用于具有两个字符的字母表，并且为具有二维带的图灵机指定了该算法。Reingold、Urban和Gries[[377](bibliography001.xhtml#endnote_377)]提供了Knuth-Morris-Pratt算法的另一种处理方式。Rabin-Karp算法由Karp和Rabin[[250](bibliography001.xhtml#endnote_250)]提出。Galil和Seiferas[[173](bibliography001.xhtml#endnote_173)]提供了一种有趣的确定性线性时间字符串匹配算法，除了存储模式和文本所需的空间外，仅使用*O*(1)的空间。
- en: The suffix-array algorithm in [Section 32.5](chapter032.xhtml#Sec_32.5) is by
    Manber and Myers [[312](bibliography001.xhtml#endnote_312)], who first proposed
    the notion of suffix arrays. The linear-time algorithm to compute the longest
    common prefix array presented here is by Kasai et al. [[252](bibliography001.xhtml#endnote_252)].
    Problem 32-2 is based on the DC3 algorithm by Kärkkäinen, Sanders, and Burkhardt
    [[245](bibliography001.xhtml#endnote_245)]. For a survey of suffix-array algorithms,
    see the article by Puglisi, Smyth, and Turpin [[370](bibliography001.xhtml#endnote_370)].
    To learn more about the Burrows-Wheeler transform from Problem 32-3, see the articles
    by Burrows and Wheeler [[78](bibliography001.xhtml#endnote_78)] and Manzini [[314](bibliography001.xhtml#endnote_314)].
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '[¹](#footnote_ref_1) 对于后缀数组，*O*(*n* 1g *n*)的预处理时间来自于[第32.5节](chapter032.xhtml#Sec_32.5)中提出的算法。通过使用问题32-2中的算法，可以将其降低到Θ(*n*)。匹配时间中的因子*k*表示文本中模式出现的次数。'
- en: '[¹](#footnote_ref_1) For suffix arrays, the preprocessing time of *O*(*n* 1g
    *n*) comes from the algorithm presented in [Section 32.5](chapter032.xhtml#Sec_32.5).
    It can be reduced to Θ(*n*) by using the algorithm in Problem 32-2\. The factor
    *k* in the matching time denotes the number of occurrences of the pattern in the
    text.'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '[²](#footnote_ref_2) 我们写成Θ(*n* – *m* + 1)而不是Θ(*n* – *m*)，因为*s*取*n* − *m* +
    1个不同的值。在渐近意义上，“+1”是重要的，因为当*m* = *n*时，计算孤立的*t*[*s*]值需要Θ(1)的时间，而不是Θ(0)的时间。'
- en: '[²](#footnote_ref_2) We write Θ(*n* – *m* + 1) instead of Θ(*n* – *m*) because
    *s* takes on *n* − *m* + 1 different values. The “+1” is significant in an asymptotic
    sense because when *m* = *n*, computing the lone *t*[*s*] value takes Θ(1) time,
    not Θ(0) time.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '[³](#footnote_ref_3) 非正式地，词典顺序是基础字符集中的“字母顺序”。关于词典顺序的更精确定义可参见第327页的问题12-2。'
- en: '[³](#footnote_ref_3) Informally, lexicographic order is “alphabetical order”
    in the underlying character set. A more precise definition of lexicographic order
    appears in Problem 12-2 on page 327.'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '[⁴](#footnote_ref_4) 中的后缀数组算法由Manber和Myers[[312](bibliography001.xhtml#endnote_312)]提出，他们首次提出了后缀数组的概念。本文介绍的线性时间算法计算最长公共前缀数组的方法由Kasai等人[[252](bibliography001.xhtml#endnote_252)]提出。问题32-2基于Kärkkäinen、Sanders和Burkhardt的DC3算法[[245](bibliography001.xhtml#endnote_245)]。关于后缀数组算法的调查，请参阅Puglisi、Smyth和Turpin的文章[[370](bibliography001.xhtml#endnote_370)]。要了解更多关于Burrows-Wheeler变换的信息，请参阅Burrows和Wheeler的文章[[78](bibliography001.xhtml#endnote_78)]和Manzini的文章[[314](bibliography001.xhtml#endnote_314)]。'
- en: '[⁴](#footnote_ref_4) Why keep saying “length at most”? Because for a given
    value of *l*, a substring of length *l* starting at position *i* is *T*[*i*:*i*
    + *l* – 1]. If *i* + *l* − 1 > *n*, then the substring cuts off at the end of
    the text.'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: '[⁴](#footnote_ref_4) 为什么一直说“长度最多”？因为对于给定的*l*值，从位置*i*开始的长度为*l*的子串是*T*[*i*:*i*
    + *l* – 1]。如果*i* + *l* − 1 > *n*，那么子串将在文本末尾截断。'
