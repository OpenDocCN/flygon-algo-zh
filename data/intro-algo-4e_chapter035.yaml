- en: '[**35        Approximation Algorithms**](toc.xhtml#chap-35)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[**35        近似算法**](toc.xhtml#chap-35)'
- en: Many problems of practical significance are NP-complete, yet they are too important
    to abandon merely because nobody knows how to find an optimal solution in polynomial
    time. Even if a problem is NP-complete, there may be hope. You have at least three
    options to get around NP-completeness. First, if the actual inputs are small,
    an algorithm with exponential running time might be fast enough. Second, you might
    be able to isolate important special cases that you can solve in polynomial time.
    Third, you can try to devise an approach to find a *near-optimal* solution in
    polynomial time (either in the worst case or the expected case). In practice,
    near-optimality is often good enough. We call an algorithm that returns near-optimal
    solutions an ***approximation algorithm***. This chapter presents polynomial-time
    approximation algorithms for several NP-complete problems.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 许多实际意义重大的问题都是NP完全的，但它们太重要了，不能仅仅因为没有人知道如何在多项式时间内找到最优解而放弃。即使一个问题是NP完全的，也可能有希望。你至少有三种方法可以避开NP完全性。首先，如果实际输入很小，具有指数运行时间的算法可能足够快。其次，您可能能够孤立出可以在多项式时间内解决的重要特殊情况。第三，您可以尝试设计一种方法，在多项式时间内找到一个*接近最优*解（无论是在最坏情况下还是在期望情况下）。在实践中，接近最优通常已经足够好了。我们称返回接近最优解的算法为***近似算法***。本章介绍了几个NP完全问题的多项式时间近似算法。
- en: '**Performance ratios for approximation algorithms**'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**近似算法的性能比率**'
- en: Suppose that you are working on an optimization problem in which each potential
    solution has a positive cost, and you want to find a near-optimal solution. Depending
    on the problem, you could define an optimal solution as one with maximum possible
    cost or as one with minimum possible cost, which is to say that the problem might
    be either a maximization or a minimization problem.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您正在解决一个优化问题，其中每个潜在解决方案都有正成本，并且您希望找到一个接近最优解。根据问题的不同，您可以将最优解定义为具有最大可能成本或具有最小可能成本的解，也就是说，问题可能是一个最大化问题或一个最小化问题。
- en: 'We say that an algorithm for a problem has an ***approximation ratio*** of
    *ρ*(*n*) if, for any input of size *n*, the cost *C* of the solution produced
    by the algorithm is within a factor of *ρ*(*n*) of the cost *C** of an optimal
    solution:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 对于问题的算法具有*ρ*(*n*)的***近似比率***，如果对于任何大小为*n*的输入，算法产生的解的成本*C*与最优解的成本*C**之间的比例在*ρ*(*n*)的因子范围内：
- en: '![art](images/Art_P1483.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1483.jpg)'
- en: If an algorithm achieves an approximation ratio of *ρ*(*n*), we call it a ***ρ*(*n*)*-approximation
    algorithm***. The definitions of approximation ratio and *ρ*(*n*)-approximation
    algorithm apply to both minimization and maximization problems. For a maximization
    problem, 0 < *C* ≤ *C**, and the ratio *C**/*C* gives the factor by which the
    cost of an optimal solution is larger than the cost of the approximate solution.
    Similarly, for a minimization problem, 0 < *C** ≤ *C*, and the ratio *C*/*C**
    gives the factor by which the cost of the approximate solution is larger than
    the cost of an optimal solution. Because we assume that all solutions have positive
    cost, these ratios are always well defined. The approximation ratio of an approximation
    algorithm is never less than 1, since *C*/*C** ≤ 1 implies *C**/*C* ≥ 1\. Therefore,
    a 1-approximation algorithm^([1](#footnote_1)) produces an optimal solution, and
    an approximation algorithm with a large approximation ratio may return a solution
    that is much worse than optimal.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比���永远不会小于1，因为*C*/*C**
    ≤ 1意味着*C**/*C* ≥ 1。因此，一个1-近似算法^([1](#footnote_1))会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。
- en: For many problems, we know of polynomial-time approximation algorithms with
    small constant approximation ratios, although for other problems, the best known
    polynomial-time approximation algorithms have approximation ratios that grow as
    functions of the input size *n*. An example of such a problem is the set-cover
    problem presented in [Section 35.3](chapter035.xhtml#Sec_35.3).
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 对于许多问题，我们知道具有小常数近似比率的多项式时间近似算法，尽管对于其他问题，已知的最佳多项式时间近似算法的近似比率会随着输入大小*n*的增长而增加。一个例子是[35.3节](chapter035.xhtml#Sec_35.3)中介绍的集合覆盖问题。
- en: Some polynomial-time approximation algorithms can achieve increasingly better
    approximation ratios by using more and more computation time. For such problems,
    you can trade computation time for the quality of the approximation. An example
    is the subset-sum problem studied in [Section 35.5](chapter035.xhtml#Sec_35.5).
    This situation is important enough to deserve a name of its own.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一些多项式时间近似算法可以通过使用越来越多的计算时间来实现越来越好的近似比率。对于这样的问题，您可以通过计算时间来交换近似的质量。一个例子是[35.5节](chapter035.xhtml#Sec_35.5)中研究的子集和问题。这种情况足够重要，值得有一个专门的名称。
- en: An ***approximation scheme*** for an optimization problem is an approximation
    algorithm that takes as input not only an instance of the problem, but also a
    value *ϵ* > 0 such that for any fixed *ϵ*, the scheme is a (1 + *ϵ*)-approximation
    algorithm. We say that an approximation scheme is a ***polynomial-time approximation
    scheme*** if for any fixed *ϵ* > 0, the scheme runs in time polynomial in the
    size *n* of its input instance.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 优化问题的一个***近似方案***是一个近似算法，它不仅接受问题的一个实例作为输入，还接受一个*ϵ* > 0的值，使得对于任何固定的*ϵ*，该方案都是一个(1
    + *ϵ*)-近似算法。我们称一个近似方案为***多项式时间近似方案***，如果对于任何固定的*ϵ* > 0，该方案在其输入实例的大小*n*的多项式时间内运行。
- en: The running time of a polynomial-time approximation scheme can increase very
    rapidly as *ϵ* decreases. For example, the running time of a polynomial-time approximation
    scheme might be *O*(*n*^(2/*ϵ*)). Ideally, if *ϵ* decreases by a constant factor,
    the running time to achieve the desired approximation should not increase by more
    than a constant factor (though not necessarily the same constant factor by which
    *ϵ* decreased).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当*ϵ*减小时，多项式时间逼近方案的运行时间可能会急剧增加。例如，多项式时间逼近方案的运行时间可能为*O*(*n*^(2/*ϵ*))。理想情况下，如果*ϵ*按照一个常数因子减小，为了达到所需的逼近，运行时间不应该增加超过一个常数因子（尽管不一定是*ϵ*减小的同一个常数因子）。
- en: We say that an approximation scheme is a ***fully polynomial-time approximation
    scheme*** if it is an approximation scheme and its running time is polynomial
    in both 1/*ϵ* and the size *n* of the input instance. For example, the scheme
    might have a running time of *O*((1/*ϵ*)²*n*³). With such a scheme, any constant-factor
    decrease in *ϵ* comes with a corresponding constant-factor increase in the running
    time.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个逼近方案是一个***完全多项式时间逼近方案***，那么它是一个逼近方案，并且其运行时间在1/*ϵ*和输入实例大小*n*中都是多项式的。例如，该方案的运行时间可能为*O*((1/*ϵ*)²*n*³)。有了这样的方案，*ϵ*的任何常数因子减少都会伴随着运行时间的相应常数因子增加。
- en: '**Chapter outline**'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节大纲**'
- en: The first four sections of this chapter present some examples of polynomial-time
    approximation algorithms for NP-complete problems, and the fifth section gives
    a fully polynomial-time approximation scheme. We begin in [Section 35.1](chapter035.xhtml#Sec_35.1)
    with a study of the vertex-cover problem, an NP-complete minimization problem
    that has an approximation algorithm with an approximation ratio of 2\. [Section
    35.2](chapter035.xhtml#Sec_35.2) looks at a version of the traveling-salesperson
    problem in which the cost function satisfies the triangle inequality and presents
    an approximation algorithm with an approximation ratio of 2\. The section also
    shows that without the triangle inequality, for any constant *ρ* ≥ 1, a *ρ*-approximation
    algorithm cannot exist unless P = NP. [Section 35.3](chapter035.xhtml#Sec_35.3)
    applies a greedy method as an effective approximation algorithm for the set-covering
    problem, obtaining a covering whose cost is at worst a logarithmic factor larger
    than the optimal cost. [Section 35.4](chapter035.xhtml#Sec_35.4) uses randomization
    and linear programming to develop two more approximation algorithms. The section
    first defines the optimization version of 3-CNF satisfiability and gives a simple
    randomized algorithm that produces a solution with an expected approximation ratio
    of 8/7\. Then [Section 35.4](chapter035.xhtml#Sec_35.4) examines a weighted variant
    of the vertex-cover problem and exhibits how to use linear programming to develop
    a 2-approximation algorithm. Finally, [Section 35.5](chapter035.xhtml#Sec_35.5)
    presents a fully polynomial-time approximation scheme for the subset-sum problem.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前四节介绍了一些NP完全问题的多项式时间逼近算法的示例，第五节提供了一个完全多项式时间逼近方案。我们从[35.1节](chapter035.xhtml#Sec_35.1)开始研究顶点覆盖问题，这是一个NP完全的最小化问题，具有逼近比为2的逼近算法。[35.2节](chapter035.xhtml#Sec_35.2)讨论了旅行推销员问题的一个版本，其中成本函数满足三角不等式，并提供了一个逼近比为2的逼近算法。该节还表明，如果没有三角不等式，对于任意常数*ρ*
    ≥ 1，除非P = NP，否则不存在*ρ*逼近算法。[35.3节](chapter035.xhtml#Sec_35.3)将贪婪方法应用为集盖问题的有效逼近算法，得到的覆盖成本最多比最优成本大一个对数因子。[35.4节](chapter035.xhtml#Sec_35.4)使用随机化和线性规划开发了另外两个逼近算法。该节首先定义了3-CNF可满足性的优化版本，并给出了一个简单的随机算法，产生一个期望逼近比为8/7的解。然后[35.4节](chapter035.xhtml#Sec_35.4)研究了顶点覆盖问题的加权变体，并展示如何使用线性规划开发一个2逼近算法。最后，[35.5节](chapter035.xhtml#Sec_35.5)提出了子集和问题的完全多项式时间逼近方案。
- en: '[**35.1    The vertex-cover problem**](toc.xhtml#Rh1-206)'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '[**35.1    顶点覆盖问题**](toc.xhtml#Rh1-206)'
- en: '[Section 34.5.2](chapter034.xhtml#Sec_34.5.2) defined the vertex-cover problem
    and proved it NP-complete. Recall that a ***vertex cover*** of an undirected graph
    *G* = (*V*, *E*) is a subset *V*′ ⊆ *V* such that if (*u*, *v*) is an edge of
    *G*, then either *u* ∈ *V*′ or *v* ∈ *V*′ (or both). The size of a vertex cover
    is the number of vertices in it.'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '[34.5.2节](chapter034.xhtml#Sec_34.5.2)定义了顶点覆盖问题并证明了其NP完全性。回想一下，对于无向图*G* = (*V*,
    *E*)，***顶点覆盖***是指一个子集*V*′ ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。'
- en: The ***vertex-cover problem*** is to find a vertex cover of minimum size in
    a given undirected graph. We call such a vertex cover an ***optimal vertex cover***.
    This problem is the optimization version of an NP-complete decision problem.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '***顶点覆盖问题***是在给定的无向图中找到最小大��的顶点覆盖。我们称这样的顶点覆盖为***最优顶点覆盖***。这个问题是NP完全决策问题的优化版本。'
- en: Even though nobody knows how to find an optimal vertex cover in a graph *G*
    in polynomial time, there is an efficient algorithm to find a vertex cover that
    is near-optimal. The approximation algorithm APPROX-VERTEX-COVER on the facing
    page takes as input an undirected graph *G* and returns a vertex cover whose size
    is guaranteed to be no more than twice the size of an optimal vertex cover.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管没有人知道如何在多项式时间内找到图*G*中的最优顶点覆盖，但有一种有效的算法可以找到一个接近最优的顶点覆盖。面对页面上的逼近算法APPROX-VERTEX-COVER以无向图*G*作为输入，并返回一个顶点覆盖，其大小保证不超过最优顶点覆盖大小的两倍。
- en: '[Figure 35.1](chapter035.xhtml#Fig_35-1) illustrates how APPROX-VERTEX-COVER
    operates on an example graph. The variable *C* contains the vertex cover being
    constructed. Line 1 initializes *C* to the empty set. Line 2 sets *E*′ to be a
    copy of the edge set *G.E* of the graph. The **while** loop of lines 3–6 repeatedly
    picks an edge (*u*, *v*) from *E*′, adds its endpoints *u* and *v* into *C*, and
    deletes all edges in *E*′ that *u* or *v* covers. Finally, line 7 returns the
    vertex cover *C*. The running time of this algorithm is *O*(*V* + *E*), using
    adjacency lists to represent *E*′.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 35.1](chapter035.xhtml#Fig_35-1) 说明了 APPROX-VERTEX-COVER 在一个示例图上的操作。变量 *C*
    包含正在构建的顶点覆盖。第 1 行将 *C* 初始化为空集。第 2 行将 *E*′ 设置为图的边集 *G.E* 的副本。第 3-6 行的 **while**
    循环重复地从 *E*′ 中选择一条边（*u*, *v*），将其端点 *u* 和 *v* 加入 *C*，并删除 *E*′ 中 *u* 或 *v* 覆盖的所有边。最后，第
    7 行返回顶点覆盖 *C*。该算法的运行时间为 *O*(*V* + *E*)，使用邻接表来表示 *E*′。'
- en: APPROX-VERTEX-COVER (*G*)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: APPROX-VERTEX-COVER (*G*)
- en: '| 1 | *C* = Ø |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *C* = Ø |'
- en: '| 2 | *E*′ = *G.E* |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *E*′ = *G.E* |'
- en: '| 3 | **while** *E*′ ≠ Ø |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **当** *E*′ ≠ Ø **时** |'
- en: '| 4 | let (*u*, *v*) be an arbitrary edge of *E*′ |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 令 (*u*, *v*) 为 *E*′ 的任意边 |'
- en: '| 5 | *C* = *C* ∪ {*u, v*} |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 5 | *C* = *C* ∪ {*u, v*} |'
- en: '| 6 | remove from *E*′ edge (*u*, *v*) and every edge incident on either *u*
    or *v* |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 从 *E*′ 中移除边（*u*, *v*）以及任何与 *u* 或 *v* 相关的边'
- en: '| 7 | **return** *C* |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 7 | **返回** *C* |'
- en: '***Theorem 35.1***'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 35.1***'
- en: APPROX-VERTEX-COVER is a polynomial-time 2-approximation algorithm.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: APPROX-VERTEX-COVER 是一个多项式时间的 2-近似算法。
- en: '***Proof***   We have already shown that APPROX-VERTEX-COVER runs in polynomial
    time.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   我们已经证明了 APPROX-VERTEX-COVER 在多项式时间内运行。'
- en: The set *C* of vertices that is returned by APPROX-VERTEX-COVER is a vertex
    cover, since the algorithm loops until every edge in *G.E* has been covered by
    some vertex in *C*.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 由 APPROX-VERTEX-COVER 返回的顶点集 *C* 是一个顶点覆盖，因为该算法循环直到图 *G.E* 中的每条边都被 *C* 中的某个顶点覆盖。
- en: To see that APPROX-VERTEX-COVER returns a vertex cover that is at most twice
    the size of an optimal cover, let *A* denote the set of edges that line 4 of APPROX-VERTEX-COVER
    picked. In order to cover the edges in *A*, any vertex cover—in particular, an
    optimal cover *C**—must include at least one endpoint of each edge in *A*. No
    two edges in *A* share an endpoint, since once an edge is picked in line 4, all
    other edges that are incident on its endpoints are deleted from *E*′ in line 6\.
    Thus, no two edges in *A* are covered by the same vertex from *C**, meaning that
    for every vertex in *C**, there is at most one edge in *A*, giving the lower bound
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到 APPROX-VERTEX-COVER 返回的顶点覆盖最多是最优覆盖大小的两倍，让 *A* 表示 APPROX-VERTEX-COVER 的第
    4 行选择的边集。为了覆盖 *A* 中的边，任何顶点覆盖——特别是最优覆盖 *C*——必须至少包括 *A* 中每条边的一个端点。*A* 中没有两条边共享一个端点，因为一旦在第
    4 行选择了一条边，所有其他与其端点相邻的边都在第 6 行从 *E*′ 中删除。因此，*A* 中没有两条边被 *C* 中的同一个顶点覆盖，这意味着对于 *C*
    中的每个顶点，*A* 中最多有一条边，给出了下界
- en: '![art](images/Art_P1484.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1484.jpg)'
- en: 'on the size of an optimal vertex cover. Each execution of line 4 picks an edge
    for which neither of its endpoints is already in *C*, yielding an upper bound
    (an exact upper bound, in fact) on the size of the vertex cover returned:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最优顶点覆盖的大小有一个上界。第 4 行的每次执行都选择一条边，该边的端点都不在 *C* 中，从而得到一个上界（实际上是一个精确的上界）来返回顶点覆盖的大小：
- en: '![art](images/Art_P1485.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1485.jpg)'
- en: Combining equations (35.2) and (35.3) yields
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 结合方程（35.2）和（35.3）得到
- en: '| &#124;*C*&#124; | = | 2 &#124;*A*&#124; |'
  id: totrans-36
  prefs: []
  type: TYPE_TB
  zh: '| &#124;*C*&#124; | = | 2 &#124;*A*&#124; |'
- en: '|  | ≤ | 2 &#124;*C**&#124;, |'
  id: totrans-37
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | 2 &#124;*C**&#124;, |'
- en: thereby proving the theorem.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 从而证明了定理。
- en: ▪
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '![art](images/Art_P1486.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1486.jpg)'
- en: '**Figure 35.1** The operation of APPROX-VERTEX-COVER. **(a)** The input graph
    *G*, which has 7 vertices and 8 edges. **(b)** The highlighted edge (*b*, *c*)
    is the first edge chosen by APPROX-VERTEX-COVER. Vertices *b* and *c*, in blue,
    are added to the set *C* containing the vertex cover being created. Dashed edges
    (*a*, *b*), (*c*, *e*), and (*c*, *d*) are removed since they are now covered
    by some vertex in *C*. **(c)** Edge (*e*, *f*) is chosen, and vertices *e* and
    *f* are added to *C*. **(d)** Edge (*d*, *g*) is chosen, and vertices *d* and
    *g* are added to *C*. **(e)** The set *C*, which is the vertex cover produced
    by APPROX-VERTEX-COVER, contains the six vertices *b, c, d, e, f, g*. **(f)**
    The optimal vertex cover for this problem contains only three vertices: *b*, *d*,
    and *e*.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 35.1** APPROX-VERTEX-COVER 的操作。**(a)** 输入图 *G*，有 7 个顶点和 8 条边。**(b)** 被
    APPROX-VERTEX-COVER 选择的第一条边 (*b*, *c*)。蓝色的顶点 *b* 和 *c* 被添加到包含正在创建的顶点覆盖的集合 *C*
    中。虚线边 (*a*, *b*)，(*c*, *e*) 和 (*c*, *d*) 被移除，因为它们现在被 *C* 中的某个顶点覆盖了。**(c)** 选择了边
    (*e*, *f*)，顶点 *e* 和 *f* 被添加到 *C* 中。**(d)** 选择了边 (*d*, *g*)，顶点 *d* 和 *g* 被添加到 *C*
    中。**(e)** 集合 *C*，由 APPROX-VERTEX-COVER 产生的顶点覆盖，包含了六个顶点 *b, c, d, e, f, g*。**(f)**
    此问题的最优顶点覆盖仅包含三个顶点：*b*, *d* 和 *e*。'
- en: Let us reflect on this proof. At first, you might wonder how you can possibly
    prove that the size of the vertex cover returned by APPROX-VERTEX-COVER is at
    most twice the size of an optimal vertex cover, when you don’t even know the size
    of an optimal vertex cover. Instead of requiring that you know the exact size
    of an optimal vertex cover, you find a lower bound on the size. As Exercise 35.1-2
    asks you to show, the set *A* of edges that line 4 of APPROX-VERTEX-COVER selects
    is actually a maximal matching in the graph *G*. (A ***maximal matching*** is
    a matching to which no edges can be added and still have a matching.) The size
    of a maximal matching is, as we argued in the proof of Theorem 35.1, a lower bound
    on the size of an optimal vertex cover. The algorithm returns a vertex cover whose
    size is at most twice the size of the maximal matching *A*. The approximation
    ratio comes from relating the size of the solution returned to the lower bound.
    We will use this methodology in later sections as well.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们反思这个证明。起初，你可能会想知道如何可能证明由 APPROX-VERTEX-COVER 返回的顶点覆盖的大小至多是最优顶点覆盖大小的两倍，当你甚至不知道最优顶点覆盖的大小时。与其要求你知道最优顶点覆盖的确切大小，不如找到大小的下界。正如习题
    35.1-2 要求你展示的那样，APPROX-VERTEX-COVER 的第 4 行选择的边集 *A* 实际上是图 *G* 中的最大匹配。 （***最大匹配***是一个不能再添加边而仍然具有匹配的匹配。）最大匹配的大小，正如我们在定理
    35.1 的证明中所讨论的那样，是最优顶点覆盖大小的下界。该算法返回的顶点覆盖大小至多是最大匹配 *A* 大小的两倍。逼近比率来自将返回的解的大小与下界相关联。我们在后面的章节中也将使用这种方法。
- en: '**Exercises**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题**'
- en: '***35.1-1***'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.1-1***'
- en: Give an example of a graph for which APPROX-VERTEX-COVER always yields a suboptimal
    solution.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个图的例子，APPROX-VERTEX-COVER 总是产生次优解。
- en: '***35.1-2***'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.1-2***'
- en: Prove that the set of edges picked in line 4 of APPROX-VERTEX-COVER forms a
    maximal matching in the graph *G*.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 证明在 APPROX-VERTEX-COVER 的第 4 行中选择的边集形成图 *G* 中的最大匹配。
- en: ★ ***35.1-3***
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***35.1-3***
- en: Consider the following heuristic to solve the vertex-cover problem. Repeatedly
    select a vertex of highest degree, and remove all of its incident edges. Give
    an example to show that this heuristic does not provide an approximation ratio
    of 2\. (*Hint:* Try a bipartite graph with vertices of uniform degree on the left
    and vertices of varying degree on the right.)
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下启发式方法来解决顶点覆盖问题。重复选择度数最高的顶点，并删除其所有关联边。给出一个示例，表明这种启发式方法不会提供 2 的逼近比率。(*提示:*
    尝试一个左侧顶点度数均匀，���侧顶点度数不同的二部图。)
- en: '***35.1-4***'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.1-4***'
- en: Give an efficient greedy algorithm that finds an optimal vertex cover for a
    tree in linear time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个有效的贪心算法，以线性时间找到树的最优顶点覆盖。
- en: '***35.1-5***'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.1-5***'
- en: The proof of Theorem 34.12 on page 1084 illustrates that the vertex-cover problem
    and the NP-complete clique problem are complementary in the sense that an optimal
    vertex cover is the complement of a maximum-size clique in the complement graph.
    Does this relationship imply that there is a polynomial-time approximation algorithm
    with a constant approximation ratio for the clique problem? Justify your answer.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 34.12 在第 1084 页的证明说明，顶点覆盖问题和 NP 完全的团问题在某种意义上是互补的，即最优顶点覆盖是互补图中最大团的补集。这种关系是否意味着存在一个具有常数逼近比的多项式时间逼近算法来解决团问题？请证明你的答案。
- en: '[**35.2    The traveling-salesperson problem**](toc.xhtml#Rh1-207)'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '[**35.2    旅行推销员问题**](toc.xhtml#Rh1-207)'
- en: 'The input to the traveling-salesperson problem, introduced in [Section 34.5.4](chapter034.xhtml#Sec_34.5.4),
    is a complete undirected graph *G* = (*V*, *E*) that has a nonnegative integer
    cost *c*(*u, v*) associated with each edge (*u*, *v*) ∈ *E*. The goal is to find
    a hamiltonian cycle (a tour) of *G* with minimum cost. As an extension of our
    notation, let *c*(*A*) denote the total cost of the edges in the subset *A* ⊆
    *E*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 旅行推销员问题的输入，介绍在 [第 34.5.4 节](chapter034.xhtml#Sec_34.5.4) 中，是一个完全无向图 *G* = (*V*,
    *E*)，每条边 (*u*, *v*) ∈ *E* 都有一个非负整数成本 *c*(*u, v*)。目标是找到 *G* 的最小成本哈密顿回路（一次遍历）。作为我们符号的扩展，让
    *c*(*A*) 表示子集 *A* ⊆ *E* 中边的总成本：
- en: '![art](images/Art_P1487.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1487.jpg)'
- en: 'In many practical situations, the least costly way to go from a place *u* to
    a place *w* is to go directly, with no intermediate steps. Put another way, cutting
    out an intermediate stop never increases the cost. Such a cost function *c* satisfies
    the ***triangle inequality***: for all vertices *u, v, w* ∈ *V*,'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多实际情况下，从一个地点 *u* 到一个地点 *w* 的最经济方式是直接前往，没有中间步骤。换句话说，去掉一个中间停靠点永远不会增加成本。这样的成本函数
    *c* 满足***三角不等式***：对于所有顶点 *u, v, w* ∈ *V*，
- en: '*c*(*u, w*) ≤ *c*(*u, v*) + *c*(*v, w*).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '*c*(*u, w*) ≤ *c*(*u, v*) + *c*(*v, w*)。'
- en: The triangle inequality seems as though it should naturally hold, and it is
    automatically satisfied in several applications. For example, if the vertices
    of the graph are points in the plane and the cost of traveling between two vertices
    is the ordinary euclidean distance between them, then the triangle inequality
    is satisfied. Furthermore, many cost functions other than euclidean distance satisfy
    the triangle inequality.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 三角不等式似乎应该自然成立，并且在几个应用中自动满足。例如，如果图的顶点是平面上的点，两个顶点之间的旅行成本是它们之间的普通欧几里德距离，那么三角不等式就满足。此外，许多除欧几里德距离之外的成本函数也满足三角不等式。
- en: As Exercise 35.2-2 shows, the traveling-salesperson problem is NP-complete even
    if you require the cost function to satisfy the triangle inequality. Thus, you
    should not expect to find a polynomial-time algorithm for solving this problem
    exactly. Your time would be better spent looking for good approximation algorithms.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 正如习题 35.2-2 所示，即使要求成本函数满足三角不等式，旅行推销员问题也是 NP 完全的。因此，不应期望找到解决此问题的多项式时间算法。你的时间最好花在寻找良好的近似算法上。
- en: In [Section 35.2.1](chapter035.xhtml#Sec_35.2.1), we examine a 2-approximation
    algorithm for the traveling-salesperson problem with the triangle inequality.
    In [Section 35.2.2](chapter035.xhtml#Sec_35.2.2), we show that without the triangle
    inequality, a polynomial-time approximation algorithm with a constant approximation
    ratio does not exist unless P = NP.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第 35.2.1 节](chapter035.xhtml#Sec_35.2.1)中，我们研究了具有三角不等式的旅行推销员问题的 2-近似算法。在[第
    35.2.2 节](chapter035.xhtml#Sec_35.2.2)中，我们展示了如果没有三角不等式，则不存在具有恒定近似比的多项式时间近似算法，除非
    P = NP。
- en: '**35.2.1    The traveling-salesperson problem with the triangle inequality**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**35.2.1** 具有三角不等式的旅行推销员问题'
- en: Applying the methodology of the previous section, start by computing a structure—a
    minimum spanning tree—whose weight gives a lower bound on the length of an optimal
    traveling-salesperson tour. Then use the minimum spanning tree to create a tour
    whose cost is no more than twice that of the minimum spanning tree’s weight, as
    long as the cost function satisfies the triangle inequality. The procedure APPROX-TSP-TOUR
    on the next page implements this approach, calling the minimum-spanning-tree algorithm
    MST-PRIM on page 596 as a subroutine. The parameter *G* is a complete undirected
    graph, and the cost function *c* satisfies the triangle inequality.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 应用前一节的方法论，首先计算一个结构——一个最小生成树，其权重给出最佳旅行推销员路线长度的下界。然后使用最小生成树创建一个路线，其成本不超过最小生成树权重的两倍，只要成本函数满足三角不等式。下一页的
    APPROX-TSP-TOUR 过程实现了这种方法，调用第 596 页的最小生成树算法 MST-PRIM 作为子例程。参数 *G* 是一个完整的无向图，成本函数
    *c* 满足三角不等式。
- en: Recall from [Section 12.1](chapter012.xhtml#Sec_12.1) that a preorder tree walk
    recursively visits every vertex in the tree, listing a vertex when it is first
    encountered, before visiting any of its children.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾[第 12.1 节](chapter012.xhtml#Sec_12.1)，前序树遍历递归地访问树中的每个顶点，在访问任何子节点之前列出一个顶点。
- en: '[Figure 35.2](chapter035.xhtml#Fig_35-2) illustrates the operation of APPROX-TSP-TOUR.
    Part (a) of the figure shows a complete undirected graph, and part (b) shows the
    minimum spanning tree *T* grown from root vertex *a* by MST-PRIM. Part (c) shows
    how a preorder walk of *T* visits the vertices, and part (d) displays the corresponding
    tour, which is the tour returned by APPROX-TSP-TOUR. Part (e) displays an optimal
    tour, which is about 23% shorter.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 35.2](chapter035.xhtml#Fig_35-2) 说明了 APPROX-TSP-TOUR 的操作。图的第一部分展示了一个完整的无向图，第二部分展示了由
    MST-PRIM 从根顶点 *a* 生长出的最小生成树 *T*。第三部分展示了 *T* 的前序遍历如何访问顶点，第四部分展示了相应的路线，即 APPROX-TSP-TOUR
    返回的路线。第五部分展示了一个最佳路线，比最佳路线短约 23%。'
- en: '![art](images/Art_P1488.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1488.jpg)'
- en: '**Figure 35.2** The operation of APPROX-TSP-TOUR. **(a)** A complete undirected
    graph. Vertices lie on intersections of integer grid lines. For example, *f* is
    one unit to the right and two units up from *h*. The cost function between two
    points is the ordinary euclidean distance. **(b)** A minimum spanning tree *T*
    of the complete graph, as computed by MST-PRIM. Vertex *a* is the root vertex.
    Only edges in the minimum spanning tree are shown. The vertices happen to be labeled
    in such a way that they are added to the main tree by MST-PRIM in alphabetical
    order. **(c)** A walk of *T*, starting at *a*. A full walk of the tree visits
    the vertices in the order *a, b, c, b, h, b, a, d, e, f, e, g, e, d, a*. A preorder
    walk of *T* lists a vertex just when it is first encountered, as indicated by
    the dot next to each vertex, yielding the ordering *a, b, c, h, d, e, f, g*. **(d)**
    A tour obtained by visiting the vertices in the order given by the preorder walk,
    which is the tour *H* returned by APPROX-TSP-TOUR. Its total cost is approximately
    19.074\. **(e)** An optimal tour *H** for the original complete graph. Its total
    cost is approximately 14.715.'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 35.2** APPROX-TSP-TOUR 的操作。**(a)** 一个完整的无向图。顶点位于整数网格线的交点上。例如，*f* 比 *h*
    右移一单位，上移两单位。两点之间的成本函数是普通的欧几里得距离。**(b)** 完整图的最小生成树 *T*，由 MST-PRIM 计算得出。顶点 *a* 是根顶点。只显示最小生成树中的边。顶点恰好按照字母顺序标记，以便
    MST-PRIM 按照字母顺序将它们添加到主树中。**(c)** *T* 的遍历，从 *a* 开始。树的完整遍历按照顺序访问顶点 *a, b, c, b,
    h, b, a, d, e, f, e, g, e, d, a*。*T* 的前序遍历列出了每个顶点第一次遇到时的顺序，如每个顶点旁边的点所示，得到顺序 *a,
    b, c, h, d, e, f, g*。**(d)** 按照前序遍历给出的顺序访问顶点得到的旅行路线，即 APPROX-TSP-TOUR 返回的路线 *H*。其总成本约为
    19.074。**(e)** 原始完整图的最佳路线 *H*。其总成本约为 14.715。'
- en: APPROX-TSP-TOUR (*G*, *c*)
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: APPROX-TSP-TOUR (*G*, *c*)
- en: '| 1 | select a vertex *r* ∈ *G.V* to be a “root” vertex |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 选择一个顶点 *r* ∈ *G.V* 作为“根”顶点 |'
- en: '| 2 | compute a minimum spanning tree *T* for *G* from root *r* using MST-PRIM
    (*G*, *c, r*) |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 使用 MST-PRIM (*G*, *c, r*) 为 *G* 从根 *r* 计算最小生成树 *T* |'
- en: '| 3 | let *H* be a list of vertices, ordered according to when they are first
    visited in a preorder tree walk of *T* |'
  id: totrans-71
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 令 *H* 为一个顶点列表，按照它们在 *T* 的前序树遍历中首次访问的顺序排序 |'
- en: '| 4 | **return** the hamiltonian cycle *H* |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **返回** 哈密顿回路 *H* |'
- en: By Exercise 21.2-2, even with a simple implementation of MST-PRIM, the running
    time of APPROX-TSP-TOUR is Θ(*V* ²). We now show that if the cost function for
    an instance of the traveling-salesperson problem satisfies the triangle inequality,
    then APPROX-TSP-TOUR returns a tour whose cost is at most twice the cost of an
    optimal tour.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 根据练习 21.2-2，即使使用简单的 MST-PRIM 实现，APPROX-TSP-TOUR 的运行时间为 Θ(*V* ²)。我们现在证明，如果旅行推销员问题的实例的成本函数满足三角不等式，则
    APPROX-TSP-TOUR 返回的路线成本最多是最佳路线成本的两倍。
- en: '***Theorem 35.2***'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 35.2***'
- en: When the triangle inequality holds, APPROX-TSP-TOUR is a polynomial-time 2-approximation
    algorithm for the traveling-salesperson problem.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当三角不等式成立时，APPROX-TSP-TOUR 是旅行推销员问题的多项式时间 2-近似算法。
- en: '***Proof***   We have already seen that APPROX-TSP-TOUR runs in polynomial
    time.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 我们已经看到 APPROX-TSP-TOUR 是多项式时间运行的。'
- en: 'Let *H** denote an optimal tour for the given set of vertices. Deleting any
    edge from a tour yields a spanning tree, and each edge cost is nonnegative. Therefore,
    the weight of the minimum spanning tree *T* computed in line 2 of APPROX-TSP-TOUR
    provides a lower bound on the cost of an optimal tour:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 设*H**表示给定顶点集的最优旅行路线。从路线中删除任意边都会得到一棵生成树，每条边的成本都是非负的。因此，APPROX-TSP-TOUR中第2行计算的最小生成树*T*的权重提供了最优旅行路线成本的下界：
- en: '![art](images/Art_P1489.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1489.jpg)'
- en: A ***full walk*** of *T* lists the vertices when they are first visited and
    also whenever they are returned to after a visit to a subtree. Let’s call this
    full walk *W*. The full walk of our example gives the order
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '*T*的***完整遍历***列出了首次访问顶点以及在访问子树后返回到它们时的顺序。我们将这种完整遍历称为*W*。我们示例的完整遍历给出了顺序'
- en: '*a, b, c, b, h, b, a, d, e, f, e, g, e, d, a.*'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '*a, b, c, b, h, b, a, d, e, f, e, g, e, d, a.*'
- en: Since the full walk traverses every edge of *T* exactly twice, by extending
    the definition of the cost *c* in the natural manner to handle multisets of edges,
    we have
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 由于完整遍历恰好遍历树*T*的每条边两次，通过将成本*c*的定义自然地扩展以处理边的多重集，我们有
- en: '![art](images/Art_P1490.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1490.jpg)'
- en: Inequality (35.4) and equation (35.5) imply that
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 不等式(35.4)和方程(35.5)意味着
- en: '![art](images/Art_P1491.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1491.jpg)'
- en: and so the cost of *W* is within a factor of 2 of the cost of an optimal tour.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*W*的成本与最优旅行路线的成本相差不超过2倍。
- en: Of course, the full walk *W* is not a tour, since it visits some vertices more
    than once. By the triangle inequality, however, deleting a visit to any vertex
    from *W* does not increase the cost. (When a vertex *v* is deleted from *W* between
    visits to *u* and *w*, the resulting ordering specifies going directly from *u*
    to *w*.) Repeatedly apply this operation on each visit to a vertex after the first
    time it’s visited in *W*, so that *W* is left with only the first visit to each
    vertex. In our example, this process leaves the ordering
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，完整遍历*W*不是一条旅行路线，因为它访问某些顶点超过一次。然而，根据三角不等式，从*W*中删除对任何顶点的访问不会增加成本。（当在访问*u*和*w*之间从*W*中删除顶点*v*时，得到的顺序指定直接从*u*到*w*。）重复对*W*中每次访问顶点的操作，使得*W*只保留每个顶点的第一次访问。在我们的示例中，这个过程留下了顺序
- en: '*a, b, c, h, d, e, f, g.*'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*a, b, c, h, d, e, f, g.*'
- en: This ordering is the same as that obtained by a preorder walk of the tree *T*.
    Let *H* be the cycle corresponding to this preorder walk. It is a hamiltonian
    cycle, since every vertex is visited exactly once, and in fact it is the cycle
    computed by APPROX-TSP-TOUR. Since *H* is obtained by deleting vertices from the
    full walk *W*, we have
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 这种顺序与通过树*T*的前序遍历获得的顺序相同。设*H*为对应于此前序遍历的循环。它是一个汉密尔顿回路，因为每个顶点都恰好被访问一次，实际上它是由APPROX-TSP-TOUR计算的循环。由于*H*是通过从完整遍历*W*中删除顶点得到的，我们有
- en: '![art](images/Art_P1492.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1492.jpg)'
- en: Combining inequalities (35.6) and (35.7) gives *c*(*H*) ≤ 2*c*(*H**), which
    completes the proof.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 结合不等式(35.6)和(35.7)得到*c*(*H*) ≤ 2*c*(*H**)，证毕。
- en: ▪
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Despite the small approximation ratio provided by Theorem 35.2, APPROX-TSP-TOUR
    is usually not the best practical choice for this problem. There are other approximation
    algorithms that typically perform much better in practice. (See the references
    at the end of this chapter.)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管定理35.2提供了较小的近似比，但APPROX-TSP-TOUR通常不是这个问题的最佳实际选择。在实践中通常有其他近似算法表现更好。（请参阅本章末尾的参考文献。）
- en: '**35.2.2    The general traveling-salesperson problem**'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '**35.2.2    一般旅行推销员问题**'
- en: When the cost function *c* does not satisfy the triangle inequality, there is
    no way to find good approximate tours in polynomial time unless P = NP.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 当成本函数*c*不满足三角不等式时，除非P = NP，否则无法在多项式时间内找到良好的近似旅行路线。
- en: '***Theorem 35.3***'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理35.3***'
- en: If P ≠ NP, then for any constant *ρ* ≥ 1, there is no polynomial-time approximation
    algorithm with approximation ratio *ρ* for the general traveling-salesperson problem.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果P ≠ NP，则对于任意常数*ρ* ≥ 1，一般旅行推销员问题没有近似比为*ρ*的多项式时间近似算法。
- en: '***Proof***   The proof is by contradiction. Suppose to the contrary that for
    some number *ρ* ≥ 1, there is a polynomial-time approximation algorithm *A* with
    approximation ratio *ρ*. Without loss of generality, assume that *ρ* is an integer,
    by rounding it up if necessary. We will show how to use *A* to solve instances
    of the hamiltonian-cycle problem (defined in [Section 34.2](chapter034.xhtml#Sec_34.2))
    in polynomial time. Since Theorem 34.13 on page 1085 says that the hamiltonian-cycle
    problem is NP-complete, Theorem 34.4 on page 1063 implies that if it has a polynomial-time
    algorithm, then P = NP.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   证明是通过反证法进行的。假设相反，对于某个数*ρ* ≥ 1，存在近似比为*ρ*的多项式时间近似算法*A*。不失一般性地，假设*ρ*是整数，必要时向上取整。我们将展示如何使用*A*在多项式时间内解决汉密尔顿回路问题的实例。由于第34.13节第1085页的定理说汉密尔顿回路问题是NP完全的，第1063页的定理34.4暗示如果它有多项式时间算法，则P
    = NP。'
- en: Let *G* = (*V*, *E*) be an instance of the hamiltonian-cycle problem. We will
    show how to determine efficiently whether *G* contains a hamiltonian cycle by
    making use of the hypothesized approximation algorithm *A*. Convert *G* into an
    instance of the traveling-salesperson problem as follows. Let *G*′ = (*V*, *E*′)
    be the complete graph on *V*, that is,
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 设*G* = (*V*, *E*)是汉密尔顿回路问题的一个实例。我们将展示如何通过使用假设的近似算法*A*高效确定*G*是否包含汉密尔顿回路。将*G*转换为旅行推销员问题的一个实例，方法如下。设*G*′
    = (*V*, *E*′)是*V*上的完全图，即，
- en: '*E*′ = {(*u*, *v*) : *u, v* ∈ *V* and *u* ≠ *v*}.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*E*′ = {(*u*, *v*) : *u, v* ∈ *V* and *u* ≠ *v*}.'
- en: 'Assign an integer cost to each edge in *E*′ as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为*E*′中的每条边分配一个整数成本如下：
- en: '![art](images/Art_P1493.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1493.jpg)'
- en: Given a representation of *G*, it takes time polynomial in |*V*| and |*E*| to
    create representations of *G*′ and *c*.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 给定*G*的表示，创建*G*′和*c*的表示需要多项式时间|*V*|和|*E*|。
- en: Now consider the traveling-salesperson problem (*G*′, *c*). If the original
    graph *G* has a hamiltonian cycle *H*, then the cost function *c* assigns to each
    edge of *H* a cost of 1, and so (*G*′, *c*) contains a tour of cost |*V*|. On
    the other hand, if *G* does not contain a hamiltonian cycle, then any tour of
    *G*′ must use some edge not in *E*. But any tour that uses an edge not in *E*
    has a cost of at least
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑旅行推销员问题（*G*′，*c*）。如果原始图 *G* 有一个哈密顿循环 *H*，那么成本函数 *c* 为 *H* 的每条边分配成本为 1，因此（*G*′，*c*）包含成本为
    |*V*| 的旅行路线。另一方面，如果 *G* 不包含哈密顿循环，则 *G*′ 的任何旅行路线必须使用一些不在 *E* 中的边。但是任何使用不在 *E* 中的边的旅行路线的成本至少为
- en: '| (*ρ* &#124;*V*&#124; + 1) + (&#124;*V*&#124; − 1) | = | *ρ* &#124;*V*&#124;
    + &#124;*V*&#124; |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| (*ρ* &#124;*V*&#124; + 1) + (&#124;*V*&#124; − 1) | = | *ρ* &#124;*V*&#124;
    + &#124;*V*&#124; |'
- en: '|  | > | *ρ* &#124;*V*&#124;. |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|  | > | *ρ* &#124;*V*&#124;. |'
- en: Because edges not in *G* are so costly, there is a gap of at least *ρ*|*V*|
    between the cost of a tour that is a hamiltonian cycle in *G* (cost |*V*|) and
    the cost of any other tour (cost at least *ρ*|*V*| + |*V*|). Therefore, the cost
    of a tour that is not a hamiltonian cycle in *G* is at least a factor of *ρ* +
    1 greater than the cost of a tour that is a hamiltonian cycle in *G*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因为不在 *G* 中的边成本很高，所以在一个是 *G* 中的哈密顿循环的旅行路线的成本（成本为 |*V*|）和任何其他旅行路线的成本（至少为 *ρ*|*V*|
    + |*V*|）之间存在至少 *ρ*|*V*| 的差距。因此，在 *G* 中不是哈密顿循环的旅行路线的成本至少比在 *G* 中是哈密顿循环的旅行路线的成本大
    *ρ* + 1 倍。
- en: What happens upon applying the approximation algorithm *A* to the traveling-salesperson
    problem (*G*′, *c*)? Because *A* is guaranteed to return a tour of cost no more
    than *ρ* times the cost of an optimal tour, if *G* contains a hamiltonian cycle,
    then *A* must return it. If *G* has no hamiltonian cycle, then *A* returns a tour
    of cost more than *ρ* |*V*|. Therefore, using *A* solves the hamiltonian-cycle
    problem in polynomial time.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 将近似算法 *A* 应用于旅行推销员问题 (*G*′, *c*) 会发生什么？因为 *A* 保证返回的旅行路线成本不会超过最优路线成本的 *ρ* 倍，如果
    *G* 包含一个哈密顿循环，那么 *A* 必须返回它。如果 *G* 没有哈密顿循环，那么 *A* 返回的旅行路线成本将超过 *ρ* |*V*|。因此，使用
    *A* 可以在多项式时间内解决哈密顿循环问题。
- en: ▪
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: The proof of Theorem 35.3 serves as an example of a general technique to prove
    that no good approximation algorithm exists for a particular problem. Given an
    NP-hard decision problem *X*, produce in polynomial time a minimization problem
    *Y* such that “yes” instances of *X* correspond to instances of *Y* with value
    at most *k* (for some *k*), but that “no” instances of *X* correspond to instances
    of *Y* with value greater than *ρk*. This technique shows that, unless P = NP,
    there is no polynomial-time *ρ*-approximation algorithm for problem *Y*.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 35.3 的证明作为证明特定问题不存在良好近似算法的一般技术的示例。给定一个 NP 难的决策问题 *X*，在多项式时间内生成一个最小化问题 *Y*，使得
    *X* 的“是”实例对应于值最多为 *k*（对于某个 *k*）的 *Y* 实例，但 *X* 的“否”实例对应于值大于 *ρk* 的 *Y* 实例。这种技术表明，除非
    P = NP，否则问题 *Y* 没有多项式时间 *ρ* 近似算法。
- en: '**Exercises**'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***35.2-1***'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.2-1***'
- en: Let *G* = (*V*, *E*) be a complete undirected graph containing at least 3 vertices,
    and let *c* be a cost function that satisfies the triangle inequality. Prove that
    *c*(*u, v*) ≥ 0 for all *u, v* ∈ *V*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 设 *G* = (*V*, *E*) 是包含至少 3 个顶点的完全无向图，*c* 是满足三角不等式的成本函数。证明对于所有 *u, v* ∈ *V*，有
    *c*(*u, v*) ≥ 0。
- en: '***35.2-2***'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.2-2***'
- en: Show how in polynomial time to transform one instance of the traveling-salesperson
    problem into another instance whose cost function satisfies the triangle inequality.
    The two instances must have the same set of optimal tours. Explain why such a
    polynomial-time transformation does not contradict Theorem 35.3, assuming that
    P ≠ NP.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何在多项式时间内将一个旅行推销员问题的实例转换为另一个满足三角不等式的成本函数的实例。这两个实例必须具有相同的最优路线集。解释为什么这样的多项式时间转换不会违反定理
    35.3，假设 P ≠ NP。
- en: '***35.2-3***'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.2-3***'
- en: Consider the following ***closest-point heuristic*** for building an approximate
    traveling-salesperson tour whose cost function satisfies the triangle inequality.
    Begin with a trivial cycle consisting of a single arbitrarily chosen vertex. At
    each step, identify the vertex *u* that is not on the cycle but whose distance
    to any vertex on the cycle is minimum. Suppose that the vertex on the cycle that
    is nearest *u* is vertex *v*. Extend the cycle to include *u* by inserting *u*
    just after *v*. Repeat until all vertices are on the cycle. Prove that this heuristic
    returns a tour whose total cost is not more than twice the cost of an optimal
    tour.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下用于构建满足三角不等式的近似旅行推销员路线的***最近点启发式***。从一个由单个任意选择的顶点组成的平凡循环开始。在每一步中，识别不在循环上但到任何循环上顶点距离最小的顶点
    *u*。假设距离 *u* 最近的循环上的顶点是顶点 *v*。通过在 *v* 之后插入 *u* 来扩展循环以包括 *u*。重复直到所有顶点都在循环上。证明这种启发式返回的旅行路线的总成本不会超过最优路线成本的两倍。
- en: '***35.2-4***'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.2-4***'
- en: A solution to the ***bottleneck traveling-salesperson problem*** is the hamiltonian
    cycle that minimizes the cost of the most costly edge in the cycle. Assuming that
    the cost function satisfies the triangle inequality, show that there exists a
    polynomial-time approximation algorithm with approximation ratio 3 for this problem.
    (*Hint:* Show recursively how to visit all the nodes in a bottleneck spanning
    tree, as discussed in Problem 21-4 on page 601, exactly once by taking a full
    walk of the tree and skipping nodes, but without skipping more than two consecutive
    intermediate nodes. Show that the costliest edge in a bottleneck spanning tree
    has a cost bounded from above by the cost of the costliest edge in a bottleneck
    hamiltonian cycle.)
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '***瓶颈旅行推销员问题***的解决方案是最小化循环中成本最高的边的哈密顿循环。假设成本函数满足三角不等式，证明存在一个近似比为 3 的多项式时间近似算法解决这个问题。(*提示:*
    递归地展示如何通过在瓶颈生成树中访问所有节点一次来解决问题 21-4 中讨论的问题 21-4，通过对树进行完整遍历并跳过节点，但不跳过两个连续的中间节点。证明瓶颈生成树中成本最高的边的成本上界受到瓶颈哈密顿循环中成本最高的边的成本的限制。)'
- en: '***35.2-5***'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.2-5***'
- en: Suppose that the vertices for an instance of the traveling-salesperson problem
    are points in the plane and that the cost *c*(*u, v*) is the euclidean distance
    between points *u* and *v*. Show that an optimal tour never crosses itself.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 假设旅行推销员问题的实例的顶点是平面上的点，成本*c*(*u, v*)是点*u*和*v*之间的欧几里德距离。证明最优旅行路线永远不会交叉。
- en: '***35.2-6***'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.2-6***'
- en: Adapt the proof of Theorem 35.3 to show that for any constant *c* ≥ 0, there
    is no polynomial-time approximation algorithm with approximation ratio |*V*|^(*c*)
    for the general traveling-salesperson problem.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 将定理35.3的证明改编为证明对于任意常数*c* ≥ 0，不存在近似比为|*V*|^(*c*)的多项式时间近似算法来解决一般旅行推销员问题。
- en: '[**35.3    The set-covering problem**](toc.xhtml#Rh1-208)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '[**35.3    集盖问题**](toc.xhtml#Rh1-208)'
- en: The set-covering problem is an optimization problem that models many problems
    that require resources to be allocated. Its corresponding decision problem generalizes
    the NP-complete vertex-cover problem and is therefore also NP-hard. The approximation
    algorithm developed to handle the vertex-cover problem doesn’t apply here, however.
    Instead, this section investigates a simple greedy heuristic with a logarithmic
    approximation ratio. That is, as the size of the instance gets larger, the size
    of the approximate solution may grow, relative to the size of an optimal solution.
    Because the logarithm function grows rather slowly, however, this approximation
    algorithm may nonetheless give useful results.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 集盖问题是一个优化问题，模拟了许多需要分配资源的问题。其对应的决策问题泛化了NP完全的顶点覆盖问题，因此也是NP难的。然而，用于处理顶点覆盖问题的近似算法在这里不适用。相反，本节研究了一个具有对数近似比的简单贪婪启发式算法。也就是说，随着实例的规模变大，近似解的大小可能会相对于最优解的大小增长。然而，由于对数函数增长相当缓慢，这种近似算法仍然可能给出有用的结果。
- en: 'An instance (*X*, *ℱ*) of the ***set-covering problem*** consists of a finite
    set *X* and a family *ℱ* of subsets of *X*, such that every element of *X* belongs
    to at least one subset in *ℱ*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 集盖问题的实例(*X*, *ℱ*)由有限集*X*和*X*的子集族*ℱ*组成，使得*X*的每个元素至少属于*ℱ*中的一个子集：
- en: '![art](images/Art_P1494.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1494.jpg)'
- en: We say that a subfamily C ⊆ *ℱ* ***covers*** a set of elements *U* if
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说子族C ⊆ *ℱ* ***覆盖*** 元素集*U*，如果
- en: '![art](images/Art_P1495.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1495.jpg)'
- en: 'The problem is to find a minimum-size subfamily C ⊆ *ℱ* whose members cover
    all of *X*:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是找到一个最小大小的子族C ⊆ *ℱ*，其成员覆盖*X*的所有元素：
- en: '![art](images/Art_P1496.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1496.jpg)'
- en: '[Figure 35.3](chapter035.xhtml#Fig_35-3) illustrates the set-covering problem.
    The size of C is the number of sets it contains, rather than the number of individual
    elements in these sets, since every subfamily C that covers *X* must contain all
    |*X*| individual elements. In [Figure 35.3](chapter035.xhtml#Fig_35-3), the minimum
    set cover has size 3.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 35.3](chapter035.xhtml#Fig_35-3)展示了集盖问题。C的大小是它包含的集合数量，而不是这些集合中的个体元素数量，因为覆盖*X*的每个子族C必须包含所有|*X*|个体元素。在[图
    35.3](chapter035.xhtml#Fig_35-3)中，最小集盖的大小为3。'
- en: The set-covering problem abstracts many commonly arising combinatorial problems.
    As a simple example, suppose that *X* represents a set of skills that are needed
    to solve a problem and that you have a given set of people available to work on
    the problem. You wish to form a committee, containing as few people as possible,
    such that for every requisite skill in *X*, at least one member of the committee
    has that skill. The decision version of the set-covering problem asks whether
    a covering exists with size at most *k*, where *k* is an additional parameter
    specified in the problem instance. The decision version of the problem is NP-complete,
    as Exercise 35.3-2 asks you to show.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 集盖问题抽象了许多常见的组合问题。举个简单的例子，假设*X*代表解决问题所需的技能集，而您有一组可用于解决问题的人员。您希望组建一个委员会，其中包含尽可能少的人员，以便对于*X*中的每个必需技能，委员会的至少一名成员具有该技能。集盖问题的决策版本询问是否存在大小最多为*k*的覆盖，其中*k*是问题实例中指定的附加参数。问题的决策版本是NP完全的，正如练习35.3-2要求您展示的那样。
- en: '**A greedy approximation algorithm**'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**一种贪婪近似算法**'
- en: The greedy method in the procedure GREEDY-SET-COVER on the facing page works
    by picking, at each stage, the set *S* that covers the greatest number of remaining
    elements that are uncovered. In the example of [Figure 35.3](chapter035.xhtml#Fig_35-3),
    GREEDY-SET-COVER adds to C, in order, the sets *S*[1], *S*[4], and *S*[5], followed
    by either *S*[3] or *S*[6].
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在对面页面上的GREEDY-SET-COVER过程中，贪婪方法通过在每个阶段选择覆盖剩余未覆盖元素最多的集合*S*来工作。在[图 35.3](chapter035.xhtml#Fig_35-3)的例子中，GREEDY-SET-COVER按顺序添加到C中集合*S*[1]、*S*[4]和*S*[5]，然后是*S*[3]或*S*[6]。
- en: '![art](images/Art_P1497.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1497.jpg)'
- en: '**Figure 35.3** An instance (*X*, *ℱ*) of the set-covering problem, where *X*
    consists of the 12 tan points and *ℱ* = {*S*[1], *S*[2], *S*[3], *S*[4], *S*[5],
    *S*[6], *S*[4], *S*[5]}, Each set *S[i]* ∈ *ℱ* is outlined in blue. A minimum-size
    set cover C = {*S*[3], *S*[4], *S*[5]}, with size 3\. The greedy algorithm produces
    a cover of size 4 by selecting either the sets *S*[1], *S*[4], *S*[5], and *S*[3]
    or the sets *S*[1], *S*[4], *S*[5], and *S*[6], in order.'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 35.3** 集盖问题的实例(*X*, *ℱ*)，其中*X*由12个棕色点组成，*ℱ* = {*S*[1], *S*[2], *S*[3],
    *S*[4], *S*[5], *S*[6], *S*[4], *S*[5]}，每个集合*S[i]* ∈ *ℱ*都用蓝色轮廓标出。最小大小集盖C = {*S*[3],
    *S*[4], *S*[5]}，大小为3。贪婪算法通过按顺序选择集合*S*[1]、*S*[4]、*S*[5]和*S*[3]或集合*S*[1]、*S*[4]、*S*[5]和*S*[6]来生成大小为4的覆盖。'
- en: GREEDY-SET-COVER (*X*, *ℱ*)
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: GREEDY-SET-COVER (*X*, *ℱ*)
- en: '| 1 | *U*[0] = *X* |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *U*[0] = *X* |'
- en: '| 2 | C = Ø |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 2 | C = Ø |'
- en: '| 3 | *i* = 0 |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *i* = 0 |'
- en: '| 4 | **while** *U[i]* ≠ Ø |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **当** *U[i]* ≠ Ø |'
- en: '| 5 | select *S* ∈ *ℱ* that maximizes &#124;*S* ∩ *U[i]*&#124; |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 选择*S* ∈ *ℱ*，使得&#124;*S* ∩ *U[i]*&#124;最大 |'
- en: '| 6 | *U*[*i*+1] = *U[i]* − *S* |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 6 | *U*[*i*+1] = *U[i]* − *S* |'
- en: '| 7 | C = C ∪ {*S*} |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 7 | C = C ∪ {*S*} |'
- en: '| 8 | *i* = *i* + 1 |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 8 | *i* = *i* + 1 |'
- en: '| 9 | **return** C |'
  id: totrans-146
  prefs: []
  type: TYPE_TB
  zh: '| 9 | **返回** C |'
- en: The greedy algorithm works as follows. At the start of each iteration, *U[i]*
    is a subset of *X* containing the remaining uncovered elements, with the initial
    subset *U*[0] containing all the elements in *X*. The set C contains the subfamily
    being constructed. Line 5 is the greedy decision-making step, choosing a subset
    *S* that covers as many uncovered elements as possible (breaking ties arbitrarily).
    After *S* is selected, line 6 updates the set of remaining uncovered elements,
    denoting it by *U*[*i*+1], and line 7 places *S* into C. When the algorithm terminates,
    C is a subfamily of *ℱ* that covers *X*.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 贪心算法的工作方式如下。在每次迭代开始时，*U[i]*是包含剩余未覆盖元素的*X*的子集，初始子集*U*[0]包含*X*中的所有元素。集合C包含正在构建的子族。第5行是贪心决策步骤，选择尽可能覆盖尽可能多未覆盖元素的子集*S*（任意打破平局）。选择*S*后，第6行更新剩余未覆盖元素的集合，用*U*[*i*+1]表示，第7行将*S*放入C。当算法终止时，C是覆盖*X*的*ℱ*的子族。
- en: '**Analysis**'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**分析**'
- en: We now show that the greedy algorithm returns a set cover that is not too much
    larger than an optimal set cover.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在展示贪心算法返回的集合覆盖不会比最佳集合覆盖大太多。
- en: '***Theorem 35.4***'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理35.4***'
- en: The procedure GREEDY-SET-COVER run on a set *X* and family of subsets *ℱ* is
    a polynomial-time *O*(lg *X*)-approximation algorithm.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在集合*X*和子集族*ℱ*上运行的GREEDY-SET-COVER过程是一个多项式时间*O*(lg *X*)-近似算法。
- en: '***Proof***   Let’s first show that the algorithm runs in time that is polynomial
    in |*X*| and |*ℱ*|. The number of iterations of the loop in lines 4–7 is bounded
    above by min {|*X*|, |*ℱ*|} = *O*(|*X*| + |*ℱ*|). The loop body can be implemented
    to run in *O*(|*X*|·|*ℱ*|) time. Thus the algorithm runs in *O*(|*X*|·|*ℱ*|·(|*X*|+|*ℱ*|))
    time, which is polynomial in the input size. (Exercise 35.3-3 asks for a linear-time
    algorithm.)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   首先我们展示算法在|*X*|和|*ℱ*|的多项式时间内运行。在���4-7行的循环的迭代次数上界为min {|*X*|, |*ℱ*|}
    = *O*(|*X*| + |*ℱ*|)。循环体可以实现在*O*(|*X*|·|*ℱ*|)时间内运行。因此，算法在*O*(|*X*|·|*ℱ*|·(|*X*|+|*ℱ*|))时间内运行，这是输入规模的多项式时间。（练习35.3-3要求一个线性时间算法。）'
- en: To prove the approximation bound, let C* be an optimal set cover for the original
    instance (*X*, *ℱ*), and let *k* = |C*|. Since C* is also a set cover of each
    subset *U[i]* of *X* constructed by the algorithm, we know that any subset *U[i]*
    constructed by the algorithm can be covered by *k* sets. Therefore, if (*U[i]*,
    *ℱ*) is an instance of the set-covering problem, its optimal set cover has size
    at most *k*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明近似界限，让C*成为原始实例(*X*, *ℱ*)的最佳集合覆盖，并让*k* = |C*|。由于C*也是算法构造的*X*的每个子集*U[i]*的集合覆盖，我们知道算法构造的任何子集*U[i]*都可以被*k*个集合覆盖。因此，如果(*U[i]*,
    *ℱ*)是集合覆盖问题的实例，其最佳集合覆盖的大小至多为*k*。
- en: If an optimal set cover for an instance (*U[i]*, *ℱ*) has size at most *k*,
    at least one of the sets in C covers at least |*U[i]*|/*k* new elements. Thus,
    line 5 of GREEDY-SET-COVER, which chooses a set with the maximum number of uncovered
    elements, must choose a set in which the number of newly covered elements is at
    least |*U[i]*|/*k*. These elements are removed when constructing *U*[*i*+1], giving
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实例(*U[i]*, *ℱ*)的最佳集合覆盖大小至多为*k*，则C中的至少一个集合覆盖至少|*U[i]*|/*k*个新元素。因此，GREEDY-SET-COVER的第5行，选择具有最大数量未覆盖元素的集合，必须选择一个其中新覆盖元素数量至少为|*U[i]*|/*k*的集合。在构建*U*[*i*+1]时，这些元素被移除，得到
- en: '![art](images/Art_P1498.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1498.jpg)'
- en: Iterating inequality (35.8) gives
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代不等式(35.8)给出
- en: '| &#124;*U*[0]&#124; | = | &#124;*X*&#124;, |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| &#124;*U*[0]&#124; | = | &#124;*X*&#124;, |'
- en: '| &#124;*U*[1]&#124; | ≤ | &#124;*U*[0]&#124; (1 − 1/*k*), |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| &#124;*U*[1]&#124; | ≤ | &#124;*U*[0]&#124; (1 − 1/*k*), |'
- en: '| &#124;*U*[2]&#124; | ≤ | &#124;*U*[1]&#124; (1 − 1/*k*) = &#124;*U*&#124;
    (1 − 1/*k*)², |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '| &#124;*U*[2]&#124; | ≤ | &#124;*U*[1]&#124; (1 − 1/*k*) = &#124;*U*&#124;
    (1 − 1/*k*)², |'
- en: and in general
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 一般地
- en: '![art](images/Art_P1499.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1499.jpg)'
- en: The algorithm stops when *U[i]* = Ø, which means that |*U[i]*| < 1\. Thus an
    upper bound on the number of iterations of the algorithm is the smallest value
    of *i* for which |*U[i]*| < 1.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 算法在*U[i]* = Ø时停止，这意味着|*U[i]*| < 1。因此，算法的迭代次数的上界是使|*U[i]*| < 1的最小*i*值。
- en: Since 1 + *x* ≤ *e^x* for all real *x* (see inequality (3.14) on page 66), by
    letting *x* = −1/*k*, we have 1 − 1/*k* ≤ *e*^(−1/*k*), so that (1 − 1/*k*)*^k*
    ≤ (*e*^(−1/*k*))*^k* = 1/*e*. Denoting the number *i* of iterations by *ck* for
    some nonnegative integer *c*, we want *c* such that
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 由于对于所有实数*x*，都有1 + *x* ≤ *e^x*（参见第66页不等式(3.14)），通过令*x* = −1/*k*，我们有1 − 1/*k*
    ≤ *e*^(−1/*k*)，因此(1 − 1/*k*)*^k* ≤ (*e*^(−1/*k*))*^k* = 1/*e*。将迭代次数*i*表示为*ck*，其中*c*是某个非负整数，我们希望找到*c*，使得
- en: '![art](images/Art_P1500.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1500.jpg)'
- en: Multiplying both sides by *e^c* and then taking the natural logarithm of both
    sides gives *c* ≥ ln |*X*|, so we can choose for *c* any integer that is at least
    ln |*X*|. We choose *c* = ⌈ln |*X*|⌉. Since *i* = *ck* is an upper bound on the
    number of iterations, which equals the size of C, and *k* = |C*|, we have |C|
    ≤ *i* = *ck* = *c* |C*| = |C*| ⌈ln |*X*|⌉, and the theorem follows.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 将两边乘以*e^c*，然后取两边的自然对数得到*c* ≥ ln |*X*|，因此我们可以选择*c*为至少ln |*X*|的任意整数。我们选择*c* =
    ⌈ln |*X*|⌉。由于*i* = *ck*是迭代次数的上界，等于C的大小，而*k* = |C*|，我们有|C| ≤ *i* = *ck* = *c* |C*|
    = |C*| ⌈ln |*X*|⌉，定理得证。
- en: ▪
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Exercises**'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***35.3-1***'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.3-1***'
- en: 'Consider each of the following words as a set of letters: {arid, dash, drain,
    heard, lost, nose, shun, slate, snare, thread}. Show which set cover GREEDY-SET-COVER
    produces when you break ties in favor of the word that appears first in the dictionary.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下每个单词视为一个字母集合：{arid, dash, drain, heard, lost, nose, shun, slate, snare, thread}。展示在偏向字典中首次出现的单词的情况下，GREEDY-SET-COVER产生的集合覆盖。
- en: '***35.3-2***'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.3-2***'
- en: Show that the decision version of the set-covering problem is NP-complete by
    reducing the vertex-cover problem to it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将顶点覆盖问题简化为决策版本的集合覆盖问题，证明集合覆盖问题是NP完全的。
- en: '***35.3-3***'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.3-3***'
- en: Show how to implement GREEDY-SET-COVER to run in *O*(Σ[*S*∈*ℱ*] |*S*|) time.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何实现GREEDY-SET-COVER以在*O*(Σ[*S*∈*ℱ*] |*S*|)时间内运行。
- en: '***35.3-4***'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.3-4***'
- en: 'The proof of Theorem 35.4 says that when GREEDY-SET-COVER, run on the instance
    (*X*, *ℱ*), returns the subfamily C, then |C| ≤ |C*| ⌈ln *X*⌉. Show that the following
    weaker bound is trivially true:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 35.4 的证明表明，当 GREEDY-SET-COVER 在实例 (*X*, *ℱ*) 上运行并返回子族 C 时，|C| ≤ |C*| ⌈ln
    *X*⌉。证明以下更弱的界是显而易见的：
- en: '|C| ≤ |C*| max {|*S*| : *S* ∈ *ℱ*}.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '|C| ≤ |C*| max {|*S*| : *S* ∈ *ℱ*}.'
- en: '***35.3-5***'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.3-5***'
- en: GREEDY-SET-COVER can return a number of different solutions, depending on how
    it breaks ties in line 5\. Give a procedure BAD-SET-COVER-INSTANCE (*n*) that
    returns an *n*-element instance of the set-covering problem for which, depending
    on how line 5 breaks ties, GREEDY-SET-COVER can return a number of different solutions
    that is exponential in *n*.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: GREEDY-SET-COVER 可以返回多种不同的解决方案，取决于它如何在第 5 行中打破平局。给出一个过程 BAD-SET-COVER-INSTANCE
    (*n*)，返回一个包含 *n* 个元素的集合覆盖问题实例，取决于第 5 行如何打破平局，GREEDY-SET-COVER 可以返回指数级的不同解决方案。
- en: '[**35.4    Randomization and linear programming**](toc.xhtml#Rh1-209)'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '[**35.4    随机化和线性规划**](toc.xhtml#Rh1-209)'
- en: 'This section studies two useful techniques for designing approximation algorithms:
    randomization and linear programming. It starts with a simple randomized algorithm
    for an optimization version of 3-CNF satisfiability, and then it shows how to
    design an approximation algorithm for a weighted version of the vertex-cover problem
    based on linear programming. This section only scratches the surface of these
    two powerful techniques. The chapter notes give references for further study of
    these areas.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本节研究了设计近似算法的两种有用技术：随机化和线性规划。它从一个简单的优化版本 3-CNF 可满足性的随机算法开始，然后展示了如何基于线性规划设计一个加权版本的顶点覆盖问题的近似算法。本节只是浅尝辄止这两种强大技术。章节注释提供了进一步研究这些领域的参考资料。
- en: '**A randomized approximation algorithm for MAX-3-CNF satisfiability**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**MAX-3-CNF 可满足性的随机近似算法**'
- en: 'Just as some randomized algorithms compute exact solutions, some randomized
    algorithms compute approximate solutions. We say that a randomized algorithm for
    a problem has an ***approximation ratio*** of *ρ*(*n*) if, for any input of size
    *n*, the *expected* cost *C* of the solution produced by the randomized algorithm
    is within a factor of *ρ*(*n*) of the cost *C** of an optimal solution:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 就像一些随机算法计算精确解决方案一样，一些随机算法计算近似解决方案。我们说一个问题的随机算法具有*ρ*(*n*)的***近似比***，如果对于任何大小为
    *n* 的输入，随机算法产生的解的*期望*成本 *C* 与最优解的��本 *C** 之间的比例因子为 *ρ*(*n*)：
- en: '![art](images/Art_P1501.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1501.jpg)'
- en: We call a randomized algorithm that achieves an approximation ratio of *ρ*(*n*)
    a ***randomized ρ*(*n*)*-approximation algorithm.*** In other words, a randomized
    approximation algorithm is like a deterministic approximation algorithm, except
    that the approximation ratio is for an expected cost.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称一个达到近似比 *ρ*(*n*) 的随机算法为***随机化 ρ*(*n*) 近似算法***。换句话说，随机近似算法类似于确定性近似算法，只是近似比是针对期望成本的。
- en: A particular instance of 3-CNF satisfiability, as defined in [Section 34.4](chapter034.xhtml#Sec_34.4),
    may or may not be satisfiable. In order to be satisfiable, there must exist an
    assignment of the variables so that every clause evaluates to 1\. If an instance
    is not satisfiable, you might instead want to know how “close” to satisfiable
    it is, that is, find an assignment of the variables that satisfies as many clauses
    as possible. We call the resulting maximization problem ***MAX-3-CNF satisfiability***.
    The input to MAX-3-CNF satisfiability is the same as for 3-CNF satisfiability,
    and the goal is to return an assignment of the variables that maximizes the number
    of clauses evaluating to 1\. You might be surprised that randomly setting each
    variable to 1 with probability 1/2 and to 0 with probability 1/2 yields a randomized
    8/7-approximation algorithm, but we’re about to see why. Recall that the definition
    of 3-CNF satisfiability from [Section 34.4](chapter034.xhtml#Sec_34.4) requires
    each clause to consist of exactly three distinct literals. We now further assume
    that no clause contains both a variable and its negation. Exercise 35.4-1 asks
    you to remove this last assumption.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 如 [34.4 节](chapter034.xhtml#Sec_34.4) 中定义的 3-CNF 可满足性的特定实例可能是可满足的，也可能不可满足。为了可满足，必须存在一种变量赋值，使得每个子句评估为
    1。如果一个实例不可满足，你可能希望知道它距离可满足有多“接近”，也就是找到一种变量赋值，使尽可能多的子句得到满足。我们称这个结果最大化问题为***MAX-3-CNF
    可满足性***。MAX-3-CNF 可满足性的输入与 3-CNF 可满足性相同，目标是返回一种变量赋值，最大化评估为 1 的子句数量。你可能会惊讶地发现，随机将每个变量设置为
    1 的概率为 1/2，设置为 0 的概率为 1/2，会产生一个随机的 8/7 近似算法，但我们即将看到原因。回想一下 [34.4 节](chapter034.xhtml#Sec_34.4)
    中对 3-CNF 可满足性的定义要求每个子句由三个不同的文字组成。我们现在进一步假设没有子句包含变量及其否定。练习 35.4-1 要求你移除这最后一个假设。
- en: '***Theorem 35.5***'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 35.5***'
- en: Given an instance of MAX-3-CNF satisfiability with *n* variables *x*[1], *x*[2],
    … , *x[n]* and *m* clauses, the randomized algorithm that independently sets each
    variable to 1 with probability 1/2 and to 0 with probability 1/2 is a randomized
    8/7-approximation algorithm.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 给定具有 *n* 个变量 *x*[1]、*x*[2]、…，*x[n]* 和 *m* 个子句的 MAX-3-CNF 可满足性实例，独立将每个变量设置为 1
    的概率为 1/2，设置为 0 的概率为 1/2 的随机算法是一个随机的 8/7 近似算法。
- en: '***Proof***   Suppose that each variable is independently set to 1 with probability
    1/2 and to 0 with probability 1/2\. Define, for *i* = 1, 2, … , *m*, the indicator
    random variable'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   假设每个变量独立地以概率 1/2 设置为 1，以概率 1/2 设置为 0。定义，对于 *i* = 1, 2, …，*m*，指示器随机变量'
- en: '*Y*[*i*] = I {clause *i* is satisfied},'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*Y*[*i*] = I {子句 *i* 被满足},'
- en: so that *Y[i]* = 1 as long as at least one of the literals in the *i*th clause
    is set to 1\. Since no literal appears more than once in the same clause, and
    since we assume that no variable and its negation appear in the same clause, the
    settings of the three literals in each clause are independent. A clause is not
    satisfied only if all three of its literals are set to 0, and so Pr {clause *i*
    is not satisfied} = (1/2)³ = 1/8\. Thus, we have Pr {clause *i* is satisfied}
    = 1 − 1/8 = 7/8, and Lemma 5.1 on page 130 gives E [*Y[i]*] = 7/8\. Let *Y* be
    the number of satisfied clauses overall, so that *Y* = *Y*[1] + *Y*[2] + ⋯ + *Y[m]*.
    Then, we have
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 使得只要第*i*个子句中的文字之一设置为1，*Y[i]* = 1。由于同一子句中没有文字出现多次，并且我们假设没有变量及其否定同时出现在同一子句中，每个子句中的三个文字的设置是独立的。只有当一个子句的三个文字都设置为0时，子句才不满足，因此Pr
    {子句*i*不满足} = (1/2)³ = 1/8。因此，我们有Pr {子句*i*满足} = 1 − 1/8 = 7/8，而第130页的引理5.1给出了E
    [*Y[i]*] = 7/8。设*Y*是总体满足子句的数量，因此*Y* = *Y*[1] + *Y*[2] + ⋯ + *Y[m]*。那么，我们有
- en: '![art](images/Art_P1502.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1502.jpg)'
- en: Since *m* is an upper bound on the number of satisfied clauses, the approximation
    ratio is at most *m*/(7*m*/8) = 8/7.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*m*是满足子句数量的上界，因此近似比最多为*m*/(7*m*/8) = 8/7。
- en: ▪
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Approximating weighted vertex cover using linear programming**'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用线性规划近似加权顶点覆盖**'
- en: 'The ***minimum-weight vertex-cover problem*** takes as input an undirected
    graph *G* = (*V*, *E*) in which each vertex *v* ∈ *V* has an associated positive
    weight *w*(*v*). The weight *w*(*V*′) of a vertex cover *V*′ ⊆ *V* is the sum
    of the weights of its vertices: *w*(*V*′) = Σ[*v*∈*V′*] *w*(*v*). The goal is
    to find a vertex cover of minimum weight.'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '***最小权重顶点覆盖问题***的输入是一个无向图*G* = (*V*, *E*)，其中每个顶点*v*∈*V*都有一个相关的正权重*w*(*v*)。顶点覆盖*V*′⊆*V*的权重*w*(*V*′)是其顶点权重之和：*w*(*V*′)
    = Σ[*v*∈*V′*] *w*(*v*)。目标是找到最小权重的顶点覆盖。'
- en: The approximation algorithm for unweighted vertex cover from [Section 35.1](chapter035.xhtml#Sec_35.1)
    won’t work here, because the solution it returns could be far from optimal for
    the weighted problem. Instead, we’ll first compute a lower bound on the weight
    of the minimum-weight vertex cover, by using a linear program. Then we’ll “round”
    this solution and use it to obtain a vertex cover.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 来自[第35.1节](chapter035.xhtml#Sec_35.1)的无权顶点覆盖的近似算法在这里不起作用，因为它返回的解可能远非加权问题的最优解。相反，我们将首先通过线性规划计算最小权重顶点覆盖的下界。然后我们将“舍入”这个解并用它来获得一个顶点覆盖。
- en: 'Start by associating a variable *x*(*v*) with each vertex *v* ∈ *V*, and require
    that *x*(*v*) equals either 0 or 1 for each *v* ∈ *V*. The vertex cover includes
    *v* if and only if *x*(*v*) = 1\. Then the constraint that for any edge (*u*,
    *v*), at least one of *u* and *v* must belong to the vertex cover can be expressed
    as *x*(*u*) + *x*(*v*) ≥ 1\. This view gives rise to the following ***0-1 integer
    program*** for finding a minimum-weight vertex cover:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，将每个顶点*v*∈*V*关联一个变量*x*(*v*)，并要求对于每个*v*∈*V*，*x*(*v*)等于0或1。如果*x*(*v*) = 1，则顶点覆盖包括*v*。然后，对于任意边(*u*,
    *v*)，至少*u*和*v*中的一个必须属于顶点覆盖的约束可以表示为*x*(*u*) + *x*(*v*) ≥ 1。这个视角引出了用于寻找最小权重顶点覆盖的以下***0-1整数规划***：
- en: '![art](images/Art_P1503.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1503.jpg)'
- en: subject to
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 满足
- en: '![art](images/Art_P1504.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1504.jpg)'
- en: 'In the special case in which all the weights *w*(*v*) equal 1, this formulation
    is the optimization version of the NP-hard vertex-cover problem. Let’s remove
    the constraint that *x*(*v*) ∈ {0, 1} and replace it by 0 ≤ *x*(*v*) ≤ 1, resulting
    in the following linear program:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有权重*w*(*v*)均为1的特殊情况下，这个公式是NP难的顶点覆盖问题的优化版本。让我们去掉*x*(*v*)∈{0, 1}的约束，并用0 ≤ *x*(*v*)
    ≤ 1替换它，得到以下线性规划：
- en: '![art](images/Art_P1505.jpg)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1505.jpg)'
- en: subject to
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 满足
- en: '![art](images/Art_P1506.jpg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1506.jpg)'
- en: We refer to this linear program as the ***linear-programming relaxation***.
    Any feasible solution to the 0-1 integer program in lines (35.12)–(35.14) is also
    a feasible solution to its linear-programming relaxation in lines (35.15)–(35.18).
    Therefore, the value of an optimal solution to the linear-programming relaxation
    provides a lower bound on the value of an optimal solution to the 0-1 integer
    program, and hence a lower bound on the optimal weight in the minimum-weight vertex-cover
    problem.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将这个线性规划称为***线性规划松弛***。在第(35.12)–(35.14)行中0-1整数规划的任何可行解也是第(35.15)–(35.18)行中其线性规划松弛的可行解。因此，线性规划松弛的最优解值提供了0-1整数规划最优解值的下界，从而提供了最小权重顶点覆盖问题的最优权重下界。
- en: 'The procedure APPROX-MIN-WEIGHT-VC on the facing page starts with a solution
    to the linear-programming relaxation and uses it to construct an approximate solution
    to the minimum-weight vertex-cover problem. The procedure works as follows. Line
    1 initializes the vertex cover to be empty. Line 2 formulates the linear-programming
    relaxation in lines (35.15)–(35.18) and then solves this linear program. An optimal
    solution gives each vertex *v* an associated value *x*(*v*), where 0 ≤ *x*(*v*)
    ≤ 1\. The procedure uses this value to guide the choice of which vertices to add
    to the vertex cover *C* in lines 3–5: the vertex cover *C* includes vertex *v*
    if and only if *x*(*v*) ≥ 1/2\. In effect, the procedure “rounds” each fractional
    variable in the solution to the linear-programming relaxation to either 0 or 1
    in order to obtain a solution to the 0-1 integer program in lines (35.12)–(35.14).
    Finally, line 6 returns the vertex cover *C*.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 面对页面的APPROX-MIN-WEIGHT-VC过程从线性规划松弛的解开始，并使用它构建一个最小权重顶点覆盖问题的近似解。该过程的工作方式如下。第1行将顶点覆盖初始化为空。第2行制定了第(35.15)–(35.18)行中的线性规划松弛，然后解决这个线性规划。最优解为每个顶点*v*分配一个相关值*x*(*v*)，其中0
    ≤ *x*(*v*) ≤ 1。该过程使用这个值来指导在第3–5行中将哪些顶点添加到顶点覆盖*C*中：当且仅当*x*(*v*) ≥ 1/2时，顶点覆盖*C*包括顶点*v*。实际上，该过程将解中的每个分数变量“舍入”为0或1，以获得第(35.12)–(35.14)行中0-1整数规划的解。最后，第6行返回顶点覆盖*C*。
- en: '***Theorem 35.6***'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理35.6***'
- en: Algorithm APPROX-MIN-WEIGHT-VC is a polynomial-time2-approximation algorithm
    for the minimum-weight vertex-cover problem.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 算法APPROX-MIN-WEIGHT-VC是最小权重顶点覆盖问题的一个多项式时间2近似算法。
- en: APPROX-MIN-WEIGHT-VC (*G*, *w*)
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: APPROX-MIN-WEIGHT-VC(*G*, *w*)
- en: '| 1 | *C* = Ø |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *C* = Ø |'
- en: '| 2 | compute *x*, an optimal solution to the linear-programming relaxation
    in lines (35.15)–(35.18) |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 计算*x*，线性规划松弛(35.15)–(35.18)行的最优解 |'
- en: '| 3 | **for** each vertex *v* ∈ *V* |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **对于** 每个顶点 *v* ∈ *V* |'
- en: '| 4 | **if** *x*(*v*) ≥ 1/2 |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **如果** *x*(*v*) ≥ 1/2 |'
- en: '| 5 | *C* = *C* ∪ {*v*} |'
  id: totrans-214
  prefs: []
  type: TYPE_TB
  zh: '| 5 | *C* = *C* ∪ {*v*} |'
- en: '| 6 | **return** *C* |'
  id: totrans-215
  prefs: []
  type: TYPE_TB
  zh: '| 6 | **返回** *C* |'
- en: '***Proof***   Because there is a polynomial-time algorithm to solve the linear
    program in line 2, and because the **for** loop of lines 3–5 runs in polynomial
    time, APPROX-MIN-WEIGHT-VC is a polynomial-time algorithm.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 因为有一个多项式时间算法来解决第2行中的线性规划，且因为第3–5行的**for**循环在多项式时间内运行，APPROX-MIN-WEIGHT-VC是一个多项式时间算法。'
- en: It remains to show that APPROX-MIN-WEIGHT-VC is a 2-approximation algorithm.
    Let *C** be an optimal solution to the minimum-weight vertex-cover problem, and
    let *z** be the value of an optimal solution to the linear-programming relaxation
    in lines (35.15)–(35.18). Since an optimal vertex cover is a feasible solution
    to the linear-programming relaxation, *z** must be a lower bound on *w*(*C**),
    that is,
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 需要证明APPROX-MIN-WEIGHT-VC是一个2近似算法。让*C*是最小权重顶点覆盖问题的最优解，*z*是在(35.15)–(35.18)行中线性规划松弛的最优解的值。由于最优顶点覆盖是线性规划松弛的可行解，*z*必须是*w*(*C*)的下界，即，
- en: '![art](images/Art_P1507.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1507.jpg)'
- en: Next, we claim that rounding the fractional values of the variables *x*(*v*)
    in lines 3–5 produces a set *C* that is a vertex cover and satisfies *w*(*C*)
    ≤ 2*z**. To see that *C* is a vertex cover, consider any edge (*u*, *v*) ∈ *E*.
    By constraint (35.16), we know that *x*(*u*) + *x*(*v*) ≥ 1, which implies that
    at least one of *x*(*u*) and *x*(*v*) is at least 1/2\. Therefore, at least one
    of *u* and *v* is included in the vertex cover, and so every edge is covered.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们声称在第3–5行中对变量*x*(*v*)的分数值四舍五入会产生一个顶点覆盖集*C*，并且满足*w*(*C*) ≤ 2*z*。要看到*C*是一个顶点覆盖，考虑任意边(*u*,
    *v*) ∈ *E*。根据约束(35.16)，我们知道*x*(*u*) + *x*(*v*) ≥ 1，这意味着*x*(*u*)和*x*(*v*)中至少一个至少为1/2。因此，*u*和*v*中至少一个包含在顶点覆盖中，因此每条边都被覆盖。
- en: Now we consider the weight of the cover. We have
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们考虑覆盖的重量。我们有
- en: '![art](images/Art_P1508.jpg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1508.jpg)'
- en: Combining inequalities (35.19) and (35.20) gives
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 结合不等式(35.19)和(35.20)得到
- en: '*w*(*C*) ≤ 2*z** ≤ 2*w*(*C**),'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '*w*(*C*) ≤ 2*z* ≤ 2*w*(*C**),'
- en: and hence APPROX-MIN-WEIGHT-VC is a 2-approximation algorithm.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 因此APPROX-MIN-WEIGHT-VC是一个2近似算法。
- en: ▪
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Exercises**'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***35.4-1***'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.4-1***'
- en: Show that even if a clause is allowed to contain both a variable and its negation,
    randomly setting each variable to 1 with probability 1/2 and to 0 with probability
    1/2 still yields a randomized 8/7-approximation algorithm.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 显示即使一个子句允许包含一个变量及其否定，随机将每个变量设置为1的概率为1/2，设置为0的概率为1/2仍会产生一个随机的8/7近似算法。
- en: '***35.4-2***'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.4-2***'
- en: The ***MAX-CNF satisfiability problem*** is like the MAX-3-CNF satisfiability
    problem, except that it does not restrict each clause to have exactly three literals.
    Give a randomized 2-approximation algorithm for the MAX-CNF satisfiability problem.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '***MAX-CNF可满足性问题***类似于MAX-3-CNF可满足性问题，不过它不限制每个子句只有三个文字。给出MAX-CNF可满足性问题的一个随机的2近似算法。'
- en: '***35.4-3***'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.4-3***'
- en: In the MAX-CUT problem, the input is an unweighted undirected graph *G* = (*V*,
    *E*). We define a cut (*S*, *V* − *S*) as in [Chapter 21](chapter021.xhtml) and
    the ***weight*** of a cut as the number of edges crossing the cut. The goal is
    to find a cut of maximum weight. Suppose that each vertex *v* is randomly and
    independently placed into *S* with probability 1/2 and into *V* −*S* with probability
    1/2\. Show that this algorithm is a randomized 2-approximation algorithm.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在MAX-CUT问题中，输入是一个无权无向图*G* = (*V*, *E*)。我们定义一个切割(*S*, *V* − *S*)如[第21章](chapter021.xhtml)中所述，切割的***权重***是穿过切割的边的数量。���标是找到最大权重的切割。假设每个顶点*v*以1/2的概率随机且独立地放入*S*，以1/2的概率放入*V*
    −*S*。证明这个算法是一个随机的2近似算法。
- en: '***35.4-4***'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.4-4***'
- en: Show that the constraints in line (35.17) are redundant in the sense that removing
    them from the linear-programming relaxation in lines (35.15)–(35.18) yields a
    linear program for which any optimal solution *x* must satisfy *x*(*v*) ≤ 1 for
    each *v* ∈ *V*.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 显示第(35.17)行中的约束是冗余的，即从(35.15)–(35.18)行中的线性规划松弛中删除它们会产生一个线性规划，其中任何最优解*x*必须满足对于每个*v*
    ∈ *V*，*x*(*v*) ≤ 1。
- en: '[**35.5    The subset-sum problem**](toc.xhtml#Rh1-210)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '[**35.5    子集和问题**](toc.xhtml#Rh1-210)'
- en: Recall from [Section 34.5.5](chapter034.xhtml#Sec_34.5.5) that an instance of
    the subset-sum problem is given by a pair (*S*, *t*), where *S* is a set {*x*[1],
    *x*[2], … , *x[n]*} of positive integers and *t* is a positive integer. This decision
    problem asks whether there exists a subset of *S* that adds up exactly to the
    target value *t*. As we saw in [Section 34.5.5](chapter034.xhtml#Sec_34.5.5),
    this problem is NP-complete.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 从[34.5.5节](chapter034.xhtml#Sec_34.5.5)回顾，子集和问题的一个实例由一对(*S*, *t*)给出，其中*S*是一组{*x*[1],
    *x*[2], … , *x[n]*}的正整数，*t*是一个正整数。这个决策问题询问是否存在一个*S*的子集，其总和恰好等于目标值*t*。正如我们在[34.5.5节](chapter034.xhtml#Sec_34.5.5)中看到的，这个问题是NP完全的。
- en: The optimization problem associated with this decision problem arises in practical
    applications. The optimization problem seeks a subset of {*x*[1], *x*[2], … ,
    *x[n]*} whose sum is as large as possible but not larger than *t*. For example,
    consider a truck that can carry no more than *t* pounds, which is to be loaded
    with up to *n* different boxes, the *i*th of which weighs *x[i]* pounds. How heavy
    a load can the truck take without exceeding the *t*-pound weight limit?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 与这个决策问题相关的优化问题在实际应用中出现。优化问题寻求一个{*x*[1], *x*[2], … , *x[n]*}的子集，其总和尽可能大但不超过*t*。例如，考虑一辆最多能装载*t*磅的卡车，需要装载最多*n*个不同的箱子，第*i*个箱子的重量为*x[i]*磅。卡车可以承载多重货物而不超过*t*磅的重量限制？
- en: We start this section with an exponential-time algorithm to compute the optimal
    value for this optimization problem. Then we show how to modify the algorithm
    so that it becomes a fully polynomial-time approximation scheme. (Recall that
    a fully polynomial-time approximation scheme has a running time that is polynomial
    in 1/*ϵ* as well as in the size of the input.)
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从一个指数时间算法开始，计算这个优化问题的最优值。然后我们展示如何修改算法，使其成为一个完全多项式时间逼近方案。（回想一下，一个完全多项式时间逼近方案的运行时间是
    1/*ϵ* 的多项式，以及输入大小的多项式。）
- en: '**An exponential-time exact algorithm**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个指数时间的精确算法**'
- en: Suppose that you compute, for each subset *S*′ of *S*, the sum of the elements
    in *S*′, and then you select, among the subsets whose sum does not exceed *t*,
    the one whose sum is closest to *t*. This algorithm returns the optimal solution,
    but it might take exponential time. To implement this algorithm, you can use an
    iterative procedure that, in iteration *i*, computes the sums of all subsets of
    {*x*[1], *x*[2], … , *x[i]*}, using as a starting point the sums of all subsets
    of {*x*[1], *x*[2], … , *x*[*i*−1]}. In doing so, you would realize that once
    a particular subset *S*′ has a sum exceeding *t*, there is no reason to maintain
    it, since no superset of *S*′ can be an optimal solution. Let’s see how to implement
    this strategy.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你计算每个子集 *S*′ 的元素之和，然后在不超过 *t* 的子集中选择最接近 *t* 的子集。这个算法返回最优解，但可能需要指数时间。要实现这个算法，可以使用一个迭代过程，在第
    *i* 次迭代中，计算 {*x*[1], *x*[2], … , *x[i]*} 的所有子集的和，起始点是 {*x*[1], *x*[2], … , *x*[*i*−1]}
    的所有子集的和。在这样做时，你会意识到一旦特定子集 *S*′ 的和超过 *t*，就没有理由维护它，因为 *S*′ 的任何超集都不可能是最优解。让我们看看如何实现这个策略。
- en: The procedure EXACT-SUBSET-SUM takes an input set *S* = {*x*[1], *x*[2], … ,
    *x[n]*}, the size *n* = |*S*|, and a target value *t*. This procedure iteratively
    computes *L[i]*, the list of sums of all subsets of {*x*[1], … , *x[i]*} that
    do not exceed *t*, and then it returns the maximum value in *L[n]*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 过程 EXACT-SUBSET-SUM 接受一个输入集合 *S* = {*x*[1], *x*[2], … , *x[n]*}，大小 *n* = |*S*|，目标值
    *t*。该过程迭代计算 *L[i]*，{*x*[1], … , *x[i]*} 的所有子集的和列表，这些和不超过 *t*，然后返回 *L[n]* 中的最大值。
- en: If *L* is a list of positive integers and *x* is another positive integer, then
    let *L* + *x* denote the list of integers derived from *L* by increasing each
    element of *L* by *x*. For example, if *L* = 〈1, 2, 3, 5, 9〉, then *L* + 2 = 〈3,
    4, 5, 7, 11〉. This notation extends to sets, so that
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *L* 是一个正整数列表，*x* 是另一个正整数，则让 *L* + *x* 表示从 *L* 派生的整数列表，通过将 *L* 的每个元素增加 *x*。例如，如果
    *L* = 〈1, 2, 3, 5, 9〉，那么 *L* + 2 = 〈3, 4, 5, 7, 11〉。这种表示法扩展到集合，因此
- en: '*S* + *x* = {*s* + *x* : *s* ∈ *S*}.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '*S* + *x* = {*s* + *x* : *s* ∈ *S*}.'
- en: EXACT-SUBSET-SUM (*S*, *n, t*)
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: EXACT-SUBSET-SUM (*S*, *n, t*)
- en: '| 1 | *L*[0] = 〈0〉 |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *L*[0] = 〈0〉 |'
- en: '| 2 | **for** *i* = 1 **to** *n* |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **对于** *i* = 1 **到** *n* |'
- en: '| 3 | *L[i]* = MERGE-LISTS (*L*[*i*−1], *L*[*i*−1] + *x[i]*) |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *L[i]* = MERGE-LISTS (*L*[*i*−1], *L*[*i*−1] + *x[i]*) |'
- en: '| 4 | remove from *L[i]* every element that is greater than *t* |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 从 *L[i]* 中移除大于 *t* 的每个元素 |'
- en: '| 5 | **return** the largest element in *L*[*n*] |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **返回** *L*[*n*] 中的最大元素 |'
- en: EXACT-SUBSET-SUM invokes an auxiliary procedure MERGE-LISTS (*L*, *L*′), which
    returns the sorted list that is the merge of its two sorted input lists *L* and
    *L*′, with duplicate values removed. Like the MERGE procedure we used in merge
    sort on page 36, MERGE-LISTS runs in *O*(|*L*| + |*L*′|) time. We omit the pseudocode
    for MERGE-LISTS.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: EXACT-SUBSET-SUM 调用一个辅助过程 MERGE-LISTS (*L*, *L*′)，返回其两个已排序输入列表 *L* 和 *L*′ 的合并列表，去除重复值。就像我们在第36页上使用的合并排序中使用的
    MERGE 过程一样，MERGE-LISTS 在 *O*(|*L*| + |*L*′|) 时间内运行。我们省略了 MERGE-LISTS 的伪代码。
- en: To see how EXACT-SUBSET-SUM works, let *P[i]* denote the set of values obtained
    by selecting each (possibly empty) subset of {*x*[1], *x*[2], … , *x[i]*} and
    summing its members. For example, if *S* = {1, 4, 5}, then
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 EXACT-SUBSET-SUM 的工作原理，让 *P[i]* 表示通过选择 {*x*[1], *x*[2], … , *x[i]*} 的每个（可能为空）子集并求和其成员得到的值集合。例如，如果
    *S* = {1, 4, 5}，那么
- en: '| *P*[1] | = | {0, 1}, |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| *P*[1] | = | {0, 1}, |'
- en: '| *P*[2] | = | {0, 1, 4, 5}, |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| *P*[2] | = | {0, 1, 4, 5}, |'
- en: '| *P*[3] | = | {0, 1, 4, 5, 6, 9, 10}. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| *P*[3] | = | {0, 1, 4, 5, 6, 9, 10}. |'
- en: Given the identity
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 给定身份
- en: '![art](images/Art_P1509.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1509.jpg)'
- en: you can prove by induction on *i* (see Exercise 35.5-1) that the list *L[i]*
    is a sorted list containing every element of *P[i]* whose value is not more than
    *t*. Since the length of *L[i]* can be as much as 2^(*i*), EXACT-SUBSET-SUM is
    an exponential-time algorithm in general, although it is a polynomial-time algorithm
    in the special cases in which *t* is polynomial in |*S*| or all the numbers in
    *S* are bounded by a polynomial in |*S*|.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过对 *i* 进行归纳证明（见练习35.5-1），列表 *L[i]* 是一个排序列表，包含 *P[i]* 中值不超过 *t* 的每个元素。由于
    *L[i]* 的长度最多可以达到 2^(*i*)，所以 EXACT-SUBSET-SUM 通常是一个指数时间算法，尽管在 *t* 是 |*S*| 的多项式或
    *S* 中的所有数字受到 |*S*| 的多项式限制的特殊情况下，它是一个多项式时���算法。
- en: '**A fully polynomial-time approximation scheme**'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个完全多项式时间逼近方案**'
- en: 'The key to devising a fully polynomial-time approximation scheme for the subset-sum
    problem is to “trim” each list *L[i]* after it is created. Here’s the idea behind
    trimming: if two values in *L* are close to each other, then since the goal is
    just an approximate solution, there is no need to maintain both of them explicitly.
    More precisely, use a trimming parameter *δ* such that 0 < *δ* < 1\. When ***trimming***
    a list *L* by *δ*, remove as many elements from *L* as possible, in such a way
    that if *L*′ is the result of trimming *L*, then for every element *y* that was
    removed from *L*, some element *z* still in *L*′ approximates *y*. For *z* to
    approximate *y*, it must be no greater than *y* and also within a factor of 1
    + *δ* of *y*, so that'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个完全多项式时间逼近方案的关键是在创建每个列表 *L[i]* 后“修剪”它们。修剪的背后思想是：如果 *L* 中的两个值接近，那么由于目标只是一个近似解，就没有必要显式地维护它们。更确切地说，使用修剪参数
    *δ*，使得 0 < *δ* < 1。当通过 *δ* 修剪列表 *L* 时，尽可能多地从 *L* 中移除元素，这样，如果 *L*′ 是修剪 *L* 的结果，则对于每个从
    *L* 中移除的元素 *y*，仍在 *L*′ 中的某个元素 *z* 近似于 *y*。为了使 *z* 近似于 *y*，它必须不大于 *y*，并且在 1 + *δ*
    的因子内接近 *y*，以便
- en: '![art](images/Art_P1510.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1510.jpg)'
- en: You can think of such a *z* as “representing” *y* in the new list *L*′. Each
    removed element *y* is represented by a remaining element *z* satisfying inequality
    (35.22). For example, suppose that *δ* = 0.1 and
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这样的 *z* 视为在新列表 *L*′ 中“表示” *y*。每个删除的元素 *y* 都由满足不等式 (35.22) 的剩余元素 *z* 表示。例如，假设
    *δ* = 0.1 和
- en: '*L* = 〈10, 11, 12, 15, 20, 21, 22, 23, 24, 29〉.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '*L* = 〈10, 11, 12, 15, 20, 21, 22, 23, 24, 29〉.'
- en: Then trimming *L* results in
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 然后修剪 *L* 的结果是
- en: '*L*′ = 〈10, 12, 15, 20, 23, 29〉,'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '*L*′ = 〈10, 12, 15, 20, 23, 29〉,'
- en: where the deleted value 11 is represented by 10, the deleted values 21 and 22
    are represented by 20, and the deleted value 24 is represented by 23\. Because
    every element of the trimmed version of the list is also an element of the original
    version of the list, trimming can dramatically decrease the number of elements
    kept while keeping a close (and slightly smaller) representative value in the
    list for each deleted element.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 其中删除的值 11 由 10 表示，删除的值 21 和 22 由 20 表示，删除的值 24 由 23 表示。因为修剪后列表的每个元素也是原始列表的元素，所以修剪可以显著减少保留的元素数量，同时保持每个删除元素的一个接近（稍小）的代表值。
- en: The procedure TRIM trims list *L* = 〈*y*[1], *y*[2], … , *y[m]*〉 in Θ(*m*) time,
    given *L* and the trimming parameter *δ*. It assumes that *L* is sorted into monotonically
    increasing order. The output of the procedure is a trimmed, sorted list. The procedure
    scans the elements of *L* in monotonically increasing order. A number is appended
    onto the returned list *L*′ only if it is the first element of *L* or if it cannot
    be represented by the most recent number placed into *L*′.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 过程 TRIM 在 Θ(*m*) 时间内修剪列表 *L* = 〈*y*[1], *y*[2], … , *y[m]*〉，给定 *L* 和修剪参数 *δ*。它假设
    *L* 已按单调递增顺序排序。该过程的输出是一个修剪后的、排序后的列表。该过程按单调递增顺序扫描 *L* 的元素。仅当它是 *L*′ 中的第一个元素或者不能由最近放入
    *L*′ 的数字表示时，才将数字附加到返回的列表 *L*′ 上。
- en: TRIM (*L*, *δ*)
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 修剪 (*L*, *δ*)
- en: '| 1 | let *m* be the length of *L* |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 让 *m* 为 *L* 的长度 |'
- en: '| 2 | *L*′ = 〈*y*[1]〉 |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *L*′ = 〈*y*[1]〉 |'
- en: '| 3 | *last* = *y*[1] |'
  id: totrans-270
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *last* = *y*[1] |'
- en: '| 4 | **for** *i* = 2 **to** *m* |'
  id: totrans-271
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **对于** *i* = 2 **到** *m* |'
- en: '| 5 | **if** *y*[*i*] > *last* · (1 + *δ*) | **//** *y[i]* ≥ *last* because
    *L* is sorted |'
  id: totrans-272
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **如果** *y*[*i*] > *last* · (1 + *δ*) | **//** 因为 *L* 已排序，所以 *y[i]* ≥
    *last* |'
- en: '| 6 | append *y[i]* onto the end of *L*′ |'
  id: totrans-273
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 将 *y[i]* 附加到 *L*′ 的末尾 |'
- en: '| 7 | *last* = *y[i]* |'
  id: totrans-274
  prefs: []
  type: TYPE_TB
  zh: '| 7 | *last* = *y[i]* |'
- en: '| 8 | **return** *L*′ |'
  id: totrans-275
  prefs: []
  type: TYPE_TB
  zh: '| 8 | **返回** *L*′ |'
- en: Given the procedure TRIM, the procedure APPROX-SUBSET-SUM on the following page
    implements the approximation scheme. This procedure takes as input a set *S* =
    {*x*[1], *x*[2], … , *x[n]*} of *n* integers (in arbitrary order), the size *n*
    = |*S*|, the target integer *t*, and an approximation parameter *ϵ*, where
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 给定过程 TRIM，下一页的 APPROX-SUBSET-SUM 过程实现了近似方案。该过程将一个包含 *n* 个整数（任意顺序）的集合 *S* = {*x*[1],
    *x*[2], … , *x[n]*}、大小 *n* = |*S*|、目标整数 *t* 和近似参数 *ϵ* 作为输入，其中
- en: '![art](images/Art_P1511.jpg)'
  id: totrans-277
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1511.jpg)'
- en: It returns a value *z** whose value is within a factor of 1 + *ϵ* of the optimal
    solution.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 它返回一个值 *z**，其值在最优解的 1 + *ϵ* 范围内。
- en: The APPROX-SUBSET-SUM procedure works as follows. Line 1 initializes the list
    *L*[0] to be the list containing just the element 0\. The **for** loop in lines
    2–5 computes *L[i]* as a sorted list containing a suitably trimmed version of
    the set *P[i]*, with all elements larger than *t* removed. Since the procedure
    creates *L[i]* from *L*[*i*−1], it must ensure that the repeated trimming doesn’t
    introduce too much compounded inaccuracy. That’s why instead of the trimming parameter
    being *ϵ* in the call to TRIM, it has the smaller value *ϵ*/2*n*. We’ll soon see
    that APPROX-SUBSET-SUM returns a correct approximation if one exists.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 近似子集和过程的工作方式如下。第 1 行将列表 *L*[0] 初始化为仅包含元素 0 的列表。第 2–5 行的 **for** 循环计算 *L[i]*，作为包含适当修剪版本的集合
    *P[i]* 的排序列表，所有大于 *t* 的元素都被移除。由于该过程从 *L*[*i*−1] 创建 *L[i]*，因此必须确保重复修剪不会引入太多的累积不准确性。这就是为什么在调用
    TRIM 时，修剪参数不是 *ϵ*，而是较��的值 *ϵ*/2*n*。我们很快将看到，如果存在正确的近似值，APPROX-SUBSET-SUM 将返回一个正确的近似值。
- en: APPROX-SUBSET-SUM (*S*, *n, t, ϵ*)
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 近似子集和 (*S*, *n, t, ϵ*)
- en: '| 1 | *L*[0] = 〈0〉 |'
  id: totrans-281
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *L*[0] = 〈0〉 |'
- en: '| 2 | **for** *i* = 1 **to** *n* |'
  id: totrans-282
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **对于** *i* = 1 **到** *n* |'
- en: '| 3 | *L[i]* = MERGE-LISTS (*L*[*i*−1], *L*[*i*−1] + *x[i]*) |'
  id: totrans-283
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *L[i]* = 合并列表 (*L*[*i*−1], *L*[*i*−1] + *x[i]*) |'
- en: '| 4 | *L[i]* = TRIM (*L*[*i*], *ϵ*/2*n*) |'
  id: totrans-284
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *L[i]* = 修剪 (*L*[*i*], *ϵ*/2*n*) |'
- en: '| 5 | remove from *L[i]* every element that is greater than *t* |'
  id: totrans-285
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 从 *L[i]* 中删除大于 *t* 的每个元素 |'
- en: '| 6 | let *z** be the largest value in *L[n]* |'
  id: totrans-286
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 让 *z** 为 *L[n]* 中的最大值 |'
- en: '| 7 | **return** *z** |'
  id: totrans-287
  prefs: []
  type: TYPE_TB
  zh: '| 7 | **返回** *z** |'
- en: As an example, suppose that APPROX-SUBSET-SUM is given
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，假设 APPROX-SUBSET-SUM 给出
- en: '*S* = 〈104, 102, 201, 101〉'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '*S* = 〈104, 102, 201, 101〉'
- en: 'with *t* = 308 and *ϵ* = 0.40\. The trimming parameter *δ* is *ϵ*/2*n* = 0.40/80
    = 0.05\. The procedure computes the following values on the indicated lines:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *t* = 308 且 *ϵ* = 0.40 时。修剪参数 *δ* 为 *ϵ*/2*n* = 0.40/80 = 0.05。该过程在指定的行上计算以下数值：
- en: '| line 1: | *L*[0] = 〈0〉, |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| 第 1 行: | *L*[0] = 〈0〉, |'
- en: '| line 3: | *L*[1] = 〈0, 104〉, |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '| 第 3 行: | *L*[1] = 〈0, 104〉, |'
- en: '| line 4: | *L*[1] = 〈0, 104〉, |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '| 第 4 行: | *L*[1] = 〈0, 104〉, |'
- en: '| line 5: | *L*[1] = 〈0, 104〉, |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '| 第 5 行: | *L*[1] = 〈0, 104〉, |'
- en: '| line 3: | *L*[2] = 〈0, 102, 104, 206〉, |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '| 第 3 行: | *L*[2] = 〈0, 102, 104, 206〉, |'
- en: '| line 4: | *L*[2] = 〈0, 102, 206〉, |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '| 第 4 行: | *L*[2] = 〈0, 102, 206〉, |'
- en: '| line 5: | *L*[2] = 〈0, 102, 206〉, |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '| 第 5 行: | *L*[2] = 〈0, 102, 206〉, |'
- en: '| line 3: | *L*[3] = 〈0, 102, 201, 206, 303, 407〉, |'
  id: totrans-298
  prefs: []
  type: TYPE_TB
  zh: '| 第 3 行: | *L*[3] = 〈0, 102, 201, 206, 303, 407〉, |'
- en: '| line 4: | *L*[3] = 〈0, 102, 201, 303, 407〉, |'
  id: totrans-299
  prefs: []
  type: TYPE_TB
  zh: '| 第 4 行: | *L*[3] = 〈0, 102, 201, 303, 407〉, |'
- en: '| line 5: | *L*[3] = 〈0, 102, 201, 303〉, |'
  id: totrans-300
  prefs: []
  type: TYPE_TB
  zh: '| 第 5 行: | *L*[3] = 〈0, 102, 201, 303〉, |'
- en: '| line 3: | *L*[4] = 〈0, 101, 102, 201, 203, 302, 303, 404〉, |'
  id: totrans-301
  prefs: []
  type: TYPE_TB
  zh: '| 第 3 行: | *L*[4] = 〈0, 101, 102, 201, 203, 302, 303, 404〉, |'
- en: '| line 4: | *L*[4] = 〈0, 101, 201, 302, 404〉, |'
  id: totrans-302
  prefs: []
  type: TYPE_TB
  zh: '| 第 4 行: | *L*[4] = 〈0, 101, 201, 302, 404〉, |'
- en: '| line 5: | *L*[4] = 〈0, 101, 201, 302〉. |'
  id: totrans-303
  prefs: []
  type: TYPE_TB
  zh: '| 第 5 行: | *L*[4] = 〈0, 101, 201, 302〉。 |'
- en: The procedure returns *z** = 302 as its answer, which is well within *ϵ* = 40%
    of the optimal answer 307 = 104 + 102 + 101\. In fact, it is within 2%.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 该过程返回 *z** = 302 作为其答案，这个答案很好地在最优答案 307 = 104 + 102 + 101 的 *ϵ* = 40% 范围内。实际上，它在
    2% 范围内。
- en: '***Theorem 35.7***'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 35.7***'
- en: APPROX-SUBSET-SUM is a fully polynomial-time approximation scheme for the subset-sum
    problem.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: APPROX-SUBSET-SUM是子集和问题的全多项式时间逼近方案。
- en: '***Proof***   The operations of trimming *L[i]* in line 4 and removing from
    *L[i]* every element that is greater than *t* maintain the property that every
    element of *L[i]* is also a member of *P[i]*. Therefore, the value *z** returned
    in line 7 is indeed the sum of some subset of *S*, that is, *z** ∈ *P[n]*. Let
    *y** ∈ *P[n]* denote an optimal solution to the subset-sum problem, so that it
    is the greatest value in *P[n]* that is less than or equal to *t*. Because line
    5 ensures that *z** ≤ *t*, we know that *z** ≤ *y**. By inequality (35.1), we
    need to show that *y**/*z** ≤ 1 + *ϵ*. We must also show that the running time
    of this algorithm is polynomial in both 1/*ϵ* and the size of the input.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   第4行中修剪*L[i]* 和从*L[i]* 中删除大于*t* 的每个元素的操作保持*L[i]* 的每个元素也是*P[i]* 的成员。因此，第7行返回的值*z**
    确实是*S* 的某个子集的和，即*z** ∈ *P[n]*。让*y** ∈ *P[n]* 表示子集和问题的最优解，使得它是小于或等于*t* 的*P[n]*
    中的最大值。因为第5行确保*z** ≤ *t*，我们知道*z** ≤ *y**。根据不等式（35.1），我们需要证明*y**/*z** ≤ 1 + *ϵ*。我们还必须证明该算法的运行时间对1/*ϵ*
    和输入大小都是多项式的。'
- en: As Exercise 35.5-2 asks you to show, for every element *y* in *P[i]* that is
    at most *t*, there exists an element *z* ∈ *L[i]* such that
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 正如练习35.5-2要求的那样，对于*P[i]* 中最多为*t*的每个元素*y*，存在一个元素*z* ∈ *L[i]*，使得
- en: '![art](images/Art_P1512.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1512.jpg)'
- en: Inequality (35.24) must hold for *y** ∈ *P[n]*, and therefore there exists an
    element *z* ∈ *L[n]* such that
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 不等式（35.24）必须对*P[n]* 中的*y** 成立，因此存在一个元素*z* ∈ *L[n]*，使得
- en: '![art](images/Art_P1513.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1513.jpg)'
- en: and thus
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 因此
- en: '![art](images/Art_P1514.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1514.jpg)'
- en: Since there exists an element *z* ∈ *L[n]* fulfilling inequality (35.25), the
    inequality must hold for *z**, which is the largest value in *L[n]*, which is
    to say
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 由于存在一个元素*z* ∈ *L[n]* 满足不等式（35.25），因此不等式必须对*z** 成立，而*z** 是*L[n]* 中的最大值，也就是说
- en: '![art](images/Art_P1515.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1515.jpg)'
- en: Now we show that *y**/*z** ≤ 1 + *ϵ*. We do so by showing that (1 +*ϵ*/2*n*)*^n*
    ≤ 1 + *ϵ*. First, inequality (35.23), 0 < *ϵ* < 1, implies that
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们要证明*y**/*z** ≤ 1 + *ϵ*。我们通过证明（1 +*ϵ*/2*n*）*^n* ≤ 1 + *ϵ* 来实现这一点。首先，不等式（35.23），0
    < *ϵ* < 1，意味着
- en: '![art](images/Art_P1516.jpg)'
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1516.jpg)'
- en: Next, from equation (3.16) on page 66, we have lim[*n*→∞](1 + *ϵ*/2*n*)*^n*
    = *e*^(*ϵ*/2). Exercise 35.5-3 asks you to show that
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，根据第66页方程（3.16），我们有lim[*n*→∞](1 + *ϵ*/2*n*)*^n* = *e*^(*ϵ*/2)。练习35.5-3要求你证明
- en: '![art](images/Art_P1517.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1517.jpg)'
- en: Therefore, the function (1 + *ϵ*/2*n*)*^n* increases with *n* as it approaches
    its limit of *e*^(*ϵ*/2), and we have
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，函数(1 + *ϵ*/2*n*)*^n* 随着*n*的增加而增加，接近其极限*e*^(*ϵ*/2)，我们有
- en: '![art](images/Art_P1518.jpg)'
  id: totrans-321
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1518.jpg)'
- en: Combining inequalities (35.26) and (35.29) completes the analysis of the approximation
    ratio.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 结合不等式（35.26）和（35.29）完成了逼近比率的分析。
- en: To show that APPROX-SUBSET-SUM is a fully polynomial-time approximation scheme,
    we derive a bound on the length of *L[i]*. After trimming, successive elements
    *z* and *z*′ of *L[i]* must have the relationship *z*′/*z* > 1 + *ϵ*/2*n*. That
    is, they must differ by a factor of at least 1 + *ϵ*/2*n*. Each list, therefore,
    contains the value 0, possibly the value 1, and up to ⌊log[1 + *ϵ*/2*n*] *t*⌋
    additional values. The number of elements in each list *L[i]* is at most
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明APPROX-SUBSET-SUM是子集和问题的全多项式时间逼近方案，我们对*L[i]* 的长度进行了限制。修剪后，连续的*L[i]* 元素*z*
    和*z*′ 必须满足*z*′/*z* > 1 + *ϵ*/2*n*。也就是说，它们之间的差异至少为1 + *ϵ*/2*n*。因此，每个列表最多包含值0，可能包含值1，以及最多⌊log[1
    + *ϵ*/2*n*] *t*⌋ 个额外值。因此，每个列表*L[i]* 中的元素数量最多为
- en: '![art](images/Art_P1519.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1519.jpg)'
- en: This bound is polynomial in the size of the input—which is the number of bits
    lg *t* needed to represent *t* plus the number of bits needed to represent the
    set *S*, which in turn is polynomial in *n*—and in 1/*ϵ*. Since the running time
    of APPROX-SUBSET-SUM is polynomial in the lengths of the lists *L[i]*, we conclude
    that APPROX-SUBSET-SUM is a fully polynomial-time approximation scheme.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 这个限制是输入大小的多项式——即表示*t* 所需的位数lg *t* 加上表示集合*S* 所需的位数，而*S* 又是*n*的多项式——以及1/*ϵ* 的。由于APPROX-SUBSET-SUM的运行时间是列表*L[i]*
    长度的多项式，我们得出结论，APPROX-SUBSET-SUM是子集和问题的全多项式时间逼近方案。
- en: ▪
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Exercises**'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***35.5-1***'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.5-1***'
- en: Prove equation (35.21). Then show that after executing line 4 of EXACT-SUBSET-SUM,
    *L[i]* is a sorted list containing every element of *P[i]* whose value is not
    more than *t*.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 证明方程（35.21）。然后证明执行EXACT-SUBSET-SUM的第4行后，*L[i]* 是一个排序列表，包含每个值不超过*t* 的*P[i]* 中的元素。
- en: '***35.5-2***'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.5-2***'
- en: Using induction on *i*, prove inequality (35.24).
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 使用对*i*的归纳，证明不等式（35.24）。
- en: '***35.5-3***'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.5-3***'
- en: Prove inequality (35.28).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 证明不等式（35.28）。
- en: '***35.5-4***'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.5-4***'
- en: How can you modify the approximation scheme presented in this section to find
    a good approximation to the smallest value not less than *t* that is a sum of
    some subset of the given input list?
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何修改本节中提出的逼近方案，以找到不小于*t* 且是给定输入列表的某个子集和的良好逼近值？
- en: '***35.5-5***'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '***35.5-5***'
- en: Modify the APPROX-SUBSET-SUM procedure to also return the subset of *S* that
    sums to the value *z**.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 修改APPROX-SUBSET-SUM过程，以返回总和为*z** 的*S* 子集。
- en: '**Problems**'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '***35-1     Bin packing***'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '***35-1     装箱问题***'
- en: You are given a set of *n* objects, where the size *s[i]* of the *i*th object
    satisfies 0 < *s*[*i*] < 1\. Your goal is to pack all the objects into the minimum
    number of unit-size bins. Each bin can hold any subset of the objects whose total
    size does not exceed 1.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一组*n*个对象，其中第*i*个对象的大小*s[i]* 满足0 < *s*[*i*] < 1。你的目标是将所有对象装入最少数量的单位大小箱中。每个箱子可以容纳任何总大小不超过1的对象子集。
- en: '***a.*** Prove that the problem of determining the minimum number of bins required
    is NP-hard. (*Hint:* Reduce from the subset-sum problem.)'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 证明确定所需最小箱数的问题是NP难的。（*提示：*从子集和问题简化。）'
- en: The ***first-fit*** heuristic takes each object in turn and places it into the
    first bin that can accommodate it, as follows. It maintains an ordered list of
    bins. Let *b* denote the number of bins in the list, where *b* increases over
    the course of the algorithm, and let 〈*B*[1], … , *B[b]*〉 be the list of bins.
    Initially *b* = 0 and the list is empty. The algorithm takes each object *i* in
    turn and places it in the lowest-numbered bin that can still accommodate it. If
    no bin can accommodate object *i*, then *b* is incremented and a new bin *B[b]*
    is opened, containing object *i*. Let ![art](images/Art_P1520.jpg).
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '***第一适合*** 启发式算法依次处理每个对象，并将其放入第一个能容纳它的箱子中，具体如下。它维护一个有序的箱子列表。让*b*表示列表中的箱子数，其中*b*随着算法的进行而增加，让〈*B*[1],
    … , *B[b]*〉为箱子列表。最初*b* = 0且列表为空。算法依次处理每个对象*i*，并将其放入仍然能容纳它的编号最低的箱子中。如果没有箱子能容纳对象*i*，则增加*b*并打开一个新箱子*B[b]*，其中包含对象*i*。让![art](images/Art_P1520.jpg)。'
- en: '***b.*** Argue that the optimal number of bins required is at least ⌈*S*⌉.'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 论证所需的最优箱子数量至少为⌈*S*⌉。'
- en: '***c.*** Argue that the first-fit heuristic leaves at most one bin at most
    half full.'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 论证第一适合启发式算法最多使一个箱子至多填充一半。'
- en: '***d.*** Prove that the number of bins used by the first-fit heuristic never
    exceeds ⌈2*S*⌉.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 证明第一适合启发式算法使用的箱子数量永远不会超过⌈2*S*⌉。'
- en: '***e.*** Prove an approximation ratio of 2 for the first-fit heuristic.'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** 证明第一适合启发式算法的近似比率为2。'
- en: '***f.*** Give an efficient implementation of the first-fit heuristic, and analyze
    its running time.'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '***f.*** 给出第一适合启发式算法的高效实现，并分析其运行时间。'
- en: '***35-2     Approximating the size of a maximum clique***'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '***35-2     最大团大小的近似***'
- en: Let *G* = (*V*, *E*) be an undirected graph. For any *k* ≥ 1, define *G*^((*k*))
    to be the undirected graph (*V* ^((*k*)), *E*^((*k*))), where *V* ^((*k*)) is
    the set of all ordered *k*-tuples of vertices from *V* and *E*^((*k*)) is defined
    so that (*v*[1], *v*[2], … , *v[k]*) is adjacent to (*w*[1], *w*[2], … , *w[k]*)
    if and only if for *i* = 1, 2, … , *k*, either vertex *v[i]* is adjacent to *w[i]*
    in *G*, or else *v[i]* = *w[i]*.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 设*G* = (*V*, *E*)为一个无向图。对于任何*k* ≥ 1，定义*G*^((*k*))为无向图(*V* ^((*k*)), *E*^((*k*)))，其中*V* ^((*k*))是*V*中所有有序*k*元组的集合，*E*^((*k*))被定义为当且仅当对于*i*
    = 1, 2, … , *k*，要么在*G*中顶点*v[i]*与*w[i]*相邻，要么*v[i]* = *w[i]*时，(*v*[1], *v*[2], …
    , *v[k]*)与(*w*[1], *w*[2], … , *w[k]*)相邻。
- en: '***a.*** Prove that the size of the maximum clique in *G*^((*k*)) is equal
    to the *k*th power of the size of the maximum clique in *G*.'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 证明*G*^((*k*))中最大团的大小等于*G*中最大团的大小的*k*次幂。'
- en: '***b.*** Argue that if there is an approximation algorithm that has a constant
    approximation ratio for finding a maximum-size clique, then there is a polynomial-time
    approximation scheme for the problem.'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 论证如果存在一个近似算法，其在寻找最大团时具有恒定的近似比率，那么该问题存在一个多项式时间的近似方案。'
- en: '***35-3     Weighted set-covering problem***'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '***35-3     加权集覆盖问题***'
- en: Suppose that sets have weights in the set-covering problem, so that each set
    *S[i]* in the family *ℱ* has an associated weight *w[i]*. The weight of a cover
    C is ![art](images/Art_P1521.jpg). The goal is wish to determine a minimum-weight
    cover. ([Section 35.3](chapter035.xhtml#Sec_35.3) handles the case in which *w[i]*
    = 1 for all *i*.)
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 假设集合在集覆盖问题中具有权重，因此家族*ℱ*中的每个集合*S[i]*都有一个相关的权重*w[i]*。覆盖C的权重是![art](images/Art_P1521.jpg)。目标是确定最小权重的覆盖。([35.3节](chapter035.xhtml#Sec_35.3)处理了*w[i]*
    = 1的情况。)
- en: Show how to generalize the greedy set-covering heuristic in a natural manner
    to provide an approximate solution for any instance of the weighted set-covering
    problem. Letting *d* be the maximum size of any set *S[i]*, show that your heuristic
    has an approximation ratio of ![art](images/Art_P1522.jpg).
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何将贪婪集覆盖启发式算法自然地推广以为加权集覆盖问题的任何实例提供近似解。让*d*是任何集合*S[i]*的最大大小，证明你的启发式算法具有近似比率为![art](images/Art_P1522.jpg)。
- en: '***35-4     Maximum matching***'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '***35-4     最大匹配***'
- en: Recall that for an undirected graph *G*, a matching is a set of edges such that
    no two edges in the set are incident on the same vertex. [Section 25.1](chapter025.xhtml#Sec_25.1)
    showed how to find a maximum matching in a bipartite graph, that is, a matching
    such that no other matching in *G* contains more edges. This problem examines
    matchings in undirected graphs that are not required to be bipartite.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下对于无向图*G*，匹配是一组边，使得集合中没有两条边与同一顶点相邻。[25.1节](chapter025.xhtml#Sec_25.1)展示了如何在二部图中找到���大匹配，即一种不包含更多边的匹配。本问题研究了不需要是二部图的无向图中的匹配。
- en: '***a.*** Show that a maximal matching need not be a maximum matching by exhibiting
    an undirected graph *G* and a maximal matching *M* in *G* that is not a maximum
    matching. (*Hint:* You can find such a graph with only four vertices.)'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 通过展示一个无向图*G*和*G*中一个最大匹配*M*的极大匹配不一定是最大匹配来展示。(*提示:* 你可以找到一个只有四个顶点的图。)'
- en: '***b.*** Consider a connected, undirected graph *G* = (*V*, *E*). Give an *O*(*E*)-time
    greedy algorithm to find a maximal matching in *G*.'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 考虑一个连通的无向图*G* = (*V*, *E*)。给出一个*O*(*E*)时间的贪婪算法来找到*G*中的极大匹配。'
- en: This problem concentrates on a polynomial-time approximation algorithm for maximum
    matching. Whereas the fastest known algorithm for maximum matching takes superlinear
    (but polynomial) time, the approximation algorithm here will run in linear time.
    You will show that the linear-time greedy algorithm for maximal matching in part
    (b) is a 2-approximation algorithm for maximum matching.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 本问题集中在最大匹配的多项式时间近似算法上。尽管已知的最快最大匹配算法需要超线性（但是多项式）时间，但这里的近似算法将在线性时间内运行。你将证明部分(b)中极大匹配的线性时间贪婪算法是最大匹配的2-近似算法。
- en: '***c.*** Show that the size of a maximum matching in *G* is a lower bound on
    the size of any vertex cover for *G*.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 证明*G*中最大匹配的大小是*G*中任何顶点覆盖的大小的下界。'
- en: '***d.*** Consider a maximal matching *M* in *G* = (*V*, *E*). Let *T* = {*v*
    ∈ *V* : some edge in *M* is incident on *v*}. What can you say about the subgraph
    of *G* induced by the vertices of *G* that are not in *T* ?'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 考虑*G* = (*V*, *E*)中的一个最大匹配*M*。设*T* = {*v* ∈ *V* : *M*中的某条边与*v*相邻}。关于*G*中不在*T*中的顶点诱导的子图，你能说些什么？'
- en: '***e.*** Conclude from part (d) that 2 |*M*| is the size of a vertex cover
    for *G*.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** 从(d)部分得出，2 |*M*| 是*G*的一个顶点覆盖的大小。'
- en: '***f.*** Using parts (c) and (e), prove that the greedy algorithm in part (b)
    is a 2-approximation algorithm for maximum matching.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '***f.*** 利用(c)和(e)部分，证明(b)部分中的贪心算法是最大匹配的2近似算法。'
- en: '***35-5     Parallel machine scheduling***'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '***35-5     并行机器调度***'
- en: 'In the ***parallel-machine-scheduling problem***, the input has two parts:
    *n* jobs, *J*[1], *J*[2], … , *J[n]*, where each job *J[k]* has an associated
    nonnegative processing time of *p[k]*, and *m* identical machines, *M*[1], *M*[2],
    … , *M[m]*. Any job can run on any machine. A ***schedule*** specifies, for each
    job *J[k]*, the machine on which it runs and the time period during which it runs.
    Each job *J[k]* must run on some machine *M[i]* for *p[k]* consecutive time units,
    and during that time period no other job may run on *M[i]*. Let *C[k]* denote
    the ***completion time*** of job *J[k]*, that is, the time at which job *J[k]*
    completes processing. Given a schedule, define *C*[max] = max {*C[j]* : 1 ≤ *j*
    ≤ *n*} to be the ***makespan*** of the schedule. The goal is to find a schedule
    whose makespan is minimum.'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: '在***并行机器调度问题***中，输入有两部分：*n*个作业*J*[1]，*J*[2]，…，*J[n]*，其中每个作业*J[k]*具有非负处理时间*p[k]*，以及*m*台相同的机器*M*[1]，*M*[2]，…，*M[m]*。任何作业都可以在任何机器上运行。一个***调度***指定了每个作业*J[k]*运行的机器以及运行期间。每个作业*J[k]*必须在某台机器*M[i]*上运行*p[k]*个连续的时间单位，而在此期间内，没有其他作业可以在*M[i]*上运行。设*C[k]*表示作业*J[k]*的***完成时间***，即作业*J[k]*完成处理的时间。给定一个调度，定义*C*[max]
    = max {*C[j]* : 1 ≤ *j* ≤ *n*}为调度的***最大完成时间***。目标是找到使最大完成时间最小的调度。'
- en: For example, consider an input with two machines *M*[1] and *M*[2], and four
    jobs *J*[1], *J*[2], *J*[3], and *J*[4] with *p*[1] = 2, *p*[2] = 12, *p*[3] =
    4, and *p*[4] = 5\. Then one possible schedule runs, on machine *M*[1], job *J*[1]
    followed by job *J*[2], and on machine *M*[2], job *J*[4] followed by job *J*[3].
    For this schedule, *C*[1] = 2, *C*[2] = 14, *C*[3] = 9, *C*[4] = 5, and *C*[max]
    = 14\. An optimal schedule runs job *J*[2] on machine *M*[1] and jobs *J*[1],
    *J*[3], and *J*[4] on machine *M*[2]. For this schedule, we have *C*[1] = 2, *C*[2]
    = 12, *C*[3] = 6, and *C*[4] = 11, and so *C*[max] = 12.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑有两台机器*M*[1]和*M*[2]，以及四个作业*J*[1]，*J*[2]，*J*[3]和*J*[4]，其中*p*[1] = 2，*p*[2]
    = 12，*p*[3] = 4，*p*[4] = 5。那么一个可能的调度是，在机器*M*[1]上，作业*J*[1]后跟作业*J*[2]，在机器*M*[2]上，作业*J*[4]后跟作业*J*[3]。对于这个调度，*C*[1]
    = 2，*C*[2] = 14，*C*[3] = 9，*C*[4] = 5，*C*[max] = 14。一个最优调度是在机器*M*[1]上运行作业*J*[2]，在机器*M*[2]上运行作业*J*[1]，*J*[3]和*J*[4]。对于这个调度，我们有*C*[1]
    = 2，*C*[2] = 12，*C*[3] = 6，*C*[4] = 11，因此*C*[max] = 12。
- en: Given the input to a parallel-machine-scheduling problem, let ![art](images/Art_P1522a.jpg)
    denote the makespan of an optimal schedule.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 给定并行机器调度问题的输入，让![艺术](images/Art_P1522a.jpg)表示最优调度的最大完成时间。
- en: '***a.*** Show that the optimal makespan is at least as large as the greatest
    processing time, that is,'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 证明最优完成时间至少与最大处理时间一样大，即'
- en: '![art](images/Art_P1522b.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1522b.jpg)'
- en: '**b.** Show that the optimal makespan is at least as large as the average machine
    load, that is,'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '**b.** 证明最优完成时间至少与平均机器负载一样大，即'
- en: '![art](images/Art_P1523.jpg)'
  id: totrans-371
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1523.jpg)'
- en: 'Consider the following greedy algorithm for parallel machine scheduling: whenever
    a machine is idle, schedule any job that has not yet been scheduled.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下并行机器调度的贪心算法：每当一台机器空闲时，调度尚未被调度的任何作业。
- en: '***c.*** Write pseudocode to implement this greedy algorithm. What is the running
    time of your algorithm?'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 编写伪代码来实现这个贪心算法。你的算法的运行时间是多少？'
- en: '***d.*** For the schedule returned by the greedy algorithm, show that'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 对于贪心算法返回的调度，证明'
- en: '![art](images/Art_P1524.jpg)'
  id: totrans-375
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1524.jpg)'
- en: Conclude that this algorithm is a polynomial-time 2-approximation algorithm.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 得出这个算法是一个多项式时间的2近似算法。
- en: '***35-6     Approximating a maximum spanning tree***'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '***35-6     近似计算最大生成树***'
- en: 'Let *G* = (*V*, *E*) be an undirected graph with distinct edge weights *w*(*u,
    v*) on each edge (*u*, *v*) ∈ *E*. For each vertex *v* ∈ *V*, denote by max(*v*)
    the maximum-weight edge incident on that vertex. Let *S*[*G*]= {max(*v*) : *v*
    ∈ *V* } be the set of maximum-weight edges incident on each vertex, and let *T*[*G*]
    be the maximum-weight spanning tree of *G*, that is, the spanning tree of maximum
    total weight. For any subset of edges *E*′ ⊆ *E*, define *w*(*E*′) = Σ[(*u*,*v*)∈*E′*] *w*(*u,
    v*).'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: '设*G* = (*V*, *E*)是一个具有不同边权重*w*(*u, v*)的无向图，其中每条边(*u*, *v*) ∈ *E*。对于每个顶点*v*
    ∈ *V*，用max(*v*)表示与该顶点相邻的最大权重边。设*S*[G]= {max(*v*) : *v* ∈ *V* }为每个顶点相邻的最大权重边的集合，*T*[G]为*G*的最大权重生成树，即总权重最大的生成树。对于边的任意子集*E*′
    ⊆ *E*，定义*w*(*E*′) = Σ[(*u*,*v*)∈*E′*] *w*(*u, v*)。'
- en: '***a.*** Give an example of a graph with at least 4 vertices for which *S*[*G*]
    = *T[G]*.'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 给出至少有4个顶点的图的一个例子，其中*S*[G] = *T[G]*。'
- en: '***b.*** Give an example of a graph with at least 4 vertices for which *S*[*G*]
    ≠ *T[G]*.'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 给出至少有4个顶点的图的一个例子，其中*S*[G] ≠ *T[G]*。'
- en: '***c.*** Prove that *S*[*G*] ⊆ *T*[*G*] for any graph *G*.'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 证明对于任意图*G*，*S*[G] ⊆ *T*[G]。'
- en: '***d.*** Prove that *w*(*S[G]*) ≥ *w*(*T[G]*)/2 for any graph *G*.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 证明对于任意图*G*，*w*(*S[G]*) ≥ *w*(*T[G]*)/2。'
- en: '***e.*** Give an *O*(*V* + *E*)-time algorithm to compute a 2-approximation
    to the maximum spanning tree.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** 给出一个*O*(*V* + *E*)时间复杂度的算法，计算最大生成树的2近似值。'
- en: '***35-7     An approximation algorithm for the 0-1 knapsack problem***'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: '***35-7     0-1背包问题的近似算法***'
- en: 'Recall the knapsack problem from [Section 15.2](chapter015.xhtml#Sec_15.2).
    The input includes *n* items, where the *i*th item is worth *v[i]* dollars and
    weighs *w[i]* pounds. The input also includes the capacity of a knapsack, which
    is *W* pounds. Here, we add the further assumptions that each weight *w[i]* is
    at most *W* and that the items are indexed in monotonically decreasing order of
    their values: *v*[1] ≥ *v*[2] ≥ ⋯ ≥ *v[n]*.'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾来自[第15.2节](chapter015.xhtml#Sec_15.2)的背包问题。输入包括*n*个物品，第*i*个物品价值为*v[i]*美元，重量为*w[i]*磅。输入还包括背包的容量，即*W*磅。在这里，我们进一步假设每个重量*w[i]*最多为*W*，并且物品按照其价值的单调递减顺序进行索引：*v*[1]
    ≥ *v*[2] ≥ ⋯ ≥ *v[n]*。
- en: In the 0-1 knapsack problem, the goal is to find a subset of the items whose
    total weight is at most *W* and whose total value is maximum. The fractional knapsack
    problem is like the 0-1 knapsack problem, except that a fraction of each item
    may be put into the knapsack, rather than either all or none of each item. If
    a fraction *x[i]* of item *i* goes into the knapsack, where 0 ≤ *x[i]* ≤ 1, it
    contributes *x[i]w[i]* to the weight of the knapsack and adds value *x[i]v[i]*.
    The goal of this problem is to develop a polynomial-time 2-approximation algorithm
    for the 0-1 knapsack problem.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 在0-1背包问题中，目标是找到一个物品子集，其总重量最多为*W*，总价值最大。分数背包问题类似于0-1背包问题，不同之处在于每个物品的一部分可以放入背包中，而不是全部或没有。如果物品*i*的一部分*x[i]*放入背包中，其中0
    ≤ *x[i]* ≤ 1，则它对背包的重量贡献了*x[i]w[i]*，并增加了价值*x[i]v[i]*。这个问题的目标是为0-1背包问题设计一个多项式时间的2近似算法。
- en: In order to design a polynomial-time algorithm, let’s consider restricted instances
    of the 0-1 knapsack problem. Given an instance *I* of the knapsack problem, form
    restricted instances *I[j]*, for *j* = 1, 2, … , *n*, by removing items 1, 2,
    … , *j* − 1 and requiring the solution to include item *j* (all of item *j* in
    both the fractional and 0-1 knapsack problems). No items are removed in instance
    *I*[1]. For instance *I[j]*, let *P[j]* denote an optimal solution to the 0-1
    problem and *Q[j]* denote an optimal solution to the fractional problem.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设计一个多项式时间算法，让我们考虑0-1背包问题的受限实例。给定背包问题的实例*I*，通过移除物品1、2、…、*j* − 1并要求解决方案包括物品*j*（在分数和0-1背包问题中都包括物品*j*）来形成受限实例*I[j]*，其中*j*
    = 1, 2, …, *n*。在实例*I*[1]中没有移除任何物品。对于实例*I[j]*，让*P[j]*表示0-1问题的最优解，*Q[j]*表示分数问题的最优解。
- en: '***a.*** Argue that an optimal solution to instance *I* of the 0-1 knapsack
    problem is one of {*P*[1], *P*[2], … , *P[n]*}.'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 论证0-1背包问题实例*I*的最优解是{*P*[1], *P*[2], …, *P*[n]*}中的一个。'
- en: '***b.*** Prove that to find an optimal solution *Q[j]* to the fractional problem
    for instance *I[j]*, you can include item *j* and then use the greedy algorithm
    in which each step takes as much as possible of the unchosen item with the maximum
    value per pound *v[i]*/*w[i]* in the set {*j* + 1, *j* + 2, … , *n*}.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 证明为了找到实例*I[j]*的分数问题的最优解*Q[j]*，可以包括物品*j*，然后使用贪婪算法，在每一步中尽可能多地选择具有最大单位价值*v[i]*/*w[i]*的未选择物品，其中*i*
    ∈ {*j* + 1, *j* + 2, …, *n*}。'
- en: '***c.*** Prove that there is always an optimal solution *Q[j]* to the fractional
    problem for instance *I[j]* that includes at most one item fractionally. That
    is, for all items except possibly one, either all of the item or none of the item
    goes into the knapsack.'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 证明总是存在一个实例*I[j]*的分数问题的最优解*Q[j]*，其中至多包含一个物品的分数部分。也就是说，除了可能有一个物品外，其他物品要么全部放入背包，要么全部不放入。'
- en: '***d.*** Given an optimal solution *Q[j]* to the fractional problem for instance
    *I[j]*, form solution *R[j]* from *Q[j]* by deleting any fractional items from
    *Q[j]*. Let *v*(*S*) denote the total value of items taken in a solution *S*.
    Prove that *v*(*R[j]*) ≥ *v*(*Q[j]*)/2 ≥ *v*(*P[j]*)/2.'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 给定实例*I[j]*的分数问题的最优解*Q[j]*，通过从*Q[j]*中删除任何分数物品形成解*R[j]*。让*v*(*S*)表示解*S*中取出的物品的总价值。证明*v*(*R[j]*)
    ≥ *v*(*Q[j]*)/2 ≥ *v*(*P[j]*)/2。'
- en: '***e.*** Give a polynomial-time algorithm that returns a maximum-value solution
    from the set {*R*[1], *R*[2], … , *R[n]*}, and prove that your algorithm is a
    polynomial-time 2-approximation algorithm for the 0-1 knapsack problem.'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** 给出一个多项式时间算法，从集合{*R*[1], *R*[2], …, *R*[n]*}中返回一个最��价值的解，并证明你的算法是0-1背包问题的多项式时间2近似算法。'
- en: '**Chapter notes**'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节注释**'
- en: Although methods that do not necessarily compute exact solutions have been known
    for thousands of years (for example, methods to approximate the value of *π*),
    the notion of an approximation algorithm is much more recent. Hochbaum [[221](bibliography001.xhtml#endnote_221)]
    credits Garey, Graham, and Ullman [[175](bibliography001.xhtml#endnote_175)] and
    Johnson [[236](bibliography001.xhtml#endnote_236)] with formalizing the concept
    of a polynomial-time approximation algorithm. The first such algorithm is often
    credited to Graham [[197](bibliography001.xhtml#endnote_197)].
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管数千年来已知不一定计算出精确解的方法（例如，近似计算*π*值的方法），但近似算法的概念要新得多。Hochbaum [[221](bibliography001.xhtml#endnote_221)]
    将多项式时间近似算法的概念归功于Garey、Graham和Ullman [[175](bibliography001.xhtml#endnote_175)]
    以及Johnson [[236](bibliography001.xhtml#endnote_236)]。第一个这样的算法通常归功于Graham [[197](bibliography001.xhtml#endnote_197)]。
- en: Since this early work, thousands of approximation algorithms have been designed
    for a wide range of problems, and there is a wealth of literature on this field.
    Texts by Ausiello et al. [[29](bibliography001.xhtml#endnote_29)], Hochbaum [[221](bibliography001.xhtml#endnote_221)],
    Vazirani [[446](bibliography001.xhtml#endnote_446)], and Williamson and Shmoys
    [[459](bibliography001.xhtml#endnote_459)] deal exclusively with approximation
    algorithms, as do surveys by Shmoys [[409](bibliography001.xhtml#endnote_409)]
    and Klein and Young [[256](bibliography001.xhtml#endnote_256)]. Several other
    texts, such as Garey and Johnson [[176](bibliography001.xhtml#endnote_176)] and
    Papadimitriou and Steiglitz [[353](bibliography001.xhtml#endnote_353)], have significant
    coverage of approximation algorithms as well. Books edited by Lawler, Lenstra,
    Rinnooy Kan, and Shmoys [[277](bibliography001.xhtml#endnote_277)] and by Gutin
    and Punnen [[204](bibliography001.xhtml#endnote_204)] provide extensive treatments
    of approximation algorithms and heuristics for the traveling-salesperson problem.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 从这项早期工作开始，已经为各种问题设计了成千上万个近似算法，并且在这一领域有大量的文献。Ausiello等人[[29](bibliography001.xhtml#endnote_29)]，Hochbaum[[221](bibliography001.xhtml#endnote_221)]，Vazirani[[446](bibliography001.xhtml#endnote_446)]，以及Williamson和Shmoys[[459](bibliography001.xhtml#endnote_459)]的文本专门涉及近似算法，Shmoys[[409](bibliography001.xhtml#endnote_409)]和Klein与Young[[256](bibliography001.xhtml#endnote_256)]的调查也是如此。其他一些文本，如Garey和Johnson[[176](bibliography001.xhtml#endnote_176)]以及Papadimitriou和Steiglitz[[353](bibliography001.xhtml#endnote_353)]也有相当涵盖近似算法。Lawler，Lenstra，Rinnooy
    Kan和Shmoys[[277](bibliography001.xhtml#endnote_277)]以及Gutin和Punnen[[204](bibliography001.xhtml#endnote_204)]编辑的书籍提供了关于旅行推销员问题的近似算法和启发式方法的广泛论述。
- en: Papadimitriou and Steiglitz attribute the algorithm APPROX-VERTEX-COVER to F.
    Gavril and M. Yannakakis. The vertex-cover problem has been studied extensively
    (Hochbaum [[221](bibliography001.xhtml#endnote_221)] lists 16 different approximation
    algorithms for this problem), but all the approximation ratios are at least 2
    − *o*(1).
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: Papadimitriou和Steiglitz将算法APPROX-VERTEX-COVER归因于F. Gavril和M. Yannakakis。顶点覆盖问题已经得到广泛研究（Hochbaum[[221](bibliography001.xhtml#endnote_221)]列出了16种不同的近似算法），但所有的近似比至少为2−*o*(1)。
- en: The algorithm APPROX-TSP-TOUR appears in a paper by Rosenkrantz, Stearns, and
    Lewis [[384](bibliography001.xhtml#endnote_384)]. Christofides improved on this
    algorithm and gave a 3/2-approximation algorithm for the traveling-salesperson
    problem with the triangle inequality. Arora [[23](bibliography001.xhtml#endnote_23)]
    and Mitchell [[330](bibliography001.xhtml#endnote_330)] have shown that if the
    points lie in the euclidean plane, there is a polynomial-time approximation scheme.
    Theorem 35.3 is due to Sahni and Gonzalez [[392](bibliography001.xhtml#endnote_392)].
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 算法APPROX-TSP-TOUR出现在Rosenkrantz，Stearns和Lewis的论文中[[384](bibliography001.xhtml#endnote_384)]。Christofides改进了这个算法，并为具有三角不等式的旅行推销员问题提供了3/2近似算法。Arora[[23](bibliography001.xhtml#endnote_23)]和Mitchell[[330](bibliography001.xhtml#endnote_330)]已经证明，如果点位于欧几里得平面上，那么存在一个多项式时间的近似方案。定理35.3归因于Sahni和Gonzalez[[392](bibliography001.xhtml#endnote_392)]。
- en: The algorithm APPROX-SUBSET-SUM and its analysis are loosely modeled after related
    approximation algorithms for the knapsack and subset-sum problems by Ibarra and
    Kim [[234](bibliography001.xhtml#endnote_234)].
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 算法APPROX-SUBSET-SUM及其分析松散地模仿了Ibarra和Kim[[234](bibliography001.xhtml#endnote_234)]关于背包和子集和问题的相关近似算法。
- en: Problem 35-7 is a combinatorial version of a more general result on approximating
    knapsack-type integer programs by Bienstock and McClosky [[55](bibliography001.xhtml#endnote_55)].
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 问题35-7是由Bienstock和McClosky[[55](bibliography001.xhtml#endnote_55)]关于近似背包型整数规划的更一般结果的组合版本。
- en: The randomized algorithm for MAX-3-CNF satisfiability is implicit in the work
    of Johnson [[236](bibliography001.xhtml#endnote_236)]. The weighted vertex-cover
    algorithm is by Hochbaum [[220](bibliography001.xhtml#endnote_220)]. [Section
    35.4](chapter035.xhtml#Sec_35.4) only touches on the power of randomization and
    linear programming in the design of approximation algorithms. A combination of
    these two ideas yields a technique called “randomized rounding,” which formulates
    a problem as an integer linear program, solves the linear-programming relaxation,
    and interprets the variables in the solution as probabilities. These probabilities
    then help guide the solution of the original problem. This technique was first
    used by Raghavan and Thompson [[374](bibliography001.xhtml#endnote_374)], and
    it has had many subsequent uses. (See Motwani, Naor, and Raghavan [[335](bibliography001.xhtml#endnote_335)]
    for a survey.) Several other notable ideas in the field of approximation algorithms
    include the primal-dual method (see Goemans and Williamson [[184](bibliography001.xhtml#endnote_184)]
    for a survey), finding sparse cuts for use in divide-and-conquer algorithms [[288](bibliography001.xhtml#endnote_288)],
    and the use of semidefinite programming [[183](bibliography001.xhtml#endnote_183)].
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: MAX-3-CNF可满足性的随机算法在Johnson的工作中是隐含的[[236](bibliography001.xhtml#endnote_236)]。加权顶点覆盖算法由Hochbaum[[220](bibliography001.xhtml#endnote_220)]提出。[第35.4节](chapter035.xhtml#Sec_35.4)仅涉及在设计近似算法中随机化和线性规划的力量。这两种思想的结合产生了一种称为“随机舍入”的技术，它将问题制定为整数线性规划，解决线性规划松弛问题，并将解决方案中的变量解释为概率。这些概率然后有助于指导原始问题的解决方案。这种技术首次由Raghavan和Thompson[[374](bibliography001.xhtml#endnote_374)]使用，后来被广泛应用。（有关调查，请参见Motwani，Naor和Raghavan[[335](bibliography001.xhtml#endnote_335)]。）近似算法领域中其他一些显著的思想包括原始-对偶方法（请参见Goemans和Williamson[[184](bibliography001.xhtml#endnote_184)]的调查），为分治算法找到稀疏切割[[288](bibliography001.xhtml#endnote_288)]，以及使用半定规划[[183](bibliography001.xhtml#endnote_183)]。
- en: As mentioned in the chapter notes for [Chapter 34](chapter034.xhtml), results
    in probabilistically checkable proofs have led to lower bounds on the approximability
    of many problems, including several in this chapter. In addition to the references
    there, the chapter by Arora and Lund [[26](bibliography001.xhtml#endnote_26)]
    contains a good description of the relationship between probabilistically checkable
    proofs and the hardness of approximating various problems.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 正如[第34章](chapter034.xhtml)的章节注释中所提到的，概率可检验证明的结果导致了许多问题的近似下界，包括本章中的几个问题。除了那里的参考文献外，Arora和Lund的章节[[26](bibliography001.xhtml#endnote_26)]中对概率可检验证明与各种问题近似难度之间的关系有很好的描述。
- en: '[¹](#footnote_ref_1) When the approximation ratio is independent of *n*, we
    use the terms “approximation ratio of *ρ*” and “*ρ*-approximation algorithm,”
    indicating no dependence on *n*.'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: '[¹](#footnote_ref_1) 当近似比率与*n*无关时，我们使用术语“*ρ*的近似比率”和“*ρ*近似算法”，表示不依赖于*n*。'
