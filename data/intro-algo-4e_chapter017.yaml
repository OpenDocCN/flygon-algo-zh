- en: '[**17        Augmenting Data Structures**](toc.xhtml#chap-17)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[**17        扩充数据结构**](toc.xhtml#chap-17)'
- en: Some solutions require no more than a “textbook” data structure—such as a doubly
    linked list, a hash table, or a binary search tree—but many others require a dash
    of creativity. Rarely will you need to create an entirely new type of data structure,
    though. More often, you can augment a textbook data structure by storing additional
    information in it. You can then program new operations for the data structure
    to support your application. Augmenting a data structure is not always straightforward,
    however, since the added information must be updated and maintained by the ordinary
    operations on the data structure.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 有些解决方案只需要一个“教科书”数据结构——比如双向链表、哈希表或二叉搜索树——但许多其他解决方案需要一点创造力。很少需要创建全新类型的数据结构，更常见的是在其中存储额外信息来扩充教科书数据结构。然后，你可以为数据结构编写新的操作以支持你的应用程序。然而，扩充数据结构并不总是直截了当的，因为添加��信息必须由数据结构上的普通操作更新和维护。
- en: 'This chapter discusses two data structures based on red-black trees that are
    augmented with additional information. [Section 17.1](chapter017.xhtml#Sec_17.1)
    describes a data structure that supports general order-statistic operations on
    a dynamic set: quickly finding the *i*th smallest number or the rank of a given
    element. [Section 17.2](chapter017.xhtml#Sec_17.2) abstracts the process of augmenting
    a data structure and provides a theorem that you can use when augmenting red-black
    trees. [Section 17.3](chapter017.xhtml#Sec_17.3) uses this theorem to help design
    a data structure for maintaining a dynamic set of intervals, such as time intervals.
    You can use this data structure to quickly find an interval that overlaps a given
    query interval.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论了基于红黑树的两种附加信息的数据结构。[第17.1节](chapter017.xhtml#Sec_17.1)描述了一个支持动态集合上的一般顺序统计操作的数据结构：快速找到第
    *i* 小的数字或给定元素的秩。[第17.2节](chapter017.xhtml#Sec_17.2)抽象了附加数据结构的过程，并提供了一个定理，当附加红黑树时可以使用。[第17.3节](chapter017.xhtml#Sec_17.3)使用这个定理来帮助设计一个用于维护动态区间集合（如时间区间）的数据结构。你可以使用这个数据结构快速找到与给定查询区间重叠的区间。
- en: '[**17.1    Dynamic order statistics**](toc.xhtml#Rh1-101)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[**17.1    动态顺序统计**](toc.xhtml#Rh1-101)'
- en: '[Chapter 9](chapter009.xhtml) introduced the notion of an order statistic.
    Specifically, the *i*th order statistic of a set of *n* elements, where *i* ∈
    {1, 2, … , *n*}, is simply the element in the set with the *i*th smallest key.
    In [Chapter 9](chapter009.xhtml), you saw how to determine any order statistic
    in *O*(*n*) time from an unordered set. This section shows how to modify red-black
    trees so that you can determine any order statistic for a dynamic set in *O*(lg
    *n*) time and also compute the ***rank*** of an element—its position in the linear
    order of the set—in *O*(lg *n*) time.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第9章](chapter009.xhtml)介绍了顺序统计的概念。具体来说，对于一个包含 *n* 个元素的集合，第 *i* 个顺序统计，其中 *i*
    ∈ {1, 2, … , *n*}，就是集合中第 *i* 小的键对应的元素。在[第9章](chapter009.xhtml)中，你看到了如何从无序集合中在
    *O*(*n*) 的时间内确定任意顺序统计。本节展示了如何修改红黑树，以便你可以在 *O*(lg *n*) 的时间内确定动态集合中的任意顺序统计，并在 *O*(lg
    *n*) 的时间内计算元素的***秩***—即其在集合的线性顺序中的位置。'
- en: '![art](images/Art_P533.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P533.jpg)'
- en: '**Figure 17.1** An order-statistic tree, which is an augmented red-black tree.
    In addition to its usual attributes, each node *x* has an attribute *x*.*size*,
    which is the number of nodes, other than the sentinel, in the subtree rooted at
    *x*.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**图17.1** 一个顺序统计树，即一个附加信息的红黑树。除了通常的属性外，每个节点 *x* 还有一个属性 *x*.*size*，表示除哨兵外以 *x*
    为根的子树中的节点数。'
- en: '[Figure 17.1](chapter017.xhtml#Fig_17-1) shows a data structure that can support
    fast order-statistic operations. An ***order-statistic tree*** *T* is simply a
    red-black tree with additional information stored in each node. Each node *x*
    contains the usual red-black tree attributes *x*.*key*, *x*.*color*, *x*.*p*,
    *x*.*left*, and *x*.*right*, along with a new attribute, *x*.*size*. This attribute
    contains the number of internal nodes in the subtree rooted at *x* (including
    *x* itself, but not including any sentinels), that is, the size of the subtree.
    If we define the sentinel’s size to be 0—that is, we set *T*.*nil*.*size* to be
    0—then we have the identity'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[图17.1](chapter017.xhtml#Fig_17-1)展示了一个可以支持快速顺序统计操作的数据结构。一个***顺序统计树*** *T*
    简单地是一个红黑树，每个节点中存储有额外的信息。每个节点 *x* 包含了通常的红黑树属性 *x*.*key*、*x*.*color*、*x*.*p*、*x*.*left*
    和 *x*.*right*，以及一个新属性 *x*.*size*。这个属性包含了以 *x* 为根的子树中的内部节点数（包括 *x* 本身，但不包括任何哨兵节点），也就是子树的大小。如果我们定义哨兵的大小为0——也就是说，我们将
    *T*.*nil*.*size* 设为0——那么我们有以下等式'
- en: '*x*.*size* = *x*.*left*.*size* + *x*.*right*.*size* + 1.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*.*size* = *x*.*left*.*size* + *x*.*right*.*size* + 1.'
- en: Keys need not be distinct in an order-statistic tree. For example, the tree
    in [Figure 17.1](chapter017.xhtml#Fig_17-1) has two keys with value 14 and two
    keys with value 21\. When equal keys are present, the above notion of rank is
    not well defined. We remove this ambiguity for an order-statistic tree by defining
    the rank of an element as the position at which it would be printed in an inorder
    walk of the tree. In [Figure 17.1](chapter017.xhtml#Fig_17-1), for example, the
    key 14 stored in a black node has rank 5, and the key 14 stored in a red node
    has rank 6.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在顺序统计树中，键值不必是唯一的。例如，[图17.1](chapter017.xhtml#Fig_17-1)中的树有两个值为14的键和两个值为21的键。当存在相等的键时，上述秩的概念就不明确了。我们通过定义元素的秩为其在树的中序遍历中打印的位置来消除这种模糊性。例如，在[图17.1](chapter017.xhtml#Fig_17-1)中，存储在黑色节点中的键14的秩为5，存储在红色节点中的键14的秩为6。
- en: '**Retrieving the element with a given rank**'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**检索具有给定秩的元素**'
- en: Before we show how to maintain the size information during insertion and deletion,
    let’s see how to implement two order-statistic queries that use this additional
    information. We begin with an operation that retrieves the element with a given
    rank. The procedure OS-SELECT(*x*, *i*) on the following page returns a pointer
    to the node containing the *i*th smallest key in the subtree rooted at *x*. To
    find the node with the *i*th smallest key in an order-statistic tree *T*, call
    OS-SELECT(*T*.*root*, *i*).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示如何在插入和删除过程中维护大小信息之前，让我们看看如何实现使用此额外信息的两个有序统计查询。我们从检索具有给定排名的元素的操作开始。下一页的 OS-SELECT(*x*,
    *i*) 过程返回指向包含以 *x* 为根的子树中第 *i* 小键的节点的指针。要找到有序统计树 *T* 中第 *i* 小键的节点，调用 OS-SELECT(*T*.*root*,
    *i*)。
- en: Here is how OS-SELECT works. Line 1 computes *r*, the rank of node *x* within
    the subtree rooted at *x*. The value of *x*.*left*.*size* is the number of nodes
    that come before *x* in an inorder tree walk of the subtree rooted at *x*. Thus,
    *x*.*left*.*size* + 1 is the rank of *x* within the subtree rooted at *x*. If
    *i* = *r*, then node *x* is the *i*th smallest element, and so line 3 returns
    *x*. If *i < r*, then the *i*th smallest element resides in *x*’s left subtree,
    and therefore, line 5 recurses on *x*.*left*. If *i > r*, then the *i*th smallest
    element resides in *x*’s right subtree. Since the subtree rooted at *x* contains
    *r* elements that come before *x*’s right subtree in an inorder tree walk, the
    *i*th smallest element in the subtree rooted at *x* is the (*i* − *r*)th smallest
    element in the subtree rooted at *x*.*right*. Line 6 determines this element recursively.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是 OS-SELECT 的工作原理。第 1 行计算 *r*，即节点 *x* 在以 *x* 为根的子树中的排名。*x*.*left*.*size* 的值是在以
    *x* 为根的子树的中序遍历中在 *x* 之前的节点数。因此，*x*.*left*.*size* + 1 就是 *x* 在以 *x* 为根的子树中的排名。如果
    *i* = *r*，那么节点 *x* 就是第 *i* 小的元素，因此第 3 行返回 *x*。如果 *i < r*，那么第 *i* 小的元素位于 *x* 的左子树中，因此，第
    5 行递归调用 *x*.*left*。如果 *i > r*，那么第 *i* 小的元素位于 *x* 的右子树中。由于以 *x* 为根的子树中有 *r* 个元素在
    *x* 的右子树之前，因此以 *x* 为根的子树中的第 *i* 小元素就是以 *x*.*right* 为根的子树中的第 (*i* − *r*) 小元素。第
    6 行通过递归确定这个元素。
- en: OS-SELECT(*x*, *i*)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: OS-SELECT(*x*, *i*)
- en: '| 1 | *r* = *x*.*left*.*size* + 1 | **//** rank of *x* within the subtree rooted
    at *x* |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *r* = *x*.*left*.*size* + 1 | **//** *x* 在以 *x* 为根的子树中的排名 |'
- en: '| 2 | **if** *i* == *r* |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **如果** *i* == *r* |'
- en: '| 3 | **return** *x* |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **返回** *x* |'
- en: '| 4 | **elseif** *i* < *r* |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **否则如果** *i* < *r* |'
- en: '| 5 | **return** OS-SELECT(*x*.*left*, *i*) |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **返回** OS-SELECT(*x*.*left*, *i*) |'
- en: '| 6 | **else return** OS-SELECT(*x*.*right*, *i* − *r*) |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 6 | **否则返回** OS-SELECT(*x*.*right*, *i* − *r*) |'
- en: As an example of how OS-SELECT operates, consider a search for the 17th smallest
    element in the order-statistic tree of [Figure 17.1](chapter017.xhtml#Fig_17-1).
    The search starts with *x* as the root, whose key is 26, and with *i* = 17\. Since
    the size of 26’s left subtree is 12, its rank is 13\. Thus, the node with rank
    17 is the 17 − 13 = 4th smallest element in 26’s right subtree. In the recursive
    call, *x* is the node with key 41, and *i* = 4\. Since the size of 41’s left subtree
    is 5, its rank within its subtree is 6\. Therefore, the node with rank 4 is the
    4th smallest element in 41’s left subtree. In the recursive call, *x* is the node
    with key 30, and its rank within its subtree is 2\. The procedure recurses once
    again to find the 4 − 2 = 2nd smallest element in the subtree rooted at the node
    with key 38\. Its left subtree has size 1, which means it is the second smallest
    element. Thus, the procedure returns a pointer to the node with key 38.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以 OS-SELECT 如何运作为例，考虑在[图 17.1](chapter017.xhtml#Fig_17-1)的有序统计树中搜索第 17 小的元素。搜索从根
    *x* 开始，其键为 26，*i* = 17。由于 26 的左子树大小为 12，其排名为 13。因此，排名为 17 的节点是 26 的右子树中的第 17 −
    13 = 4 小元素。在递归调用中，*x* 是键为 41 的节点，*i* = 4。由于 41 的左子树大小为 5，其在子树中的排名为 6。因此，排名为 4
    的节点是 41 的左子树中的第 4 小元素。在递归调用中，*x* 是键为 30 的节点，其在子树中的排名为 2。过程再次递归以找到根为键为 38 的节点子树中的第
    4 − 2 = 2 小元素。其左子树大小为 1，这意味着它是第二小的元素。因此，过程返回键为 38 的节点的指针。
- en: Because each recursive call goes down one level in the order-statistic tree,
    the total time for OS-SELECT is at worst proportional to the height of the tree.
    Since the tree is a red-black tree, its height is *O*(lg *n*), where *n* is the
    number of nodes. Thus, the running time of OS-SELECT is *O*(lg *n*) for a dynamic
    set of *n* elements.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '因为每次递归调用都会在有序统计树中下降一层，所以 OS-SELECT 的总时间最坏情况下与树的高度成比例。由于树是红黑树，其高度为 *O*(lg *n*)，其中
    *n* 是节点数。因此，OS-SELECT 的运行时间为 *O*(lg *n*)，对于包含 *n* 个元素的动态集合。 '
- en: '**Determining the rank of an element**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**确定元素的排名**'
- en: Given a pointer to a node *x* in an order-statistic tree *T*, the procedure
    OS-RANK on the facing page returns the position of *x* in the linear order determined
    by an inorder tree walk of *T*.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 给定有序统计树 *T* 中节点 *x* 的指针，面向页面的 OS-RANK 过程返回 *x* 在由 *T* 的中序遍历确定的线性顺序中的位置。
- en: OS-RANK(*T*, *x*)
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: OS-RANK(*T*, *x*)
- en: '| 1 | *r* = *x*.*left*.*size* + 1 | **//** rank of *x* within the subtree rooted
    at *x* |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *r* = *x*.*left*.*size* + 1 | **//** *x* 在以 *x* 为根的子树中的排名 |'
- en: '| 2 | *y* = *x* | **//** root of subtree being examined |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *y* = *x* | **//** 正在检查的子树的根 |'
- en: '| 3 | **while** *y* ≠ *T*.*root* |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **当** *y* ≠ *T*.*root* **时** |'
- en: '| 4 | **if** *y* == *y*.*p*.*right* |  | **//** if root of a right subtree
    … |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **如果** *y* == *y*.*p*.*right* |  | **//** 如果是右子树的根 … |'
- en: '| 5 | *r* = *r* + *y*.*p*.*left*.*size* + 1 |  | **//** … add in parent and
    its left subtree |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| 5 | *r* = *r* + *y*.*p*.*left*.*size* + 1 |  | **//** … 加上父节点及其左子树 |'
- en: '| 6 | *y* = *y*.*p* |  | **//** move *y* toward the root |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 6 | *y* = *y*.*p* |  | **//** 向根移动 *y* |'
- en: '| 7 | **return** *r* |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 7 | **返回** *r* |'
- en: 'The OS-RANK procedure works as follows. You can think of node *x*’s rank as
    the number of nodes preceding *x* in an inorder tree walk, plus 1 for *x* itself.
    OS-RANK maintains the following loop invariant:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: OS-RANK 过程的工作原理如下。你可以将节点 *x* 的排名看作是在中序遍历中 *x* 之前的节点数加上 *x* 本身的数量。OS-RANK 保持以下循环不变性：
- en: At the start of each iteration of the **while** loop of lines 3–6, *r* is the
    rank of *x*.*key* in the subtree rooted at node *y*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在第 3-6 行的 **while** 循环的每次迭代开始时，*r* 是 *y* 节点根的子树中 *x*.*key* 的排名。
- en: 'We use this loop invariant to show that OS-RANK works correctly as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用这个循环不变式来展示 OS-RANK 的正确性如下：
- en: '**Initialization:** Prior to the first iteration, line 1 sets *r* to be the
    rank of *x*.*key* within the subtree rooted at *x*. Setting *y* = *x* in line
    2 makes the invariant true the first time the test in line 3 executes.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化：** 在第一次迭代之前，第 1 行将 *r* 设置为 *x*.*key* 在以 *x* 为根的子树中的排名。在第 2 行中将 *y* =
    *x* 使得第 3 行的测试第一次执行时不变式成立。'
- en: '**Maintenance:** At the end of each iteration of the **while** loop, line 6
    sets *y* = *y*.*p*. Thus, we must show that if *r* is the rank of *x*.*key* in
    the subtree rooted at *y* at the start of the loop body, then *r* is the rank
    of *x*.*key* in the subtree rooted at *y*.*p* at the end of the loop body. In
    each iteration of the **while** loop, consider the subtree rooted at *y*.*p*.
    The value of *r* already includes the number of nodes in the subtree rooted at
    node *y* that precede *x* in an inorder walk, and so the procedure must add the
    nodes in the subtree rooted at *y*’s sibling that precede *x* in an inorder walk,
    plus 1 for *y*.*p* if it, too, precedes *x*. If *y* is a left child, then neither
    *y*.*p* nor any node in *y*.*p*’s right subtree precedes *x*, and so OS-RANK leaves
    *r* alone. Otherwise, *y* is a right child and all the nodes in *y*.*p*’s left
    subtree precede *x*, as does *y*.*p* itself. In this case, line 5 adds *y*.*p*.*left*.*size*
    + 1 to the current value of *r*.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**维护：** 在 **while** 循环的每次迭代结束时，第 6 行将 *y* = *y*.*p*。因此，我们必须证明如果 *r* 是循环体开始时
    *y* 为根的子树中 *x*.*key* 的排名，那么循环体结束时 *r* 是 *y*.*p* 为根的子树中 *x*.*key* 的排名。在 **while**
    循环的每次迭代中，考虑以 *y*.*p* 为根的子树。*r* 的值已经包括了在中序遍历中在节点 *y* 之前的节点数，因此过程必须添加在 *y* 的兄弟节点中在中序遍历中在
    *x* 之前的节点数，再加上 1 个 *y*.*p* 如果它也在 *x* 之前。如果 *y* 是左子节点，则 *y*.*p* 或 *y*.*p* 的右子树中的任何节点都不在
    *x* 之前，因此 OS-RANK 不会改变 *r*。否则，*y* 是右子节点，*y*.*p* 的左子树中的所有节点都在 *x* 之前，*y*.*p* 本身也在
    *x* 之前。在这种情况下，第 5 行将 *y*.*p*.*left*.*size* + 1 添加到 *r* 的当前值。'
- en: '**Termination:** Because each iteration of the loop moves *y* toward the root
    and the loop terminates when *y* = *T*.*root*, the loop eventually terminates.
    Moreover, the subtree rooted at *y* is the entire tree. Thus, the value of *r*
    is the rank of *x*.*key* in the entire tree.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**终止：** 因为循环的每次迭代都将 *y* 向根移动，当 *y* = *T*.*root* 时循环终止。此外，以 *y* 为根的子树就是整棵树。因此，*r*
    的值就是 *x*.*key* 在整棵树中的排名。'
- en: 'As an example, when OS-RANK runs on the order-statistic tree of [Figure 17.1](chapter017.xhtml#Fig_17-1)
    to find the rank of the node with key 38, the following sequence of values of
    *y*.*key* and *r* occurs at the top of the **while** loop:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，当 OS-RANK 在 [图 17.1](chapter017.xhtml#Fig_17-1) 的顺序统计树上运行以找到关键字为 38 的节点的排名时，在
    **while** 循环的顶部发生以下 *y*.*key* 和 *r* 值的序列：
- en: '| iteration | *y*.*key* | *r* |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| 迭代 | *y*.*key* | *r* |'
- en: '| 1 | 38 | 2 |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 38 | 2 |'
- en: '| 2 | 30 | 4 |'
  id: totrans-41
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 30 | 4 |'
- en: '| 3 | 41 | 4 |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 3 | 41 | 4 |'
- en: '| 4 | 26 | 17 |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 26 | 17 |'
- en: The procedure returns the rank 17.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 过程返回排名 17。
- en: 'Since each iteration of the **while** loop takes *O*(1) time, and *y* goes
    up one level in the tree with each iteration, the running time of OS-RANK is at
    worst proportional to the height of the tree: *O*(lg *n*) on an *n*-node order-statistic
    tree.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 **while** 循环的每次迭代都需要 *O*(1) 时间，并且 *y* 每次迭代在树中上升一级，因此 OS-RANK 的运行时间最坏情况下与树的高度成正比：在一个
    *n* 个节点的顺序统计树上为 *O*(lg *n*)。
- en: '**Maintaining subtree sizes**'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**维护子树大小**'
- en: Given the *size* attribute in each node, OS-SELECT and OS-RANK can quickly compute
    order-statistic information. But if the basic modifying operations on red-black
    trees cannot efficiently maintain the *size* attribute, our work will have been
    for naught. Let’s see how to maintain subtree sizes for both insertion and deletion
    without affecting the asymptotic running time of either operation.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 给定每个节点中的 *size* 属性，OS-SELECT 和 OS-RANK 可以快速计算顺序统计信息。但是，如果红黑树上的基本修改操作不能有效地维护
    *size* 属性，那么我们的工作将毫无意义。让我们看看如何在不影响这两个操作的渐近运行时间的情况下维护插入和删除的子树大小。
- en: Recall from [Section 13.3](chapter013.xhtml#Sec_13.3) that insertion into a
    red-black tree consists of two phases. The first phase goes down the tree from
    the root, inserting the new node as a child of an existing node. The second phase
    goes up the tree, changing colors and performing rotations to maintain the red-black
    properties.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [第 13.3 节](chapter013.xhtml#Sec_13.3) 回顾插入到红黑树中的过程包括两个阶段。第一阶段从根节点向下遍历树，将新节点插入为现有节点的子节点。第二阶段向上遍历树，改变颜色并执行旋转以保持红黑属性。
- en: To maintain the subtree sizes in the first phase, simply increment *x*.*size*
    for each node *x* on the simple path traversed from the root down toward the leaves.
    The new node added gets a *size* of 1\. Since there are *O*(lg *n*) nodes on the
    traversed path, the additional cost of maintaining the *size* attributes is *O*(lg
    *n*).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一阶段中为了维护子树大小，只需对从根向叶子遍历的简单路径上的每个节点 *x* 递增 *x*.*size*。新添加的节点得到一个 *size* 为 1。由于在遍历路径上有
    *O*(lg *n*) 个节点，因此维护 *size* 属性的额外成本为 *O*(lg *n*)。
- en: 'In the second phase, the only structural changes to the underlying red-black
    tree are caused by rotations, of which there are at most two. Moreover, a rotation
    is a local operation: only two nodes have their *size* attributes invalidated.
    The link around which the rotation is performed is incident on these two nodes.
    Referring to the code for LEFT-ROTATE(*T*, *x*) on page 336, add the following
    lines:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二阶段中，底层红黑树的唯一结构更改是由旋转引起的，最多有两次旋转。此外，旋转是一个局部操作：只有两个节点的 *size* 属性会失效。旋转围绕的链接作用于这两个节点。参考第
    336 页的 LEFT-ROTATE(*T*, *x*) 代码，添加以下行：
- en: '| 13 | *y*.*size* = *x*.*size* |'
  id: totrans-51
  prefs: []
  type: TYPE_TB
  zh: '| 13 | *y*.*size* = *x*.*size* |'
- en: '| 14 | *x*.*size* = *x*.*left*.*size* + *x*.*right*.*size* + 1 |'
  id: totrans-52
  prefs: []
  type: TYPE_TB
  zh: '| 14 | *x*.*size* = *x*.*left*.*size* + *x*.*right*.*size* + 1 |'
- en: '[Figure 17.2](chapter017.xhtml#Fig_17-2) illustrates how the attributes are
    updated. The change to RIGHT-ROTATE is symmetric.'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '[图17.2](chapter017.xhtml#Fig_17-2)展示了属性如何更新。对RIGHT-ROTATE的更改是对称的。'
- en: Since inserting into a red-black tree requires at most two rotations, updating
    the *size* attributes in the second phase costs only *O*(1) additional time. Thus,
    the total time for insertion into an *n*-node order-statistic tree is *O*(lg *n*),
    which is asymptotically the same as for an ordinary red-black tree.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于插入红黑树最多需要两次旋转，第二阶段中更新*size*属性只需额外*O*(1)的时间。因此，插入到*n*节点顺序统计树的总时间为*O*(lg *n*)，这在渐近意义上与普通红黑树相同。
- en: '![art](images/Art_P534.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P534.jpg)'
- en: '**Figure 17.2** Updating subtree sizes during rotations. The updates are local,
    requiring only the *size* information stored in *x*, *y*, and the roots of the
    subtrees shown as triangles.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**图17.2** 旋转期间更新子树大小。更新是局部的，只需要*x*、*y*和三角形表示的子树根中存储的*size*信息。'
- en: 'Deletion from a red-black tree also consists of two phases: the first operates
    on the underlying search tree, and the second causes at most three rotations and
    otherwise performs no structural changes. (See [Section 13.4](chapter013.xhtml#Sec_13.4).)
    The first phase removes one node *z* from the tree and could move at most two
    other nodes within the tree (nodes *y* and *x* in [Figure 12.4](chapter012.xhtml#Fig_12-4)
    on page 323). To update the subtree sizes, simply traverse a simple path from
    the lowest node that moves (starting from its original position within the tree)
    up to the root, decrementing the *size* attribute of each node on the path. Since
    this path has length *O*(lg *n*) in an *n*-node red-black tree, the additional
    time spent maintaining *size* attributes in the first phase is *O*(lg *n*). For
    the *O*(1) rotations in the second phase of deletion, handle them in the same
    manner as for insertion. Thus, both insertion and deletion, including maintaining
    the *size* attributes, take *O*(lg *n*) time for an *n*-node order-statistic tree.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从红黑树中删除也包括两个阶段：第一个在基础搜索树上操作，第二个最多进行三次旋转，否则不进行结构更改。（参见[第13.4节](chapter013.xhtml#Sec_13.4)。）第一阶段从树中移除一个节点*z*，最多可能将其他两个节点移动到树中（[图12.4](chapter012.xhtml#Fig_12-4)中的节点*y*和*x*）。要更新子树大小，只需沿着从移动的最低节点（从其原始位置开始）到根的简单路径遍历，递减路径上每个节点的*size*属性。由于在*n*节点红黑树中，这条路径的长度为*O*(lg
    *n*)，在第一阶段中花费的额外时间维护*size*属性为*O*(lg *n*)。对于删除的第二阶段中的*O*(1)次旋转，处理方式与插入相同。因此，对于*n*节点顺序统计树，包括维护*size*属性，插入和删除都需要*O*(lg
    *n*)的时间。
- en: '**Exercises**'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***17.1-1***'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '***17.1-1***'
- en: Show how OS-SELECT(*T*.*root*, 10) operates on the red-black tree *T* shown
    in [Figure 17.1](chapter017.xhtml#Fig_17-1).
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 展示OS-SELECT(*T*.*root*, 10)如何在红黑树*T*（见[图17.1](chapter017.xhtml#Fig_17-1)）上操作。
- en: '***17.1-2***'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '***17.1-2***'
- en: Show how OS-RANK(*T*, *x*) operates on the red-black tree *T* shown in [Figure
    17.1](chapter017.xhtml#Fig_17-1) and the node *x* with *x*.*key* = 35.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 展示OS-RANK(*T*, *x*)如何在红黑树*T*（见[图17.1](chapter017.xhtml#Fig_17-1)）和节点*x*（*x*.*key*
    = 35）上操作。
- en: '***17.1-3***'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '***17.1-3***'
- en: Write a nonrecursive version of OS-SELECT.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 编写OS-SELECT的非递归版本。
- en: '***17.1-4***'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '***17.1-4***'
- en: Write a procedure OS-KEY-RANK(*T*, *k*) that takes an order-statistic tree *T*
    and a key *k* and returns the rank of *k* in the dynamic set represented by *T*.
    Assume that the keys of *T* are distinct.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个过程OS-KEY-RANK(*T*, *k*)，接受一个顺序统计树*T*和一个关键字*k*，返回*T*表示的动态集合中*k*的秩。假设*T*的关键字是不同的。
- en: '***17.1-5***'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '***17.1-5***'
- en: Given an element *x* in an *n*-node order-statistic tree and a natural number
    *i*, show how to determine the *i*th successor of *x* in the linear order of the
    tree in *O*(lg *n*) time.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 给定*n*节点顺序统计树中的元素*x*和自然数*i*，展示如何在树的线性顺序中以*O*(lg *n*)时间确定*x*的第*i*个后继。
- en: '***17.1-6***'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '***17.1-6***'
- en: The procedures OS-SELECT and OS-RANK use the *size* attribute of a node only
    to compute a rank. Suppose that you store in each node its rank in the subtree
    of which it is the root instead of the *size* attribute. Show how to maintain
    this information during insertion and deletion. (Remember that these two operations
    can cause rotations.)
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 过程OS-SELECT和OS-RANK仅使用节点的*size*属性来计算秩。假设在每个节点中存储其在其为根的子树中的秩，而不是*size*属性。展示如何在插入和删除期间维护此信息。（请记住这两个操作可能会导致旋转。）
- en: '***17.1-7***'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '***17.1-7***'
- en: Show how to use an order-statistic tree to count the number of inversions (see
    Problem 2-4 on page 47) in an array of *n* distinct elements in *O*(*n* lg *n*)
    time.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何使用顺序统计树在*O*(*n* lg *n*)时间内计算数组中*n*个不同元素的逆序对数（参见第47页的问题2-4）。
- en: ★ ***17.1-8***
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***17.1-8***
- en: Consider *n* chords on a circle, each defined by its endpoints. Describe an
    *O*(*n* lg *n*)-time algorithm to determine the number of pairs of chords that
    intersect inside the circle. (For example, if the *n* chords are all diameters
    that meet at the center, then the answer is ![art](images/Art_P535.jpg).) Assume
    that no two chords share an endpoint.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在圆上考虑*n*条弦，每条弦由其端点定义。描述一个*O*(*n* lg *n*)时间复杂度的算法，用于确定圆内相交的弦对数。（例如，如果*n*条弦都是直径，相交于中心，则答案是![艺术](images/Art_P535.jpg)。）假设没有两条弦共享一个端点。
- en: '[**17.2    How to augment a data structure**](toc.xhtml#Rh1-102)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[**17.2    如何增强数据结构**](toc.xhtml#Rh1-102)'
- en: The process of augmenting a basic data structure to support additional functionality
    occurs quite frequently in algorithm design. We’ll use it again in the next section
    to design a data structure that supports operations on intervals. This section
    examines the steps involved in such augmentation. It includes a useful theorem
    that allows you to augment red-black trees easily in many cases.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 增强基本数据结构以支持额外功能的过程在算法设计中经常发生。我们将在下一节中再次使用它来设计支持区间操作的数据结构。本节探讨了这种增强所涉及的步骤。它包括一个有用的定理，允许您在许多情况下轻松增强红黑树。
- en: 'You can break the process of augmenting a data structure into four steps:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将增强数据结构的过程分为四个步骤：
- en: Choose an underlying data structure.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个基础数据结构。
- en: Determine additional information to maintain in the underlying data structure.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定要在基础数据结构中维护的额外信息。
- en: Verify that you can maintain the additional information for the basic modifying
    operations on the underlying data structure.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证您可以在基础数据结构的基本修改操作中维护额外信息。
- en: Develop new operations.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开发新操作。
- en: As with any prescriptive design method, you’ll rarely be able to follow the
    steps precisely in the order given. Most design work contains an element of trial
    and error, and progress on all steps usually proceeds in parallel. There is no
    point, for example, in determining additional information and developing new operations
    (steps 2 and 4) if you cannot maintain the additional information efficiently.
    Nevertheless, this four-step method provides a good focus for your efforts in
    augmenting a data structure, and it is also a good framework for documenting an
    augmented data structure.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何规范性设计方法一样，您很少能够按照给定顺序精确地遵循这些步骤。大多数设计工作都包含试验和错误的元素，通常所有步骤的进展都是并行的。例如，如果您无法有效地维护��外信息，那么确定额外信息和开发新操作（步骤2和4）就没有意义。尽管如此，这四步方法为您在增强数据结构方面的努力提供了一个很好的焦点，也是记录增强数据结构的良好框架。
- en: We followed these four steps in [Section 17.1](chapter017.xhtml#Sec_17.1) to
    design order-statistic trees. For step 1, we chose red-black trees as the underlying
    data structure. Red-black trees seemed like a good starting point because they
    efficiently support other dynamic-set operations on a total order, such as MINIMUM,
    MAXIMUM, SUCCESSOR, and PREDECESSOR.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第17.1节](chapter017.xhtml#Sec_17.1)中遵循了这四个步骤来设计顺序统计树。在第1步中，我们选择红黑树作为基础数据结构。红黑树似乎是一个很好的起点，因为它们有效地支持总序上的其他动态集合操作，如MINIMUM、MAXIMUM、SUCCESSOR和PREDECESSOR。
- en: In Step 2, we added the *size* attribute, so that each node *x* stores the size
    of the subtree rooted at *x*. Generally, the additional information makes operations
    more efficient. For example, it is possible to implement OS-SELECT and OS-RANK
    using just the keys stored in the tree, but then they would not run in *O*(lg
    *n*) time. Sometimes, the additional information is pointer information rather
    than data, as in Exercise 17.2-1.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2步中，我们添加了*size*属性，这样每个节点*x*都存储以*x*为根的子树的大小。通常，额外信息使操作更有效率。例如，可以仅使用树中存储的键来实现OS-SELECT和OS-RANK，但这样它们不会在*O*(lg
    *n*)时间内运行。有时，额外信息是指针信息而不是数据，就像在练习17.2-1中一样。
- en: For step 3, we ensured that insertion and deletion can maintain the *size* attributes
    while still running in *O*(lg *n*) time. Ideally, you would like to update only
    a few elements of the data structure in order to maintain the additional information.
    For example, if each node simply stores its rank in the tree, the OS-SELECT and
    OS-RANK procedures run quickly, but inserting a new minimum element might cause
    a change to this information in every node of the tree. Because we chose to store
    subtree sizes instead, inserting a new element causes information to change in
    only *O*(lg *n*) nodes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第3步，我们确保插入和删除可以在仍然在*O*(lg *n*)时间内维护*size*属性。理想情况下，您希望仅更新数据结构的少数元素以维护额外信息。例如，如果每个节点仅存储其在树中的排名，那么OS-SELECT和OS-RANK过程将快速运行，但插入一个新的最小元素可能会导致树中每个节点的信息发生变化。因为我们选择存储子树大小，插入新元素只会导致*O*(lg
    *n*)个节点的信息发生变化。
- en: In Step 4, we developed the operations OS-SELECT and OS-RANK. After all, the
    need for new operations is why anyone bothers to augment a data structure in the
    first place. Occasionally, rather than developing new operations, you can use
    the additional information to expedite existing ones, as in Exercise 17.2-1.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在第4步中，我们开发了操作OS-SELECT和OS-RANK。毕竟，需要新操作是任何人首先考虑增强数据结构的原因。有时，而不是开发新操作，您可以使用额外信息来加快现有操作，就像在练习17.2-1中一样。
- en: '**Augmenting red-black trees**'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '**增强红黑树**'
- en: When red-black trees underlie an augmented data structure, we can prove that
    insertion and deletion can always efficiently maintain certain kinds of additional
    information, thereby simplifying step 3\. The proof of the following theorem is
    similar to the argument from [Section 17.1](chapter017.xhtml#Sec_17.1) that we
    can maintain the *size* attribute for order-statistic trees.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 当红黑树作为增强数据结构的基础时，我们可以证明插入和删除总是可以有效地维护某些额外信息，从而简化第3步。以下定理的证明类似于[第17.1节](chapter017.xhtml#Sec_17.1)中的论证，我们可以为顺序统计树维护*size*属性。
- en: '***Theorem 17.1 (Augmenting a red-black tree)***'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理17.1（增强红黑树）***'
- en: Let *f* be an attribute that augments a red-black tree *T* of *n* nodes, and
    suppose that the value of *f* for each node *x* depends only the information in
    nodes *x*, *x*.*left*, and *x*.*right* (possibly including *x*.*left*.*f* and
    *x*.*right*.*f*), and that the value of *x*.*f* can be computed from this information
    in *O*(1) time. Then, the insertion and deletion operations can maintain the values
    of *f* in all nodes of *T* without asymptotically affecting the *O*(lg *n*) running
    times of these operations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 设*f*是增强了一个包含*n*个节点的红黑树*T*的属性，假设每个节点*x*的*f*值仅取决于节点*x*、*x*.*left*和*x*.*right*中的信息（可能包括*x*.*left*.*f*和*x*.*right*.*f*），并且*x*.*f*的值可以在*O*(1)时间内从这些信息中计算出来。那么，插入和删除操作可以在不影响这些操作的*O*(lg
    *n*)运行时间的情况下，维护*T*中所有节点的*f*值。
- en: '***Proof***   The main idea of the proof is that a change to an *f* attribute
    in a node *x* propagates only to ancestors of *x* in the tree. That is, changing
    *x*.*f* may require *x*.*p*.*f* to be updated, but nothing else; updating *x*.*p*.*f*
    may require *x*.*p*.*p*.*f* to be updated, but nothing else; and so on up the
    tree. After updating *T*.*root*.*f*, no other node depends on the new value, and
    so the process terminates. Since the height of a red-black tree is *O*(lg *n*),
    changing an *f* attribute in a node costs *O*(lg *n*) time in updating all nodes
    that depend on the change.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 主要思想是，对节点*x*中的*f*属性的更改仅传播到树中*x*的祖先。也就是说，更改*x*.*f*可能需要更新*x*.*p*.*f*，但不需要更新其他任何内容；更新*x*.*p*.*f*可能需要更新*x*.*p*.*p*.*f*，但不需要更新其他任何内容；依此类推直至树的顶部。在更新*T*.*root*.*f*后，没有其他节点依赖于新值，因此过程终止。由于红黑树的高度为*O*(lg
    *n*)，在更新所有依赖于更改的节点时，更改节点中的*f*属性的成本为*O*(lg *n*)时间。'
- en: As we saw in [Section 13.3](chapter013.xhtml#Sec_13.3), insertion of a node
    *x* into red-black tree *T* consists of two phases. If the tree *T* is empty,
    then the first phase simply makes *x* be the root of *T*. If *T* is not empty,
    then the first phase inserts *x* as a child of an existing node. Because we assume
    that the value of *x*.*f* depends only on information in the other attributes
    of *x* itself and the information in *x*’s children, and because *x*’s children
    are both the sentinel *T*.*nil*, it takes only *O*(1) time to compute the value
    of *x*.*f*. Having computed *x*.*f*, the change propagates up the tree. Thus,
    the total time for the first phase of insertion is *O*(lg *n*). During the second
    phase, the only structural changes to the tree come from rotations. Since only
    two nodes change in a rotation, but a change to an attribute might need to propagate
    up to the root, the total time for updating the *f* attributes is *O*(lg *n*)
    per rotation. Since the number of rotations during insertion is at most two, the
    total time for insertion is *O*(lg *n*).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第13.3节](chapter013.xhtml#Sec_13.3)中看到的，将节点*x*插入红黑树*T*包括两个阶段。如果树*T*为空，则第一阶段只需使*x*成为*T*的根。如果*T*不为空，则第一阶段将*x*插入为现有节点的子节点。因为我们假设*x*.*f*的值仅取决于*x*本身的其他属性和*x*的子节点中的信息，并且因为*x*的子节点都是哨兵*T*.*nil*，所以计算*x*.*f*的值仅需*O*(1)时间。计算完*x*.*f*后，更改向上传播到树中。因此，插入的第一阶段的总时间为*O*(lg
    *n*)。在第二阶段，树的结构更改仅来自旋转。由于旋转只更改两个节点，但更改属性可能需要向上传播到根，因此每次旋转更新*f*属性的总时间为*O*(lg *n*)。由于插入期间旋转的次数最多为两次，因此插入的总时间为*O*(lg
    *n*)。
- en: Like insertion, deletion has two phases, as [Section 13.4](chapter013.xhtml#Sec_13.4)
    discusses. In the first phase, changes to the tree occur when a node is deleted,
    and at most two other nodes could move within the tree. Propagating the updates
    to *f* caused by these changes costs at most *O*(lg *n*), since the changes modify
    the tree locally along a simple path from the lowest changed node to the root.
    Fixing up the red-black tree during the second phase requires at most three rotations,
    and each rotation requires at most *O*(lg *n*) time to propagate the updates to
    *f*. Thus, like insertion, the total time for deletion is *O*(lg *n*).
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 与插入类似，删除有两个阶段，如[第13.4节](chapter013.xhtml#Sec_13.4)所述。在第一阶段，当删除节点时，树发生更改，最多有两个其他节点可能在树中移动。由于这些更改沿着从最低更改节点到根的简单路径在树中局部修改树，因此由于这些更改导致的*f*的更新最多花费*O*(lg
    *n*)。在第二阶段修复红黑树时，最多需要三次旋转，每次旋转最多需要*O*(lg *n*)时间来传播*f*的更新。因此，与插入类似，删除的总时间为*O*(lg
    *n*)。
- en: ▪
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: In many cases, such as maintaining the *size* attributes in order-statistic
    trees, the cost of updating after a rotation is *O*(1), rather than the *O*(lg
    *n*) derived in the proof of Theorem 17.1\. Exercise 17.2-3 gives an example.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多情况下，例如在顺序统计树中维护*size*属性时，旋转后的更新成本为*O*(1)，而不是定理17.1证明中推导的*O*(lg *n*)。练习17.2-3给出了一个例子。
- en: On the other hand, when an update after a rotation requires a traversal all
    the way up to the root, it is important that insertion into and deletion from
    a red-black tree require a constant number of rotations. The chapter notes for
    [Chapter 13](chapter013.xhtml) list other schemes for balancing search trees that
    do not bound the number of rotations per insertion or deletion by a constant.
    If each operation might require Θ(lg *n*) rotations and each rotation traverses
    a path up to the root, then a single operation could require Θ(lg²*n*) time, rather
    than the *O*(lg *n*) time bound given by Theorem 17.1.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，当旋转后的更新需要遍历一直到根时，插入和删除红黑树需要恒定数量的旋转是很重要的。[第13章](chapter013.xhtml)的章节注释列出了其他平衡搜索树的方案，这些方案不通过常数限制每次插入或删除的旋转次数。如果每个操作可能需要Θ(lg
    *n*)次旋转，并且每次旋转都遍历一条路径到根，那么单个操作可能需要Θ(lg²*n*)时间，而不是定理17.1给出的*O*(lg *n*)时间界限。
- en: '**Exercises**'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***17.2-1***'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '***17.2-1***'
- en: Show, by adding pointers to the nodes, how to support each of the dynamic-set
    queries MINIMUM, MAXIMUM, SUCCESSOR, and PREDECESSOR in *O*(1) worst-case time
    on an augmented order-statistic tree. The asymptotic performance of other operations
    on order-statistic trees should not be affected.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通过向节点添加指针，展示如何在增强的顺序统计树上以*O*(1)的最坏情况时间支持每个动态集查询MINIMUM、MAXIMUM、SUCCESSOR和PREDECESSOR。顺序统计树上其他操作的渐近性能不应受影响。
- en: '***17.2-2***'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '***17.2-2***'
- en: Can you maintain the black-heights of nodes in a red-black tree as attributes
    in the nodes of the tree without affecting the asymptotic performance of any of
    the red-black tree operations? Show how, or argue why not. How about maintaining
    the depths of nodes?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你能否在红黑树中将节点的黑高度作为节点的属性而不影响任何红黑树操作的渐近性能？展示如何做到，或者为什么不能。那么维护节点的深度呢？
- en: '***17.2-3***'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '***17.2-3***'
- en: Let ⊗ be an associative binary operator, and let *a* be an attribute maintained
    in each node of a red-black tree. Suppose that you want to include in each node
    *x* an additional attribute *f* such that *x*.*f* = *x*[1].*a* ⊗ *x*[2].*a* ⊗
    … ⊗ *x[m]*.*a*, where *x*[1], *x*[2], … , *x[m]* is the inorder listing of nodes
    in the subtree rooted at *x*. Show how to update the *f* attributes in *O*(1)
    time after a rotation. Modify your argument slightly to apply it to the *size*
    attributes in order-statistic trees.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让⊗是一个可结合的二元运算符，*a*是红黑树每个节点中维护的一个属性。假设你想在每个节点*x*中包含一个额外属性*f*，使得*x*.*f* = *x*[1].*a*
    ⊗ *x*[2].*a* ⊗ … ⊗ *x[m]*.*a*，其中*x*[1]，*x*[2]，…，*x[m]*是以*x*为根的子树中节点的中序列表。展示如何在旋转后在*O*(1)时间内更新*f*属性。稍微修改你的论点，以将其应用于有序统计树中的*size*属性。
- en: '[**17.3    Interval trees**](toc.xhtml#Rh1-103)'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '[**17.3    区间树**](toc.xhtml#Rh1-103)'
- en: This section shows how to augment red-black trees to support operations on dynamic
    sets of intervals. In this section, we’ll assume that intervals are closed. Extending
    the results to open and half-open intervals is conceptually straightforward. (See
    page 1157 for definitions of closed, open, and half-open intervals.)
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了如何扩展红黑树以支持动态区间集合上的操作。在本节中，我们将假设区间是闭合的。将结果扩展到开放和半开放区间在概念上是直接的。（有关闭合、开放和半开放区间的定义，请参见第1157页。）
- en: Intervals are convenient for representing events that each occupy a continuous
    period of time. For example, you could query a database of time intervals to find
    out which events occurred during a given interval. The data structure in this
    section provides an efficient means for maintaining such an interval database.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 区间方便地表示每个占据连续时间段的事件。例如，您可以查询时间间隔数据库，以查找在给定时间间隔内发生了哪些事件。本节中的数据结构提供了一种维护这种区间数据库的有效方法。
- en: A simple way to represent an interval [*t*[1], *t*[2]] is as an object *i* with
    attributes *i*.*low* = *t*[1] (the ***low endpoint***) and *i*.*high* = *t*[2]
    (the ***high endpoint***). We say that intervals *i* and *i*′ ***overlap*** if
    *i* ∩*i*′ ≠ ∅, that is, if *i*.*low* ≤ *i*′.*high* and *i*′.*low* ≤ *i*.*high*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 表示一个区间[*t*[1], *t*[2]]的简单方法是将其表示为一个对象*i*，其属性为*i*.*low* = *t*[1]（***低端点***）和*i*.*high*
    = *t*[2]（***高端点***）。我们说区间*i*和*i*′***重叠***，如果*i* ∩*i*′ ≠ ∅，即，如果*i*.*low* ≤ *i*′.*high*且*i*′.*low*
    ≤ *i*.*high*。
- en: '![art](images/Art_P536.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P536.jpg)'
- en: '**Figure 17.3** The interval trichotomy for two closed intervals *i* and *i*′.
    **(a)** If *i* and *i*′ overlap, there are four situations, and in each, *i*.*low*
    ≤ *i*′.*high* and *i*′.*low* ≤ *i*.*high*. **(b)** The intervals do not overlap,
    and *i*.*high < i*′.*low*. **(c)** The intervals do not overlap, and *i*′.*high
    < i*.*low*.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**图17.3** 两个闭区间*i*和*i*′的区间三歧性。**(a)** 如果*i*和*i*′重叠，有四种情况，在每种情况中，*i*.*low* ≤
    *i*′.*high*且*i*′.*low* ≤ *i*.*high*。**(b)** 区间不重叠，且*i*.*high < i*′.*low*。**(c)**
    区间不重叠，且*i*′.*high < i*.*low*。'
- en: 'As [Figure 17.3](chapter017.xhtml#Fig_17-3) shows, any two intervals *i* and
    *i*′ satisfy the ***interval trichotomy***, that is, exactly one of the following
    three properties holds:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图17.3](chapter017.xhtml#Fig_17-3)所示，任意两个区间*i*和*i*′满足***区间三歧性***，即，以下三种属性中恰好有一种成立：
- en: a. *i* and *i*′ overlap,
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: a. *i*和*i*′重叠，
- en: b. *i* is to the left of *i*′ (i.e., *i*.*high* < *i*′.*low*),
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: b. *i*在*i*′的左侧（即，*i*.*high* < *i*′.*low*），
- en: c. *i* is to the right of *i*′ (i.e., *i*′.*high* < *i*.*low*).
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: c. *i*在*i*′的右侧（即，*i*′.*high* < *i*.*low*）。
- en: 'An ***interval tree*** is a red-black tree that maintains a dynamic set of
    elements, with each element *x* containing an interval *x*.*int*. Interval trees
    support the following operations:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 一个***区间树***是一棵红黑树，用于维护一个动态元素集合，其中每个元素*x*包含一个区间*x*.*int*。区间树支持以下操作：
- en: INTERVAL-INSERT(*T*, *x*) adds the element *x*, whose *int* attribute is assumed
    to contain an interval, to the interval tree *T*.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: INTERVAL-INSERT(*T*, *x*)将元素*x*（假定其*int*属性包含一个区间）添加到区间树*T*中。
- en: INTERVAL-DELETE(*T*, *x*) removes the element *x* from the interval tree *T*.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: INTERVAL-DELETE(*T*, *x*)从区间树*T*中移除元素*x*。
- en: INTERVAL-SEARCH(*T*, *i*) returns a pointer to an element *x* in the interval
    tree *T* such that *x*.*int* overlaps interval *i*, or a pointer to the sentinel
    *T*.*nil* if no such element belongs to the set.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: INTERVAL-SEARCH(*T*, *i*)返回指向区间树*T*中元素*x*的指针，使得*x*.*int*与区间*i*重叠，或者如果没有这样的元素属于集合，则返回指向哨兵*T*.*nil*的指针。
- en: '[Figure 17.4](chapter017.xhtml#Fig_17-4) shows how an interval tree represents
    a set of intervals. The four-step method from [Section 17.2](chapter017.xhtml#Sec_17.2)
    will guide our design of an interval tree and the operations that run on it.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '[图17.4](chapter017.xhtml#Fig_17-4)展示了区间树如何表示一组区间。来自[第17.2节](chapter017.xhtml#Sec_17.2)的四步方法将指导我们设计区间树及其上运行的操作。'
- en: '**Step 1: Underlying data structure**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤1：基础数据结构**'
- en: A red-black tree serves as the underlying data structure. Each node *x* contains
    an interval *x*.*int*. The key of *x* is the low endpoint, *x*.*int*.*low*, of
    the interval. Thus, an inorder tree walk of the data structure lists the intervals
    in sorted order by low endpoint.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑树作为基础数据结构。每个节点*x*包含一个区间*x*.*int*。*x*的关键是区间的低端点*x*.*int*.*low*。因此，数据结构的中序树遍历按低端点的顺序列出区间。
- en: '![art](images/Art_P537.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P537.jpg)'
- en: '**Figure 17.4** An interval tree. **(a)** A set of 10 intervals, shown sorted
    bottom to top by left endpoint. **(b)** The interval tree that represents them.
    Each node *x* contains an interval, shown above the dashed line, and the maximum
    value of any interval endpoint in the subtree rooted at *x*, shown below the dashed
    line. An inorder tree walk of the tree lists the nodes in sorted order by left
    endpoint.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '**图17.4** 一个区间树。**(a)** 一组10个区间，按左端点从底部到顶部排序显示。**(b)** 代表它们的区间树。每个节点*x*包含一个区间，显示在虚线上方，并且在以*x*为根的子树中任何区间端点的最大值，显示在虚线下方。树的中序遍历按左端点的顺序列出节点。'
- en: '**Step 2: Additional information**'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**步骤2：额外信息**'
- en: In addition to the intervals themselves, each node *x* contains a value *x*.*max*,
    which is the maximum value of any interval endpoint stored in the subtree rooted
    at *x*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 除了区间本身，每个节点 *x* 还包含一个值 *x*.*max*，它是存储在以 *x* 为根的子树中任何区间端点的最大值。
- en: '**Step 3: Maintaining the information**'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '**第 3 步：维护信息**'
- en: 'We must verify that insertion and deletion take *O*(lg *n*) time on an interval
    tree of *n* nodes. It is simple enough to determine *x*.*max* in *O*(1) time,
    given interval *x*.*int* and the *max* values of node *x*’s children:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须验证在 *n* 个节点的区间树上插入和删除需要 *O*(lg *n*) 的时间。很容易确定 *x*.*max*，只需在 *O*(1) 的时间内给定区间
    *x*.*int* 和节点 *x* 的子节点的 *max* 值：
- en: '*x*.*max* = max {*x*.*int*.*high*, *x*.*left*.*max*, *x*.*right*.*max*}.'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*.*max* = max {*x*.*int*.*high*, *x*.*left*.*max*, *x*.*right*.*max*}.'
- en: Thus, by Theorem 17.1, insertion and deletion run in *O*(lg *n*) time. In fact,
    you can use either Exercise 17.2-3 or 17.3-1 to show how to update all the *max*
    attributes that change after a rotation in just *O*(1) time.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据定理 17.1，插入和删除在 *O*(lg *n*) 的时间内运行。实际上，您可以使用练习 17.2-3 或 17.3-1 来展示如何在旋转后仅用
    *O*(1) 的时间更新所有更改的 *max* 属性。
- en: '**Step 4: Developing new operations**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**第 4 步：开发新操作**'
- en: The only new operation is INTERVAL-SEARCH(*T*, *i*), which finds a node in tree
    *T* whose interval overlaps interval *i*. If there is no interval in the tree
    that overlaps *i*, the procedure returns a pointer to the sentinel *T*.*nil*.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的新操作是 INTERVAL-SEARCH(*T*, *i*)，它在树 *T* 中找到与区间 *i* 重叠的节点。如果树中没有与 *i* 重叠的区间，则该过程返回指向哨兵
    *T*.*nil* 的指针。
- en: INTERVAL-SEARCH(*T*, *i*)
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: INTERVAL-SEARCH(*T*, *i*)
- en: '| 1 | *x* = *T*.*root* |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *x* = *T*.*root* |'
- en: '| 2 | **while** *x* ≠ *T*.*nil* and *i* does not overlap *x*.*int* |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **while** *x* ≠ *T*.*nil* and *i* does not overlap *x*.*int* |'
- en: '| 3 | **if** *x*.*left* ≠ *T*.*nil* and *x*.*left*.*max* ≥ *i*.*low* |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **if** *x*.*left* ≠ *T*.*nil* and *x*.*left*.*max* ≥ *i*.*low* |'
- en: '| 4 | *x* = *x*.*left* | **//** overlap in left subtree or no overlap in right
    subtree |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *x* = *x*.*left* | **//** 左子树中有重叠或右子树中没有重叠 |'
- en: '| 5 | **else** *x* = *x*.*right* | **//** no overlap in left subtree |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **else** *x* = *x*.*right* | **//** 左子树中没有重叠 |'
- en: '| 6 | **return** *x* |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 6 | **return** *x* |'
- en: The search for an interval that overlaps *i* starts at the root of the tree
    and proceeds downward. It terminates when either it finds an overlapping interval
    or it reaches the sentinel *T*.*nil*. Since each iteration of the basic loop takes
    *O*(1) time, and since the height of an *n*-node red-black tree is *O*(lg *n*),
    the INTERVAL-SEARCH procedure takes *O*(lg *n*) time.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找与 *i* 重叠的区间从树的根开始并向下进行。当找到重叠区间或到达哨兵 *T*.*nil* 时终止。由于基本循环的每次迭代都需要 *O*(1) 的时间，并且由于
    *n* 个节点的红黑树的高度为 *O*(lg *n*)，因此 INTERVAL-SEARCH 过程需要 *O*(lg *n*) 的时间。
- en: Before we see why INTERVAL-SEARCH is correct, let’s examine how it works on
    the interval tree in [Figure 17.4](chapter017.xhtml#Fig_17-4). Let’s look for
    an interval that overlaps the interval *i* = [22, 25]. Begin with *x* as the root,
    which contains [16, 21] and does not overlap *i*. Since *x*.*left*.*max* = 23
    is greater than *i*.*low* = 22, the loop continues with *x* as the left child
    of the root—the node containing [8, 9], which also does not overlap *i*. This
    time, *x*.*left*.*max* = 10 is less than *i*.*low* = 22, and so the loop continues
    with the right child of *x* as the new *x*. Because the interval [15, 23] stored
    in this node overlaps *i*, the procedure returns this node.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们看到 INTERVAL-SEARCH 为什么正确之前，让我们看看它在 [图 17.4](chapter017.xhtml#Fig_17-4) 中的区间树上是如何工作的。让我们寻找一个与区间
    *i* = [22, 25] 重叠的区间。从 *x* 作为根开始，其中包含 [16, 21]，不与 *i* 重叠。由于 *x*.*left*.*max* =
    23 大于 *i*.*low* = 22，循环继续，*x* 作为根的左子节点——包含 [8, 9] 的节点，也不与 *i* 重叠。这次，*x*.*left*.*max*
    = 10 小于 *i*.*low* = 22，所以循环继续，将 *x* 的右子节点作为新的 *x*。因为这个节点中存储的区间 [15, 23] 与 *i*
    重叠，所以该过程返回这个节点。
- en: Now let’s try an unsuccessful search, for an interval that overlaps *i* = [11,
    14] in the interval tree of [Figure 17.4](chapter017.xhtml#Fig_17-4). Again, begin
    with *x* as the root. Since the root’s interval [16, 21] does not overlap *i*,
    and since *x*.*left*.*max* = 23 is greater than *i*.*low* = 11, go left to the
    node containing [8, 9]. Interval [8, 9] does not overlap *i*, and *x*.*left*.*max*
    = 10 is less than *i*.*low* = 11, and so the search goes right. (No interval in
    the left subtree overlaps *i*.) Interval [15, 23] does not overlap *i*, and its
    left child is *T*.*nil*, so again the search goes right, the loop terminates,
    and INTERVAL-SEARCH returns the sentinel *T*.*nil*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们尝试一个不成功的搜索，寻找在 [图 17.4](chapter017.xhtml#Fig_17-4) 的区间树中与 *i* = [11, 14]
    重叠的区间。同样，从 *x* 作为根开始。由于根的区间 [16, 21] 不与 *i* 重叠，并且 *x*.*left*.*max* = 23 大于 *i*.*low*
    = 11，向左移动到包含 [8, 9] 的节点。区间 [8, 9] 不与 *i* 重叠，*x*.*left*.*max* = 10 小于 *i*.*low*
    = 11，所以搜索向右移动。（左子树中没有区间与 *i* 重叠。）区间 [15, 23] 不与 *i* 重叠，其左子节点为 *T*.*nil*，所以搜索再次向右移动，循环终止，INTERVAL-SEARCH
    返回哨兵 *T*.*nil*。
- en: 'To see why INTERVAL-SEARCH is correct, we must understand why it suffices to
    examine a single path from the root. The basic idea is that at any node *x*, if
    *x*.*int* does not overlap *i*, the search always proceeds in a safe direction:
    the search will definitely find an overlapping interval if the tree contains one.
    The following theorem states this property more precisely.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解 INTERVAL-SEARCH 为什么正确，我们必须理解为什么只需检查从根到单个路径就足够了。基本思想是，在任何节点 *x* 处，如果 *x*.*int*
    不与 *i* 重叠，则搜索总是朝着安全方向进行：如果树中包含重叠区间，则搜索一定会找到重叠区间。以下定理更准确地陈述了这一属性。
- en: '***Theorem 17.2***'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 17.2***'
- en: Any execution of INTERVAL-SEARCH(*T*, *i*) either returns a node whose interval
    overlaps *i*, or it returns *T*.*nil* and the tree *T* contains no node whose
    interval overlaps *i*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 任何执行 INTERVAL-SEARCH(*T*, *i*) 要么返回一个与 *i* 重叠的节点，要么返回 *T*.*nil*，表示树 *T* 不包含与
    *i* 重叠的节点。
- en: '***Proof***   The **while** loop of lines 2–5 terminates when either *x* =
    *T*.*nil* or *i* overlaps *x*.*int*. In the latter case, it is certainly correct
    to return *x*. Therefore, we focus on the former case, in which the **while**
    loop terminates because *x* = *T*.*nil*, which is the node that INTERVAL-SEARCH
    returns.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** **while** 循环在第2-5行终止，当*x* = *T*.*nil*或*i*与*x*.*int*重叠时。在后一种情况下，返回*x*当然是正确的。因此，我们关注前一种情况，即**while**循环终止于*x*
    = *T*.*nil*，即INTERVAL-SEARCH返回的节点。'
- en: We’ll prove that if the procedure returns *T*.*nil*, then it did not miss any
    intervals in *T* that overlap *i*. The idea is to show that whether the search
    goes left in line 4 or right in line 5, it always heads toward a node containing
    an interval overlapping *i*, if any such interval exists. In particular, we’ll
    prove that
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将证明，如果过程返回*T*.*nil*，则它没有错过与*i*重叠的*T*中的任何区间。思路是表明无论搜索在第4行向左还是在第5行向右，它总是朝向包含与*i*重叠的区间的节点前进，如果存在这样的区间。特别地，我们将证明
- en: If the search goes left in line 4, then the left subtree of node *x* contains
    an interval that overlaps *i* or the right subtree of *x* contains no interval
    that overlaps *i*. Therefore, even if *x*’s left subtree contains no interval
    that overlaps *i* but the search goes left, it does not make a mistake, because
    *x*’s right subtree does not contain an interval overlapping *i*, either.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果搜索在第4行向左进行，那么节点*x*的左子树包含一个与*i*重叠的区间，或者*x*的右子树不包含与*i*重叠的区间。因此，即使*x*的左子树不包含与*i*重叠的区间，但搜索向左进行也不会出错，因为*x*的右子树也不包含与*i*重叠的区间。
- en: If the search goes right in line 5, then the left subtree of *x* contains no
    interval that overlaps *i*. Thus, if the search goes right, it does not make a
    mistake.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果搜索在第5行正确进行，那么*x*的左子树不包含与*i*重叠的区间。因此，如果搜索向右进行，就不会出错。
- en: For both cases, we rely on the interval trichotomy. Let’s start with the case
    where the search goes right, whose proof is simpler. By the tests in line 3, we
    know that *x*.*left* = *T*.*nil* or *x*.*left*.*max < i*.*low*. If *x*.*left*
    = *T*.*nil*, then *x*’s left subtree contains no interval that overlaps *i*, since
    it contains no intervals at all. Now suppose that *x*.*left* ≠ *T*.*nil*, so that
    we must have *x*.*left*.*max < i*.*low*. Consider any interval *i*′ in *x*’s left
    subtree. Because *x*.*left*.*max* is the maximum endpoint in *x*’s left subtree,
    we have *i*′.*high* ≤ *x*.*left*.*max*. Thus, as [Figure 17.5(a)](chapter017.xhtml#Fig_17-5)
    shows,
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这两种情况，我们依赖于区间三歧性。让我们从搜索向右的情况开始，其证明更简单。通过第3行的测试，我们知道*x*.*left* = *T*.*nil*或*x*.*left*.*max
    < i*.*low*。如果*x*.*left* = *T*.*nil*，那么*x*的左子树不包含与*i*重叠的区间，因为它根本不包含任何区间。现在假设*x*.*left*
    ≠ *T*.*nil*，因此我们必须有*x*.*left*.*max < i*.*low*。考虑*x*的左子树中的任何区间*i*′。因为*x*.*left*.*max*是*x*的左子树中的最大端点，我们有*i*′.*high*
    ≤ *x*.*left*.*max*。因此，正如[图17.5(a)](chapter017.xhtml#Fig_17-5)所示，
- en: '| *i*′.*high* | ≤ | *x*.*left*.*max* |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| *i*′.*high* | ≤ | *x*.*left*.*max* |'
- en: '|  | < | *i*.*low*. |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  | < | *i*.*low*. |'
- en: By the interval trichotomy, therefore, intervals *i* and *i*′ do not overlap,
    and so *x*’s left subtree contains no interval that overlaps *i*.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据区间三歧性，区间*i*和*i*′不重叠，因此*x*的左子树不包含与*i*重叠的区间。
- en: '![art](images/Art_P538.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P538.jpg)'
- en: '**Figure 17.5** Intervals in the proof of Theorem 17.2\. The value of *x*.*left*.*max*
    is shown in each case as a dashed line. **(a)** The search goes right. No interval
    *i*′ in *x*’s left subtree can overlap *i*. **(b)** The search goes left. The
    left subtree of *x* contains an interval that overlaps *i* (situation not shown),
    or *x*’s left subtree contains an interval *i*′ such that *i*′.*high* = *x*.*left*.*max*.
    Since *i* does not overlap *i*′, neither does it overlap any interval *i*″ in
    *x*’s right subtree, since *i*′.*low* ≤ *i*″.*low*.'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '**图17.5** 定理17.2证明中的区间。每种情况下*x*.*left*.*max*的值都显示为虚线。**(a)** 搜索向右。*x*的左子树中没有区间*i*′可以与*i*重叠。**(b)**
    搜索向左。*x*的左子树包含一个与*i*重叠的区间（未显示的情况），或者*x*的左子树包含一个区间*i*′，使得*i*′.*high* = *x*.*left*.*max*。由于*i*不与*i*′重叠，它也不与*x*的右子树中的任何区间*i*″重叠，因为*i*′.*low*
    ≤ *i*″.*low*。'
- en: Now we examine the case in which the search goes left. If the left subtree of
    node *x* contains an interval that overlaps *i*, we’re done, so let’s assume that
    no node in *x*’s left subtree overlaps *i*. We need to show that in this case,
    no node in *x*’s right subtree overlaps *i*, so that going left will not miss
    any overlaps in *x*’s right subtree. By the tests in line 3, the left subtree
    of *x* is not empty and *x*.*left*.*max* ≥ *i*.*low*. By the definition of the
    *max* attribute, *x*’s left subtree contains some interval *i*′ such that
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看搜索向左的情况。如果节点*x*的左子树包含一个与*i*重叠的区间，那么我们完成了，因此假设*x*的左子树中没有节点与*i*重叠。我们需要证明在这种情况下，*x*的右子树中没有节点与*i*重叠，因此向左不会错过*x*的右子树中的任何重叠。通过第3行的测试，*x*的左子树不为空且*x*.*left*.*max*
    ≥ *i*.*low*。根据*max*属性的定义，*x*的左子树包含一些区间*i*′，使得
- en: '| *i*′.*high* | = | *x*.*left*.*max* |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| *i*′.*high* | = | *x*.*left*.*max* |'
- en: '|  | ≥ | *i*.*low*, |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|  | ≥ | *i*.*low*, |'
- en: as illustrated in [Figure 17.5(b)](chapter017.xhtml#Fig_17-5). Since *i*′ is
    in *x*’s left subtree, it does not overlap *i*, and since *i*′.*high* ≥ *i*.*low*,
    the interval trichotomy tells us that *i*.*high < i*′.*low*. Now we bring in the
    property that interval trees are keyed on the low endpoints of intervals. Because
    *i*′ is in *x*’s left subtree, we have *i*′.*low* ≤ *x*.*int*.*low*. Now consider
    any interval *i*″ in *x*’s right subtree, so that *x*.*int*.*low* ≤ *i*″.*low*.
    Putting inequalities together, we get
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图17.5(b)](chapter017.xhtml#Fig_17-5)所示。由于*i*′在*x*的左子树中，它不与*i*重叠，且由于*i*′.*high*
    ≥ *i*.*low*，区间三歧性告诉我们*i*.*high < i*′.*low*。现在我们引入区间树以低端点为键的属性。因为*i*′在*x*的左子树中，我们有*i*′.*low*
    ≤ *x*.*int*.*low*。现在考虑*x*的右子树中的任何区间*i*″，使得*x*.*int*.*low* ≤ *i*″.*low*。将不等式放在一起，我们得到
- en: '| *i*.*high* | < | *i*′.*low* |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| *i*.*high* | < | *i*′.*low* |'
- en: '|  | ≤ | *x*.*int*.*low* |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | *x*.*int*.*low* |'
- en: '|  | ≤ | *i*″.*low*. |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | *i*″.*low*. |'
- en: Because *i*.*high < i*″.*low*, the interval trichotomy tells us that *i* and
    *i*″ do not overlap. Since we chose *i*″ as any interval in *x*’s right subtree,
    no node in *x*’s right subtree overlaps *i*.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*i*.*high < i*″.*low*，区间三分法告诉我们*i*和*i*″不重叠。由于我们选择*i*″作为*x*右子树中的任意区间，所以*x*右子树中的任何节点都不会与*i*重叠。
- en: ▪
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Thus, the INTERVAL-SEARCH procedure works correctly.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，INTERVAL-SEARCH过程运行正确。
- en: '**Exercises**'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***17.3-1***'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '***17.3-1***'
- en: Write pseudocode for LEFT-ROTATE that operates on nodes in an interval tree
    and updates all the *max* attributes that change in *O*(1) time.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个在区间树中操作并在*O*(1)时间内更新所有更改的*max*属性的LEFT-ROTATE的伪代码。
- en: '***17.3-2***'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '***17.3-2***'
- en: Describe an efficient algorithm that, given an interval *i*, returns an interval
    overlapping *i* that has the minimum low endpoint, or *T*.*nil* if no such interval
    exists.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 描述一个有效的算法，给定一个区间*i*，返回与*i*重叠且具有最小低端点的区间，如果不存在这样的区间，则返回*T*.*nil*。
- en: '***17.3-3***'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '***17.3-3***'
- en: 'Given an interval tree *T* and an interval *i*, describe how to list all intervals
    in *T* that overlap *i* in *O*(min {*n*, *k* lg *n*}) time, where *k* is the number
    of intervals in the output list. (*Hint*: One simple method makes several queries,
    modifying the tree between queries. A slightly more complicated method does not
    modify the tree.)'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个区间树*T*和一个区间*i*，描述如何在*O*(min {*n*, *k* lg *n*})时间内列出*T*中与*i*重叠的所有区间，其中*k*是输出列表中的区间数。(*提示*：一种简单的方法在查询之间进行修改，修改树。稍微复杂一点的方法不修改树。)
- en: '***17.3-4***'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '***17.3-4***'
- en: Suggest modifications to the interval-tree procedures to support the new operation
    INTERVAL-SEARCH-EXACTLY(*T*, *i*), where *T* is an interval tree and *i* is an
    interval. The operation should return a pointer to a node *x* in *T* such that
    *x*.*int*.*low* = *i*.*low* and *x*.*int*.*high* = *i*.*high*, or *T*.*nil* if
    *T* contains no such node. All operations, including INTERVAL-SEARCH-EXACTLY,
    should run in *O*(lg *n*) time on an *n*-node interval tree.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 建议修改区间树程序以支持新操作INTERVAL-SEARCH-EXACTLY(*T*, *i*)，其中*T*是一个区间树，*i*是一个区间。该操作应返回*T*中满足*x*.*int*.*low*
    = *i*.*low*和*x*.*int*.*high* = *i*.*high*的节点*x*的指针，如果*T*不包含这样的节点，则返回*T*.*nil*。所有操作，包括INTERVAL-SEARCH-EXACTLY，应在*n*个节点的区间树上以*O*(lg
    *n*)时间运行。
- en: '***17.3-5***'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '***17.3-5***'
- en: Show how to maintain a dynamic set *Q* of numbers that supports the operation
    MIN-GAP, which gives the absolute value of the difference of the two closest numbers
    in *Q*. For example, if we have *Q* = {1, 5, 9, 15, 18, 22}, then MIN-GAP(*Q*)
    returns 3, since 15 and 18 are the two closest numbers in *Q*. Make the operations
    INSERT, DELETE, SEARCH, and MIN-GAP as efficient as possible, and analyze their
    running times.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何维护一个支持MIN-GAP操作的数字动态集合*Q*，该操作返回*Q*中两个最接近数字的绝对值差。例如，如果我们有*Q* = {1, 5, 9,
    15, 18, 22}，那么MIN-GAP(*Q*)返回3，因为15和18是*Q*中最接近的两个数字。使INSERT、DELETE、SEARCH和MIN-GAP操作尽可能高效，并分析它们的运行时间。
- en: ★ ***17.3-6***
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***17.3-6***
- en: 'VLSI databases commonly represent an integrated circuit as a list of rectangles.
    Assume that each rectangle is rectilinearly oriented (sides parallel to the *x*-
    and *y*-axes), so that each rectangle is represented by four values: its minimum
    and maximum *x*- and *y*-coordinates. Give an *O*(*n* lg *n*)-time algorithm to
    decide whether a set of *n* rectangles so represented contains two rectangles
    that overlap. Your algorithm need not report all intersecting pairs, but it must
    report that an overlap exists if one rectangle entirely covers another, even if
    the boundary lines do not intersect. (*Hint*: Move a “sweep” line across the set
    of rectangles.)'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: VLSI数据库通常将集成电路表示为矩形列表。假设每个矩形都是直角方向（边平行于*x*和*y*轴），因此每个矩形由四个值表示：其最小和最大*x*和*y*坐标。给出一个*O*(*n*
    lg *n*)时间算法，以确定以这种方式表示的一组*n*个矩形是否包含重叠的两个矩形。你的算法不需要报告所有相交的对，但如果一个矩形完全覆盖另一个矩形，即使边界线不相交，也必须报告存在重叠。(*提示*：在矩形集合上移动“扫描”线。)
- en: '**Problems**'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '***17-1     Point of maximum overlap***'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '***17-1     最大重叠点***'
- en: You wish to keep track of a ***point of maximum overlap*** in a set of intervals—a
    point with the largest number of intervals in the set that overlap it.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望跟踪一组区间中的***最大重叠点***—一个集合中与之重叠的区间数最多的点。
- en: '***a.*** Show that there is always a point of maximum overlap that is an endpoint
    of one of the intervals.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 展示总是存在一个作为区间端点的最大重叠点。'
- en: '***b.*** Design a data structure that efficiently supports the operations INTERVAL-INSERT,
    INTERVAL-DELETE, and FIND-POM, which returns a point of maximum overlap. (*Hint*:
    Keep a red-black tree of all the endpoints. Associate a value of +1 with each
    left endpoint, and associate a value of −1 with each right endpoint. Augment each
    node of the tree with some extra information to maintain the point of maximum
    overlap.)'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 设计一个数据结构，有效支持INTERVAL-INSERT、INTERVAL-DELETE和FIND-POM操作，返回最大重叠点。(*提示*：保持所有端点的红黑树。将每个左端点关联值+1，将每个右端点关联值-1。增加树的每个节点的一些额外信息以维护最大重叠点。)'
- en: '***17-2     Josephus permutation***'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '***17-2     Josephus排列***'
- en: We define the ***Josephus problem*** as follows. A group of *n* people form
    a circle, and we are given a positive integer *m* ≤ *n*. Beginning with a designated
    first person, proceed around the circle, removing every *m*th person. After each
    person is removed, counting continues around the circle that remains. This process
    continues until nobody remains in the circle. The order in which the people are
    removed from the circle defines the **(*n*, *m*)-*Josephus permutation*** of the
    integers 1, 2, … , *n*. For example, the (7, 3)-Josephus permutation is 〈3, 6,
    2, 7, 5, 1, 4〉.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将***Josephus问题***定义如下。一组*n*个人围成一个圆圈，给定一个正整数*m* ≤ *n*。从指定的第一个人开始，沿着圆圈继续，每隔*m*个人移除一个人。每次移除一个人后，继续计数剩下的圆圈。这个过程一直持续，直到圆圈中没有人。从圆圈中移除人的顺序定义了整数1,
    2, … , *n*的**(*n*, *m*)-Josephus排列**。例如，(7, 3)-Josephus排列是〈3, 6, 2, 7, 5, 1, 4〉。
- en: '***a.*** Suppose that *m* is a constant. Describe an *O*(*n*)-time algorithm
    that, given an integer *n*, outputs the (*n*, *m*)-Josephus permutation.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 假设*m*是一个常数。描述一个*O*(*n*)时间复杂度的算法，给定一个整数*n*，输出(*n*, *m*)-Josephus排列。'
- en: '***b.*** Suppose that *m* is not necessarily a constant. Describe an *O*(*n*
    lg *n*)-time algorithm that, given integers *n* and *m*, outputs the (*n*, *m*)-Josephus
    permutation.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 假设*m*不一定是一个常数。描述一个*O*(*n* lg *n*)时间复杂度的算法，给定整数*n*和*m*，输出(*n*, *m*)-Josephus排列。'
- en: '**Chapter notes**'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节注释**'
- en: In their book, Preparata and Shamos [[364](bibliography001.xhtml#endnote_364)]
    describe several of the interval trees that appear in the literature, citing work
    by H. Edelsbrunner (1980) and E. M. McCreight (1981). The book details an interval
    tree that, given a static database of *n* intervals, allows us to enumerate all
    *k* intervals that overlap a given query interval in *O*(*k* + lg *n*) time.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 在他们的书中，Preparata和Shamos [[364](bibliography001.xhtml#endnote_364)] 描述了文献中出现的几种区间树，引用了H.
    Edelsbrunner（1980）和E. M. McCreight（1981）的工作。该书详细介绍了一种区间树，给定一个静态数据库的*n*个区间，允许我们在*O*(*k*
    + lg *n*)时间内枚举所有与给定查询区间重叠的*k*个区间。
