- en: '[**30        Polynomials and the FFT**](toc.xhtml#chap-30)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[**30        多项式与FFT**](toc.xhtml#chap-30)'
- en: The straightforward method of adding two polynomials of degree *n* takes Θ(*n*)
    time, but the straightforward method of multiplying them takes Θ(*n*²) time. This
    chapter will show how the fast Fourier transform, or FFT, can reduce the time
    to multiply polynomials to Θ(*n* lg *n*).
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 将两个次数为*n*的多项式相加的直接方法需要Θ(*n*)的时间，但将它们相乘的直接方法需要Θ(*n*²)的时间。本章将展示快速傅立叶变换（FFT）如何将多项式乘法的时间降低到Θ(*n*
    lg *n*)。
- en: 'The most common use for Fourier transforms, and hence the FFT, is in signal
    processing. A signal is given in the ***time domain***: as a function mapping
    time to amplitude. Fourier analysis expresses the signal as a weighted sum of
    phase-shifted sinusoids of varying frequencies. The weights and phases associated
    with the frequencies characterize the signal in the ***frequency domain***. Among
    the many everyday applications of FFT’s are compression techniques used to encode
    digital video and audio information, including MP3 files. Many fine books delve
    into the rich area of signal processing, and the chapter notes reference a few
    of them.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 傅立叶变换，因此FFT最常见的用途是信号处理。信号在***时域***中给出：作为将时间映射到幅度的函数。傅立叶分析将信号表示为各种频率的相移正弦波的加权和。与频率相关的权重和相位表征了频域中的信号。FFT的许多日常应用包括用于编码数字视频和音频信息的压缩技术，包括MP3文���。许多优秀的书籍深入探讨了信号处理的丰富领域，章节注释中引用了其中一些。
- en: '**Polynomials**'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**多项式**'
- en: 'A ***polynomial*** in the variable *x* over an algebraic field *F* represents
    a function *A*(*x*) as a formal sum:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在代数域*F*上的变量*x*中的一个***多项式***表示为形式求和的函数*A*(*x*)：
- en: '![art](images/Art_P1030.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1030.jpg)'
- en: The values *a*[0], *a*[1], … , *a*[*n*−1] are the ***coefficients*** of the
    polynomial. The coefficients and *x* are drawn from a field *F*, typically the
    set ℂ of complex numbers. A polynomial *A*(*x*) has ***degree*** *k* if its highest
    nonzero coefficient is *a[k]*, in which case we say that degree(*A*) = *k*. Any
    integer strictly greater than the degree of a polynomial is a ***degree-bound***
    of that polynomial. Therefore, the degree of a polynomial of degree-bound *n*
    may be any integer between 0 and *n* − 1, inclusive.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 值*a*[0]、*a*[1]、… , *a*[*n*−1]是多项式的***系数***。系数和*x*来自一个域*F*，通常是复数集ℂ。如果一个多项式的最高非零系数是*a[k]*，则称多项式的***次数***为*k*。多项式的次数界大于多项式的次数。因此，次数界为*n*的多项式的次数可以是0到*n*
    − 1之间的任何整数，包括*n* − 1。
- en: A variety of operations extend to polynomials. For ***polynomial addition***,
    if *A*(*x*) and *B*(*x*) are polynomials of degree-bound *n*, their ***sum***
    is a polynomial *C*(*x*), also of degree-bound *n*, such that *C*(*x*) = *A*(*x*)+*B*(*x*)
    for all *x* in the underlying field. That is, if
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式有许多操作。对于***多项式加法***，如果*A*(*x*)和*B*(*x*)是次数界为*n*的多项式，它们的***和***是一个多项式*C*(*x*)，同样次数界为*n*，使得对于底层域中的所有*x*，都有*C*(*x*)
    = *A*(*x*)+*B*(*x*)。也就是说，如果
- en: '![art](images/Art_P1031.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1031.jpg)'
- en: then
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 然后
- en: '![art](images/Art_P1032.jpg)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1032.jpg)'
- en: where *c[j]* = *a[j]* + *b[j]* for *j* = 0, 1, … , *n* − 1\. For example, given
    the polynomials *A*(*x*) = 6*x*³ + 7*x*² − 10*x* + 9 and *B*(*x*) = −2*x*³ + 4*x*
    − 5, their sum is *C*(*x*) = 4*x*³ + 7*x*² − 6*x* + 4.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *c[j]* = *a[j]* + *b[j]*，对于*j* = 0, 1, … , *n* − 1\. 例如，给定多项式 *A*(*x*) =
    6*x*³ + 7*x*² − 10*x* + 9 和 *B*(*x*) = −2*x*³ + 4*x* − 5，它们的和为 *C*(*x*) = 4*x*³
    + 7*x*² − 6*x* + 4。
- en: 'For ***polynomial multiplication***, if *A*(*x*) and *B*(*x*) are polynomials
    of degree-bound *n*, their ***product*** *C*(*x*) is a polynomial of degree-bound
    2*n* − 1 such that *C*(*x*) = *A*(*x*)*B*(*x*) for all *x* in the underlying field.
    You probably have multiplied polynomials before, by multiplying each term in *A*(*x*)
    by each term in *B*(*x*) and then combining terms with equal powers. For example,
    you can multiply *A*(*x*) = 6*x*³ + 7*x*² − 10*x* + 9 and *B*(*x*) = −2*x*³ +
    4*x* − 5 as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于***多项式乘法***，如果*A*(*x*)和*B*(*x*)是次数界为*n*的多项式，它们的***乘积*** *C*(*x*)是一个次数界为2*n*
    − 1的多项式，使得对于底层域中的所有*x*，都有*C*(*x*) = *A*(*x*)*B*(*x*)。你可能以前曾经乘过多项式，方法是将*A*(*x*)中的每一项与*B*(*x*)中的每一项相乘，然后将具有相同幂次的项合并。例如，你可以将*A*(*x*)
    = 6*x*³ + 7*x*² − 10*x* + 9 和 *B*(*x*) = −2*x*³ + 4*x* − 5 相乘如下所示：
- en: '![art](images/Art_P1033.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1033.jpg)'
- en: Another way to express the product *C*(*x*) is
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 表达乘积*C*(*x*)的另一种方式是
- en: '![art](images/Art_P1034.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1034.jpg)'
- en: where
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 其中
- en: '![art](images/Art_P1035.jpg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1035.jpg)'
- en: (By the definition of degree, *a[k]* = 0 for all *k* > degree(*A*) and *b[k]*
    = 0 for all *k* > degree(*B*).) If *A* is a polynomial of degree-bound *n*[a]
    and *B* is a polynomial of degree-bound *n[b]*, then *C* must be a polynomial
    of degree-bound *n*[a] + *n[b]* − 1, because degree(*C*) = degree(*A*) + degree(*B*).
    Since a polynomial of degree-bound *k* is also a polynomial of degree-bound *k*
    + 1, we normally make the somewhat simpler statement that the product polynomial
    *C* is a polynomial of degree-bound *n*[a] + *n[b]*.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: （根据次数的定义，对于所有*k* > degree(*A*)，*a[k]* = 0，对于所有*k* > degree(*B*)，*b[k]* = 0。）如果*A*是次数界为*n*[a]*的多项式，*B*是次数界为*n*[b]*的多项式，则*C*必须是次数界为*n*[a]
    + *n*[b] − 1的多项式，因为次数(*C*) = 次数(*A*) + 次数(*B*)。因此，次数界为*k*的多项式也是次数界为*k* + 1的多项式，我们通常简单地陈述乘积多项式*C*是次数界为*n*[a]
    + *n*[b]*的多项式。
- en: '**Chapter outline**'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节大纲**'
- en: '[Section 30.1](chapter030.xhtml#Sec_30.1) presents two ways to represent polynomials:
    the coefficient representation and the point-value representation. The straightforward
    method for multiplying polynomials of degree *n*—equations (30.1) and (30.2)—takes
    Θ(*n*²) time with polynomials represented in coefficient form, but only Θ(*n*)
    time with point-value form. Converting between the two representations, however,
    reduces the time to multiply polynomials to just Θ(*n* lg *n*). To see why this
    approach works, you must first understand complex roots of unity, which [Section
    30.2](chapter030.xhtml#Sec_30.2) covers. [Section 30.2](chapter030.xhtml#Sec_30.2)
    then uses the FFT and its inverse to perform the conversions. Because the FFT
    is used so often in signal processing, it is often implemented as a circuit in
    hardware, and [Section 30.3](chapter030.xhtml#Sec_30.3) illustrates the structure
    of such circuits.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '[第30.1节](chapter030.xhtml#Sec_30.1)介绍了表示多项式的两种方法：系数表示和点值表示。对于次数为*n*的多项式相乘的直接方法——方程(30.1)和(30.2)——在系数形式中表示多项式需要Θ(*n*²)的时间，但在点值形式中仅需要Θ(*n*)的时间。然而，转换两种表示之间将时间降低到Θ(*n*
    lg *n*)以便相乘多项式。要理解为什么这种方法有效，首先必须了解复数单位根，[第30.2节](chapter030.xhtml#Sec_30.2)进行了介绍。[第30.2节](chapter030.xhtml#Sec_30.2)然后使用FFT及其逆来执行转换。由于FFT在信号处理中经常使用，因此通常作为硬件电路实现，[第30.3节](chapter030.xhtml#Sec_30.3)展示了这些电路的结构。'
- en: This chapter relies on complex numbers, and within this chapter the symbol *i*
    denotes ![art](images/Art_P1036.jpg) exclusively.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章依赖于复数，并在本章中符号*i*专门表示![art](images/Art_P1036.jpg)。
- en: '[**30.1    Representing polynomials**](toc.xhtml#Rh1-172)'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '[**30.1    多项式表示**](toc.xhtml#Rh1-172)'
- en: 'The coefficient and point-value representations of polynomials are in a sense
    equivalent: a polynomial in point-value form has a unique counterpart in coefficient
    form. This section introduces the two representations and shows how to combine
    them in order to multiply two degree-bound *n* polynomials in Θ(*n* lg *n*) time.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式的系数表示和点值表示在某种意义上是等价的：点值形式的多项式在系数形式中有一个唯一的对应物。本节介绍了这两种表示，并展示了如何将它们结合起来以在Θ(*n*
    lg *n*)的时间内相乘两个次数限制为*n*的多项式。
- en: '**Coefficient representation**'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**系数表示**'
- en: A ***coefficient representation*** of a polynomial ![art](images/Art_P1037.jpg)
    of degree-bound *n* is a vector of coefficients *a* = (*a*[0], *a*[1], … , *a*[*n*−1]).
    Matrix equations in this chapter generally treat vectors as column vectors.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式![art](images/Art_P1037.jpg)的***系数表示***是一个系数向量*a* = (*a*[0], *a*[1], … ,
    *a*[*n*−1])，其中多项式的次数限制为*n*。本章中的矩阵方程通常将向量视为列向量。
- en: 'The coefficient representation is convenient for certain operations on polynomials.
    For example, the operation of ***evaluating*** the polynomial *A*(*x*) at a given
    point *x*[0] consists of computing the value of *A*(*x*[0]). To evaluate a polynomial
    in Θ(*n*) time, use ***Horner’s rule***:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 系数表示对于多项式的某些操作很方便。例如，对多项式*A*(*x*)在给定点*x*[0]处进行***求值***的操作包括计算*A*(*x*[0])的值。要在Θ(*n*)的时间内评估一个多项式，使用***霍纳法则***：
- en: '![art](images/Art_P1038.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1038.jpg)'
- en: 'Similarly, adding two polynomials represented by the coefficient vectors *a*
    = (*a*[0], *a*[1], … , *a*[*n*−1]) and *b* = (*b*[0], *b*[1], … , *b*[*n*−1])
    takes Θ(*n*) time: just produce the coefficient vector *c* = (*c*[0], *c*[1],
    … , *c*[*n*−1]), where *c[j]* = *a[j]* + *b[j]* for *j* = 0, 1, … , *n*− 1.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，通过系数向量*a* = (*a*[0], *a*[1], … , *a*[*n*−1])和*b* = (*b*[0], *b*[1], … ,
    *b*[*n*−1])表示的两个多项式相加需要Θ(*n*)的时间：只需生成系数向量*c* = (*c*[0], *c*[1], … , *c*[*n*−1])，其中*j*
    = 0, 1, … , *n*− 1，*c[j]* = *a[j]* + *b[j]*。
- en: Now, consider multiplying two degree-bound *n* polynomials *A*(*x*) and *B*(*x*)
    represented in coefficient form. The method described by equations (30.1) and
    (30.2) takes Θ(*n*²) time, since it multiplies each coefficient in the vector
    *a* by each coefficient in the vector *b*. The operation of multiplying polynomials
    in coefficient form seems to be considerably more difficult than that of evaluating
    a polynomial or adding two polynomials. The resulting coefficient vector *c*,
    given by equation (30.2), is also called the ***convolution*** of the input vectors
    *a* and *b*, denoted *c* = *a* ⊗ *b*. Since multiplying polynomials and computing
    convolutions are fundamental computational problems of considerable practical
    importance, this chapter concentrates on efficient algorithms for them.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑将以系数形式表示的两个次数限制为*n*的多项式*A*(*x*)和*B*(*x*)相乘。根据方程(30.1)和(30.2)描述的方法，由于它将向量*a*中的每个系数与向量*b*中的每个系数相乘，所以需要Θ(*n*²)的时间。在系数形式中相乘多项式的操作似乎比求多项式值或两个多项式相加要困难得多。由方程(30.2)给出的结果系数向量*c*也被称为输入向量*a*和*b*的***卷积***，表示为*c*
    = *a* ⊗ *b*。由于相乘多项式和计算卷积是具有相当实际重要性的基本计算问题，本章重点关注它们的高效算法。
- en: '**Point-value representation**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**点值表示**'
- en: A ***point-value representation*** of a polynomial *A*(*x*) of degree-bound
    *n* is a set of *n* ***point-value pairs***
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个多项式*A*(*x*)的***点值表示***是一组*n* ***点值对***
- en: '{(*x*[0], *y*[0]), (*x*[1], *y*[1]), … , (*x*[*n*−1], *y*[*n*−1])}'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '{(*x*[0], *y*[0]), (*x*[1], *y*[1]), … , (*x*[*n*−1], *y*[*n*−1])}'
- en: such that all of the *x[k]* are distinct and
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 使得所有*x[k]*都不同且
- en: '![art](images/Art_P1039.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1039.jpg)'
- en: for *k* = 0, 1, … , *n* − 1\. A polynomial has many different point-value representations,
    since any set of *n* distinct points *x*[0], *x*[1], … , *x*[*n*−1] can serve
    as a basis for the representation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*k* = 0, 1, … , *n* − 1。一个多项式有许多不同的点值表示，因为任何一组不同的点*x*[0], *x*[1], … , *x*[*n*−1]都可以作为表示的基础。
- en: Computing a point-value representation for a polynomial given in coefficient
    form is in principle straightforward, since all you have to do is select *n* distinct
    points *x*[0], *x*[1], … , *x*[*n*−1] and then evaluate *A*(*x[k]*) for *k* =
    0, 1, … , *n* − 1\. With Horner’s method, evaluating a polynomial at *n* points
    takes Θ(*n*²) time. We’ll see later that if you choose the points *x[k]* cleverly,
    you can accelerate this computation to run in Θ(*n* lg *n*) time.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，给定系数形式的多项式的点值表示是很简单的，因为你只需选择*n*个不同的点*x*[0], *x*[1], … , *x*[*n*−1]，然后对*k*
    = 0, 1, … , *n* − 1评估*A*(*x[k]*)。使用霍纳方法，在*n*个点处评估多项式的时间复杂度为Θ(*n*²)。稍后我们会看到，如果你聪明地选择*x[k]*点，可以加速这个计算，使其在Θ(*n*
    lg *n*)时间内运行。
- en: The inverse of evaluation—determining the coefficient form of a polynomial from
    a point-value representation—is ***interpolation***. The following theorem shows
    that interpolation is well defined when the desired interpolating polynomial must
    have a degree-bound equal to the given number of point-value pairs.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 逆求值——从一个点值表示中确定多项式的系数形式——被称为***插值***。下面的定理表明，当所需的插值多项式的次数限制等于给定的点值对数时，插值是明确定义的。
- en: '***Theorem 30.1 (Uniqueness of an interpolating polynomial)***'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理30.1（插值多项式的唯一性）***'
- en: For any set {(*x*[0], *y*[0]), (*x*[1], *y*[1]), … , (*x*[*n*−1], *y*[*n*−1])}
    of *n* point-value pairs such that all the *x[k]* values are distinct, there is
    a unique polynomial *A*(*x*) of degree-bound *n* such that *y[k]* = *A*(*x[k]*)
    for *k* = 0, 1, … , *n* − 1.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意一组{(*x*[0], *y*[0]), (*x*[1], *y*[1]), … , (*x*[*n*−1], *y*[*n*−1])}，其中所有*x[k]*值都不同，存在一个唯一的次数限制为*n*的多项式*A*(*x*)，使得*k*
    = 0, 1, … , *n* − 1时*y[k]* = *A*(*x[k]*)。
- en: '***Proof***   The proof relies on the existence of the inverse of a certain
    matrix. Equation (30.3) is equivalent to the matrix equation'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   该证明依赖于某个矩阵的逆的存在。方程（30.3）等价于矩阵方程'
- en: '![art](images/Art_P1040.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1040.jpg)'
- en: The matrix on the left is denoted *V*(*x*[0], *x*[1], … , *x*[*n*−1]) and is
    known as a ***Vandermonde matrix***. By Problem D-1 on page 1223, this matrix
    has determinant
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧的矩阵记为*V*(*x*[0], *x*[1], … , *x*[*n*−1])，被称为***范德蒙矩阵***。根据第1223页的问题D-1，该矩阵的行列式为
- en: '![art](images/Art_P1041.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1041.jpg)'
- en: 'and therefore, by Theorem D.5 on page 1221, it is invertible (that is, nonsingular)
    if the *x[k]* are distinct. To solve for the coefficients *a[j]* uniquely given
    the point-value representation, use the inverse of the Vandermonde matrix:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，根据第1221页的定理D.5，如果*x[k]*不同，则该矩阵是可逆的（即非奇异的）。为了唯一地解出给定点值表示的系数*a[j]*，使用范德蒙矩阵的逆：
- en: '*a* = *V*(*x*[0], *x*[1], … , *x*[*n*−1])^(−1)*y*.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* = *V*(*x*[0], *x*[1], … , *x*[*n*−1])^(−1)*y*。'
- en: ▪
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: The proof of Theorem 30.1 describes an algorithm for interpolation based on
    solving the set (30.4) of linear equations. [Section 28.1](chapter028.xhtml#Sec_28.1)
    shows how to solve these equations in *O*(*n*³) time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 定理30.1的证明描述了一个基于解线性方程组（30.4）的插值算法。[第28.1节](chapter028.xhtml#Sec_28.1)展示了如何在*O*(*n*³)时间内解这些方程。
- en: 'A faster algorithm for *n*-point interpolation is based on ***Lagrange’s formula***:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更快的*n*点插值算法基于***拉格朗日公式***：
- en: '![art](images/Art_P1042.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1042.jpg)'
- en: You might want to verify that the right-hand side of equation (30.5) is a polynomial
    of degree-bound *n* that satisfies *A*(*x[k]*) = *y[k]* for all *k*. Exercise
    30.1-5 asks you how to compute the coefficients of *A* using Lagrange’s formula
    in Θ(*n*²) time.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要验证方程（30.5）的右侧是否是一个次数限制为*n*的多项式，满足所有*k*时的*A*(*x[k]*) = *y[k]*。练习30.1-5问你如何使用拉格朗日公式在Θ(*n*²)时间内计算*A*的系数。
- en: Thus, *n*-point evaluation and interpolation are well-defined inverse operations
    that transform between the coefficient representation of a polynomial and a point-value
    representation.^([1](#footnote_1)) The algorithms described above for these problems
    take Θ(*n*²) time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*n*点求值和插值是互为逆操作的，可以在多项式的系数表示和点值表示之间转换。上述问题的算法时间复杂度为Θ(*n*²)。
- en: The point-value representation is quite convenient for many operations on polynomials.
    For addition, if *C*(*x*) = *A*(*x*) + *B*(*x*), then *C*(*x[k]*) = *A*(*x[k]*)
    + *B*(*x[k]*) for any point *x[k]*. More precisely, given point-value representations
    for *A*,
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 点值表示对于多项式的许多操作非常方便。对于加法，如果*C*(*x*) = *A*(*x*) + *B*(*x*)，那么对于任何点*x[k]*，*C*(*x[k]*)
    = *A*(*x[k]*) + *B*(*x[k]*)。更准确地说，给定*A*的点值表示，
- en: '{(*x*[0], *y*[0]), (*x*[1], *y*[1]), … , (*x*[*n*−1], *y*[*n*−1])},'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '{(*x*[0], *y*[0]), (*x*[1], *y*[1]), … , (*x*[*n*−1], *y*[*n*−1])}，'
- en: and for *B*,
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 以及*B*，
- en: '![art](images/Art_P1043.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1043.jpg)'
- en: where *A* and *B* are evaluated at the *same n* points, then a point-value representation
    for *C* is
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*A*和*B*在*相同的n个*点处求值，那么*C*的一个点值表示为
- en: '![art](images/Art_P1044.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1044.jpg)'
- en: Thus the time to add two polynomials of degree-bound *n* in point-value form
    is Θ(*n*).
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在点值形式中添加两个次数限制为*n*的多项式的时间复杂度为Θ(*n*)。
- en: 'Similarly, the point-value representation is convenient for multiplying polynomials.
    If *C*(*x*) = *A*(*x*)*B*(*x*), then *C*(*x[k]*) = *A*(*x[k]*)*B*(*x[k]*) for
    any point *x[k]*, and to obtain a point-value representation for *C*, just pointwise
    multiply a point-value representation for *A* by a point-value representation
    for *B*. Polynomial multiplication differs from polynomial addition in one key
    aspect, however: degree(*C*) = degree(*A*) + degree(*B*), so that if *A* and *B*
    have degree-bound *n*, then *C* has degree-bound 2*n*. A standard point-value
    representation for *A* and *B* consists of *n* point-value pairs for each polynomial.
    Multiplying these together gives *n* point-value pairs, but 2*n* pairs are necessary
    to interpolate a unique polynomial *C* of degree-bound 2*n*. (See Exercise 30.1-4.)
    Instead, begin with “extended” point-value representations for *A* and for *B*
    consisting of 2*n* point-value pairs each. Given an extended point-value representation
    for *A*,'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，点值表示对于乘法多项式很方便。如果*C*(*x*) = *A*(*x*)*B*(*x*)，那么*C*(*x[k]*) = *A*(*x[k]*)*B*(*x[k]*)对于任何点*x[k]*成立，为了获得*C*的点值表示，只需将*A*的点值表示逐点乘以*B*的点值表示。然而，多项式乘法与多项式加法在一个关键方面有所不同：degree(*C*)
    = degree(*A*) + degree(*B*)，因此如果*A*和*B*的度受限于*n*，那么*C*的度受限于2*n*。*A*和*B*的标准点值表示各包含每个多项式的*n*个点值对。将它们相乘得到*n*个点值对，但是为了插值一个度受限于2*n*的唯一多项式*C*，需要2*n*对。
    （参见练习30.1-4。）相反，从*A*的“扩展”点值表示开始，
- en: '{(*x*[0], *y*[0]), (*x*[1], *y*[1]), … , (*x*[2*n*−1], *y*[2*n*−1])},'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '{(*x*[0], *y*[0]), (*x*[1], *y*[1]), … , (*x*[2*n*−1], *y*[2*n*−1])},'
- en: and a corresponding extended point-value representation for *B*,
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 和相应的扩展点值表示为*B*，
- en: '![art](images/Art_P1045.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1045.jpg)'
- en: then a point-value representation for *C* is
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 然后*C*的点值表示为
- en: '![art](images/Art_P1046.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1046.jpg)'
- en: Given two input polynomials in extended point-value form, multiplying them to
    obtain the point-value form of the result takes just Θ(*n*) time, much less than
    the Θ(*n*²) time required to multiply polynomials in coefficient form.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个扩展点值形式的输入多项式，将它们相乘以获得结果的点值形式只需Θ(*n*)的时间，远少于在系数形式下乘多项式所需的Θ(*n*²)的时间。
- en: Finally, let’s consider how to evaluate a polynomial given in point-value form
    at a new point. For this problem, the simplest approach known is to first convert
    the polynomial to coefficient form and then evaluate it at the new point.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们考虑如何在新点处评估以点值形式给出的多项式。对于这个问题，已知的最简单方法是首先将多项式转换为系数形式，然后在新点处评估它。
- en: '**Fast multiplication of polynomials in coefficient form**'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '**多项式系数形式的快速乘法**'
- en: Can the linear-time multiplication method for polynomials in point-value form
    expedite polynomial multiplication in coefficient form? The answer hinges on whether
    it is possible convert a polynomial quickly from coefficient form to point-value
    form (evaluate) and vice versa (interpolate).
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 点值形式中多项式的线性时间乘法方法是否可以加速系数形式中的多项式乘法？答案取决于是否可能快速将多项式从系数形��转换为点值形式（评估）以及反之（插值）。
- en: '![art](images/Art_P1047.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1047.jpg)'
- en: '**Figure 30.1** A graphical outline of an efficient polynomial-multiplication
    process. Representations on the top are in coefficient form, and those on the
    bottom are in point-value form. The arrows from left to right correspond to the
    multiplication operation. The *ω*[2*n*] terms are complex (2*n*)th roots of unity.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**图30.1** 一个高效多项式乘法过程的图形概述。顶部的表示是系数形式，底部的表示是点值形式。从左到右的箭头对应乘法操作。*ω*[2*n*]项是复数（2*n*）次单位根。'
- en: Any points can serve as evaluation points, but certain evaluation points allow
    conversion between representations in only Θ(*n* lg *n*) time. As we’ll see in
    [Section 30.2](chapter030.xhtml#Sec_30.2), if “complex roots of unity” are the
    evaluation points, then the discrete Fourier transform (or DFT) evaluates and
    the inverse DFT interpolates. [Section 30.2](chapter030.xhtml#Sec_30.2) shows
    how the FFT accomplishes the DFT and inverse DFT operations in Θ(*n* lg *n*) time.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 任何点都可以作为评估点，但是某些评估点只需Θ(*n* lg *n*)的时间就可以在不同表示之间转换。正如我们将在[第30.2节](chapter030.xhtml#Sec_30.2)中看到的，如果“复数单位根”是评估点，那么离散傅立叶变换（或DFT）进行评估，逆DFT进行插值。[第30.2节](chapter030.xhtml#Sec_30.2)展示了FFT如何在Θ(*n*
    lg *n*)的时间内完成DFT和逆DFT操作。
- en: '[Figure 30.1](chapter030.xhtml#Fig_30-1) shows this strategy graphically. One
    minor detail concerns degree-bounds. The product of two polynomials of degree-bound
    *n* is a polynomial of degree-bound 2*n*. Before evaluating the input polynomials
    *A* and *B*, therefore, first double their degree-bounds to 2*n* by adding *n*
    high-order coefficients of 0\. Because the vectors have 2*n* elements, use “complex
    (2*n*)th roots of unity,” which are denoted by the *ω*[2*n*] terms in [Figure
    30.1](chapter030.xhtml#Fig_30-1).'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '[图30.1](chapter030.xhtml#Fig_30-1)以图形方式显示了这种策略。一个小细节涉及度限制。两个度受限于*n*的多项式的乘积是一个度受限于2*n*的多项式。因此，在评估输入多项式*A*和*B*之前，首先通过添加*n*个高阶系数为0来将它们的度限制加倍到2*n*。因为向量有2*n*个元素，所以使用“复数（2*n*）次单位根”，在[图30.1](chapter030.xhtml#Fig_30-1)中用*ω*[2*n*]项表示。'
- en: The following procedure takes advantage of the FFT to multiply two polynomials
    *A*(*x*) and *B*(*x*) of degree-bound *n* in Θ(*n* lg *n*)-time, where the input
    and output representations are in coefficient form. The procedure assumes that
    *n* is an exact power of 2, so if it isn’t, just add high-order zero coefficients.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 以下过程利用FFT在Θ(*n* lg *n*)时间内乘两个度限制为*n*的多项式*A*(*x*)和*B*(*x*)，其中输入和输出表示均为系数形式。该过程假定*n*是2的幂，因此如果不是，则只需添加高阶零系数。
- en: '**Double degree-bound:** Create coefficient representations of *A*(*x*) and
    *B*(*x*) as degree-bound 2*n* polynomials by adding *n* high-order zero coefficients
    to each.'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**双度限制：** 通过向每个多项式添加*n*个高阶零系数，将*A*(*x*)和*B*(*x*)的系数表示创建为度限制为2*n*的多项式。'
- en: '**Evaluate:** Compute point-value representations of *A*(*x*) and *B*(*x*)
    of length 2*n* by applying the FFT of order 2*n* on each polynomial. These representations
    contain the values of the two polynomials at the (2*n*)th roots of unity.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**求值：** 通过在每个多项式上应用阶数为2*n*的FFT，在长度为2*n*的点值表示中计算*A*(*x*)和*B*(*x*)的值。这些表示包含两个多项式在第(2*n*)个单位根处的值。'
- en: '**Pointwise multiply:** Compute a point-value representation for the polynomial
    *C*(*x*) = *A*(*x*)*B*(*x*) by multiplying these values together pointwise. This
    representation contains the value of *C*(*x*) at each (2*n*)th root of unity.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**逐点相乘：** 通过逐点相乘这些值，计算多项式*C*(*x*) = *A*(*x*)*B*(*x*)的点值表示。这个表示包含*C*(*x*)在每个(2*n*)次单位根处的值。'
- en: '**Interpolate:** Create the coefficient representation of the polynomial *C*(*x*)
    by applying the FFT on 2*n* point-value pairs to compute the inverse DFT.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**插值：** 通过在2*n*个点值对上应用FFT来创建多项式*C*(*x*)的系数表示，以计算逆DFT。'
- en: Steps (1) and (3) take Θ(*n*) time, and steps (2) and (4) take Θ(*n* lg *n*)
    time. Thus, once we show how to use the FFT, we will have proven the following.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 步骤(1)和(3)需要Θ(*n*)时间，步骤(2)和(4)需要Θ(*n* lg *n*)时间。因此，一旦我们展示如何使用FFT，我们将证明以下内容。
- en: '***Theorem 30.2***'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 30.2***'
- en: Two polynomials of degree-bound *n* with both the input and output representations
    in coefficient form can be multiplied in Θ(*n* lg *n*) time.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 两个输入输出表示均为系数形式的次数界为*n*的多项式可以在Θ(*n* lg *n*)时间内相乘。
- en: ▪
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Exercises**'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***30.1-1***'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '***30.1-1***'
- en: Multiply the polynomials *A*(*x*) = 7*x*³ − *x*² + *x* − 10 and *B*(*x*) = 8*x*³
    − 6*x* + 3 using equations (30.1) and (30.2).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方程(30.1)和(30.2)相乘多项式*A*(*x*) = 7*x*³ − *x*² + *x* − 10 和 *B*(*x*) = 8*x*³
    − 6*x* + 3。
- en: '***30.1-2***'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '***30.1-2***'
- en: Another way to evaluate a polynomial *A*(*x*) of degree-bound *n* at a given
    point *x*[0] is to divide *A*(*x*) by the polynomial (*x* − *x*[0]), obtaining
    a quotient polynomial *q*(*x*) of degree-bound *n* − 1 and a remainder *r*, such
    that
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在给定点*x*[0]处评估次数界为*n*的多项式*A*(*x*)的另一种方法是将*A*(*x*)除以多项式(*x* − *x*[0])，得到次数界为*n*
    − 1的商多项式*q*(*x*)和余数*r*，使得
- en: '*A*(*x*) = *q*(*x*)(*x* − *x*[0]) + *r*.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '*A*(*x*) = *q*(*x*)(*x* − *x*[0]) + *r*。'
- en: Then we have *A*(*x*[0]) = *r*. Show how to compute the remainder *r* and the
    coefficients of *q*(*x*) from *x*[0] and the coefficients of *A* in Θ(*n*) time.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们有*A*(*x*[0]) = *r*。展示如何在Θ(*n*)时间内从*x*[0]和*A*的系数中计算余数*r*和*q*(*x*)的系数。
- en: '***30.1-3***'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '***30.1-3***'
- en: Given a polynomial ![art](images/Art_P1048.jpg), define ![art](images/Art_P1049.jpg).
    Show how to derive a point-value representation for *A*^(rev)(*x*) from a point-value
    representation for *A*(*x*), assuming that none of the points is 0.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个多项式 ![art](images/Art_P1048.jpg)，定义 ![art](images/Art_P1049.jpg)。展示如何从给定的点值表示*A*(*x*)中导出*A*^(rev)(*x*)的点值表示，假设没有任何点是0。
- en: '***30.1-4***'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '***30.1-4***'
- en: Prove that *n* distinct point-value pairs are necessary to uniquely specify
    a polynomial of degree-bound *n*, that is, if fewer than *n* distinct point-value
    pairs are given, they fail to specify a unique polynomial of degree-bound *n*.
    (*Hint:* Using Theorem 30.1, what can you say about a set of *n* − 1 point-value
    pairs to which you add one more arbitrarily chosen point-value pair?)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 证明对于次数界为*n*的多项式，需要*n*个不同的点值对来唯一确定一个多项式，也就是说，如果给出少于*n*个不同的点值对，它们无法唯一确定一个次数界为*n*的多项式。（*提示：*使用定理
    30.1，对于一个由*n* − 1个点值对组成的集合，如果再添加一个任意选择的点值对，你能说些什么？）
- en: '***30.1-5***'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '***30.1-5***'
- en: Show how to use equation (30.5) to interpolate in Θ(*n*²) time. (*Hint:* First
    compute the coefficient representation of the polynomial ∏*[j]*(*x* − *x[j]*)
    and then divide by (*x* − *x[k]*) as necessary for the numerator of each term
    (see Exercise 30.1-2). You can compute each of the *n* denominators in *O*(*n*)
    time.)
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何利用方程（30.5）在Θ(*n*²)时间内进行插值。（*提示：*首先计算多项式∏*[j]*(*x* − *x[j]*)的系数表示，然后根据需要除以(*x*
    − *x[k]*)以获得每个项的分子（参见练习 30.1-2）。你可以在*O*(*n*)时间内计算每个*n*的分母。）
- en: '***30.1-6***'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '***30.1-6***'
- en: 'Explain what is wrong with the “obvious” approach to polynomial division using
    a point-value representation: dividing the corresponding *y* values. Discuss separately
    the case in which the division comes out exactly and the case in which it doesn’t.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 解释使用点值表示进行多项式除法的“显而易见”方法有什么问题：将相应的*y*值进行除法。分别讨论除法完全正确和除法不正确的情况。
- en: '***30.1-7***'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '***30.1-7***'
- en: Consider two sets *A* and *B*, each having *n* integers in the range from 0
    to 10*n*. The ***Cartesian sum*** of *A* and *B* is defined by
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑两个集合*A*和*B*，每个集合中有*n*个整数，范围从0到10*n*。*A*和*B*的***笛卡尔和***定义为
- en: '*C* = {*x* + *y* : *x* ∈ *A* and *y* ∈ *B*}.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '*C* = {*x* + *y*：*x* ∈ *A* 且 *y* ∈ *B*}。'
- en: The integers in *C* lie in the range from 0 to 20*n*. Show how, in *O*(*n* lg
    *n*) time, to find the elements of *C* and the number of times each element of
    *C* is realized as a sum of elements in *A* and *B*. (*Hint:* Represent *A* and
    *B* as polynomials of degree at most 10*n*.)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '*C*中的整数位于0到20*n*的范围内。展示如何在*O*(*n* lg *n*)时间内找到*C*的元素以及*C*中每个元素被表示为*A*和*B*元素之和的次数。(*提示：*将*A*和*B*表示为最多为10*n*的次数的多项式。)'
- en: '[**30.2    The DFT and FFT**](toc.xhtml#Rh1-173)'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '[**30.2    DFT 和 FFT**](toc.xhtml#Rh1-173)'
- en: In [Section 30.1](chapter030.xhtml#Sec_30.1), we claimed that by computing the
    DFT and its inverse by using the FFT, it is possible to evaluate and interpolate
    a degree *n* polynomial at the complex roots of unity in Θ(*n* lg *n*) time. This
    section defines complex roots of unity, studies their properties, defines the
    DFT, and then shows how the FFT computes the DFT and its inverse in Θ(*n* lg *n*)
    time.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第30.1节](chapter030.xhtml#Sec_30.1)中，我们声称通过使用FFT计算DFT及其逆变换，可以在Θ(*n* lg *n*)时间内在复数单位根处评估和插值度为*n*的多项式。本节定义了复数单位根，研究了它们的性质，定义了DFT，然后展示了FFT如何在Θ(*n*
    lg *n*)时间内计算DFT及其逆变换。
- en: '**Complex roots of unity**'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**复数单位根**'
- en: A ***complex nth root of unity*** is a complex number *ω* such that
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 复数单位根是一个复数*ω*，使得
- en: '*ω^n* = 1.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '*ω^n* = 1。'
- en: 'There are exactly *n* complex *n*th roots of unity: *e*^(2*πik*/*n*) for *k*
    = 0, 1, … , *n* − 1\. To interpret this formula, use the definition of the exponential
    of a complex number:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 恰好有*n*个复数第*n*个单位根：*e*^(2*πik*/*n*)，其中*k* = 0, 1, … , *n* − 1。要解释这个公式，使用复数指数的定义：
- en: '*e^(iu)* = cos(*u*) + *i* sin(*u*).'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '*e^(iu)* = cos(*u*) + *i* sin(*u*)。'
- en: '[Figure 30.2](chapter030.xhtml#Fig_30-2) shows that the *n* complex roots of
    unity are equally spaced around the circle of unit radius centered at the origin
    of the complex plane. The value'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '[图30.2](chapter030.xhtml#Fig_30-2)显示了*n*个复数第*n*个单位根均匀分布在以复平面原点为中心的单位半径圆周上。数值'
- en: '![art](images/Art_P1050.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1050.jpg)'
- en: '**Figure 30.2** The values of ![art](images/Art_P1051.jpg) in the complex plane,
    where *ω*[8] = *e*^(2*πi*/8) is the principal 8th root of unity.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**图30.2** 复平面中的![艺术](images/Art_P1051.jpg)值，其中*ω*[8] = *e*^(2*πi*/8)是主要的第8个单位根。'
- en: '![art](images/Art_P1052.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1052.jpg)'
- en: is the ***principal nth root of unity***.^([2](#footnote_2)) All other complex
    *n*th roots of unity are powers of *ω[n]*.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 是***主要的第n个单位根***。^([2](#footnote_2)) 所有其他复数第*n*个单位根都是*ω[n]*的幂。
- en: The *n* complex *n*th roots of unity,
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '*n*个复数第*n*个单位根，'
- en: '![art](images/Art_P1053.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1053.jpg)'
- en: form a group under multiplication (see [Section 31.3](chapter031.xhtml#Sec_31.3)).
    This group has the same structure as the additive group (ℤ*[n]*, +) modulo *n*,
    since ![art](images/Art_P1054.jpg) implies that ![art](images/Art_P1055.jpg).
    Similarly, ![art](images/Art_P1056.jpg). The following lemmas furnish some essential
    properties of the complex *n*th roots of unity.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 形成一个群（参见[第31.3节](chapter031.xhtml#Sec_31.3)）在乘法下。这个群与加法群（ℤ*[n]*, +）模*n*具有相同的结构，因为![艺术](images/Art_P1054.jpg)意味着![艺术](images/Art_P1055.jpg)。同样，![艺术](images/Art_P1056.jpg)。以下引理提供了复数第*n*个单位根的一些基本性质。
- en: '***Lemma 30.3 (Cancellation lemma)***'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理30.3（消去引理）***'
- en: For any integers *n* > 0, *k* ≥ 0, and *d* > 0,
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何整数*n* > 0，*k* ≥ 0和*d* > 0，
- en: '![art](images/Art_P1057.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1057.jpg)'
- en: '***Proof***   The lemma follows directly from equation (30.6), since'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   引理直接由方程(30.6)得出，因为'
- en: '![art](images/Art_P1058.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1058.jpg)'
- en: ▪
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Corollary 30.4***'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论30.4***'
- en: For any even integer *n* > 0,
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何偶数*n* > 0，
- en: '![art](images/Art_P1059.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1059.jpg)'
- en: '***Proof***   The proof is left as Exercise 30.2-1.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   证明留作练习30.2-1。'
- en: ▪
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Lemma 30.5 (Halving lemma)***'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理30.5（折半引理）***'
- en: If *n* > 0 is even, then the squares of the *n* complex *n*th roots of unity
    are the *n*/2 complex (*n*/2)th roots of unity.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*n* > 0是偶数，则*n*个复数第*n*个单位根的平方是*n*/2个复数（*n*/2）个单位根。
- en: '***Proof***   By the cancellation lemma, ![art](images/Art_P1060.jpg) for any
    nonnegative integer *k*. Squaring all of the complex *n*th roots of unity produces
    each (*n*/2)th root of unity exactly twice, since'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   通过消去引理，对于任何非负整数*k*，![艺术](images/Art_P1060.jpg)。平方所有复数第*n*个单位根会产生每个(*n*/2)个单位根正好两次，因为'
- en: '![art](images/Art_P1061.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1061.jpg)'
- en: Thus ![art](images/omega.jpg) and ![art](images/Art_P1062.jpg) have the same
    square. We could also have used Corollary 30.4 to prove this property, since ![art](images/Art_P1063.jpg)
    implies ![art](images/Art_P1064.jpg), and thus ![art](images/Art_P1065.jpg).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 因此![艺术](images/omega.jpg)和![艺术](images/Art_P1062.jpg)具有相同的平方。我们也可以使用推论30.4来证明这个性质，因为![艺术](images/Art_P1063.jpg)意味着![艺术](images/Art_P1064.jpg)，从而![艺术](images/Art_P1065.jpg)。
- en: ▪
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: As we’ll see, the halving lemma is essential to the divide-and-conquer approach
    for converting between coefficient and point-value representations of polynomials,
    since it guarantees that the recursive subproblems are only half as large.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将看到的，折半引理对于在多项式的系数和点值表示之间进行分治方法至关重要，因为它保证了递归子问题只有一半那么大。
- en: '***Lemma 30.6 (Summation lemma)***'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理30.6（求和引理）***'
- en: For any integer *n* ≥ 1 and nonzero integer *k* not divisible by *n*,
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何整数*n* ≥ 1和不能被*n*整除的非零整数*k*，
- en: '![art](images/Art_P1066.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1066.jpg)'
- en: '***Proof***   Equation (A.6) on page 1142 applies to complex values as well
    as to reals, giving'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   第1142页的方程(A.6)也适用于复值，给出'
- en: '![art](images/Art_P1067.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1067.jpg)'
- en: To see that the denominator is not 0, note that ![art](images/Art_P1068.jpg)
    only when *k* is divisible by *n*, which the lemma statement prohibits.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 要看分母不为0，注意到只有当*k*可被*n*整除时，![艺术](images/Art_P1068.jpg)，而引理声明禁止这种情况。
- en: ▪
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**The DFT**'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**DFT**'
- en: Recall the goal of evaluating a polynomial
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下评估多项式的目标
- en: '![art](images/Art_P1069.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1069.jpg)'
- en: 'of degree-bound *n* at ![art](images/Art_P1070.jpg), ![art](images/Art_P1071.jpg),
    ![art](images/Art_P1072.jpg) (that is, at the *n* complex *n*th roots of unity).^([3](#footnote_3))
    The polynomial *A* is given in coefficient form: *a* = (*a*[0], *a*[1], … , *a*[*n*−1]).
    Let us define the results *y[k]*, for *k* = 0, 1, … , *n* − 1, by'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 在![艺术](images/Art_P1070.jpg)、![艺术](images/Art_P1071.jpg)、![艺术](images/Art_P1072.jpg)处的度限制为*n*的多项式（即，*n*个复数第*n*个单位根）。^([3](#footnote_3))
    多项式*A*以系数形式给出：*a* = (*a*[0], *a*[1], … , *a*[*n*−1])。我们定义结果*y[k]*，对于*k* = 0, 1,
    … , *n* − 1，如下
- en: '![art](images/Art_P1073.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1073.jpg)'
- en: The vector *y* = (*y*[0], *y*[1], … , *y*[*n*−1]) is the ***discrete Fourier
    transform (DFT)*** of the coefficient vector *a* = (*a*[0], *a*[1], … , *a*[*n*−1]).
    We also write *y* = DFT*[n]*(*a*).
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 向量*y* = (*y*[0], *y*[1], … , *y*[*n*−1])是系数向量*a* = (*a*[0], *a*[1], … , *a*[*n*−1])的***离散傅立叶变换（DFT）***。我们也写成*y*
    = DFT*[n]*(*a*)。
- en: '**The FFT**'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '**FFT**'
- en: The ***fast Fourier transform (FFT)*** takes advantage of the special properties
    of the complex roots of unity to compute DFT*[n]*(*a*) in Θ(*n* lg *n*) time,
    as opposed to the Θ(*n*²) time of the straightforward method. Assume throughout
    that *n* is an exact power of 2\. Although strategies for dealing with sizes that
    are not exact powers of 2 are known, they are beyond the scope of this book.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '***快速傅立叶变换（FFT）***利用复单位根的特殊性质来计算Θ(*n* lg *n*)时间内的DFT*[n]*(*a*)，而不是直接方法的Θ(*n*²)时间。在整个过程中假设*n*是2的幂。尽管已知处理不是2的幂大小的策略，但这超出了本书的范围。'
- en: 'The FFT method employs a divide-and-conquer strategy, using the even-indexed
    and odd-indexed coefficients of *A*(*x*) separately to define the two new polynomials
    *A*^(even)(*x*) and *A*^(odd)(*x*) of degree-bound *n*/2:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: FFT方法采用分治策略，分别使用*A*(*x*)的偶数索引和奇数索引系数来定义两个新的次数界限为*n*/2的多项式*A*^(even)(*x*)和*A*^(odd)(*x*)：
- en: '*A*^(even)(*x*) = *a*[0] + *a*[2]*x* + *a*[4]*x*² + ⋯ + *a*[*n*−2]*x*^(*n*/2−1),'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '*A*^(even)(*x*) = *a*[0] + *a*[2]*x* + *a*[4]*x*² + ⋯ + *a*[*n*−2]*x*^(*n*/2−1),'
- en: '*A*^(odd)(*x*) = *a*[1] + *a*[3]*x* + *a*[5]*x*² + ⋯ + *a*[*n*−1]*x*^(*n*/2−1).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '*A*^(odd)(*x*) = *a*[1] + *a*[3]*x* + *a*[5]*x*² + ⋯ + *a*[*n*−1]*x*^(*n*/2−1).'
- en: Note that *A*^(even) contains all the even-indexed coefficients of *A* (the
    binary representation of the index ends in 0) and *A*^(odd) contains all the odd-indexed
    coefficients (the binary representation of the index ends in 1). It follows that
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意*A*^(even)包含*A*的所有偶数索引系数（索引的二进制表示以0结尾），*A*^(odd)包含所有奇数索引系数（索引的二进制表示以1结尾）。由此可知
- en: '![art](images/Art_P1074.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1074.jpg)'
- en: so that the problem of evaluating *A*(*x*) at ![art](images/Art_P1075.jpg),
    ![art](images/Art_P1076.jpg) reduces to
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 使得在![art](images/Art_P1084.jpg)的情况下，评估*A*(*x*)在![art](images/Art_P1075.jpg)、![art](images/Art_P1076.jpg)处，简化为
- en: evaluating the degree-bound *n*/2 polynomials *A*^(even)(*x*) and *A*^(odd)(*x*)
    at the points
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 评估次数界限为*n*/2的多项式*A*^(even)(*x*)和*A*^(odd)(*x*)在点上
- en: '![art](images/Art_P1077.jpg)'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![art](images/Art_P1077.jpg)'
- en: and then
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后
- en: combining the results according to equation (30.9).
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 根据方程(30.9)组合结果。
- en: By the halving lemma, the list of values (30.10) consists not of *n* distinct
    values but only of the *n*/2 complex (*n*/2)th roots of unity, with each root
    occurring exactly twice. Therefore, the FFT recursively evaluates the polynomials
    *A*^(even) and *A*^(odd) of degree-bound *n*/2 at the *n*/2 complex (*n*/2)th
    roots of unity. These subproblems have exactly the same form as the original problem,
    but are half the size, dividing an *n*-element DFT*[n]* computation into two *n*/2-element
    DFT[*n*/2] computations. This decomposition is the basis for the FFT procedure
    on the next page, which computes the DFT of an *n*-element vector *a* = (*a*[0],
    *a*[1], … , *a*[*n*−1]), where *n* is an exact power of 2.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 根据减半引理，值列表（30.10）不是*n*个不同值，而只是*n*/2个复数（*n*/2）次单位根，每个根恰好出现两次。因此，FFT递归地在*n*/2复数（*n*/2）次单位根处评估次数界限为*n*/2的多项式*A*^(even)和*A*^(odd)。这些子问题与原始问题具有完全相同的形式，但是大小减半，将*n*元素的DFT[*n*]计算分解为两个*n*/2元素的DFT[*n*/2]计算。这种分解是FFT程序的基础，该程序在下一页上计算*n*元素向量*a*
    = (*a*[0], *a*[1], …, *a*[*n*−1])的DFT，其中*n*是2的幂。
- en: The FFT procedure works as follows. Lines 1–2 represent the base case of the
    recursion. The DFT of 1 element is the element itself, since in this case
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: FFT过程的工作方式如下。第1-2行代表递归的基本情况。1个元素的DFT是元素本身，因为在这种情况下
- en: '| *y*[0] | = | ![art](images/Art_P1078.jpg) |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| *y*[0] | = | ![art](images/Art_P1078.jpg) |'
- en: '|  | = | *a*[0] · 1 |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *a*[0] · 1 |'
- en: '|  | = | *a*[0]. |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *a*[0]. |'
- en: Lines 5–6 define the coefficient vectors for the polynomials *A*^(even) and
    *A*^(odd). Lines 3, 4, and 12 guarantee that *ω* is updated properly so that whenever
    lines 10–11 are executed, ![art](images/Art_P1079.jpg). (Keeping a running value
    of *ω* from iteration to iteration saves time over computing ![art](images/omega.jpg)
    from scratch each time through the **for** loop.^([4](#footnote_4))) Lines 7–8
    perform the recursive DFT[*n*/2] computations, setting, for *k* = 0, 1, … , *n*/2
    − 1,
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 第5-6行定义了多项式*A*^(even)和*A*^(odd)的系数向量。第3、4和12行确保*ω*被正确更新，以便每当执行第10-11行时，![art](images/Art_P1079.jpg)。（在迭代中保持*ω*的运行值比每次通过**for**循环从头计算![art](images/omega.jpg)节省时间。^([4](#footnote_4))）第7-8行执行递归DFT[*n*/2]计算，设置*k*
    = 0, 1, …, *n*/2 − 1，
- en: FFT(*a*, *n*)
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: FFT(*a*, *n*)
- en: '|   1 | **if** *n* == 1 |  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '|   1 | **if** *n* == 1 |  |'
- en: '|   2 | **return** *a* | **//** DFT of 1 element is the element itself |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|   2 | **return** *a* | **//** 1个元素的DFT是元素本身 |'
- en: '|   3 | *ω[n]* = *e*^(2*πi*/*n*) |  |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '|   3 | *ω[n]* = *e*^(2*πi*/*n*) |  |'
- en: '|   4 | *ω* = 1 |  |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '|   4 | *ω* = 1 |  |'
- en: '|   5 | *a*^(even) = (*a*[0], *a*[2], … , *a*[*n*−2]) |  |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '|   5 | *a*^(even) = (*a*[0], *a*[2], …, *a*[*n*−2]) |  |'
- en: '|   6 | *a*^(odd) = (*a*[1], *a*[3], … , *a*[*n*−1]) |  |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|   6 | *a*^(odd) = (*a*[1], *a*[3], …, *a*[*n*−1]) |  |'
- en: '|   7 | *y*^(even) = FFT(*a*^(even), *n*/2) |  |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '|   7 | *y*^(even) = FFT(*a*^(even), *n*/2) |  |'
- en: '|   8 | *y*^(odd) = FFT(*a*^(odd), *n*/2) |  |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '|   8 | *y*^(odd) = FFT(*a*^(odd), *n*/2) |  |'
- en: '|   9 | **for** *k* = 0 **to** *n*/2 − 1 | **//** at this point, ![art](images/Art_P1080.jpg)
    |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '|   9 | **for** *k* = 0 **to** *n*/2 − 1 | **//** 此时，![art](images/Art_P1080.jpg)
    |'
- en: '| 10 | ![art](images/Art_P1081.jpg) |  |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 10 | ![art](images/Art_P1081.jpg) |  |'
- en: '| 11 | ![art](images/Art_P1082.jpg) |  |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 11 | ![art](images/Art_P1082.jpg) |  |'
- en: '| 12 | *ω* = *ωω[n]* |  |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 12 | *ω* = *ωω[n]* |  |'
- en: '| 13 | **return** *y* |  |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 13 | **return** *y* |  |'
- en: '![art](images/Art_P1083.jpg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1083.jpg)'
- en: or, since ![art](images/Art_P1084.jpg) by the cancellation lemma,
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，由于通过消除引理![art](images/Art_P1084.jpg)，
- en: '![art](images/Art_P1085.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1085.jpg)'
- en: Lines 10–11 combine the results of the recursive DFT[*n*/2] calculations. For
    the first *n*/2 results *y*[0], *y*[1], … , *y*[*n*/2−1], line 10 yields
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 第10-11行将递归DFT[*n*/2]计算的结果合并。对于前*n*/2个结果*y*[0]、*y*[1]、…、*y*[*n*/2−1]，第10行得到
- en: '![art](images/Art_P1086.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1086.jpg)'
- en: For *y*[*n*/2], *y*[*n*/2+1], … , *y*[*n*−1], letting *k* = 0, 1, … , *n*/2
    − 1, line 11 yields
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*y*[*n*/2]、*y*[*n*/2+1]、…、*y*[*n*−1]，令*k* = 0, 1, …, *n*/2 − 1，第11行得到
- en: '![art](images/Art_P1087.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1087.jpg)'
- en: Thus the vector *y* returned by FFT is indeed the DFT of the input vector *a*.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，FFT返回的向量*y*确实是输入向量*a*的DFT。
- en: Lines 10 and 11 multiply each value ![art](images/Art_P1088.jpg) by ![art](images/omega.jpg),
    for *k* = 0, 1, … , *n*/2 − 1\. Line 10 adds this product to ![art](images/Art_P1089.jpg),
    and line 11 subtracts it. Because each factor ![art](images/omega.jpg) appears
    in both its positive and negative forms, we call the factors ![art](images/omega.jpg)
    ***twiddle factors***.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 第10和11行将每个值![art](images/Art_P1088.jpg)乘以![art](images/omega.jpg)，对*k* = 0,
    1, …, *n*/2 − 1。第10行将此乘积添加到![art](images/Art_P1089.jpg)，第11行将其��去。因为每个因子![art](images/omega.jpg)都以其正负形式出现，我们称这些因子为***扭曲因子***。
- en: To determine the running time of the procedure FFT, note that exclusive of the
    recursive calls, each invocation takes Θ(*n*) time, where *n* is the length of
    the input vector. The recurrence for the running time is therefore
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 要确定FFT过程的运行时间，请注意，除了递归调用之外，每次调用都需要Θ(*n*)的时间，其中*n*是输入向量的长度。因此，运行时间的递归关系式为
- en: '| *T*(*n*) | = | 2*T*(*n*/2) + Θ(*n*) |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| *T*(*n*) | = | 2*T*(*n*/2) + Θ(*n*) |'
- en: '|  | = | Θ(*n* lg *n*), |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '|  | = | Θ(*n* lg *n*)，|'
- en: by case 2 of the master theorem (Theorem 4.1). Thus the FFT can evaluate a polynomial
    of degree-bound *n* at the complex *n*th roots of unity in Θ(*n* lg *n*) time.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 通过主定理（定理4.1）的情况2，因此FFT可以在Θ(*n* lg *n*)时间内评估复数*n*次单位根的多项式的度数限制为*n*。
- en: '**Interpolation at the complex roots of unity**'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: '**在复数单位根处的插值**'
- en: The polynomial multiplication scheme entails converting from coefficient form
    to point-value form by evaluating the polynomial at the complex roots of unity,
    pointwise multiplying, and finally converting from point-value form back to coefficient
    form by interpolating. We’ve just seen how to evaluate, so now we’ll see how to
    interpolate the complex roots of unity by a polynomial. To interpolate, we’ll
    write the DFT as a matrix equation and then look at the form of the matrix inverse.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式乘法方案包括通过在复数单位根处评估多项式，逐点相乘，最后通过插值将系数形式转换回点值形式。我们刚刚看到了如何进行评估，现在我们将看到如何通过多项式插值复数单位根。为了进行插值，我们将将DFT写成矩阵方程，然后查看矩阵逆的形式。
- en: 'From equation (30.4), we can write the DFT as the matrix product *y* = *V[n]a*,
    where *V[n]* is a Vandermonde matrix containing the appropriate powers of *ω[n]*:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 从方程(30.4)中，我们可以将DFT写成矩阵乘积*y* = *V[n]a*，其中*V[n]*是包含*ω[n]*适当幂的Vandermonde矩阵：
- en: '![art](images/Art_P1090.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1090.jpg)'
- en: The (*k*, *j*) entry of *V[n]* is ![art](images/Art_P1091.jpg), for *j*, *k*
    = 0, 1, … , *n* − 1\. The exponents of the entries of *V[n]* form a multiplication
    table for factors 0 to *n* − 1.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '*V[n]*的(*k*, *j*)条目为![艺术](images/Art_P1091.jpg)，对于*j*，*k* = 0, 1, … , *n* −
    1。*V[n]*的条目的指数形成了0到*n* − 1的因子的乘法表。'
- en: For the inverse operation, which we write as ![art](images/Art_P1092.jpg), multiply
    *y* by the matrix ![art](images/V1.jpg), the inverse of *V[n]*.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 对于逆操作，我们将其写为![艺术](images/Art_P1092.jpg)，将*y*乘以矩阵![艺术](images/V1.jpg)，即*V[n]*的逆。
- en: '***Theorem 30.7***'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理30.7***'
- en: For *j*, *k* = 0, 1, … , *n* − 1, the (*j*, *k*) entry of ![art](images/V1.jpg)
    is ![art](images/Art_P1093.jpg).
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*j*，*k* = 0, 1, … , *n* − 1，![艺术](images/V1.jpg)的(*j*, *k*)条目为![艺术](images/Art_P1093.jpg)。
- en: '***Proof***   We show that ![art](images/Art_P1094.jpg), the *n* × *n* identity
    matrix. Consider the (*k*, *k*′) entry of ![art](images/Art_P1095.jpg):'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 我们证明![艺术](images/Art_P1094.jpg)，即*n* × *n*单位矩阵。考虑![艺术](images/Art_P1095.jpg)的(*k*,
    *k*′)条目：'
- en: '![art](images/Art_P1096.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1096.jpg)'
- en: This summation equals 1 if *k*′ = *k*, and it is 0 otherwise by the summation
    lemma (Lemma 30.6). Note that in order for the summation lemma to apply, *k*′
    − *k* must not be divisible by *n*. Indeed, it is not, since −(*n* − 1) ≤ *k*′
    − *k* ≤ *n* − 1.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*k*′ = *k*，则这个求和等于1，否则根据求和引理（引理30.6）等于0。请注意，为了应用求和引理，*k*′ − *k* 不能被*n*整除。实际上，它不会，因为−(*n*
    − 1) ≤ *k*′ − *k* ≤ *n* − 1。
- en: ▪
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: With the inverse matrix ![art](images/V1.jpg) defined, ![art](images/Art_P1097.jpg)
    is given by
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 通过定义逆矩阵![艺术](images/V1.jpg)，![艺术](images/Art_P1097.jpg)由以下给出
- en: '![art](images/Art_P1098.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1098.jpg)'
- en: for *j* = 0, 1, … , *n* − 1\. By comparing equations (30.8) and (30.11), you
    can see that if you modify the FFT algorithm to switch the roles of *a* and *y*,
    replace *ω[n]* by ![art](images/Art_P1099.jpg), and divide each element of the
    result by *n*, you get the inverse DFT (see Exercise 30.2-4). Thus, ![art](images/DFT.jpg)
    is computable in Θ(*n* lg *n*) time as well.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*j* = 0, 1, … , *n* − 1。通过比较方程(30.8)和(30.11)，您可以看到，如果修改FFT算法以交换*a*和*y*的角色，用![艺术](images/Art_P1099.jpg)替换*ω[n]*，并将结果的每个元素除以*n*，则可以获得逆DFT（参见练习30.2-4）。因此，![艺术](images/DFT.jpg)也可以在Θ(*n*
    lg *n*)时间内计算。
- en: 'Thus, the FFT and the inverse FFT provide a way to transform a polynomial of
    degree-bound *n* back and forth between its coefficient representation and a point-value
    representation in only Θ(*n* lg *n*) time. In the context of polynomial multiplication,
    we have shown the following about the convolution *a* ⊗ *b* of vectors *a* and
    *b*:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，FFT和逆FFT提供了一种在Θ(*n* lg *n*)时间内在多项式的系数表示和点值表示之间来回转换的方法。在多项式乘法的背景下，我们已经展示了关于向量*a*和*b*的卷积*a*
    ⊗ *b*的以下内容：
- en: '***Theorem 30.8 (Convolution theorem)***'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理30.8（卷积定理）***'
- en: For any two vectors *a* and *b* of length *n*, where *n* is an exact power of
    2,
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于长度为*n*的任意两个向量*a*和*b*，其中*n*是2的幂，
- en: '![art](images/Art_P1100.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1100.jpg)'
- en: where the vectors *a* and *b* are padded with 0s to length 2*n* and · denotes
    the componentwise product of two 2*n*-element vectors.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 其中向量*a*和*b*被填充为长度为2*n*的0，并且·表示两个2*n*元素向量的分量乘积。
- en: ▪
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Exercises**'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***30.2-1***'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '***30.2-1***'
- en: Prove Corollary 30.4.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 证明推论30.4。
- en: '***30.2-2***'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '***30.2-2***'
- en: Compute the DFT of the vector (0, 1, 2, 3).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 计算向量(0, 1, 2, 3)的DFT。
- en: '***30.2-3***'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '***30.2-3***'
- en: Do Exercise 30.1-1 by using the Θ(*n* lg *n*)-time scheme.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Θ(*n* lg *n*)时间方案执行练习30.1-1。
- en: '***30.2-4***'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '***30.2-4***'
- en: Write pseudocode to compute ![art](images/DFT.jpg) in Θ(*n* lg *n*) time.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 编写伪代码以在Θ(*n* lg *n*)时间内计算![艺术](images/DFT.jpg)。
- en: '***30.2-5***'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '***30.2-5***'
- en: Describe the generalization of the FFT procedure to the case in which *n* is
    an exact power of 3\. Give a recurrence for the running time, and solve the recurrence.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 描述将FFT过程推广到*n*是3的幂的情况。给出运行时间的递归关系式，并解决递归关系式。
- en: ★ ***30.2-6***
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***30.2-6***
- en: Instead of performing an *n*-element FFT over the field of complex numbers (where
    *n* is an exact power of 2), let’s use the ring ℤ*[m]* of integers modulo *m*,
    where *m* = 2^(*tn*/2) + 1 and *t* is an arbitrary positive integer. We can use
    *ω* = 2*^t* instead of *ω[n]* as a principal *n*th root of unity, modulo *m*.
    Prove that the DFT and the inverse DFT are well defined in this system.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 不要在复数域上执行*n*元素FFT（其中*n*是2的幂），而是使用模*m*的整数环ℤ*[m]*，其中*m* = 2^(*tn*/2) + 1，*t*是任意正整数。我们可以使用*ω*
    = 2*^t*代替*ω[n]*作为模*m*的主*n*次单位根。证明在这个系统中DFT和逆DFT是良定义的。
- en: '***30.2-7***'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '***30.2-7***'
- en: Given a list of values *z*[0], *z*[1], … , *z*[*n*−1] (possibly with repetitions),
    show how to find the coefficients of a polynomial *P*(*x*) of degree-bound *n*
    + 1 that has zeros only at *z*[0], *z*[1], … , *z*[*n*−1] (possibly with repetitions).
    Your procedure should run in *O*(*n* lg² *n*) time. (*Hint:* The polynomial *P*(*x*)
    has a zero at *z[j]* if and only if *P*(*x*) is a multiple of (*x* − *z[j]*).)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 给定值列表*z*[0], *z*[1], … , *z*[*n*−1]（可能重复），展示如何找到一个多项式*P*(*x*)的系数，其次数限制为*n* +
    1，只在*z*[0], *z*[1], … , *z*[*n*−1]（可能重复）处有零点。您的过程应在*O*(*n* lg² *n*)时间内运行。（*提示：*多项式*P*(*x*)在*z[j]*处有零点当且仅当*P*(*x*)是(*x*
    − *z[j]*)的倍数。）
- en: ★ ***30.2-8***
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***30.2-8***
- en: The ***chirp transform*** of a vector *a* = (*a*[0], *a*[1], … , *a*[*n*−1])
    is the vector *y* = (*y*[0], *y*[1], … , *y*[*n*−1]), where ![art](images/Art_P1101.jpg)
    and *z* is any complex number. The DFT is therefore a special case of the chirp
    transform, obtained by taking *z* = *ω[n]*. Show how to evaluate the chirp transform
    for any complex number *z* in *O*(*n* lg *n*) time. (*Hint:* Use the equation
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 向量*a* = (*a*[0], *a*[1], … , *a*[*n*−1])的***chirp变换***是向量*y* = (*y*[0], *y*[1],
    … , *y*[*n*−1])，其中![art](images/Art_P1101.jpg)，*z*是任意复数。因此，DFT是通过取*z* = *ω[n]*获得的chirp变换的特殊情况。展示如何在*O*(*n*
    lg *n*)时间内评估任意复数*z*的chirp变换。（*提示：*使用方程
- en: '![art](images/Art_P1102.jpg)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1102.jpg)'
- en: to view the chirp transform as a convolution.)
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 将chirp变换视为卷积。）
- en: '[**30.3    FFT circuits**](toc.xhtml#Rh1-174)'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[**30.3    FFT电路**](toc.xhtml#Rh1-174)'
- en: Many of the FFT’s applications in signal processing require the utmost speed,
    and so the FFT is often implemented as a circuit in hardware. The FFT’s divide-and-conquer
    structure enables the circuit to have a parallel structure so that the ***depth***
    of the circuit—the maximum number of computational elements between any output
    and any input that can reach it—is Θ(lg *n*). Moreover, the structure of the FFT
    circuit has several interesting mathematical properties, which we won’t go into
    here.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 信号处理中FFT的许多应用需要最快的速度，因此FFT通常作为硬件电路实现。FFT的分而治之结构使电路具有并行结构，因此电路的深度——任何输出和任何可以到达它的输入之间的最大计算元素数量——为Θ(lg
    *n*)。此外，FFT电路的结构具有几个有趣的数学性质，我们在这里不会详细介绍。
- en: '**Butterfly operations**'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '**蝴蝶操作**'
- en: 'Notice that the **for** loop of lines 9–12 of the FFT procedure computes the
    value ![art](images/Art_P1103.jpg) twice per iteration: once in line 10 and once
    in line 11\. A good optimizing compiler produces code that evaluates this ***common
    subexpression*** just once, storing its value into a temporary variable, so that
    lines 10–11 are treated like the three lines'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 注意FFT过程的第9-12行的**for**循环每次迭代计算值![art](images/Art_P1103.jpg)两次：在第10行和第11行各一次。一个优化良好的编译器会生成��码，只评估这个***公共子表达式***一次，并将其值存储到临时变量中，以便第10-11行被视为三行
- en: '![art](images/Art_P1104.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1104.jpg)'
- en: This operation, multiplying the twiddle factor ![art](images/Art_P1105.jpg)
    by ![art](images/Art_P1106.jpg), storing the product into the temporary variable
    *t*, and adding and subtracting *t* from ![art](images/Art_P1107.jpg), is known
    as a ***butterfly operation***. [Figure 30.3](chapter030.xhtml#Fig_30-3) shows
    it as a circuit, and you can see how it vaguely resembles the shape of a butterfly.
    (Although less colorfully, it could have been called a “bowtie” operation.)
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个操作，将旋转因子![art](images/Art_P1105.jpg)乘以![art](images/Art_P1106.jpg)，��乘积存储到临时变量*t*中，并从![art](images/Art_P1107.jpg)中加减*t*，被称为***蝴蝶操作***。[图30.3](chapter030.xhtml#Fig_30-3)将其显示为一个电路，您可以看到它如何模糊地类似于蝴蝶的形状。（尽管不那么丰富多彩，它也可以被称为“蝴蝶结”操作。）
- en: '![art](images/Art_P1108.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1108.jpg)'
- en: '**Figure 30.3** A circuit for a butterfly operation. **(a)** The two input
    values enter from the left, the twiddle factor ![art](images/omega.jpg) is multiplied
    by ![art](images/Art_P1109.jpg), and the sum and difference are output on the
    right. **(b)** A simplified drawing of a butterfly operation, which we’ll use
    when drawing the parallel FFT circuit.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**图30.3** 蝴蝶操作的电路。**(a)** 两个输入值从左侧输入，乘以旋转因子![art](images/omega.jpg)，并将和与差输出到右侧。**(b)**
    蝴蝶操作的简化图，我们在绘制并行FFT电路时将使用。'
- en: '![art](images/Art_P1110.jpg)'
  id: totrans-240
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1110.jpg)'
- en: '**Figure 30.4** The schema for the conquer and combine steps of an *n*-input,
    *n*-output FFT circuit, FFT*[n]*, shown for *n* = 8\. Inputs enter from the left,
    and outputs exit from the right. The input values first go through two FFT[*n*/2]
    circuits, and then *n*/2 butterfly circuits combine the results. Only the top
    and bottom wires entering a butterfly interact with it: wires that pass through
    the middle of a butterfly do not affect that butterfly, nor are their values changed
    by that butterfly.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '**图30.4** *n*输入，*n*输出FFT电路FFT*[n]*的征程和合并步骤的模式，以*n* = 8为例。输入从左侧进入，输出从右侧退出。输入值首先经过两个FFT[*n*/2]电路，然后*n*/2个蝴蝶电路组合结果。只有进入蝴蝶的顶部和底部导线与之交互：通过蝴蝶中间的导线不影响该蝴蝶，也不会被该蝴蝶改变其值。'
- en: '**Recursive circuit structure**'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '**递归电路结构**'
- en: 'The FFT procedure follows the divide-and-conquer strategy that we first saw
    in [Section 2.3.1](chapter002.xhtml#Sec_2.3.1):'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: FFT过程遵循我们在[第2.3.1节](chapter002.xhtml#Sec_2.3.1)中首次看到的分而治之策略：
- en: '**Divide** the *n*-element input vector into its *n*/2 even-indexed and *n*/2
    odd-indexed elements.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '**分割** *n*元素输入向量为其*n*/2偶索引和*n*/2奇索引元素。'
- en: '**Conquer** by recursively computing the DFTs of the two subproblems, each
    of size *n*/2.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '**征服**通过递归计算两个大小为*n*/2的子问题的DFT。'
- en: '**Combine** by performing *n*/2 butterfly operations. These butterfly operations
    work with twiddle factors ![art](images/Art_P1111.jpg), ![art](images/Art_P1112.jpg).'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '**合并**通过执行*n*/2个蝶形操作。这些蝶形操作使用旋转因子![艺术](images/Art_P1111.jpg)、![艺术](images/Art_P1112.jpg)。'
- en: The circuit schema in [Figure 30.4](chapter030.xhtml#Fig_30-4) follows the conquer
    and combine steps of this pattern for an FFT circuit with *n* inputs and *n* outputs,
    denoted by FFT*[n]*. Each line is a wire that carries a value. Inputs enter from
    the left, one per wire, and outputs exit from the right. The conquer step runs
    the inputs through two FFT[*n*/2] circuits, which are also constructed recursively.
    The values produced by the two FFT[*n*/2] circuits feed into *n*/2 butterfly circuits,
    with twiddle factors ![art](images/Art_P1113.jpg), ![art](images/Art_P1114.jpg),
    to combine the results. The base case of the recursion occurs when *n* = 1, where
    the sole output value equals the sole input value. An FFT[1] circuit, therefore,
    does nothing, and so the smallest nontrivial FFT circuit is FFT[2], a single butterfly
    operation whose twiddle factor is ![art](images/Art_P1115.jpg).
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '[图30.4](chapter030.xhtml#Fig_30-4)中的电路模式遵循FFT电路的征服和合并步骤，其中有*n*个输入和*n*个输出，用FFT*[n]*表示。每条线都是携带值的导线。输入从左侧进入，每根导线一个输入，输出从右侧退出。征服步骤将输入通过两个FFT[*n*/2]电路，这些电路也是递归构建的。两个FFT[*n*/2]电路产生的值输入到*n*/2个蝶形电路中，旋转因子为![艺术](images/Art_P1113.jpg)、![艺术](images/Art_P1114.jpg)，以合并结果。递归的基本情况发生在*n*=1时，此时唯一的输出值等于唯一的输入值。因此，FFT[1]电路什么也不做，因此最小的非平凡FFT电路是FFT[2]，一个单独的蝶形操作，其旋转因子为![艺术](images/Art_P1115.jpg)。'
- en: '![art](images/Art_P1116.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1116.jpg)'
- en: '**Figure 30.5** The tree of input vectors to the recursive calls of the FFT
    procedure. The initial invocation is for *n* = 8.'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '**图30.5** FFT过程的递归调用的输入向量树。初始调用是*n*=8。'
- en: '**Permuting the inputs**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**重新排列输入**'
- en: How does the divide step enter into the circuit design? Let’s examine how input
    vectors to the various recursive calls of the FFT procedure relate to the original
    input vector, so that the circuit can emulate the divide step at the start for
    all levels of recursion. [Figure 30.5](chapter030.xhtml#Fig_30-5) arranges the
    input vectors to the recursive calls in an invocation of FFT in a tree structure,
    where the initial call is for *n* = 8\. The tree has one node for each call of
    the procedure, labeled by the elements of the initial call as they appear in the
    corresponding input vector. Each FFT invocation makes two recursive calls, unless
    it has received a 1-element vector. The first call appears in the left child,
    and the second call appears in the right child.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如何将分治步骤融入电路设计？让我们来看看FFT过程的各个递归调用的输入向量如何与原始输入向量相关联，以便电路可以在所有递归级别上模拟开始时的分治步骤。[图30.5](chapter030.xhtml#Fig_30-5)
    将FFT的递归调用的输入向量排列在树状结构中，其中初始调用是*n*=8。树中每个过程调用都有一个节点，标记为初始调用的元素，这些元素按照相应输入向量中的顺序出现。每个FFT调用都会进行两次递归调用，除非它收到一个1元素向量。第一个调用出现在左子节点中，第二个调用出现在右子节点中。
- en: Looking at the tree, observe that if you arrange the elements of the initial
    vector *a* into the order in which they appear in the leaves, you can trace the
    execution of the FFT procedure, but bottom up instead of top down. First, take
    the elements in pairs, compute the DFT of each pair using one butterfly operation,
    and replace the pair with its DFT. The vector then holds *n*/2 two-element DFTs.
    Next, take these *n*/2 DFTs in pairs and compute the DFT of the four vector elements
    they come from by executing two butterfly operations, replacing two two-element
    DFTs with one four-element DFT. The vector then holds *n*/4 four-element DFTs.
    Continue in this manner until the vector holds two (*n*/2)-element DFTs, which
    *n*/2 butterfly operations combine into the final *n*-element DFT. In other words,
    you can start with the elements of the initial vector *a*, but rearranged as in
    the leaves of [Figure 30.5](chapter030.xhtml#Fig_30-5), and then feed them directly
    into a circuit that follows the schema in [Figure 30.4](chapter030.xhtml#Fig_30-4).
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 从树中可以看出，如果你将初始向量*a*的元素按照它们在叶子中出现的顺序排列，你可以追踪FFT过程的执行，但是从底部向上而不是从顶部向下。首先，将元素成对取出，使用一个蝶形操作计算每对的DFT，并用其DFT替换该对。向量现在包含*n*/2个两元素DFT。接下来，将这些*n*/2个DFT成对取出，并通过执行两个蝶形操作计算它们来自的四个向量元素的DFT，用一个四元素DFT替换两个两元素DFT。向量现在包含*n*/4个四元素DFT。以此类推，直到向量包含两个(*n*/2)元素DFT，这些DFT通过*n*/2个蝶形操作组合成最终的*n*元素DFT。换句话说，你可以从初始向量*a*的元素开始，但按照[图30.5](chapter030.xhtml#Fig_30-5)中叶子的排列方式重新排列，然后直接将它们输入到遵循[图30.4](chapter030.xhtml#Fig_30-4)中模式的电路中。
- en: Let’s think about the permutation that rearranges the input vector. The order
    in which the leaves appear in [Figure 30.5](chapter030.xhtml#Fig_30-5) is a ***bit-reversal
    permutation***. That is, letting rev(*k*) be the lg *n*-bit integer formed by
    reversing the bits of the binary representation of *k*, then vector element *a[k]*
    moves to position rev(*k*). In [Figure 30.5](chapter030.xhtml#Fig_30-5), for example,
    the leaves appear in the order 0, 4, 2, 6, 1, 5, 3, 7\. This sequence in binary
    is 000, 100, 010, 110, 001, 101, 011, 111, and you can obtain it by reversing
    the bits of each number in the sequence 0, 1, 2, 3, 4, 6, 7 or, in binary, 000,
    001, 010, 011, 100, 101, 110, 111\. To see in general that the input vector should
    be rearranged by a bit-reversal permutation, note that at the top level of the
    tree, indices whose low-order bit is 0 go into the left subtree and indices whose
    low-order bit is 1 go into the right subtree. Stripping off the low-order bit
    at each level, continue this process down the tree, until you get the order given
    by the bit-reversal permutation at the leaves.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑重新排列输入向量的排列。在[图30.5](chapter030.xhtml#Fig_30-5)中叶子出现的顺序是***位逆序排列***。也就是说，让*rev(k)*是通过颠倒*k*的二进制表示的位得到的lg
    *n*位整数，那么向量元素*a[k]*移动到位置*rev(k)*。例如，在[图30.5](chapter030.xhtml#Fig_30-5)中，叶子的顺序是0,
    4, 2, 6, 1, 5, 3, 7。这个二进制序列是000, 100, 010, 110, 001, 101, 011, 111，你可以通过颠倒序列0,
    1, 2, 3, 4, 6, 7中每个数字的位来获得它，或者用二进制表示为000, 001, 010, 011, 100, 101, 110, 111。为了一般地看到输入向量应该通过位逆序排列重新排列，注意在树的顶层，低位为0的索引进入左子树，低位为1的索引进入右子树。在每个级别剥离低位，继续这个过程直到树的底部，直到你得到叶子处位逆序排列给出的顺序。
- en: '**The full FFT circuit**'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '**完整的FFT电路**'
- en: '[Figure 30.6](chapter030.xhtml#Fig_30-6) depicts the entire circuit for *n*
    = 8\. The circuit begins with a bit-reversal permutation of the inputs, followed
    by lg *n* stages, each stage consisting of *n*/2 butterflies executed in parallel.
    Assuming that each butterfly circuit has constant depth, the full circuit has
    depth Θ(lg *n*). The butterfly operations at each level of recursion in the FFT
    procedure are independent, and so the circuit performs them in parallel. The figure
    shows wires running from left to right, carrying values through the lg *n* stages.
    For *s* = 1, 2, … , lg *n*, stage *s* consists of *n*/2*^s* groups of butterflies,
    with 2^(*s*−1) butterflies per group. The twiddle factors in stage *s* are ![art](images/Art_P1117.jpg),
    ![art](images/Art_P1118.jpg), where *m* = 2*^s*.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '[图30.6](chapter030.xhtml#Fig_30-6)描绘了*n* = 8的整个电路。电路以输入的位逆序排列开始，然后是lg *n*个阶段，每个阶段包括*n*/2个并行执行的蝴蝶。假设每个蝴蝶电路的深度恒定，整个电路的深度为Θ(lg
    *n*)。FFT过程中每个递归级别的蝴蝶操作是独立的，因此电路并行执行它们。图中显示了从左到右传输值的导线，通过lg *n*个阶段。对于*s* = 1, 2,
    … , lg *n*，第*s*阶段由*n*/2*^s*组蝴蝶组成，每组有2^(*s*−1)个蝴蝶。第*s*阶段的旋转因子是![art](images/Art_P1117.jpg)，![art](images/Art_P1118.jpg)，其中*m*
    = 2*^s*。'
- en: '**Exercises**'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***30.3-1***'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '***30.3-1***'
- en: Show the values on the wires for each butterfly input and output in the FFT
    circuit of [Figure 30.6](chapter030.xhtml#Fig_30-6), given the input vector (0,
    2, 3, −1, 4, 5, 7, 9).
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 给定输入向量(0, 2, 3, −1, 4, 5, 7, 9)，在FFT电路[图30.6](chapter030.xhtml#Fig_30-6)中展示每个蝴蝶输入和输出导线上的值。
- en: '***30.3-2***'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '***30.3-2***'
- en: Consider an FFT*[n]* circuit, such as in [Figure 30.6](chapter030.xhtml#Fig_30-6),
    with wires 0, 1, … , *n*−1 (wire *j* has output *y[j]*) and stages numbered as
    in the figure. Stage *s*, for *s* = 1, 2 … , lg *n*, consists of *n*/2*^s* groups
    of butterflies. Which two wires are inputs and outputs for the *j*th butterfly
    circuit in the *g*th group in stage *s*?
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个FFT*[n]*电路，例如[图30.6](chapter030.xhtml#Fig_30-6)，具有0, 1, … , *n*−1（导线*j*有输出*y[j]*）和如图中编号的阶段。第*s*阶段，对于*s*
    = 1, 2 … , lg *n*，包括*n*/2*^s*组蝴蝶。在第*s*阶段中，第*g*组中的第*j*个蝴蝶电路的输入和输出是哪两根导线？
- en: '***30.3-3***'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '***30.3-3***'
- en: Consider a *b*-bit integer *k* in the range 0 ≤ *k* < 2*^b*. Treating *k* as
    a *b*-element vector over {0, 1}, describe a *b* × *b* matrix *M* such that the
    matrix-vector product *Mk* is the binary representation of rev(*k*).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个范围在0 ≤ *k* < 2*^b*的*b*位整数*k*。将*k*视为{0, 1}上的*b*元素向量，描述一个*b* × *b*矩阵*M*，使得矩阵-向量乘积*Mk*是*rev(k)*的二进制表示。
- en: '![art](images/Art_P1119.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1119.jpg)'
- en: '**Figure 30.6** A full circuit that computes the FFT in parallel, here shown
    for *n* = 8 inputs. It has lg *n* stages, and each stage comprises *n*/2 butterflies
    that can operate in parallel. As in [Figure 30.4](chapter030.xhtml#Fig_30-4),
    only the top and bottom wires entering a butterfly interact with it. For example,
    the top butterfly in stage 2 has inputs and outputs only on wires 0 and 2 (the
    wires with outputs *y*[0] and *y*[2], respectively). This circuit has depth Θ(lg
    *n*) and performs Θ(*n* lg *n*) butterfly operations altogether.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '**图30.6** 一个完整的并行计算FFT的电路，这里展示了*n* = 8个输入的情况。它有lg *n*个阶段，每个阶段包括*n*/2个可以并行操作的蝴蝶。就像[图30.4](chapter030.xhtml#Fig_30-4)中一样，只有进入蝴蝶的顶部和底部导线与之交互。例如，第2阶段的顶部蝴蝶只在0和2号导线上有输入和输出（分别是输出*y*[0]和*y*[2]的导线）。这个电路的深度为Θ(lg
    *n*)，总共执行Θ(*n* lg *n*)个蝴蝶操作。'
- en: '***30.3-4***'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '***30.3-4***'
- en: Write pseudocode for the procedure BIT-REVERSE-PERMUTATION(*a*, *n*), which
    performs the bit-reversal permutation on a vector *a* of length *n* in-place.
    Assume that you may call the procedure BIT-REVERSE-OF(*k*, *b*), which returns
    an integer that is the *b*-bit reversal of the nonnegative integer *k*, where
    0 ≤ *k* < 2*^b*.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为过程BIT-REVERSE-PERMUTATION(*a*, *n*)编写伪代码，该过程在长度为*n*的向量*a*上原地执行位逆序排列。假设你可以调用过程BIT-REVERSE-OF(*k*,
    *b*)，它返回一个整数，即非负整数*k*的*b*位颠倒，其中0 ≤ *k* < 2*^b*。
- en: ★ ***30.3-5***
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***30.3-5***
- en: Suppose that the adders within the butterfly operations of a given FFT circuit
    sometimes fail in such a manner that they always produce a 0 output, independent
    of their inputs. In addition, suppose that exactly one adder has failed, but you
    don’t know which one. Describe how you can identify the failed adder by supplying
    inputs to the overall FFT circuit and observing the outputs. How efficient is
    your method?
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 假设给定FFT电路��蝴蝶操作中的加法器有时会以一种总是产生0输出的方式失败，而且假设只有一个加法器失败，但你不知道是哪一个。描述如何通过向整个FFT电路提供输入并观察输出来识别失败的加法器。你的方法效率如何？
- en: '**Problems**'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '***30-1     Divide-and-conquer multiplication***'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '***30-1     分治乘法***'
- en: '***a.*** Show how to multiply two linear polynomials *ax* + *b* and *cx* +
    *d* using only three multiplications. (*Hint:* One of the multiplications is (*a*
    + *b*) · (*c* + *d*).)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 展示如何仅使用三次乘法来乘两个线性多项式*ax* + *b*和*cx* + *d*。(*提示:* 其中一次乘法是(*a* + *b*)
    · (*c* + *d*)。)'
- en: '***b.*** Give two divide-and-conquer algorithms for multiplying two polynomials
    of degree-bound *n* in Θ(*n*^(lg 3)) time. The first algorithm should divide the
    input polynomial coefficients into a high half and a low half, and the second
    algorithm should divide them according to whether their index is odd or even.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 给出两种在Θ(*n*^(lg 3))时间内将两个度数限制为*n*的多项式相乘的分治算法。第一种算法应该将输入多项式系数分为高半部分和低半部分，第二种算法应该根据它们的索引是奇数还是偶数来分割它们。'
- en: '***c.*** Show how to multiply two *n*-bit integers in *O*(*n*^(lg 3)) steps,
    where each step operates on at most a constant number of 1-bit values.'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 展示如何在*O*(*n*^(lg 3))步内乘两个*n*位整数，其中每一步最多操作常数个1位值。'
- en: '***30-2     Multidimensional fast Fourier transform***'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '***30-2     多维快速傅里叶变换***'
- en: The 1-dimensional discrete Fourier transform defined by equation (30.8) generalizes
    to *d* dimensions. The input is a *d*-dimensional array *A* = (*a*[*j*1,*j*2,…,*j[d]*])
    whose dimensions are *n*[1], *n*[2], … , *n[d]*, where *n*[1]*n*[2] ⋯ *n[d]* =
    *n*. The *d*-dimensional discrete Fourier transform is defined by the equation
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 方程(30.8)定义的一维离散傅里叶变换推广到*d*维。输入是一个*d*维数组*A* = (*a*[*j*1,*j*2,…,*j[d]*])，其维度为*n*[1]，*n*[2]，…，*n[d]*，其中*n*[1]*n*[2]
    ⋯ *n[d]* = *n*。*d*维离散傅里叶变换由以下方程定义：
- en: '![art](images/Art_P1120.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1120.jpg)。'
- en: for 0 ≤ *k*[1] < *n*[1], 0 ≤ *k*[2] < *n*[2], … , 0 ≤ *k[d]* < *n[d]*.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 对于0 ≤ *k*[1] < *n*[1]，0 ≤ *k*[2] < *n*[2]，…，0 ≤ *k[d]* < *n[d]*。
- en: '***a.*** Show how to produce a *d*-dimensional DFT by computing 1-dimensional
    DFTs on each dimension in turn. That is, first compute *n*/*n*[1] separate 1-dimensional
    DFTs along dimension 1\. Then, using the result of the DFTs along dimension 1
    as the input, compute *n*/*n*[2] separate 1-dimensional DFTs along dimension 2\.
    Using this result as the input, compute *n*/*n*[3] separate 1-dimensional DFTs
    along dimension 3, and so on, through dimension *d*.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 展示如何通过依次在每个维度上计算一维DFT来生成*d*维DFT。也就是说，首先沿第一维计算*n*/*n*[1]个单独的一维DFT。然后，使用第一维DFT的结果作为输入，沿第二维计算*n*/*n*[2]个单独的一维DFT。使用这个结果作为输入，沿第三维计算*n*/*n*[3]个单独的一维DFT，依此类推，直到第*d*维。'
- en: '***b.*** Show that the ordering of dimensions does not matter, so that if you
    compute the 1-dimensional DFTs in any order of the *d* dimensions, you compute
    the *d*-dimensional DFT.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 表明维度的顺序不重要，因此如果按照*d*个维度的任何顺序计算一维DFT，则可以计算*d*维DFT。'
- en: '***c.*** Show that if you compute each 1-dimensional DFT by computing the fast
    Fourier transform, the total time to compute a *d*-dimensional DFT is *O*(*n*
    lg *n*), independent of *d*.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 表明如果通过计算快速傅里叶变换来计算每个一维DFT，则计算*d*维DFT的总时间为*O*(*n* lg *n*），与*d*无关。'
- en: '***30-3     Evaluating all derivatives of a polynomial at a point***'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '***30-3     在一个点评估多项式的所有导数***'
- en: Given a polynomial *A*(*x*) of degree-bound *n*, we define its *t*th derivative
    by
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 给定度数限制为*n*的多项式*A*(*x*)，我们通过以下方式定义其第*t*次导数：
- en: '![art](images/Art_P1121.jpg)'
  id: totrans-283
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1121.jpg)。'
- en: In this problem, you will show how to determine *A*^((*t*))(*x*[0]) for *t*
    = 0, 1, … , *n* − 1, given the coefficient representation (*a*[0], *a*[1], … ,
    *a*[*n*−1]) of *A*(*x*) and a point *x*[0].
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个问题中，你将展示如何确定给定多项式*A*(*x*)的系数表示(*a*[0]，*a*[1]，…，*a*[*n*−1])和一个点*x*[0]时，如何计算*t*
    = 0, 1, … , *n* − 1的*A*^((*t*))(*x*[0])。
- en: '***a.*** Given coefficients *b*[0], *b*[1], … , *b*[*n*−1] such that'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 给定系数*b*[0]，*b*[1]，…，*b*[*n*−1]，使得'
- en: '![art](images/Art_P1122.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1122.jpg)。'
- en: show how to compute *A*^((*t*))(*x*[0]), for *t* = 0, 1, … , *n* − 1, in *O*(*n*)
    time.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何在*O*(*n*)时间内计算*A*^((*t*))(*x*[0])，对于*t* = 0, 1, … , *n* − 1。
- en: '***b.*** Explain how to find *b*[0], *b*[1], … , *b*[*n*−1] in *O*(*n* lg *n*)
    time, given ![art](images/Art_P1123.jpg) for *k* = 0, 1, … , *n* − 1.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 解释如何在*O*(*n* lg *n*)时间内找到*b*[0]，*b*[1]，…，*b*[*n*−1]，给定![艺术](images/Art_P1123.jpg)对于*k*
    = 0, 1, … , *n* − 1。'
- en: '***c.*** Prove that'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 证明'
- en: '![art](images/Art_P1124.jpg)'
  id: totrans-290
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1124.jpg)。'
- en: where *f*(*j*) = *a[j]* · *j*! and
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*f*(*j*) = *a[j]* · *j*!。
- en: '![art](images/Art_P1125.jpg)'
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1125.jpg)。'
- en: '***d.*** Explain how to evaluate ![art](images/Art_P1126.jpg) for *k* = 0,
    1, … , *n* − 1 in *O*(*n* lg *n*) time. Conclude that you can evaluate all nontrivial
    derivatives of *A*(*x*) at *x*[0] in *O*(*n* lg *n*) time.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 解释如何在*O*(*n* lg *n*)时间内评估![艺术](images/Art_P1126.jpg)对于*k* = 0, 1,
    … , *n* − 1。得出结论，你可以在*O*(*n* lg *n*)时间内评估*A*(*x*)在*x*[0]处的所有非平凡导数。'
- en: '***30-4     Polynomial evaluation at multiple points***'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '***30-4     多点多项式评估***'
- en: Problem 2-3 showed how to evaluate a polynomial of degree-bound *n* at a single
    point in *O*(*n*) time using Horner’s rule. This chapter described how to evaluate
    such a polynomial at all *n* complex roots of unity in *O*(*n* lg *n*) time using
    the FFT. Now, you will show how to evaluate a polynomial of degree-bound *n* at
    *n* arbitrary points in *O*(*n* lg² *n*) time.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 问题2-3展示了如何使用霍纳法则在*O*(*n*)时间内在单点评估度数限制为*n*的多项式。本章描述了如何使用快速傅里叶变换在*O*(*n* lg *n*)时间内在所有*n*个复数单位根处评估这样的多项式。现在，你将展示如何在*O*(*n*
    lg² *n*)时间内在*n*个任意点评估度数限制为*n*的多项式。
- en: To do so, assume that you can compute the polynomial remainder when one such
    polynomial is divided by another in *O*(*n* lg *n*) time. For example, the remainder
    of 3*x*³ + *x*² − 3*x* + 1 when divided by *x*² + *x* + 2 is
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你可以在 *O*(*n* lg *n*) 的时间内计算一个多项式被另一个多项式除的余数。例如，当 3*x*³ + *x*² − 3*x* + 1 被
    *x*² + *x* + 2 除时的余数是
- en: (3*x*³ + *x*² − 3*x* + 1) mod (*x*² + *x* + 2) = −7*x* + 5.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: (3*x*³ + *x*² − 3*x* + 1) mod (*x*² + *x* + 2) = −7*x* + 5。
- en: Given the coefficient representation of a polynomial ![art](images/Art_P1127.jpg)
    and *n* points *x*[0], *x*[1], … , *x*[*n*−1], your goal is to compute the *n*
    values *A*(*x*[0]), *A*(*x*[1]), … , *A*(*x*[*n*−1]). For 0 ≤ *i* ≤ *j* ≤ *n*
    − 1, define the polynomials ![art](images/Art_P1128.jpg) and *Q[ij]*(*x*) = *A*(*x*)
    mod *P[ij]*(*x*). Note that *Q[ij]*(*x*) has degree at most *j* − *i*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 给定多项式的系数表示 ![art](images/Art_P1127.jpg) 和 *n* 个点 *x*[0], *x*[1], … , *x*[*n*−1]，你的目标是计算
    *n* 个值 *A*(*x*[0]), *A*(*x*[1]), … , *A*(*x*[*n*−1])。对于 0 ≤ *i* ≤ *j* ≤ *n* −
    1，定义多项式 ![art](images/Art_P1128.jpg) 和 *Q[ij]*(*x*) = *A*(*x*) mod *P[ij]*(*x*)。注意
    *Q[ij]*(*x*) 的次数最多为 *j* − *i*。
- en: '***a.*** Prove that *A*(*x*) mod (*x* − *z*) = *A*(*z*) for any point *z*.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 证明对于任意点 *z*，*A*(*x*) mod (*x* − *z*) = *A*(*z*)。'
- en: '***b.*** Prove that *Q[kk]*(*x*) = *A*(*x[k]*) and that *Q*[0,*n*−1](*x*) =
    *A*(*x*).'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 证明 *Q[kk]*(*x*) = *A*(*x[k]*) 且 *Q*[0,*n*−1](*x*) = *A*(*x*)。'
- en: '***c.*** Prove that for *i* ≤ *k* ≤ *j*, we have both *Q[ik]*(*x*) = *Q[ij]*(*x*)
    mod *P[ik]*(*x*) and *Q[kj]*(*x*) = *Q[ij]*(*x*) mod *P[kj]*(*x*).'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 证明对于 *i* ≤ *k* ≤ *j*，我们有 *Q[ik]*(*x*) = *Q[ij]*(*x*) mod *P[ik]*(*x*)
    且 *Q[kj]*(*x*) = *Q[ij]*(*x*) mod *P[kj]*(*x*)。'
- en: '***d.*** Give an *O*(*n* lg² *n*)-time algorithm to evaluate *A*(*x*[0]), *A*(*x*[1]),
    … , *A*(*x*[*n*−1]).'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 给出一个 *O*(*n* lg² *n*) 的算法来计算 *A*(*x*[0]), *A*(*x*[1]), … , *A*(*x*[*n*−1])。'
- en: '***30-5     FFT using modular arithmetic***'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '***30-5     使用模算术的FFT***'
- en: As defined, the discrete Fourier transform requires computation with complex
    numbers, which can result in a loss of precision due to round-off errors. For
    some problems, the answer is known to contain only integers, and a variant of
    the FFT based on modular arithmetic can guarantee that the answer is calculated
    exactly. An example of such a problem is that of multiplying two polynomials with
    integer coefficients. Exercise 30.2-6 gives one approach, using a modulus of length
    Ω(*n*) bits to handle a DFT on *n* points. This problem explores another approach
    that uses a modulus of the more reasonable length *O*(lg *n*), but it requires
    that you understand the material of [Chapter 31](chapter031.xhtml). Let *n* be
    an exact power of 2.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 如定义，离散傅立叶变换需要使用复数进行计算，这可能会由于舍入误差而导致精度损失。对于某些问题，已知答案仅包含整数，并且基于模算术的FFT变体可以保证准确计算答案。这类问题的一个示例是两个具有整数系数的多项式相乘。练习
    30.2-6 给出了一种方法，使用长度为 Ω(*n*) 位的模来处理 *n* 个点上的DFT。这个问题探讨了另一种方法，使用更合理长度 *O*(lg *n*)
    的模，但需要你理解[第31章](chapter031.xhtml)的内容。让 *n* 是 2 的幂。
- en: '***a.*** You wish to search for the smallest *k* such that *p* = *kn* + 1 is
    prime. Give a simple heuristic argument why you might expect *k* to be approximately
    ln *n*. (The value of *k* might be much larger or smaller, but you can reasonably
    expect to examine *O*(lg *n*) candidate values of *k* on average.) How does the
    expected length of *p* compare to the length of *n*?'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 你希望寻找最小的 *k*，使得 *p* = *kn* + 1 是素数。给出一个简单的启发式论证，说明为什么你可能期望 *k* 大约为
    ln *n*。（*k* 的值可能大得多或小得多，但你可以合理地期望平均检查 *O*(lg *n*) 个候选 *k* 值。）期望的 *p* 长度与 *n* 的长度相比如何？'
- en: Let *g* be a generator of ![art](images/Art_P1129.jpg), and let *w* = *g^k*
    mod *p*.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 让 *g* 是 ![art](images/Art_P1129.jpg) 的一个生成元，令 *w* = *g^k* mod *p*。
- en: '***b.*** Argue that the DFT and the inverse DFT are well-defined inverse operations
    modulo *p*, where *w* is used as a principal *n*th root of unity.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 论证DFT和逆DFT在模 *p* 下是互为逆操作的，其中 *w* 被用作主要的 *n* 次单位根。'
- en: '***c.*** Show how to make the FFT and its inverse work modulo *p* in *O*(*n*
    lg *n*) time, where operations on words of *O*(lg *n*) bits take unit time. Assume
    that the algorithm is given *p* and *w*.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 展示如何使FFT及其逆运算在模 *p* 下以 *O*(*n* lg *n*) 的时间内工作，其中对 *O*(lg *n*) 位的字进行操作需要单位时间。假设算法给定
    *p* 和 *w*。'
- en: '***d.*** Compute the DFT modulo *p* = 17 of the vector (0, 5, 3, 7, 7, 2, 1,
    6). (*Hint:* Verify and use the fact that *g* = 3 is a generator of ![art](images/Art_P1130.jpg).)'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 计算向量 (0, 5, 3, 7, 7, 2, 1, 6) 的模 *p* = 17 的DFT。(*提示:* 验证并使用 *g* =
    3 是 ![art](images/Art_P1130.jpg) 的一个生成元。)'
- en: '**Chapter notes**'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节注释**'
- en: Van Loan’s book [[442](bibliography001.xhtml#endnote_442)] provides an outstanding
    treatment of the fast Fourier transform. Press, Teukolsky, Vetterling, and Flannery
    [[365](bibliography001.xhtml#endnote_365), [366](bibliography001.xhtml#endnote_366)]
    offer a good description of the fast Fourier transform and its applications. For
    an excellent introduction to signal processing, a popular FFT application area,
    see the texts by Oppenheim and Schafer [[347](bibliography001.xhtml#endnote_347)]
    and Oppenheim and Willsky [[348](bibliography001.xhtml#endnote_348)]. The Oppenheim
    and Schafer book also shows how to handle cases in which *n* is not an exact power
    of 2.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: Van Loan 的书[[442](bibliography001.xhtml#endnote_442)]提供了对快速傅立叶变换的出色阐述。Press,
    Teukolsky, Vetterling 和 Flannery[[365](bibliography001.xhtml#endnote_365), [366](bibliography001.xhtml#endnote_366)]提供了对快速傅立叶变换及其应用的良好描述。对于信号处理的出色介绍，一个流行的FFT应用领域，请参阅Oppenheim
    和 Schafer的文本[[347](bibliography001.xhtml#endnote_347)]以及Oppenheim 和 Willsky的文本[[348](bibliography001.xhtml#endnote_348)]。Oppenheim
    和 Schafer 的书还展示了如何处理 *n* 不是 2 的幂的情况。
- en: Fourier analysis is not limited to 1-dimensional data. It is widely used in
    image processing to analyze data in two or more dimensions. The books by Gonzalez
    and Woods [[194](bibliography001.xhtml#endnote_194)] and Pratt [[363](bibliography001.xhtml#endnote_363)]
    discuss multidimensional Fourier transforms and their use in image processing,
    and books by Tolimieri, An, and Lu [[439](bibliography001.xhtml#endnote_439)]
    and Van Loan [[442](bibliography001.xhtml#endnote_442)] discuss the mathematics
    of multidimensional fast Fourier transforms.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 傅立叶分析不仅限于 1 维数据。它广泛用于图像处理中分析二维或多维数据。Gonzalez 和 Woods 的书[[194](bibliography001.xhtml#endnote_194)]以及
    Pratt 的书[[363](bibliography001.xhtml#endnote_363)]讨论了多维傅立叶变换及其在图像处理中的应用，而 Tolimieri、An
    和 Lu 的书[[439](bibliography001.xhtml#endnote_439)]以及 Van Loan 的书[[442](bibliography001.xhtml#endnote_442)]讨论了多维快速傅立叶变换的数学。
- en: Cooley and Tukey [[101](bibliography001.xhtml#endnote_101)] are widely credited
    with devising the FFT in the 1960s. The FFT had in fact been discovered many times
    previously, but its importance was not fully realized before the advent of modern
    digital computers. Although Press, Teukolsky, Vetterling, and Flannery attribute
    the origins of the method to Runge and König in 1924, an article by Heideman,
    Johnson, and Burrus [[211](bibliography001.xhtml#endnote_211)] traces the history
    of the FFT as far back as C. F. Gauss in 1805.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Cooley 和 Tukey [[101](bibliography001.xhtml#endnote_101)] 被广泛认为是在 1960 年代设计
    FFT 的人。实际上，FFT 事实上在此之前被多次发现，但在现代数字计算机出现之前，其重要性并没有被充分认识到。尽管 Press、Teukolsky、Vetterling
    和 Flannery 将该方法的起源归因于 1924 年的 Runge 和 König，但 Heideman、Johnson 和 Burrus 的一篇文章[[211](bibliography001.xhtml#endnote_211)]将
    FFT 的历史追溯到 1805 年的高斯。
- en: Frigo and Johnson [[161](bibliography001.xhtml#endnote_161)] developed a fast
    and flexible implementation of the FFT, called FFTW (“fastest Fourier transform
    in the West”). FFTW is designed for situations requiring multiple DFT computations
    on the same problem size. Before actually computing the DFTs, FFTW executes a
    “planner,” which, by a series of trial runs, determines how best to decompose
    the FFT computation for the given problem size on the host machine. FFTW adapts
    to use the hardware cache efficiently, and once subproblems are small enough,
    FFTW solves them with optimized, straight-line code. Moreover, FFTW has the advantage
    of taking Θ(*n* lg *n*) time for any problem size *n*, even when *n* is a large
    prime.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: Frigo 和 Johnson [[161](bibliography001.xhtml#endnote_161)] 开发了一种快速灵活的 FFT 实现，称为
    FFTW（“西部最快的傅立叶变换”）。 FFTW 专为需要在相同问题规模上进行多次 DFT 计算的情况而设计。在实际计算 DFT 之前，FFTW 执行一个“规划器”，通过一系列试运行确定如何最佳地分解给定问题规模的
    FFT 计算在主机上的执行方式。 FFTW 能够有效地利用硬件缓存，并且一旦子问题足够小，FFTW 就会用优化的直线代码解决它们。此外，FFTW 具有在任何问题规模
    *n* 下都花费 Θ(*n* lg *n*) 时间的优势，即使 *n* 是一个大素数时也是如此。
- en: Although the standard Fourier transform assumes that the input represents points
    that are uniformly spaced in the time domain, other techniques can approximate
    the FFT on “nonequispaced” data. The article by Ware [[449](bibliography001.xhtml#endnote_449)]
    provides an overview.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管标准傅立叶变换假定输入表示在时间域中均匀间隔的点，但其他技术可以在“非等间距”数据上近似 FFT。 Ware 的文章[[449](bibliography001.xhtml#endnote_449)]提供了一个概述。
- en: '[¹](#footnote_ref_1) Interpolation is a notoriously tricky problem from the
    point of view of numerical stability. Although the approaches described here are
    mathematically correct, small differences in the inputs or round-off errors during
    computation can cause large differences in the result.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 插值从数值稳定性的角度来看是一个非常棘手的问题。尽管这里描述的方法在数学上是正确的，但输入的微小差异或计算过程中的舍入误差可能导致结果的巨大差异。
- en: '[²](#footnote_ref_2) Many other authors define *ω[n]* differently: *ω[n]* =
    *e*^(−2*πi*/*n*). This alternative definition tends to be used for signal-processing
    applications. The underlying mathematics is substantially the same with either
    definition of *ω[n]*.'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 许多其他作者对 *ω[n]* 的定义不同：*ω[n]* = *e*^(��2*πi*/*n*)。这种替代定义往往用于信号处理应用。无论使用哪种定义，底层数学都基本相同。
- en: '[³](#footnote_ref_3) The length *n* is actually what [Section 30.1](chapter030.xhtml#Sec_30.1)
    referred to as 2*n*, since the degree-bound of the given polynomials doubles prior
    to evaluation. In the context of polynomial multiplication, therefore, we are
    actually working with complex (2*n*)th roots of unity.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 长度 *n* 实际上是[第 30.1 节](chapter030.xhtml#Sec_30.1)所称的 2*n*，因为在评估之前给定多项式的次数限制加倍。因此，在多项式乘法的上下文中，我们实际上是在处理复杂的（2*n*）次单位根。
- en: '[⁴](#footnote_ref_4) The downside of iteratively updating *ω* is that round-off
    errors can accumulate, especially for larger input sizes. Several techniques to
    limit the magnitude of FFT round-off errors have been proposed, but are beyond
    the scope of this book. If several FFTs are going to be run on inputs of the same
    size, then it might be worthwhile to directly precompute a table of all *n*/2
    values of ![art](images/omega.jpg).'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 更新 *ω* 的迭代方法的缺点是舍入误差可能会积累，特别是对于更大的输入大小。已经提出了几种限制 FFT 舍入误差幅度的技术，但超出了本书的范围。如果将要在相同大小的输入上运行多个
    FFT，则直接预计算所有 *n*/2 个值的表可能是值得的！
