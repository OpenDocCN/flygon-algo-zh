- en: '[**18        B-Trees**](toc.xhtml#chap-18)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[**18        B-树**](toc.xhtml#chap-18)'
- en: B-trees are balanced search trees designed to work well on disk drives or other
    direct-access secondary storage devices. B-trees are similar to red-black trees
    ([Chapter 13](chapter013.xhtml)), but they are better at minimizing the number
    of operations that access disks. (We often say just “disk” instead of “disk drive.”)
    Many database systems use B-trees, or variants of B-trees, to store information.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: B-树是设计用于磁盘驱动器或其他直接访问辅助存储设备的平衡搜索树。B-树类似于红黑树（[第13章](chapter013.xhtml)），但它们更擅长最小化访问磁盘的操作次数。许多数据库系统使用B-树或B-树的变体来存储信息。
- en: B-trees differ from red-black trees in that B-tree nodes may have many children,
    from a few to thousands. That is, the “branching factor” of a B-tree can be quite
    large, although it usually depends on characteristics of the disk drive used.
    B-trees are similar to red-black trees in that every *n*-node B-tree has height
    *O*(lg *n*), so that B-trees can implement many dynamic-set operations in *O*(lg
    *n*) time. But a B-tree has a larger branching factor than a red-black tree, so
    the base of the logarithm that expresses its height is larger, and hence its height
    can be considerably lower.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: B-树与红黑树的不同之处在于B-树节点可以有许多子节点，从几个到数千个不等。也就是说，B-树的“分支因子”可以相当大，尽管通常取决于所使用的磁盘驱动器的特性。B-树与红黑树类似，每个*n*节点的B-树的高度为*O*(lg
    *n*)，因此B-树可以在*O*(lg *n*)时间内实现许多动态集合操作。但是，B-树的分支因子比红黑树大，因此表达其高度的对数的底数更大，因此其高度可以明显较低。
- en: B-trees generalize binary search trees in a natural manner. [Figure 18.1](chapter018.xhtml#Fig_18-1)
    shows a simple B-tree. If an internal B-tree node *x* contains *x*.*n* keys, then
    *x* has *x*.*n* + 1 children. The keys in node *x* serve as dividing points separating
    the range of keys handled by *x* into *x*.*n* + 1 subranges, each handled by one
    child of *x*. A search for a key in a B-tree makes an (*x*.*n* + 1)-way decision
    based on comparisons with the *x*.*n* keys stored at node *x*. An internal node
    contains pointers to its children, but a leaf node does not.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: B-树以自然的方式推广了二叉搜索树。[图18.1](chapter018.xhtml#Fig_18-1)展示了一个简单的B-树。如果内部B-树节点*x*包含*x*.*n*个键，则*x*有*x*.*n*
    + 1个子节点。节点*x*中的键作为分隔点，将*x*处理的键范围分成*x*.*n* + 1个子范围，每个子范围由*x*的一个子节点处理。在B-树中搜索键时，根据与存储在节点*x*中的*x*.*n*个键的比较，做出一个(*x*.*n*
    + 1)路决策。内部节点包含指向其子节点的指针，但叶子节点不包含。
- en: '[Section 18.1](chapter018.xhtml#Sec_18.1) gives a precise definition of B-trees
    and proves that the height of a B-tree grows only logarithmically with the number
    of nodes it contains. [Section 18.2](chapter018.xhtml#Sec_18.2) describes how
    to search for a key and insert a key into a B-tree, and [Section 18.3](chapter018.xhtml#Sec_18.3)
    discusses deletion. Before proceeding, however, we need to ask why we evaluate
    data structures designed to work on a disk drive differently from data structures
    designed to work in main random-access memory.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第18.1节](chapter018.xhtml#Sec_18.1)给出了B-树的精确定义，并证明了B-树的高度仅随其包含的节点数对数增长。[第18.2节](chapter018.xhtml#Sec_18.2)描述了如何搜索键和插入键到B-树中，[第18.3节](chapter018.xhtml#Sec_18.3)讨论了删除。然而，在继续之前，我们需要问为什么我们要将设计用于磁盘驱动器的数据结构与设计用于主随机访问内存中的数据结构进行不同的评估。'
- en: '![art](images/Art_P539.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P539.jpg)'
- en: '**Figure 18.1** A B-tree whose keys are the consonants of English. An internal
    node *x* containing *x*.*n* keys has *x*.*n* + 1 children. All leaves are at the
    same depth in the tree. The blue nodes are examined in a search for the letter
    *R*.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**图18.1** 一个以英语辅音为键的B-树。包含*x*.*n*个键的内部节点*x*有*x*.*n* + 1个子节点。所有叶子节点在树中具有相同的深度。在搜索字母*R*时，蓝色节点被检查。'
- en: '**Data structures on secondary storage**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**辅助存储上的数据结构**'
- en: Computer systems take advantage of various technologies that provide memory
    capacity. The ***main memory*** of a computer system normally consists of silicon
    memory chips. This technology is typically more than an order of magnitude more
    expensive per bit stored than magnetic storage technology, such as tapes or disk
    drives. Most computer systems also have ***secondary storage*** based on solid-state
    drives (SSDs) or magnetic disk drives. The amount of such secondary storage often
    exceeds the amount of primary memory by one to two orders of magnitude. SSDs have
    faster access times than magnetic disk drives, which are mechanical devices. In
    recent years, SSD capacities have increased while their prices have decreased.
    Magnetic disk drives typically have much higher capacities than SSDs, and they
    remain a more cost-effective means for storing massive amounts of information.
    Disk drives that store several terabytes^([1](#footnote_1)) can be found for under
    $100.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机系统利用各种提供内存容量的技术。计算机系统的***主内存***通常由硅内存芯片组成。这种技术通常比磁性存储技术（如磁带或磁盘驱动器）每存储比特的成��高出一个数量级以上。大多数计算机系统还具有基于固态驱动器（SSD）或磁盘驱动器的***辅助存储***。这种辅助存储的数量通常比主内存的数量高出一个数量级或两个数量级。SSD的访问时间比磁盘驱动器快，后者是机械设备。近年来，SSD的容量增加而价格下降。磁盘驱动器通常比SSD具有更高的容量，并且它们仍然是存储大量信息的更具成本效益的手段。存储数TB的磁盘驱动器可以在100美元以下找到。
- en: '[Figure 18.2](chapter018.xhtml#Fig_18-2) shows a typical disk drive. The drive
    consists of one or more ***platters***, which rotate at a constant speed around
    a common ***spindle***. A magnetizable material covers the surface of each platter.
    The drive reads and writes each platter by a ***head*** at the end of an ***arm***.
    The arms can move their heads toward or away from the spindle. The surface that
    passes underneath a given head when it is stationary is called a ***track***.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18.2](chapter018.xhtml#Fig_18-2)显示了一个典型的磁盘驱动器。驱动器由一个或多个***盘片***组成，它们围绕一个共同的***主轴***以恒定速度旋转。每个盘片的表面覆盖着一种可磁化材料。驱动器通过位于***臂***末端的***磁头***读取和写入每个盘片。臂可以将它们的磁头向主轴靠近或远离。当给定磁头静止时经过其下方的表面称为***磁道***。'
- en: 'Although disk drives are cheaper and have higher capacity than main memory,
    they are much, much slower because they have moving mechanical parts. The mechanical
    motion has two components: platter rotation and arm movement. As of this writing,
    commodity disk drives rotate at speeds of 5400–15,000 revolutions per minute (RPM).
    Typical speeds are 15,000 RPM in server-grade drives, 7200 RPM in drives for desktops,
    and 5400 RPM in drives for laptops. Although 7200 RPM may seem fast, one rotation
    takes 8.33 milliseconds, which is over 5 orders of magnitude longer than the 50
    nanosecond access times (more or less) commonly found for main memory. In other
    words, if a computer waits a full rotation for a particular item to come under
    the read/write head, it could access main memory more than 100,000 times during
    that span. The average wait is only half a rotation, but still, the difference
    in access times for main memory compared with disk drives is enormous. Moving
    the arms also takes some time. As of this writing, average access times for commodity
    disk drives are around 4 milliseconds.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管磁盘驱动器比主存储器便宜且容量更大，但它们要慢得多，因为它们有移动的机械部件。机械运动有两个组成部分：盘片旋转和臂运动。截至目前，商品磁盘驱动器的旋转速度为5400-15,000转每分钟（RPM）。服务器级驱动器的典型速度为15,000
    RPM，台式机驱动器的速度为7200 RPM，笔记本电脑驱动器的速度为5400 RPM。尽管7200 RPM可能看起来很快，但一次旋转需要8.33毫秒，这比主存储器通常的50纳秒访问时间（多或少）长了5个数量级以上。换句话说，如果计算机等待一个完整的旋转来使特定项目位于读/写头下，它在这段时间内可以访问主存储器超过100,000次。平均等待时间只有半个旋转，但是，与磁盘驱动器相比，主存储器的访问时间差异巨大。移动臂也需要一些时间。截至目前，商品磁盘驱动器的平均访问时间约为4毫秒。
- en: '![art](images/Art_P540.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P540.jpg)'
- en: '**Figure 18.2** A typical magnetic disk drive. It consists of one or more platters
    covered with a magnetizable material (two platters are shown here) that rotate
    around a spindle. Each platter is read and written with a head, shown in red,
    at the end of an arm. Arms rotate around a common pivot axis. A track, drawn in
    blue, is the surface that passes beneath the read/write head when the head is
    stationary.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**图18.2** 典型的磁盘驱动器。它由一个或多个覆盖有可磁化��料的盘片组成（这里显示了两个盘片），这些盘片围绕一个主轴旋转。每个盘片都有一个在臂末端的头（红色显示）。臂围绕一个共同的枢轴轴旋转。蓝色绘制的磁道是当读/写头静止时通过的表面。'
- en: In order to amortize the time spent waiting for mechanical movements, also known
    as ***latency***, disk drives access not just one item but several at a time.
    Information is divided into a number of equal-sized ***blocks*** of bits that
    appear consecutively within tracks, and each disk read or write is of one or more
    entire blocks.^([2](#footnote_2)) Typical disk drives have block sizes running
    from 512 to 4096 bytes. Once the read/write head is positioned correctly and the
    platter has rotated to the beginning of the desired block, reading or writing
    a magnetic disk drive is entirely electronic (aside from the rotation of the platter),
    and the disk drive can quickly read or write large amounts of data.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 为了分摊等待机械运动（也称为***延迟***）所花费的时间，磁盘驱动器不仅访问一个项目，而是同时访问多个项目。信息被分成一些等大小的***块***位，这些块连续出现在磁道内，并且每次磁盘读取或写入都是一个或多个完整的块。典型磁盘驱动器的块大小从512到4096字节不等。一旦读/写头正确定位并且盘片已旋转到所需块的开头，读取或写入磁盘驱动器完全是电子的（除了盘片的旋转），磁盘驱动器可以快速读取或写入大量数据。
- en: 'Often, accessing a block of information and reading it from a disk drive takes
    longer than processing all the information read. For this reason, in this chapter
    we’ll look separately at the two principal components of the running time:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，访问一块信息并从磁盘驱动器中读取它所需的时间比处理所有读取的信息所需的时间更长。因此，在本章中，我们将分别看一下运行时间的两个主要组成部分：
- en: the number of disk accesses, and
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 磁盘访问次数，以及
- en: the CPU (computing) time.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CPU（计算）时间。
- en: We measure the number of disk accesses in terms of the number of blocks of information
    that need to be read from or written to the disk drive. Although disk-access time
    is not constant—it depends on the distance between the current track and the desired
    track and also on the initial rotational position of the platters—the number of
    blocks read or written provides a good first-order approximation of the total
    time spent accessing the disk drive.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们以需要从磁盘驱动器中读取或写入的信息块的数量来衡量磁盘访问次数。尽管磁盘访问时间不是恒定的——它取决于当前磁道和所需磁道之间的距离，也取决于盘片的初始旋转位置——但读取或写入的块数提供了对访问磁盘驱动器所需的总时间的一个很好的一阶近似。
- en: In a typical B-tree application, the amount of data handled is so large that
    all the data do not fit into main memory at once. The B-tree algorithms copy selected
    blocks from disk into main memory as needed and write back onto disk the blocks
    that have changed. B-tree algorithms keep only a constant number of blocks in
    main memory at any time, and thus the size of main memory does not limit the size
    of B-trees that can be handled.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的B树应用中，处理的数据量非常大，所有数据一次无法全部放入主存储器中。B树算法根据需要将选定的块从磁盘复制到主存储器，并将已更改的块写回磁盘。B树算法在任何时候只在主存储器中保留恒定数量的块，因此主存储器的大小不限制可以处理的B树的大小。
- en: 'B-tree procedures need to be able to read information from disk into main memory
    and write information from main memory to disk. Consider some object *x*. If *x*
    is currently in the computer’s main memory, then the code can refer to the attributes
    of *x* as usual: *x*.*key*, for example. If *x* resides on disk, however, then
    the procedure must perform the operation DISK-READ(*x*) to read the block containing
    object *x* into main memory before it can refer to *x*’s attributes. (Assume that
    if *x* is already in main memory, then DISK-READ(*x*) requires no disk accesses:
    it is a “no-op.”) Similarly, procedures call DISK-WRITE(*x*) to save any changes
    that have been made to the attributes of object *x* by writing to disk the block
    containing *x*. Thus, the typical pattern for working with an object is as follows:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: B树的过程需要能够将信息从磁盘读入主存储器，并将信息从主存储器写入磁盘。考虑某个对象 *x*。如果 *x* 当前在计算机的主存储器中，那么代码可以像往常一样引用
    *x* 的属性：例如 *x*.*key*。然而，如果 *x* 存储在磁盘上，那么该过程必须执行操作 DISK-READ(*x*)，将包含对象 *x* 的块读入主存储器，然后才能引用
    *x* 的属性。（假设如果 *x* 已经在主存储器中，则 DISK-READ(*x*) 不需要磁盘访问：它是一个“无操作”）。类似地，过程调用 DISK-WRITE(*x*)
    来保存对对象 *x* 的属性所做的任何更改，通过将包含 *x* 的块写入磁盘。因此，处理对象的典型模式如下：
- en: '| *x* = a pointer to some object |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| *x* = 指向某个对象的指针 |'
- en: '| DISK-READ(*x*) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| DISK-READ(*x*) |'
- en: '| operations that access and/or modify the attributes of *x* |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 访问和/或修改 *x* 的属性的操作 |'
- en: '| DISK-WRITE(*x*) | **//** omitted if no attributes of *x* were changed |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| DISK-WRITE(*x*) | **//** 如果 *x* 的属性没有更改，则省略 |'
- en: '| other operations that access but do not modify attributes of *x* |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 其他访问但不修改 *x* 的属性的操作 |'
- en: The system can keep only a limited number of blocks in main memory at any one
    time. Our B-tree algorithms assume that the system automatically flushes from
    main memory blocks that are no longer in use.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 系统一次只能在主存储器中保留有限数量的块。我们的B树算法假定系统会自动从主存储器中刷新不再使用的块。
- en: Since in most systems the running time of a B-tree algorithm depends primarily
    on the number of DISK-READ and DISK-WRITE operations it performs, we typically
    want each of these operations to read or write as much information as possible.
    Thus, a B-tree node is usually as large as a whole disk block, and this size limits
    the number of children a B-tree node can have.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在大多数系统中，B树算法的运行时间主要取决于其执行的 DISK-READ 和 DISK-WRITE 操作的次数，我们通常希望每个操作读取或写入尽可能多的信息。因此，B树节点通常与整个磁盘块一样大，这个大小限制了B树节点可以拥有的子节点数量。
- en: '![art](images/Art_P541.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P541.jpg)'
- en: '**Figure 18.3** A B-tree of height 2 containing over one billion keys. Shown
    inside each node *x* is *x*.*n*, the number of keys in *x*. Each internal node
    and leaf contains 1000 keys. This B-tree has 1001 nodes at depth 1 and over one
    million leaves at depth 2.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**图18.3** 高度为2的B树，包含超过十亿个关键字。每个节点 *x* 中显示 *x*.*n*，即 *x* 中的关键字数量。每个内部节点和叶子节点包含1000个关键字。这棵B树在深度1有1001个节点，在深度2有超过一百万个叶子节点。'
- en: Large B-trees stored on disk drives often have branching factors between 50
    and 2000, depending on the size of a key relative to the size of a block. A large
    branching factor dramatically reduces both the height of the tree and the number
    of disk accesses required to find any key. [Figure 18.3](chapter018.xhtml#Fig_18-3)
    shows a B-tree with a branching factor of 1001 and height 2 that can store over
    one billion keys. Nevertheless, if the root node is kept permanently in main memory,
    at most two disk accesses suffice to find any key in this tree.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 存储在磁盘驱动器上的大型B树通常具有50到2000之间的分支因子，这取决于关键字的大小相对于块的大小。较大的分支因子显著减少了树的高度和查找任何关键字所需的磁盘访问次数。[图18.3](chapter018.xhtml#Fig_18-3)
    展示了一个分支因子为1001，高度为2的B树，可以存储超过十亿个关键字。然而，如果根节点永久保留在主存储器中，最多只需要两次磁盘访问就可以在这棵树中找到任何关键字。
- en: '[**18.1    Definition of B-trees**](toc.xhtml#Rh1-106)'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '[**18.1    B树的定义**](toc.xhtml#Rh1-106)'
- en: To keep things simple, let’s assume, as we have for binary search trees and
    red-black trees, that any satellite information associated with a key resides
    in the same node as the key. In practice, you might actually store with each key
    just a pointer to another disk block containing the satellite information for
    that key. The pseudocode in this chapter implicitly assumes that the satellite
    information associated with a key, or the pointer to such satellite information,
    travels with the key whenever the key is moved from node to node. A common variant
    on a B-tree, known as a ***B*^+-*tree***, stores all the satellite information
    in the leaves and stores only keys and child pointers in the internal nodes, thus
    maximizing the branching factor of the internal nodes.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，让我们假设，就像对于二叉搜索树和红黑树一样，与关键字关联的任何卫星信息都存储在与关键字相同的节点中。实际上，您可能实际上只存储与每个关键字关联的另一个磁盘块的指针。本章中的伪代码默认假设与关键字关联的卫星信息，或指向这种卫星信息的指针，随着关键字从一个节点移动到另一个节点而一起移动。B树的一种常见变体，称为***B*^+-*tree***，将所有卫星信息存储在叶子节点中，只在内部节点中存储关键字和子指针，从而最大化内部节点的分支因子。
- en: 'A ***B-tree*** *T* is a rooted tree with root *T*.*root* having the following
    properties:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 一个***B树*** *T* 是一棵根为 *T*.*root* 的树，具有以下属性：
- en: 'Every node *x* has the following attributes:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个节点 *x* 具有以下属性：
- en: a. *x*.*n*, the number of keys currently stored in node *x*,
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. *x*.*n*，当前存储在节点 *x* 中的关键字数量，
- en: b. the *x*.*n* keys themselves, *x*.*key*[1], *x*.*key*[2], … , *x*.*key*[*x*.*n*],
    stored in monotonically increasing order, so that *x*.*key*[1] ≤ *x*.*key*[2]
    ≤ ⋯ ≤ *x*.*key*[*x*.*n*],
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 关键字本身，*x*.*key*[1]、*x*.*key*[2]、…、*x*.*key*[*x*.*n*]，按单调递增的顺序存储，使得 *x*.*key*[1]
    ≤ *x*.*key*[2] ≤ ⋯ ≤ *x*.*key*[*x*.*n*]，
- en: c. *x*.*leaf*, a boolean value that is TRUE if *x* is a leaf and FALSE if *x*
    is an internal node.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. *x*.*leaf*，一个布尔值，如果 *x* 是叶子节点则为TRUE，如果 *x* 是内部节点则为FALSE。
- en: Each internal node *x* also contains *x*.*n* + 1 pointers *x*.*c*[1], *x*.*c*[2],
    … , *x*.*c*[*x*.*n*+1] to its children. Leaf nodes have no children, and so their
    *c[i]* attributes are undefined.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 每个内部节点 *x* 还包含 *x*.*n* + 1 个指向其子节点的指针 *x*.*c*[1]、*x*.*c*[2]、…、*x*.*c*[*x*.*n*+1]。叶子节点没有子节点，因此它们的
    *c[i]* 属性未定义。
- en: 'The keys *x*.*key[i]* separate the ranges of keys stored in each subtree: if
    *k[i]* is any key stored in the subtree with root *x*.*c[i]*, then'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 键 *x*.*key[i]* 分隔存储在每个子树中的键范围：如果 *k[i]* 是存储在以 *x*.*c[i]* 为根的子树中的任何键，则
- en: '*k*[1] ≤ *x*.*key*[1] ≤ *k*[2] ≤ *x*.*key*[2] ≤ ⋯ ≤ *x*.*key*[*x*.*n*] ≤ *k*[*x*.*n*+1].'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '*k*[1] ≤ *x*.*key*[1] ≤ *k*[2] ≤ *x*.*key*[2] ≤ ⋯ ≤ *x*.*key*[*x*.*n*] ≤ *k*[*x*.*n*+1]。'
- en: All leaves have the same depth, which is the tree’s height *h*.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有叶子节点的深度相同，即树的高度 *h*。
- en: 'Nodes have lower and upper bounds on the number of keys they can contain, expressed
    in terms of a fixed integer *t* ≥ 2 called the ***minimum degree*** of the B-tree:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 节点对于它们可以包含的键的数量有下限和上限，以一个称为 B 树的***最小度数***的固定整数 *t* ≥ 2 来表示：
- en: a. Every node other than the root must have at least *t* − 1 keys. Every internal
    node other than the root thus has at least *t* children. If the tree is nonempty,
    the root must have at least one key.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 除根节点外的每个节点必须至少有 *t* − 1 个键。因此，除根节点外的每个内部节点至少有 *t* 个子节点。如果树非空，则根必须至少有一个键。
- en: b. Every node may contain at most 2*t* − 1 keys. Therefore, an internal node
    may have at most 2*t* children. We say that a node is ***full*** if it contains
    exactly 2*t* − 1 keys.^([3](#footnote_3))
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 每个节点最多可以包含 2*t* − 1 个键。因此，内部节点最多可以有 2*t* 个子节点。如果一个节点包含恰好 2*t* − 1 个键，则称其为***满节点***。^([3](#footnote_3))
- en: The simplest B-tree occurs when *t* = 2\. Every internal node then has either
    2, 3, or 4 children, and it is a ***2-3-4 tree***. In practice, however, much
    larger values of *t* yield B-trees with smaller height.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *t* = 2 时，最简单的 B 树出现。每个内部节点都有 2、3 或 4 个子节点，这是一个***2-3-4 树***。然而，在实践中，更大的 *t*
    值会产生高度较小的 B 树。
- en: '**The height of a B-tree**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**B 树的高度**'
- en: The number of disk accesses required for most operations on a B-tree is proportional
    to the height of the B-tree. The following theorem bounds the worst-case height
    of a B-tree.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 B 树上的操作所需的磁盘访问次数与 B 树的高度成正比。以下定理限制了 B 树的最坏情况高度。
- en: '![art](images/Art_P542.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P542.jpg)'
- en: '**Figure 18.4** A B-tree of height 3 containing a minimum possible number of
    keys. Shown inside each node *x* is *x*.*n*.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 18.4** 高度为 3 的 B 树，包含最少数量的键。每个节点 *x* 中显示了 *x*.*n*。'
- en: '***Theorem 18.1***'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 18.1***'
- en: If *n* ≥ 1, then for any *n*-key B-tree *T* of height *h* and minimum degree
    *t* ≥ 2,
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *n* ≥ 1，则对于高度为 *h* 且最小度数为 *t* ≥ 2 的任何 *n* 个键的 B 树 *T*，
- en: '![art](images/Art_P543.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P543.jpg)'
- en: '***Proof***   By definition, the root of a nonempty B-tree *T* contains at
    least one key, and all other nodes contain at least *t* − 1 keys. Let *h* be the
    height of *T*. Then *T* contains at least 2 nodes at depth 1, at least 2*t* nodes
    at depth 2, at least 2*t*[2] nodes at depth 3, and so on, until at depth *h*,
    it has at least 2*t*^(*h*−1) nodes. [Figure 18.4](chapter018.xhtml#Fig_18-4) illustrates
    such a tree for *h* = 3\. The number *n* of keys therefore satisfies the inequality'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***  根据定义，非空 B 树 *T* 的根至少包含一个键，所有其他节点至少包含 *t* − 1 个键。设 *h* 为 *T* 的高度。那么
    *T* 至少包含 2 个深度为 1 的节点，至少包含 2*t* 个深度为 2 的节点，至少包含 2*t*[2] 个深度为 3 的节点，依此类推，直到深度 *h*，它至少有
    2*t*^(*h*−1) 个节点。[图 18.4](chapter018.xhtml#Fig_18-4) 说明了 *h* = 3 时这样的树。因此，键的数量
    *n* 满足不等式'
- en: '![art](images/Art_P544.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P544.jpg)'
- en: so that *t^h* ≤ (*n* + 1)/2\. Taking base-*t* logarithms of both sides proves
    the theorem.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使得 *t^h* ≤ (*n* + 1)/2。对两边取以 *t* 为底的对数证明了定理。
- en: ▪
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: You can see the power of B-trees as compared with red-black trees. Although
    the height of the tree grows as *O*(log *n*) in both cases (recall that *t* is
    a constant), for B-trees the base of the logarithm can be many times larger. Thus,
    B-trees save a factor of about lg *t* over red-black trees in the number of nodes
    examined for most tree operations. Because examining an arbitrary node in a tree
    usually entails accessing the disk, B-trees avoid a substantial number of disk
    accesses.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到 B 树与红黑树相比的强大之处。尽管在两种情况下树的高度都以 *O*(log *n*) 增长（回想一下 *t* 是一个常数），但对于 B 树，对数的底数可以是许多倍。因此，B
    树在大多数树操作中比红黑树节省了约 lg *t* 的因子。因为检查树中的任意节点通常需要访问磁盘，所以 B 树避免了大量的磁盘访问。
- en: '**Exercises**'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***18.1-1***'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '***18.1-1***'
- en: Why isn’t a minimum degree of *t* = 1 allowed?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么不允许最小度数为 *t* = 1？
- en: '***18.1-2***'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '***18.1-2***'
- en: For what values of *t* is the tree of [Figure 18.1](chapter018.xhtml#Fig_18-1)
    a legal B-tree?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 [图 18.1](chapter018.xhtml#Fig_18-1) 中的树，*t* 的哪些值是合法的 B 树？
- en: '***18.1-3***'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '***18.1-3***'
- en: Show all legal B-trees of minimum degree 2 that store the keys 1, 2, 3, 4, 5.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 显示存储键 1、2、3、4、5 的最小度数为 2 的所有合法 B 树。
- en: '***18.1-4***'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '***18.1-4***'
- en: As a function of the minimum degree *t*, what is the maximum number of keys
    that can be stored in a B-tree of height *h*?
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 作为最小度数 *t* 的函数，高度为 *h* 的 B 树中可以存储的键的最大数量是多少？
- en: '***18.1-5***'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '***18.1-5***'
- en: Describe the data structure that results if each black node in a red-black tree
    absorbs its red children, incorporating their children with its own.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 描述红黑树中每个黑色节点吸收其红色子节点并将其子节点合并到自己的数据结构中的结果。
- en: '[**18.2    Basic operations on B-trees**](toc.xhtml#Rh1-107)'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '[**18.2    B 树的基本操作**](toc.xhtml#Rh1-107)'
- en: 'This section presents the details of the operations B-TREE-SEARCH, B-TREE-CREATE,
    and B-TREE-INSERT. These procedures observe two conventions:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了操作 B-TREE-SEARCH、B-TREE-CREATE 和 B-TREE-INSERT 的详细信息。这些过程遵守两个约定：
- en: The root of the B-tree is always in main memory, so that no procedure ever needs
    to perform a DISK-READ on the root. If any changes to the root node occur, however,
    then DISK-WRITE must be called on the root.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: B 树的根始终在主存储器中，因此任何过程都不需要对根执行 DISK-READ。但是，如果对根节点进行任何更改，则必须在根上调用 DISK-WRITE。
- en: Any nodes that are passed as parameters must already have had a DISK-READ operation
    performed on them.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 作为参数传递的任何节点必须已经执行了 DISK-READ 操作。
- en: The procedures are all “one-pass” algorithms that proceed downward from the
    root of the tree, without having to back up.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过程都是“一遍过”的算法，从树的根向下进行，无需后退。
- en: '**Searching a B-tree**'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '**搜索 B 树**'
- en: Searching a B-tree is much like searching a binary search tree, except that
    instead of making a binary, or “two-way,” branching decision at each node, the
    search makes a multiway branching decision according to the number of the node’s
    children. More precisely, at each internal node *x*, the search makes an (*x*.*n*
    + 1)-way branching decision.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索B树很像搜索二叉搜索树，只是在每个节点不是做二进制或“两路”分支决策，而是根据节点的子节点数量做多路分支决策。更准确地说，在每个内部节点*x*处，搜索会做一个(*x*.*n*
    + 1)路分支决策。
- en: The procedure B-TREE-SEARCH generalizes the TREE-SEARCH procedure defined for
    binary search trees on page 316\. It takes as input a pointer to the root node
    *x* of a subtree and a key *k* to be searched for in that subtree. The top-level
    call is thus of the form B-TREE-SEARCH(*T*.*root*, *k*). If *k* is in the B-tree,
    then B-TREE-SEARCH returns the ordered pair (*y*, *i*) consisting of a node *y*
    and an index *i* such that *y*.*key[i]* = *k*. Otherwise, the procedure returns
    NIL.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: B-树-搜索过程将二叉搜索树在第316页定义的TREE-SEARCH过程推广到了B树。它以一个指向子树的根节点*x*和要在该子树中搜索的关键字*k*作为输入。因此，顶层调用的形式为B-树-搜索(*T*.*root*,
    *k*)。如果*k*在B树中，则B-树-搜索返回有序对(*y*, *i*)，其中*y*和索引*i*满足*y*.*key[i]* = *k*。否则，该过程返回NIL。
- en: B-TREE-SEARCH(*x*, *k*)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: B-树-搜索(*x*, *k*)
- en: '| 1 | *i* = 1 |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *i* = 1 |'
- en: '| 2 | **while** *i* ≤ *x*.*n* and *k > x*.*key[i]* |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **当** *i* ≤ *x*.*n* 且 *k > x*.*key[i]* 时 |'
- en: '| 3 | *i* = *i* + 1 |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *i* = *i* + 1 |'
- en: '| 4 | **if** *i* ≤ *x*.*n* and *k* == *x*.*key[i]* |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **如果** *i* ≤ *x*.*n* 且 *k* == *x*.*key[i]* 时 |'
- en: '| 5 | **return** (*x*, *i*) |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **返回** (*x*, *i*) |'
- en: '| 6 | **elseif** *x*.*leaf* |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| 6 | **否则** *x*.*leaf* |'
- en: '| 7 | **return**NIL |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| 7 | **返回**NIL |'
- en: '| 8 | **else** DISK-READ(*x*.*c[i]*) |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| 8 | **否则** DISK-READ(*x*.*c[i]*) |'
- en: '| 9 | **return** B-TREE-SEARCH(*x*.*c[i]*, *k*) |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| 9 | **返回** B-树-搜索(*x*.*c[i]*, *k*) |'
- en: Using a linear-search procedure, lines 1–3 of B-TREE-SEARCH find the smallest
    index *i* such that *k* ≤ *x*.*key[i]*, or else they set *i* to *x*.*n* + 1\.
    Lines 4–5 check to see whether the search has discovered the key, returning if
    it has. Otherwise, if *x* is a leaf, then line 7 terminates the search unsuccessfully,
    and if *x* is an internal node, lines 8–9 recurse to search the appropriate subtree
    of *x*, after performing the necessary DISK-READ on that child. [Figure 18.1](chapter018.xhtml#Fig_18-1)
    illustrates the operation of B-TREE-SEARCH. The blue nodes are those examined
    during a search for the key *R*.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 使用线性搜索过程，B-树-搜索的1-3行找到最小的索引*i*，使得*k* ≤ *x*.*key[i]*，否则将*i*设置为*x*.*n* + 1。4-5行检查搜索是否发现了关键字，如果发现则返回。否则，如果*x*是叶子，则第7行以失败结束搜索，如���*x*是内部节点，则8-9行递归搜索*x*的适当子树，在对该子节点进行必要的DISK-READ后。[图18.1](chapter018.xhtml#Fig_18-1)说明了B-树-搜索的操作。蓝色节点是在搜索关键字*R*时检查的节点。
- en: As in the TREE-SEARCH procedure for binary search trees, the nodes encountered
    during the recursion form a simple path downward from the root of the tree. The
    B-TREE-SEARCH procedure therefore accesses *O*(*h*) = *O*(log*[t] n*) disk blocks,
    where *h* is the height of the B-tree and *n* is the number of keys in the B-tree.
    Since *x*.*n* < 2*t*, the **while** loop of lines 2–3 takes *O*(*t*) time within
    each node, and the total CPU time is *O*(*th*) = *O*(*t* log*[t]n*).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 与二叉搜索树的TREE-SEARCH过程一样，递归期间遇到的节点形成了从树根向下的简单路径。因此，B-树-搜索过程访问*O*(*h*) = *O*(log*[t]
    n*)磁盘块，其中*h*是B树的高度，*n*是B树中的关键字数。由于*x*.*n* < 2*t*，因此2-3行的**while**循环在每个节点内部需要*O*(*t*)时间，总CPU时间为*O*(*th*)
    = *O*(*t* log*[t]n*)。
- en: '**Creating an empty B-tree**'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '**创建空B树**'
- en: To build a B-tree *T*, first use the B-TREE-CREATE procedure on the next page
    to create an empty root node and then call the B-TREE-INSERT procedure on page
    508 to add new keys. Both of these procedures use an auxiliary procedure ALLOCATE-NODE,
    whose pseudocode we omit and which allocates one disk block to be used as a new
    node in *O*(1) time. A node created by ALLOCATE-NODE requires no DISK-READ, since
    there is as yet no useful information stored on the disk for that node. B-TREE-CREATE
    requires *O*(1) disk operations and *O*(1) CPU time.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建B树*T*，首先使用下一页上的B-树-创建过程创建一个空根节点，然后调用第508页上的B-树-插入过程添加新关键字。这两个过程都使用一个辅助过程分配-节点，我们省略其伪代码，它在*O*(1)时间内分配一个磁盘块用作新节点。由分配-节点创建的节点不需要DISK-READ，因为磁盘上尚未存储有关该节点的有用信息。B-树-创建需要*O*(1)磁盘操作和*O*(1)
    CPU时间。
- en: B-TREE-CREATE(*T*)
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 创建B-树(*T*)
- en: '| 1 | *x* = ALLOCATE-NODE() |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *x* = 分配-节点() |'
- en: '| 2 | *x*.*leaf* = TRUE |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *x*.*leaf* = TRUE |'
- en: '| 3 | *x*.*n* = 0 |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *x*.*n* = 0 |'
- en: '| 4 | DISK-WRITE(*x*) |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 4 | DISK-WRITE(*x*) |'
- en: '| 5 | *T*.*root* = *x* |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 5 | *T*.*root* = *x* |'
- en: '**Inserting a key into a B-tree**'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '**将关键字插入B树**'
- en: Inserting a key into a B-tree is significantly more complicated than inserting
    a key into a binary search tree. As with binary search trees, you search for the
    leaf position at which to insert the new key. With a B-tree, however, you cannot
    simply create a new leaf node and insert it, as the resulting tree would fail
    to be a valid B-tree. Instead, you insert the new key into an existing leaf node.
    Since you cannot insert a key into a leaf node that is full, you need an operation
    that ***splits*** a full node *y* (having 2*t* − 1 keys) around its ***median
    key*** *y*.*key[t]* into two nodes having only *t* − 1 keys each. The median key
    moves up into *y*’s parent to identify the dividing point between the two new
    trees. But if *y*’s parent is also full, you must split it before you can insert
    the new key, and thus you could end up splitting full nodes all the way up the
    tree.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 将关键字插入B树比将关键字插入二叉搜索树要复杂得多。与二叉搜索树一样，您需要搜索要插入新关键字的叶子位置。然而，在B树中，您不能简单地创建一个新的叶子节点并插入，因为结果树将无法成为有效的B树。相反，您将新关键字插入到现有的叶子节点中。由于您不能将关键字插入到已满的叶子节点中，您需要一个操作来将一个拥有2*t*
    − 1个关键字的满节点*y*（在其***中位关键字*** *y*.*key[t]*周围）分割成每个仅具有*t* − 1个关键字的两个节点。中位关键字上移至*y*的父节点，以标识两个新树之间的分隔点。但如果*y*的父节点也已满，则您必须在插入新关键字之前对其进行拆分，因此您可能会一直将满节点拆分到整个树的顶部。
- en: To avoid having to go back up the tree, just split every full node you encounter
    as you go down the tree. In this way, whenever you need to split a full node,
    you are assured that its parent is not full. Inserting a key into a B-tree then
    requires only a single pass down the tree from the root to a leaf.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免需要返回树的上层，只需在下行树时分裂遇到的每个满节点。通过这种方式，每当需要分裂一个满节点时，可以确保其父节点不是满的。将键插入B树只需要从根到叶子的单次遍历。
- en: '***Splitting a node in a B-tree***'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '***在B树中分裂节点***'
- en: 'The procedure B-TREE-SPLIT-CHILD on the facing page takes as input a *nonfull*
    internal node *x* (assumed to reside in main memory) and an index *i* such that
    *x*.*c[i]* (also assumed to reside in main memory) is a *full* child of *x*. The
    procedure splits this child in two and adjusts *x* so that it has an additional
    child. To split a full root, you first need to make the root a child of a new
    empty root node, so that you can use B-TREE-SPLIT-CHILD. The tree thus grows in
    height by 1: splitting is the only means by which the tree grows taller.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: B-TREE-SPLIT-CHILD程序在下一页上以一个*非满*内部节点*x*（假定驻留在主存储器中）和一个索引*i*作为输入，其中*x*.*c[i]*（也假定驻留在主存储器中）是*x*的一个*满*子节点。该程序将这个子节点分成两部分，并调整*x*，使其具有一个额外的子节点。要分裂一个满根节点，首先需要将根节点作为一个新的空根节点的子节点，以便可以使用B-TREE-SPLIT-CHILD。因此，树的高度增加了1：分裂是树增高的唯一手段。
- en: B-TREE-SPLIT-CHILD(*x*, *i*)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: B-TREE-SPLIT-CHILD(*x*, *i*)
- en: '|   1 | *y* = *x*.*c[i]* | **//** full node to split |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '|   1 | *y* = *x*.*c[i]* | **//** 需要分裂的满节点 |'
- en: '|   2 | *z* = ALLOCATE-NODE() | **//** *z* will take half of *y* |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '|   2 | *z* = ALLOCATE-NODE() | **//** *z*将获得*y*的一半 |'
- en: '|   3 | *z*.*leaf* = *y*.*leaf* |  |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '|   3 | *z*.*leaf* = *y*.*leaf* |  |'
- en: '|   4 | *z*.*n* = *t* − 1 |  |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|   4 | *z*.*n* = *t* − 1 |  |'
- en: '|   5 | **for** *j* = 1 **to** *t* − 1 | **//** *z* gets *y*’s greatest keys
    … |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|   5 | **for** *j* = 1 **to** *t* − 1 | **//** *z*获得*y*的最大键 … |'
- en: '|   6 | *z*.*key[j]* = *y*.*key*[*j*+*t*] |  |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '|   6 | *z*.*key[j]* = *y*.*key*[*j*+*t*] |  |'
- en: '|   7 | **if** not *y*.*leaf* |  |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '|   7 | **if** not *y*.*leaf* |  |'
- en: '|   8 | **for** *j* = 1 **to** *t* | **//** … and its corresponding children
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '|   8 | **for** *j* = 1 **to** *t* | **//** … 及其相应的子节点 |'
- en: '|   9 | *z*.*c[j]* = *y*.*c*[*j*+*t*] |  |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '|   9 | *z*.*c[j]* = *y*.*c*[*j*+*t*] |  |'
- en: '| 10 | *y*.*n* = *t* − 1 | **//** *y* keeps *t* − 1 keys |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| 10 | *y*.*n* = *t* − 1 | **//** *y*保留*t* − 1个键 |'
- en: '| 11 | **for** *j* = *x*.*n* + 1 **downto** *i* + 1 | **//** shift *x*’s children
    to the right … |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| 11 | **for** *j* = *x*.*n* + 1 **downto** *i* + 1 | **//** 移动*x*的子节点到右侧 …
    |'
- en: '| 12 | *x*.*c*[*j*+1] = *x*.*c[j]* |  |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| 12 | *x*.*c*[*j*+1] = *x*.*c[j]* |  |'
- en: '| 13 | *x*.*c*[*i*+1] = *z* | **//** … to make room for *z* as a child |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| 13 | *x*.*c*[*i*+1] = *z* | **//** … 为*z*腾出空间作为子节点 |'
- en: '| 14 | **for** *j* = *x*.*n***downto** *i* | **//** shift the corresponding
    keys in *x* |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| 14 | **for** *j* = *x*.*n***downto** *i* | **//** 移动*x*中相应的键 |'
- en: '| 15 | *x*.*key*[*j*+1] = *x*.*key[j]* |  |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| 15 | *x*.*key*[*j*+1] = *x*.*key[j]* |  |'
- en: '| 16 | *x*.*key[i]* = *y*.*key[t]* | **//** insert *y*’s median key |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| 16 | *x*.*key[i]* = *y*.*key[t]* | **//** 插入*y*的中位键 |'
- en: '| 17 | *x*.*n* = *x*.*n* + 1 | **//** *x* has gained a child |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| 17 | *x*.*n* = *x*.*n* + 1 | **//** *x*增加了一个子节点 |'
- en: '| 18 | DISK-WRITE(*y*) |  |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| 18 | DISK-WRITE(*y*) |  |'
- en: '| 19 | DISK-WRITE(*z*) |  |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| 19 | DISK-WRITE(*z*) |  |'
- en: '| 20 | DISK-WRITE(*x*) |  |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| 20 | DISK-WRITE(*x*) |  |'
- en: '[Figure 18.5](chapter018.xhtml#Fig_18-5) illustrates how a node splits. B-TREE-SPLIT-CHILD
    splits the full node *y* = *x*.*c[i]* about its median key (*S* in the figure),
    which moves up into *y*’s parent node *x*. Those keys in *y* that are greater
    than the median key move into a new node *z*, which becomes a new child of *x*.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '[图18.5](chapter018.xhtml#Fig_18-5)展示了一个节点如何分裂。B-TREE-SPLIT-CHILD将满节点*y* = *x*.*c[i]*围绕其中位键（图中的*S*）分裂，该键上移至*y*的父节点*x*。*y*中大于中位键的键移至一个新节点*z*，成为*x*的新子节点。'
- en: B-TREE-SPLIT-CHILD works by straightforward cutting and pasting. Node *x* is
    the parent of the node *y* being split, which is *x*’s *i*th child (set in line
    1). Node *y* originally has 2*t* children and 2*t* − 1 keys, but splitting reduces
    *y* to *t* children and *t* − 1 keys. The *t* largest children and *t* − 1 keys
    of node *y* move over to node *z*, which becomes a new child of *x*, positioned
    just after *y* in *x*’s table of children. The median key of *y* moves up to become
    the key in node *x* that separates the pointers to nodes *y* and *z*.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: B-TREE-SPLIT-CHILD通过简单的剪切和粘贴工作。节点*x*是正在分裂的节点*y*的父节点，该节点是*x*的第*i*个子节点（在第1行设置）。节点*y*最初有2*t*个子节点和2*t*
    − 1个键，但分裂将*y*减少为*t*个子节点和*t* − 1个键。节点*y*的*t*个最大子节点和*t* − 1个键移至节点*z*，成为*x*的新子节点，位于*x*的子节点表中的*y*之后。节点*y*的中位键上移成为节点*x*中分隔指向节点*y*和*z*的指针的键。
- en: Lines 2–9 create node *z* and give it the largest *t* − 1 keys and, if *y* and
    *z* are internal nodes, the corresponding *t* children of *y*. Line 10 adjusts
    the key count for *y*. Then, lines 11–17 shift keys and child pointers in *x*
    to the right in order to make room for *x*’s new child, insert *z* as a new child
    of *x*, move the median key from *y* up to *x* in order to separate *y* from *z*,
    and adjust *x*’s key count. Lines 18–20 write out all modified disk blocks. The
    CPU time used by B-TREE-SPLIT-CHILD is Θ(*t*), due to the **for** loops in lines
    5–6 and 8–9\. (The **for** loops in lines 11–12 and 14–15 also run for *O*(*t*)
    iterations.) The procedure performs *O*(1) disk operations.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 行2-9创建节点*z*并赋予它最大的*t* − 1个键，如果*y*和*z*是内部节点，则*y*的相应*t*个子节点。第10行调整*y*的键计数。然后，行11-17将*x*中的键和子指针向右移动，以便为*x*的新子节点腾出空间，将*z*插入为*x*的新子节点，将*y*的中位键上移至*x*以将*y*与*z*分开，并调整*x*的键计数。行18-20写出所有修改后的磁盘块。B-TREE-SPLIT-CHILD使用的CPU时间为Θ(*t*)，这是由于第5-6行和第8-9行中的**for**循环。（第11-12行和第14-15行中的**for**循环也运行*O*(*t*)次。）该过程执行*O*(1)次磁盘操作。
- en: '![art](images/Art_P545.jpg)'
  id: totrans-125
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P545.jpg)'
- en: '**Figure 18.5** Splitting a node with *t* = 4\. Node *y* = *x*.*c[i]* splits
    into two nodes, *y* and *z*, and the median key *S* of *y* moves up into *y*’s
    parent.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '**图18.5** 分裂一个*t* = 4的节点。节点*y* = *x*.*c[i]*分裂为两个节点*y*和*z*，并且*y*的中位键*S*上移至*y*的父节点。'
- en: '***Inserting a key into a B-tree in a single pass down the tree***'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '***在树中单次遍历插入键***'
- en: Inserting a key *k* into a B-tree *T* of height *h* requires just a single pass
    down the tree and *O*(*h*) disk accesses. The CPU time required is *O*(*th*) =
    *O*(*t* log*[t] n*). The B-TREE-INSERT procedure uses B-TREE-SPLIT-CHILD to guarantee
    that the recursion never descends to a full node. If the root is full, B-TREE-INSERT
    splits it by calling the procedure B-TREE-SPLIT-ROOT on the facing page.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 将键 *k* 插入高度为 *h* 的B树 *T* 只需要沿着树向下进行一次遍历和 *O*(*h*) 次磁盘访问。所需的CPU时间为 *O*(*th*)
    = *O*(*t* log*[t] n*)。B-TREE-INSERT过程使用B-TREE-SPLIT-CHILD来确保递归永远不会降到一个满节点。如果根节点满了，B-TREE-INSERT通过调用下一页上的B-TREE-SPLIT-ROOT过程来分裂它。
- en: B-TREE-INSERT(*T*, *k*)
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: B-TREE-INSERT(*T*, *k*)
- en: '| 1 | *r* = *T*.*root* |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *r* = *T*.*root* |'
- en: '| 2 | **if** *r*.*n* == 2*t* − 1 |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **if** *r*.*n* == 2*t* − 1 |'
- en: '| 3 | *s* = B-TREE-SPLIT-ROOT(*T*) |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *s* = B-TREE-SPLIT-ROOT(*T*) |'
- en: '| 4 | B-TREE-INSERT-NONFULL(*s*, *k*) |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| 4 | B-TREE-INSERT-NONFULL(*s*, *k*) |'
- en: '| 5 | **else** B-TREE-INSERT-NONFULL(*r*, *k*) |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **else** B-TREE-INSERT-NONFULL(*r*, *k*) |'
- en: B-TREE-INSERT works as follows. If the root is full, then line 3 calls B-TREE-SPLIT-ROOT
    in line 3 to split it. A new node *s* (with two children) becomes the root and
    is returned by B-TREE-SPLIT-ROOT. Splitting the root, illustrated in [Figure 18.6](chapter018.xhtml#Fig_18-6),
    is the only way to increase the height of a B-tree. Unlike a binary search tree,
    a B-tree increases in height at the top instead of at the bottom. Regardless of
    whether the root split, B-TREE-INSERT finishes by calling B-TREE-INSERT-NONFULL
    to insert key *k* into the tree rooted at the nonfull root node, which is either
    the new root (the call in line 4) or the original root (the call in line 5).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: B-TREE-INSERT的工作方式如下。如果根节点满了，那么第3行调用第3行的B-TREE-SPLIT-ROOT来分裂它。一个新节点*s*（带有两个子节点）成为根节点，并被B-TREE-SPLIT-ROOT返回。如[图
    18.6](chapter018.xhtml#Fig_18-6)所示，分裂根节点是增加B树高度的唯一方法。与二叉搜索树不同，B树在顶部增加高度而不是在底部。无论根节点是否分裂，B-TREE-INSERT都通过调用B-TREE-INSERT-NONFULL来完成，将键*k*插入到非满根节点为根的树中，这个根节点可以是新根（第4行的调用）或原始根（第5行的调用）。
- en: '![art](images/Art_P546.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P546.jpg)'
- en: '**Figure 18.6** Splitting the root with *t* = 4\. Root node *r* splits in two,
    and a new root node *s* is created. The new root contains the median key of *r*
    and has the two halves of *r* as children. The B-tree grows in height by one when
    the root is split. A B-tree’s height increases only when the root splits.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 18.6** 用 *t* = 4 分割根节点。根节点 *r* 分裂成两个，新的根节点 *s* 被创建。新的根包含 *r* 的中位键，并将 *r*
    的两半作为子节点。当根节点分裂时，B树的高度增加了一层。只有当根节点分裂时，B树的高度才会增加。'
- en: B-TREE-SPLIT-ROOT(*T*)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: B-TREE-SPLIT-ROOT(*T*)
- en: '| 1 | *s* = ALLOCATE-NODE() |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *s* = ALLOCATE-NODE() |'
- en: '| 2 | *s*.*leaf* = FALSE |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *s*.*leaf* = FALSE |'
- en: '| 3 | *s*.*n* = 0 |'
  id: totrans-141
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *s*.*n* = 0 |'
- en: '| 4 | *s*.*c*[1] = *T*.*root* |'
  id: totrans-142
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *s*.*c*[1] = *T*.*root* |'
- en: '| 5 | *T*.*root* = *s* |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| 5 | *T*.*root* = *s* |'
- en: '| 6 | B-TREE-SPLIT-CHILD(*s*, 1) |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '| 6 | B-TREE-SPLIT-CHILD(*s*, 1) |'
- en: '| 7 | **return** *s* |'
  id: totrans-145
  prefs: []
  type: TYPE_TB
  zh: '| 7 | **return** *s* |'
- en: The auxiliary procedure B-TREE-INSERT-NONFULL on page 511 inserts key *k* into
    node *x*, which is assumed to be nonfull when the procedure is called. B-TREEINSERT-NONFULL
    recurses as necessary down the tree, at all times guaranteeing that the node to
    which it recurses is not full by calling B-TREE-SPLIT-CHILD as necessary. The
    operation of B-TREE-INSERT and the recursive operation of B-TREE-INSERT-NONFULL
    guarantee that this assumption is true.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助过程B-TREE-INSERT-NONFULL在页面511上将键*k*插入到假设调用该过程时节点*x*中，该节点被假定为非满。B-TREE-INSERT-NONFULL在树中必要时递归下降，始终通过必要时调用B-TREE-SPLIT-CHILD来保证递归到的节点不是满的。B-TREE-INSERT的操作和B-TREE-INSERT-NONFULL的递归操作保证了这一假设的正确性。
- en: '[Figure 18.7](chapter018.xhtml#Fig_18-7) illustrates the various cases of how
    B-TREE-INSERT-NONFULL inserts a key into a B-tree. Lines 3–8 handle the case in
    which *x* is a leaf node by inserting key *k* into *x*, shifting to the right
    all keys in *x* that are greater than *k*. If *x* is not a leaf node, then *k*
    should go into the appropriate leaf node in the subtree rooted at internal node
    *x*. Lines 9–11 determine the child *x*.*c[i]* to which the recursion descends.
    Line 13 detects whether the recursion would descend to a full child, in which
    case line 14 calls B-TREE-SPLIT-CHILD to split that child into two nonfull children,
    and lines 15–16 determine which of the two children is the correct one to descend
    to. (Note that DISK-READ(*x*.*c[i]*) is not needed after line 16 increments *i*,
    since the recursion descends in this case to a child that was just created by
    B-TREE-SPLIT-CHILD.) The net effect of lines 13–16 is thus to guarantee that the
    procedure never recurses to a full node. Line 17 then recurses to insert *k* into
    the appropriate subtree.'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 18.7](chapter018.xhtml#Fig_18-7) 展示了B-TREE-INSERT-NONFULL将键插入B树的各种情况。第3-8行处理*x*是叶节点的情况，通过将键*k*插入*x*，将*x*中大于*k*的所有键向右移动。如果*x*不是叶节点，则*k*应该插入到以内部节点*x*为根的子树中的适当叶节点。第9-11行确定递归下降到的子节点*x*.*c[i]*。第13行检测递归是否会降到一个满子节点，如果是，则第14行调用B-TREE-SPLIT-CHILD将该子节点分裂为两个非满子节点，第15-16行确定下降到哪个子节点是正确的。（请注意，在第16行增加*i*后，不需要DISK-READ(*x*.*c[i]*)，因为在这种情况下递归下降到了刚刚由B-TREE-SPLIT-CHILD创建的子节点。）第13-16行的净效果是确保该过程永远不会递归到一个满节点。第17行然后递归将*k*插入到适当的子树中。'
- en: '![art](images/Art_P547.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P547.jpg)'
- en: '**Figure 18.7** Inserting keys into a B-tree. The minimum degree *t* for this
    B-tree is 3, so that a node can hold at most 5 keys. Blue nodes are modified by
    the insertion process. **(a)** The initial tree for this example. **(b)** The
    result of inserting *B* into the initial tree. This case is a simple insertion
    into a leaf node. **(c)** The result of inserting *Q* into the previous tree.
    The node *RST U V* splits into two nodes containing *RS* and *U V*, the key *T*
    moves up to the root, and *Q* is inserted in the leftmost of the two halves (the
    *RS* node). **(d)** The result of inserting *L* into the previous tree. The root
    splits right away, since it is full, and the B-tree grows in height by one. Then
    *L* is inserted into the leaf containing *JK*. **(e)** The result of inserting
    *F* into the previous tree. The node *ABCDE* splits before *F* is inserted into
    the rightmost of the two halves (the *DE* node).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**图18.7** 将关键字插入B树。此B树的最小度数*t*为3，因此一个节点最多可以容纳5个关键字。蓝色节点由插入过程修改。**(a)** 此示例的初始树。**(b)**
    将*B*插入初始树的结果。这种情况是简单地插入到叶节点中。**(c)** 将*Q*插入到先前树的结果。节点*RST U V*分裂为包含*RS*和*U V*的两个节点，关键字*T*上移至根，*Q*插入到两个半部分中的最左边（*RS*节点）。**(d)**
    将*L*插入到先前树的结果。根节点立即分裂，因为它已满，并且B树的高度增加了一层。然后将*L*插入到包含*JK*的叶节点中。**(e)** 将*F*插入到先前树的结果。在将*F*插入到两个半部分中的最右边（*DE*节点）之前，节点*ABCDE*在*F*之前分裂。'
- en: B-TREE-INSERT-NONFULL(*x*, *k*)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: B-TREE-INSERT-NONFULL(*x*, *k*)
- en: '|   1 | *i* = *x*.*n* |  |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|   1 | *i* = *x*.*n* |  |'
- en: '|   2 | **if** *x*.*leaf* | **//** inserting into a leaf? |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|   2 | **if** *x*.*leaf* | **//** 插入到叶节点？ |'
- en: '|   3 | **while** *i* ≥ 1 and *k* < *x*.*key[i]* | **//** shift keys in *x*
    to make room for *k* |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|   3 | **while** *i* ≥ 1 and *k* < *x*.*key[i]* | **//** 移动 *x* 中的关键字以为 *k*
    腾出空间 |'
- en: '|   4 | *x*.*key*[*i*+1] = *x*.*key[i]* |  |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|   4 | *x*.*key*[*i*+1] = *x*.*key[i]* |  |'
- en: '|   5 | *i* = *i* − 1 |  |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|   5 | *i* = *i* − 1 |  |'
- en: '|   6 | *x*.*key*[*i*+1] = *k* | **//** insert key *k* in *x* |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|   6 | *x*.*key*[*i*+1] = *k* | **//** 在 *x* 中插入关键字 *k* |'
- en: '|   7 | *x*.*n* = *x*.*n* + 1 | **//** now *x* has 1 more key |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|   7 | *x*.*n* = *x*.*n* + 1 | **//** 现在 *x* 有1个更多的关键字 |'
- en: '|   8 | DISK-WRITE(*x*) |  |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|   8 | DISK-WRITE(*x*) |  |'
- en: '|   9 | **else while** *i* ≥ 1 and *k* < *x*.*key[i]* | **//** find the child
    where *k* belongs |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|   9 | **else while** *i* ≥ 1 and *k* < *x*.*key[i]* | **//** 找到 *k* 应该插入的子节点
    |'
- en: '| 10 | *i* = *i* − 1 |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 10 | *i* = *i* − 1 |'
- en: '| 11 | *i* = *i* + 1 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 11 | *i* = *i* + 1 |'
- en: '| 12 | DISK-READ(*x*.*c[i]*) |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 12 | DISK-READ(*x*.*c[i]*) |'
- en: '| 13 | **if** *x*.*c[i]*.*n* == 2*t* − 1 | **//** split the child if it’s full
    |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 13 | **if** *x*.*c[i]*.*n* == 2*t* − 1 | **//** 如果子节点已满，则分裂该子节点 |'
- en: '| 14 | B-TREE-SPLIT-CHILD(*x*, *i*) |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 14 | B-TREE-SPLIT-CHILD(*x*, *i*) |'
- en: '| 15 | **if** *k > x*.*key[i]* | **//** does *k* go into *x*.*c[i]* or *x*.*c*[*i*+1]?
    |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 15 | **if** *k > x*.*key[i]* | **//** *k* 是否进入 *x*.*c[i]* 或 *x*.*c*[*i*+1]？
    |'
- en: '| 16 | *i* = *i* + 1 |  |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 16 | *i* = *i* + 1 |  |'
- en: '| 17 | B-TREE-INSERT-NONFULL(*x*.*c[i]*, *k*) |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 17 | B-TREE-INSERT-NONFULL(*x*.*c[i]*, *k*) |'
- en: For a B-tree of height *h*, B-TREE-INSERT performs *O*(*h*) disk accesses, since
    only *O*(1) DISK-READ and DISK-WRITE operations occur at each level of the tree.
    The total CPU time used is *O*(*t*) in each level of the tree, or *O*(*th*) =
    *O*(*t* log*[t] n*) overall. Since B-TREE-INSERT-NONFULL is tail-recursive, you
    can instead implement it with a **while** loop, thereby demonstrating that the
    number of blocks that need to be in main memory at any time is *O*(1).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于高度为*h*的B树，B-TREE-INSERT执行*O*(*h*)次磁盘访问，因为每个树级别只发生*O*(1)次DISK-READ和DISK-WRITE操作。总CPU时间为每个树级别的*O*(*t*),
    或者总体为*O*(*th*) = *O*(*t* log*[t] n*)。由于B-TREE-INSERT-NONFULL是尾递归的，您可以使用**while**循环来实现它，从而证明任何时候需要在主内存中的块���为*O*(1)。
- en: '**Exercises**'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***18.2-1***'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '***18.2-1***'
- en: Show the results of inserting the keys
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 展示插入关键字的结果
- en: '*F*, *S*, *Q*, *K*, *C*, *L*, *H*, *T*, *V*, *W*, *M*, *R*, *N*, *P*, *A*,
    *B*, *X*, *Y*, *D*, *Z*, *E*'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '*F*, *S*, *Q*, *K*, *C*, *L*, *H*, *T*, *V*, *W*, *M*, *R*, *N*, *P*, *A*,
    *B*, *X*, *Y*, *D*, *Z*, *E*'
- en: in order into an empty B-tree with minimum degree 2\. Draw only the configurations
    of the tree just before some node must split, and also draw the final configuration.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 有序地将关键字插入到最小度数为2的空B树中。仅在某个节点必须分裂之前绘制树的配置，并绘制最终配置。
- en: '***18.2-2***'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '***18.2-2***'
- en: Explain under what circumstances, if any, redundant DISK-READ or DISK-WRITE
    operations occur during the course of executing a call to B-TREE-INSERT. (A redundant
    DISK-READ is a DISK-READ for a block that is already in memory. A redundant DISK-WRITE
    writes to disk a block of information that is identical to what is already stored
    there.)
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 解释在执行B-TREE-INSERT调用过程中，是否会发生多余的DISK-READ或DISK-WRITE操作。 （多余的DISK-READ是指对已经在内存中的块进行DISK-READ。多余的DISK-WRITE是指将与已存储在磁盘上的信息相同的块写入磁盘。）
- en: '***18.2-3***'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '***18.2-3***'
- en: Professor Bunyan asserts that the B-TREE-INSERT procedure always results in
    a B-tree with the minimum possible height. Show that the professor is mistaken
    by proving that with *t* = 2 and the set of keys {1, 2, … , 15}, there is no insertion
    sequence that results in a B-tree with the minimum possible height.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 布尼恩教授断言，B-TREE-INSERT过程总是会导致具有最小可能高度的B树。通过证明当*t* = 2和关键字集合{1, 2, … , 15}时，不存在导致B树具有最小可能高度的插入序列来证明教授是错误的。
- en: ★ ***18.2-4***
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***18.2-4***
- en: If you insert the keys {1, 2, … , *n*} into an empty B-tree with minimum degree
    2, how many nodes does the final B-tree have?
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将关键字{1, 2, … , *n*}插入到最小度数为2的空B树中，最终B树有多少个节点？
- en: '***18.2-5***'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '***18.2-5***'
- en: Since leaf nodes require no pointers to children, they could conceivably use
    a different (larger) *t* value than internal nodes for the same disk block size.
    Show how to modify the procedures for creating and inserting into a B-tree to
    handle this variation.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 由于叶节点不需要指向子节点的指针，它们可以使用与相同磁盘块大小的内部节点不同（更大）的*t*值。展示如何修改创建和插入B树的过程以处理这种变化。
- en: '***18.2-6***'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '***18.2-6***'
- en: Suppose that you implement B-TREE-SEARCH to use binary search rather than linear
    search within each node. Show that this change makes the required CPU time *O*(lg
    *n*), independent of how *t* might be chosen as a function of *n*.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 假设您实现了使用二分查找而不是线性查找的B-TREE-SEARCH。证明这种改变使得所需的CPU时间为*O*(lg *n*), 与如何选择*t*作为*n*的函数无关。
- en: '***18.2-7***'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '***18.2-7***'
- en: Suppose that disk hardware allows you to choose the size of a disk block arbitrarily,
    but that the time it takes to read the disk block is *a*+*bt*, where *a* and *b*
    are specified constants and *t* is the minimum degree for a B-tree using blocks
    of the selected size. Describe how to choose *t* so as to minimize (approximately)
    the B-tree search time. Suggest an optimal value of *t* for the case in which
    *a* = 5 milliseconds and *b* = 10 microseconds.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 假设磁盘硬件允许您任意选择磁盘块的大小，但读取磁盘块所需的时间为*a*+*bt*，其中*a*和*b*是指定的常数，*t*是使用选定大小的块的B树的最小度。描述如何选择*t*以最小化（近似）B树搜索时间。建议在*a*
    = 5毫秒和*b* = 10微秒的情况下选择*t*的最佳值。
- en: '[**18.3    Deleting a key from a B-tree**](toc.xhtml#Rh1-108)'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '[**18.3    从B树中删除键**](toc.xhtml#Rh1-108)'
- en: Deletion from a B-tree is analogous to insertion but a little more complicated,
    because you can delete a key from any node—not just a leaf—and when you delete
    a key from an internal node, you must rearrange the node’s children. As in insertion,
    you must guard against deletion producing a tree whose structure violates the
    B-tree properties. Just as a node should not get too big due to insertion, a node
    must not get too small during deletion (except that the root is allowed to have
    fewer than the minimum number *t* − 1 of keys). And just as a simple insertion
    algorithm might have to back up if a node on the path to where the key is to be
    inserted is full, a simple approach to deletion might have to back up if a node
    (other than the root) along the path to where the key is to be deleted has the
    minimum number of keys.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 从B树中删除类似于插入，但稍微复杂一些，因为您可以从任何节点删除键——不仅仅是叶子节点——当您从内部节点删除键时，必须重新排列节点的子节点。与插入一样，您必须防止删除产生违反B树属性的树结构。就像插入时节点不应该因为过大而需要回退一样，删除的简单算法可能需要在路径上的节点（除了根节点）中有最小数量的键时回退。
- en: The procedure B-TREE-DELETE deletes the key *k* from the subtree rooted at *x*.
    Unlike the procedures TREE-DELETE on page 325 and RB-DELETE on page 348, which
    are given the node to delete—presumably as the result of a prior search—B-TREE-DELETE
    combines the search for key *k* with the deletion process. Why do we combine search
    and deletion in B-TREE-DELETE? Just as B-TREE-INSERT prevents any node from becoming
    overfull (having more than 2*t* − 1 keys) while making a single pass down the
    tree, B-TREE-DELETE prevents any node from becoming underfull (having fewer than
    *t* − 1 keys) while also making a single pass down the tree, searching for and
    ultimately deleting the key.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 过程B-TREE-DELETE从以*x*为根的子树中删除键*k*。与第325页的TREE-DELETE和第348页的RB-DELETE过程不同，这两个过程给出了要删除的节点——可能是先前搜索的结果——B-TREE-DELETE将搜索键*k*与删除过程结合在一起。为什么我们在B-TREE-DELETE中将搜索和删除结合在一起？就像B-TREE-INSERT在树中向下进行单次遍历时防止任何节点过满（拥有超过2*t*
    − 1个键）一样，B-TREE-DELETE在树中向下进行单次遍历时防止任何节点过少（拥有少于*t* − 1个键），同时搜索并最终删除键。
- en: To prevent any node from becoming underfull, the design of B-TREE-DELETE guarantees
    that whenever it calls itself recursively on a node *x*, the number of keys in
    *x* is at least the minimum degree *t* at the time of the call. (Although the
    root may have fewer than *t* keys and a recursive call may be made *from* the
    root, no recursive call is made *on* the root.) This condition requires one more
    key than the minimum required by the usual B-tree conditions, and so a key might
    have to be moved from *x* into one of its child nodes (still leaving *x* with
    at least the minimum *t* − 1 keys) before a recursive call is made on that child,
    thus allowing deletion to occur in one downward pass without having to traverse
    back up the tree.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为防止任何节点过少，B-TREE-DELETE的设计保证每当在节点*x*上递归调用自身时，*x*中的键数至少是调用时的最小度*t*。（尽管根可能少于*t*个键，并且可能从根节点进行递归调用，但不会在根节点上进行递归调用。）这个条件要求比通常的B树条件所需的最小键多一个，因此在对子节点进行递归调用之前，可能需要将一个键从*x*移动到其中一个子节点中（仍然保留*x*至少有最小*t*
    − 1个键），从而允许删除在一次向下传递中发生，而无需遍历树���上。
- en: We describe how the procedure B-TREE-DELETE(*T*, *k*) deletes a key *k* from
    a B-tree *T* instead of presenting detailed pseudocode. We examine three cases,
    illustrated in [Figure 18.8](chapter018.xhtml#Fig_18-8). The cases are for when
    the search arrives at a leaf, at an internal node containing key *k*, and at an
    internal node not containing key *k*. As mentioned above, in all three cases node
    *x* has at least *t* keys (with the possible exception of when *x* is the root).
    Cases 2 and 3—when *x* is an internal node—guarantee this property as the recursion
    descends through the B-tree.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们描述了过程B-TREE-DELETE(*T*, *k*)如何从B树*T*中删除键*k*，而不是提供详细的伪代码。我们研究了三种情况，如[图18.8](chapter018.xhtml#Fig_18-8)所示。这些情况是当搜索到达叶子节点时，到达包含键*k*的内部节点时，以及到达不包含键*k*的内部节点时。如上所述，在这三种情况下，节点*x*至少有*t*个键（可能的例外是*x*是根节点时）。情况2和3——当*x*是内部节点时——通过递归沿着B树下降来保证这个属性。
- en: '![art](images/Art_P548.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P548.jpg)'
- en: '![art](images/Art_P549.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P549.jpg)'
- en: '**Figure 18.8** Deleting keys from a B-tree. The minimum degree for this B-tree
    is *t* = 3, so that, other than the root, every node must have at least 2 keys.
    Blue nodes are those that are modified by the deletion process. **(a)** The B-tree
    of [Figure 18.7(e)](chapter018.xhtml#Fig_18-7). **(b)** Deletion of *F*, which
    is case 1: simple deletion from a leaf when all nodes visited during the search
    (other than the root) have at least *t* = 3 keys. **(c)** Deletion of *M*, which
    is case 2a: the predecessor *L* of *M* moves up to take *M*’s position. **(d)**
    Deletion of *G*, which is case 2c: push *G* down to make node *DEGJK* and then
    delete *G* from this leaf (case 1). **(e)** Deletion of *D*, which is case 3b:
    since the recursion cannot descend to node *CL* because it has only 2 keys, push
    *P* down and merge it with *CL* and *TX* to form *CLP TX*. Then delete *D* from
    a leaf (case 1). **(e**⁰**)** After (e), delete the empty root. The tree shrinks
    in height by 1\. **(f)** Deletion of *B*, which is case 3a: *C* moves to fill
    *B*’s position and *E* moves to fill *C*’s position.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**图18.8** 从B树中删除键。此B树的最小度数为*t* = 3，因此除了根节点外，每个节点必须至少有2个键。蓝色节点是删除过程中修改的节点。**(a)**
    [图18.7(e)](chapter018.xhtml#Fig_18-7)中的B树。**(b)** 删除*F*，这是情况1：在搜索过程中访问的所有节点（除了根节点）至少有*t*
    = 3个键时，从叶节点简单删除。**(c)** 删除*M*，这是情况2a：*M*的前驱*L*上移以占据*M*的位置。**(d)** 删除*G*，这是情况2c：将*G*下移以形成节点*DEGJK*，然后从该叶节点中删除*G*（情况1）。**(e)**
    删除*D*，这是情况3b：由于递归无法下降到节点*CL*，因为它只有2个键，所以将*P*下移并与*CL*和*TX*合并形成*CLP TX*。然后从叶节点中删除*D*（情况1）。**(e**⁰**)**
    在(e)之后，删除空根。树的高度减少1。**(f)** 删除*B*，这是情况3a：*C*移动以填充*B*的位置，*E*移动以填充*C*的位置。'
- en: '***Case 1:*** *The search arrives at a leaf node x.* If *x* contains key *k*,
    then delete *k* from *x*. If *x* does not contain key *k*, then *k* was not in
    the B-tree and nothing else needs to be done.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '***情况 1:*** 搜索到达叶节点*x*。如果*x*包含键*k*，则从*x*中删除*k*。如果*x*不包含键*k*，则*k*不在B树中，无需执行其他操作。'
- en: '***Case 2:*** *The search arrives at an internal node x that contains key k.*
    Let *k* = *x*.*key[i]*. One of the following three cases applies, depending on
    the number of keys in *x*.*c[i]* (the child of *x* that precedes *k*) and *x*.*c*[*i*+1]
    (the child of *x* that follows *k*).'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '***情况 2:*** 搜索到包含键*k*的内部节点*x*。设*k* = *x*.*key[i]*。根据*x*.*c[i]*（紧随*k*的*x*的子节点）和*x*.*c*[*i*+1]*（跟随*k*的*x*的子节点）中的键数，应用以下三种情况之一。'
- en: '***Case 2a:*** *x*.*c[i] has at least t keys.* Find the predecessor *k*′ of
    *k* in the subtree rooted at *x*.*c[i]*. Recursively delete *k*′ from *x*.*c[i]*,
    and replace *k* by *k*′ in *x*. (Key *k*′ can be found and deleted in a single
    downward pass.)'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '***情况 2a:*** *x*.*c[i]*至少有*t*个键。在以*x*.*c[i]*为根的子树中找到*k*的前驱*k*′。递归地从*x*.*c[i]*中���除*k*′，并在*x*中用*k*′替换*k*。（键*k*′可以在单次向下遍历中找到并删除。）'
- en: '***Case 2b:*** *x*.*c[i] has t* − 1 *keys and x*.*c*[*i*+1]*has at least t
    keys.* This case is symmetric to case 2a. Find the successor *k*′ of *k* in the
    subtree rooted at *x*.*c*[*i*+1]. Recursively delete *k*′ from *x*.*c*[*i*+1],
    and replace *k* by *k*′ in *x*. (Again, finding and deleting *k*′ can be done
    in a single downward pass.)'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '***情况 2b:*** *x*.*c[i]*有*t* − 1个键，而*x*.*c*[*i*+1]*至少有*t*个键。这种情况对称于情况2a。在以*x*.*c*[*i*+1]*为根的子树中找到*k*的后继*k*′。递归地从*x*.*c*[*i*+1]*中删除*k*′，并在*x*中用*k*′替换*k*。（同样，找到并删除*k*′可以在单次向下遍历中完成。）'
- en: '***Case 2c*:** *Both x*.*c[i] and x*.*c*[*i*+1]*have t − 1 keys.* Merge *k*
    and all of *x*.*c*[*i*+1] into *x*.*c[i]*, so that *x* loses both *k* and the
    pointer to *x*.*c*[*i*+1], and *x*.*c[i]* now contains 2*t* − 1 keys. Then free
    *x*.*c*[*i*+1] and recursively delete *k* from *x*.*c[i]*.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '***情况 2c*:** *x*.*c[i]*和*x*.*c*[*i*+1]*都有*t* − 1个键。将*k*和*x*.*c*[*i*+1]*中的所有内容合并到*x*.*c[i]*中，这样*x*既失去了*k*，也失去了指向*x*.*c*[*i*+1]*的指针，而*x*.*c[i]*现在包含了2*t*
    − 1个键。然后释放*x*.*c*[*i*+1]*，并递归地从*x*.*c[i]*中删除*k*。'
- en: '***Case 3*:** *The search arrives at an internal node x that does not contain
    key k.* Continue searching down the tree while ensuring that each node visited
    has at least *t* keys. To do so, determine the root *x*.*c[i]* of the appropriate
    subtree that must contain *k*, if *k* is in the tree at all. If *x*.*c[i]* has
    only *t* − 1 keys, execute case 3a or 3b as necessary to guarantee descending
    to a node containing at least *t* keys. Then finish by recursing on the appropriate
    child of *x*.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '***情况 3:*** 搜索到不包含键*k*的内部节点*x*。在继续向树下搜索的同时，确保每个访问的节点至少有*t*个键。为此，确定适当子树的根*x*.*c[i]*，该子树必须包含*k*，如果*k*在树中的话。如果*x*.*c[i]*只有*t*
    − 1个键，则根据需要执行情况3a或3b，以确保下降到包含至少*t*个键的节点。然后在*x*的适当子节点上递归完成。'
- en: '***Case 3a*:** *x*.*c[i] has only t* − 1 *keys but has an immediate sibling
    with at least t keys.* Give *x*.*c[i]* an extra key by moving a key from *x* down
    into *x*.*c[i]*, moving a key from *x*.*c[i]*’s immediate left or right sibling
    up into *x*, and moving the appropriate child pointer from the sibling into *x*.*c[i]*.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '***情况 3a*:** *x*.*c[i]*只有*t* − 1个键，但有一个至少有*t*个键的直接兄弟。通过将一个键从*x*移动到*x*.*c[i]*，将*x*.*c[i]*的直接左侧或右侧兄弟中的一个键移动到*x*中，以及将兄弟中的适当子指针移动到*x*.*c[i]*中，为*x*.*c[i]*增加一个额外的键。'
- en: '***Case 3b*:** *x*.*c[i] and each of x*.*c[i]’s immediate siblings have t*
    − 1 *keys.* (It is possible for *x*.*c[i]* to have either one or two siblings.)
    Merge *x*.*c[i]* with one sibling, which involves moving a key from *x* down into
    the new merged node to become the median key for that node.'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '***情况 3b*:** *x*.*c[i]*和*x*.*c[i]*的每个直接兄弟都有*t* − 1个键。（*x*.*c[i]*可能有一个或两个兄弟。）将*x*.*c[i]*与一个兄弟合并，这涉及将一个键从*x*移动到新合并的节点中，成为该节点的中位键。'
- en: In cases 2c and 3b, if node *x* is the root, it could end up having no keys.
    When this situation occurs, then *x* is deleted, and *x*’s only child *x*.*c*[1]
    becomes the new root of the tree. This action decreases the height of the tree
    by one and preserves the property that the root of the tree contains at least
    one key (unless the tree is empty).
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在情况2c和3b中，如果节点*x*是根节点，则可能最终没有键。当出现这种情况时，删除*x*，并且*x*的唯一子节点*x*.*c*[1]*成为树的新根。此操作将树的高度减少1，并保持树的根至少包含一个键（除非树为空）。
- en: Since most of the keys in a B-tree are in the leaves, deletion operations often
    end up deleting keys from leaves. The B-TREE-DELETE procedure then acts in one
    downward pass through the tree, without having to back up. When deleting a key
    in an internal node *x*, however, the procedure might make a downward pass through
    the tree to find the key’s predecessor or successor and then return to node *x*
    to replace the key with its predecessor or successor (cases 2a and 2b). Returning
    to node *x* does not require a traversal through all the levels between *x* and
    the node containing the predecessor or successor, however, since the procedure
    can just keep a pointer to *x* and the key position within *x* and put the predecessor
    or successor key directly there.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 由于B树中大多数键位于叶子中，删除操作通常会删除叶子中的键。然后，B-TREE-DELETE过程在树中进行一次向下遍历，而无需备份。但是，在删除内部节点*x*中的键时，该过程可能会通过树进行向下遍历，以找到键的前任或后继者，然后返回到节点*x*以用其前任或后继者替换键（情况2a和2b）。然而，返回到节点*x*不需要通过*x*和包含前任或后继者的节点之间的所有级别进行遍历，因为该过程可以只保留指向*x*和*x*内的键位置的指针，并直接将前任或后继者键放在那里。
- en: Although this procedure seems complicated, it involves only *O*(*h*) disk operations
    for a B-tree of height *h*, since only *O*(1) calls to DISK-READ and DISK-WRITE
    are made between recursive invocations of the procedure. The CPU time required
    is *O*(*th*) = *O*(*t* log[*t*]*n*).
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这个过程看起来复杂，但对于高度为*h*的B树，只涉及*O*(*h*)个磁盘操作，因为在过程的递归调用之间只进行*O*(1)次DISK-READ和DISK-WRITE调用。所需的CPU时间为*O*(*th*)
    = *O*(*t* log[*t*]*n*)。
- en: '**Exercises**'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***18.3-1***'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '***18.3-1***'
- en: Show the results of deleting *C*, *P*, and *V*, in order, from the tree of [Figure
    18.8(f)](chapter018.xhtml#Fig_18-8).
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 展示从[图18.8(f)](chapter018.xhtml#Fig_18-8)的树中按顺序删除*C*、*P*和*V*的结果。
- en: '***18.3-2***'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '***18.3-2***'
- en: Write pseudocode for B-TREE-DELETE.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为B-TREE-DELETE编写伪代码。
- en: '**Problems**'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '***18-1     Stacks on secondary storage***'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '***18-1     辅助存储器上的堆栈***'
- en: Consider implementing a stack in a computer that has a relatively small amount
    of fast primary memory and a relatively large amount of slower disk storage. The
    operations PUSH and POP work on single-word values. The stack can grow to be much
    larger than can fit in memory, and thus most of it must be stored on disk.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在具有相对较小的快速主存储器和相对较大的较慢磁盘存储器的计算机中实现堆栈。PUSH和POP操作适用于单字值。堆栈可以增长到远远大于内存容量的大小，因此大部分必须存储在磁盘上。
- en: A simple, but inefficient, stack implementation keeps the entire stack on disk.
    Maintain in memory a stack pointer, which is the disk address of the top element
    on the stack. Indexing block numbers and word offsets within blocks from 0, if
    the pointer has value *p*, the top element is the (*p* mod *m*)th word on block
    ⌊*p*/*m*⌋ of the disk, where *m* is the number of words per block.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单但低效的堆栈实现将整个堆栈保留在磁盘上。在内存中维护一个堆栈指针，它是堆栈顶部元素的磁盘地址。从0开始索引块号和块内单词偏移，如果指针的值为*p*，则顶部元素是磁盘块⌊*p*/*m*⌋上的第(*p*
    mod *m*)个单词，其中*m*是每个块的单词数。
- en: To implement the PUSH operation, increment the stack pointer, read the appropriate
    block into memory from disk, copy the element to be pushed to the appropriate
    word on the block, and write the block back to disk. A POP operation is similar.
    Read in the appropriate block from disk, save the top of the stack, decrement
    the stack pointer, and return the saved value. You need not write back the block,
    since it was not modified, and the word in the block that contained the popped
    value is ignored.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现PUSH操作，增加堆栈指针，从磁盘读取适当的块到内存中，将要推送的元素复制到块上的适当单词，并将块写回磁盘。POP操作类似。从磁盘读取适当的块，保存堆栈顶部，减少堆栈指针，并返回保存的值。不需要写回块，因为它没有被修改，而包含弹出值的块中的单词被忽略。
- en: 'As in the analyses of B-tree operations, two costs matter: the total number
    of disk accesses and the total CPU time. A disk access also incurs a cost in CPU
    time. In particular, any disk access to a block of *m* words incurs charges of
    one disk access and Θ(*m*) CPU time.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 与B树操作的分析类似，有两个成本要考虑：总磁盘访问次数和总CPU��间。磁盘访问还会产生CPU时间成本。特别是，对*m*个单词的块的任何磁盘访问都会产生一个磁盘访问和Θ(*m*)的CPU时间开销。
- en: '***a.*** Asymptotically, what is the worst-case number of disk accesses for
    *n* stack operations using this simple implementation? What is the CPU time for
    *n* stack operations? Express your answer in terms of *m* and *n* for this and
    subsequent parts.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 从渐近意义上讲，使用这种简单实现进行*n*个堆栈操作所需的最坏情况磁盘访问次数是多少？*n*个堆栈操作的CPU时间是多少？用*m*和*n*来表达你的答案，适用于这个和后续部分。'
- en: Now consider a stack implementation in which you keep one block of the stack
    in memory. (You also maintain a small amount of memory to record which block is
    currently in memory.) You can perform a stack operation only if the relevant disk
    block resides in memory. If necessary, you can write the block currently in memory
    to the disk and read the new block from the disk into memory. If the relevant
    disk block is already in memory, then no disk accesses are required.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在考虑一种堆栈实现，其中将堆栈的一个块保留在内存中。（还要保留少量内存来记录当前在内存中的块。）只有在相关磁盘块驻留在内存中时，才能执行堆栈操作。必要时，可以将当前在内存中的块写入磁盘，并从磁盘读取新块到内存中。如果相关磁盘块已经在内存中，则不需要进行磁盘访问。
- en: '***b.*** What is the worst-case number of disk accesses required for *n* PUSH
    operations? What is the CPU time?'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** *n*个PUSH操作所需的最坏情况磁盘访问次数是多少？CPU时间是多少？'
- en: '***c.*** What is the worst-case number of disk accesses required for *n* stack
    operations? What is the CPU time?'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** *n*个堆栈操作所需的最坏情况磁盘访问次数是多少？CPU时间是多少？'
- en: Suppose that you now implement the stack by keeping two blocks in memory (in
    addition to a small number of words for bookkeeping).
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在通过在内存中保留两个块（以及少量用于簿记的单词）来实现堆栈。
- en: '***d.*** Describe how to manage the stack blocks so that the amortized number
    of disk accesses for any stack operation is *O*(1/*m*) and the amortized CPU time
    for any stack operation is *O*(1).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 描述如何管理堆栈块，以便对于任何堆栈操作的摊销磁盘访问次数为*O*(1/*m*)，摊销CPU时间为*O*(1)。'
- en: '***18-2     Joining and splitting 2-3-4 trees***'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '***18-2     连接和分割2-3-4树***'
- en: 'The ***join*** operation takes two dynamic sets *S*′ and *S*″ and an element
    *x* such that *x*′.*key < x*.*key < x*″.*key* for any *x*′ ∈ *S*′ and *x*″ ∈ *S*″.
    It returns a set *S* = *S*′ ∪ {*x*} ∪ *S*″. The ***split*** operation is like
    an “inverse” join: given a dynamic set *S* and an element *x* ∈ *S*, it creates
    a set *S*′ that consists of all elements in *S* − {*x*} whose keys are less than
    *x*.*key* and another set *S*″ that consists of all elements in *S* − {*x*} whose
    keys are greater than *x*.*key*. This problem investigates how to implement these
    operations on 2-3-4 trees (B-trees with *t* = 2). Assume for convenience that
    elements consist only of keys and that all key values are distinct.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '***join***操作接受两个动态集合*S*′和*S*″以及一个元素*x*，使得对于任何*x*′ ∈ *S*′和*x*″ ∈ *S*″，都有*x*′.*key
    < x*.*key < x*″.*key*。它返回一个集合*S* = *S*′ ∪ {*x*} ∪ *S*″。***split***操作类似于“逆”连接：给定一个动态集合*S*和一个元素*x*
    ∈ *S*，它创建一个集合*S*′，其中包含*S* − {*x*}中所有关键字小于*x*.*key*的元素，以及另一个集合*S*″，其中包含*S* − {*x*}中所有关键字大于*x*.*key*的元素。本问题研究如何在2-3-4树（*t*
    = 2的B树）上实现这些操作。为方便起见，假设元素仅由关键字组成，并且所有关键字值都是不同的。'
- en: '***a.*** Show how to maintain, for every node *x* of a 2-3-4 tree, the height
    of the subtree rooted at *x* as an attribute *x*.*height*. Make sure that your
    implementation does not affect the asymptotic running times of searching, insertion,
    and deletion.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 展示如何为2-3-4树的每个节点*x*维护以*x*为根的子树的高度作为属性*x*.*height*。确保您的实现不会影响搜索、插入和删除的渐近运行时间。'
- en: '***b.*** Show how to implement the join operation. Given two 2-3-4 trees *T*′
    and *T*″ and a key *k*, the join operation should run in *O*(1 + |*h*′ − *h*″|)
    time, where *h*′ and *h*″ are the heights of *T*′ and *T*″, respectively.'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 展示如何实现连接操作。给定两个2-3-4树*T*′和*T*″以及一个关键字*k*，连接操作应在*O*(1 + |*h*′ − *h*″|)时间内运行，其中*h*′和*h*″分别是*T*′和*T*″的高度。'
- en: '***c.*** Consider the simple path *p* from the root of a 2-3-4 tree *T* to
    a given key *k*, the set *S*′ of keys in *T* that are less than *k*, and the set
    *S*″ of keys in *T* that are greater than *k*. Show that *p* breaks *S*′ into
    a set of trees ![art](images/Art_P550.jpg) and a set of keys ![art](images/Art_P551.jpg)
    such that ![art](images/Art_P552.jpg) for *i* = 1, 2, … , *m* and any keys ![art](images/Art_P553.jpg)
    and ![art](images/Art_P554.jpg). What is the relationship between the heights
    of ![art](images/Art_P555.jpg) and ![art](images/Art_P556.jpg)? Describe how *p*
    breaks *S*″ into sets of trees and keys.'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 考虑从2-3-4树*T*的根到给定关键字*k*的简单路径*p*，在*T*中小于*k*的关键字集合*S*′，以及在*T*中大于*k*的关键字集合*S*″。展示*p*如何将*S*′分解为一组树![art](images/Art_P550.jpg)和一组关键字![art](images/Art_P551.jpg)，使得对于*i*
    = 1, 2, … , *m*和任何关键字![art](images/Art_P553.jpg)和![art](images/Art_P554.jpg)都成立。![art](images/Art_P552.jpg)的高度之间有什么关系？描述*p*如何将*S*″分解为树和关键字集合。'
- en: '***d.*** Show how to implement the split operation on *T*. Use the join operation
    to assemble the keys in *S*′ into a single 2-3-4 tree *T*′ and the keys in *S*″
    into a single 2-3-4 tree *T*″. The running time of the split operation should
    be *O*(lg *n*), where *n* is the number of keys in *T*. (*Hint*: The costs for
    joining should telescope.)'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 展示如何在*T*上实现分割操作。使用连接操作将*S*′中的关键字组装成单个2-3-4树*T*′，将*S*″中的关键字组装成单个2-3-4树*T*″。分割操作的运行时间应为*O*(lg
    *n*)，其中*n*是*T*中的关键字数。(*提示*：连接的成本应该是可伸缩的。)'
- en: '**Chapter notes**'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节注释**'
- en: Knuth [[261](bibliography001.xhtml#endnote_261)], Aho, Hopcroft, and Ullman
    [[5](bibliography001.xhtml#endnote_5)], and Sedgewick and Wayne [[402](bibliography001.xhtml#endnote_402)]
    give further discussions of balanced-tree schemes and B-trees. Comer [[99](bibliography001.xhtml#endnote_99)]
    provides a comprehensive survey of B-trees. Guibas and Sedgewick [[202](bibliography001.xhtml#endnote_202)]
    discuss the relationships among various kinds of balanced-tree schemes, including
    red-black trees and 2-3-4 trees.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Knuth、Aho、Hopcroft和Ullman以及Sedgewick和Wayne进一步讨论了平衡树方案和B树。Comer提供了B树的全面调查。Guibas和Sedgewick讨论了各种平衡树方案之间的关系，包括红黑树和2-3-4树。
- en: In 1970, J. E. Hopcroft invented 2-3 trees, a precursor to B-trees and 2-3-4
    trees, in which every internal node has either two or three children. Bayer and
    McCreight [[39](bibliography001.xhtml#endnote_39)] introduced B-trees in 1972
    with no explanation of their choice of name.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 1970年，J. E. Hopcroft发明了2-3树，这是B树和2-3-4树的前身，其中每个内部节点只有两个或三个子节点。Bayer和McCreight于1972年引入了B树，但没有解释他们选择这个名称的原因。
- en: Bender, Demaine, and Farach-Colton [[47](bibliography001.xhtml#endnote_47)]
    studied how to make B-trees perform well in the presence of memory-hierarchy effects.
    Their ***cache-oblivious*** algorithms work efficiently without explicitly knowing
    the data transfer sizes within the memory hierarchy.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: Bender、Demaine和Farach-Colton研究了如何使B树在存在内存层次效应时表现良好。他们的***cache-oblivious***算法在不明确知道内存层次中数据传输大小的��况下有效地工作。
- en: '[¹](#footnote_ref_1) When specifying disk capacities, one terabyte is one trillion
    bytes, rather than 2[40] bytes.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '[¹](#footnote_ref_1) 在指定磁盘容量时，一兆字节是一万亿字节，而不是2[40]字节。'
- en: '[²](#footnote_ref_2) SSDs also exhibit greater latency than main memory and
    access data in blocks.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '[²](#footnote_ref_2) 固态硬盘的延迟也比主存大，并以块的形式访问数据。'
- en: '[³](#footnote_ref_3) Another common variant on a B-tree, known as a ***B*^*-*tree***,
    requires each internal node to be at least 2/3 full, rather than at least half
    full, as a B-tree requires.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '[³](#footnote_ref_3) B树的另一个常见变体称为***B*^*-*tree***，要求每个内部节点至少填充2/3，而不是B树所需的至少一半。'
