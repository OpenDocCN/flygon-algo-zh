- en: '[**31        Number-Theoretic Algorithms**](toc.xhtml#chap-31)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[**31        数论算法**](toc.xhtml#chap-31)'
- en: Number theory was once viewed as a beautiful but largely useless subject in
    pure mathematics. Today number-theoretic algorithms are used widely, due in large
    part to the invention of cryptographic schemes based on large prime numbers. These
    schemes are feasible because we can find large primes quickly, and they are secure
    because we do not know how to factor the product of large primes (or solve related
    problems, such as computing discrete logarithms) efficiently. This chapter presents
    some of the number theory and related algorithms that underlie such applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 数论曾经被视为纯数学中美丽但基本无用的学科。如今，由于基于大素数的加密方案的发明，数论算法被广泛应用。这些方案是可行的，因为我们可以快速找到大素数，它们是安全的，因为我们不知道如何高效地分解大素数的乘积（或解决相关问题，如计算离散对数）。本章介绍了支撑这些应用的一些数论和相关算法。
- en: 'We start in [Section 31.1](chapter031.xhtml#Sec_31.1) by introducing basic
    concepts of number theory, such as divisibility, modular equivalence, and unique
    prime factorization. [Section 31.2](chapter031.xhtml#Sec_31.2) studies one of
    the world’s oldest algorithms: Euclid’s algorithm for computing the greatest common
    divisor of two integers, and [Section 31.3](chapter031.xhtml#Sec_31.3) reviews
    concepts of modular arithmetic. [Section 31.4](chapter031.xhtml#Sec_31.4) then
    explores the set of multiples of a given number *a*, modulo *n*, and shows how
    to find all solutions to the equation *ax* = *b* (mod *n*) by using Euclid’s algorithm.
    The Chinese remainder theorem is presented in [Section 31.5](chapter031.xhtml#Sec_31.5).
    [Section 31.6](chapter031.xhtml#Sec_31.6) considers powers of a given number *a*,
    modulo *n*, and presents a repeated-squaring algorithm for efficiently computing
    *a^b* mod *n*, given *a*, *b*, and *n*. This operation is at the heart of efficient
    primality testing and of much modern cryptography, such as the RSA public-key
    cryptosystem described in [Section 31.7](chapter031.xhtml#Sec_31.7). We wrap up
    in [Section 31.8](chapter031.xhtml#Sec_31.8), which examines a randomized primality
    test. This test finds large primes efficiently, an essential step in creating
    keys for the RSA cryptosystem.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从[31.1节](chapter031.xhtml#Sec_31.1)开始介绍数论的基本概念，如可除性、模同余和唯一素因子分解。[31.2节](chapter031.xhtml#Sec_31.2)研究了世界上最古老的算法之一：欧几里得算法，用于计算两个整数的最大公约数，[31.3节](chapter031.xhtml#Sec_31.3)回顾了模算术的概念。[31.4节](chapter031.xhtml#Sec_31.4)探讨了给定数*a*在模*n*下的倍数集，并展示了如何通过使用欧几里得算法找到方程*ax*
    = *b* (mod *n*)的所有解。中国剩余定理在[31.5节](chapter031.xhtml#Sec_31.5)中介绍。[31.6节](chapter031.xhtml#Sec_31.6)考虑了给定数*a*在模*n*下的幂，并提出了一个有效计算*a^b*
    mod *n*的重复平方法，给定*a*、*b*和*n*。这个操作是高效素性检测和许多现代密码学的核心，比如[31.7节](chapter031.xhtml#Sec_31.7)中描述的RSA公钥加密系统。我们在[31.8节](chapter031.xhtml#Sec_31.8)结束，该节考虑了一个随机素性测试。这个测试可以高效地找到大素数，这是为RSA密码系统创建密钥的一个重要步骤。
- en: '**Size of inputs and cost of arithmetic computations**'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入大小和算术计算成本**'
- en: Because we’ll be working with large integers, we need to adjust how to think
    about the size of an input and about the cost of elementary arithmetic operations.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 因为我们将处理大整数，所以我们需要调整对输入大小以及基本算术运算成本的思考方式。
- en: In this chapter, a “large input” typically means an input containing “large
    integers” rather than an input containing “many integers” (as for sorting). Thus,
    the size of an input depends on the *number of bits* required to represent that
    input, not just the number of integers in the input. An algorithm with integer
    inputs *a*[1], *a*[2], …, *a[k]* is a ***polynomial-time algorithm*** if it runs
    in time polynomial in 1g *a*[1], 1g *a*[2], …, 1g *a*[*k*], that is, polynomial
    in the lengths of its binary-encoded inputs.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，“大输入”通常指的是包含“大整数”而不是包含“许多整数”的输入（比如排序）。因此，输入的大小取决于表示该输入所需的*比特数*，而不仅仅是输入中整数的数量。如果一个算法的整数输入为*a*[1]、*a*[2]、…、*a[k]*，那么如果它在1g
    *a*[1]、1g *a*[2]、…、1g *a*[*k*]的长度中运行时间是多项式的，那么它就是一个***多项式时间算法***。
- en: Most of this book considers the elementary arithmetic operations (multiplications,
    divisions, or computing remainders) as primitive operations that take one unit
    of time. Counting the number of such arithmetic operations that an algorithm performs
    provides a basis for making a reasonable estimate of the algorithm’s actual running
    time on a computer. Elementary operations can be time-consuming, however, when
    their inputs are large. It thus becomes appropriate to measure how many ***bit
    operations*** a number-theoretic algorithm requires. In this model, multiplying
    two *β*-bit integers by the ordinary method uses Θ(*β*²) bit operations. Similarly,
    dividing a *β*-bit integer by a shorter integer or taking the remainder of a *β*-bit
    integer when divided by a shorter integer requires Θ(*β*²) time by simple algorithms.
    (See Exercise 31.1-12.) Faster methods are known. For example, a simple divide-and-conquer
    method for multiplying two *β*-bit integers has a running time of Θ(*β*^(1g 3)),
    and *O*(*β* 1g *β* 1g 1g *β*) time is possible. For practical purposes, however,
    the Θ(*β*²) algorithm is often best, and we use this bound as a basis for our
    analyses. In this chapter, we’ll usually analyze algorithms in terms of both the
    number of arithmetic operations and the number of bit operations they require.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本书大部分内容考虑基本算术运算（乘法、除法或计算余数）作为原始操作，每次操作需要一单位时间。计算算法执行的这些算术操作数量为基础，可用于合理估计算法在计算机上的实际运行时间。然而，当输入较大时，基本操作可能耗时。因此，衡量数论算法需要多少
    ***比特操作*** 是合适的。在这个模型中，用普通方法将两个 *β* 位整数相乘需要 Θ(*β*²) 比特操作。同样地，用简单算法将 *β* 位整数除以较短整数或求
    *β* 位整数除以较短整数的余数需要 Θ(*β*²) 时间。已知更快的方法。例如，一种简单的分治方法用于将两个 *β* 位整数相乘，其运行时间为 Θ(*β*^(1g
    3))，并且 *O*(*β* 1g *β* 1g 1g *β*) 时间是可能的。然而，对于实际目的，Θ(*β*²) 算法通常是最佳选择，我们将此界限作为分析的基础。在本章中，我们通常会分析算法所需的算术操作数量和比特操作数量。
- en: '[**31.1    Elementary number-theoretic notions**](toc.xhtml#Rh1-177)'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '[**31.1    基本数论概念**](toc.xhtml#Rh1-177)'
- en: This section provides a brief review of notions from elementary number theory
    concerning the set ℤ = {…, –2, –1, 0, 1, 2, …} of integers and the set ℕ = {0,
    1, 2, …} of natural numbers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本节简要回顾了关于整数集合 ℤ = {…, –2, –1, 0, 1, 2, …} 和自然数集合 ℕ = {0, 1, 2, …} 的基本数论概念。
- en: '**Divisibility and divisors**'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '**整除性和除数**'
- en: The notion of one integer being divisible by another is key to the theory of
    numbers. The notation *d* | *a* (read “*d* ***divides*** *a*”) means that *a*
    = *kd* for some integer *k*. Every integer divides 0\. If *a* > 0 and *d* | *a*,
    then |*d*| ≤ |*a*|. If *d* | *a*, then we also say that *a* is a ***multiple***
    of *d*. If *d* does not divide *a*, we write *d* ∤ *a*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 一个整数能被另一个整数整除的概念是数字理论的关键。符号 *d* | *a*（读作“*d* ***整除*** *a*”）表示 *a* = *kd*，其中
    *k* 是某个整数。每个整数都能整除 0。如果 *a* > 0 且 *d* | *a*，那么 |*d*| ≤ |*a*|。如果 *d* | *a*，那么我们也说
    *a* 是 *d* 的 ***倍数***。如果 *d* 不能整除 *a*，我们写作 *d* ∤ *a*。
- en: If *d* | *a* and *d* ≥ 0, then *d* is a ***divisor*** of *a*. Since *d* | *a*
    if and only if –*d* | *a*, without loss of generality, we define the divisors
    of *a* to be nonnegative, with the understanding that the negative of any divisor
    of *a* also divides *a*. A divisor of a nonzero integer *a* is at least 1 but
    not greater than |*a*|. For example, the divisors of 24 are 1, 2, 3, 4, 6, 8,
    12, and 24.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *d* | *a* 且 *d* ≥ 0，则 *d* 是 *a* 的 ***除数***。由于 *d* | *a* 当且仅当 –*d* | *a*，为了方便起见，我们定义
    *a* 的除数为非负数，理解为 *a* 的任何除数的负数也能整除 *a*。一个非零整数 *a* 的除数至少为 1 但不超过 |*a*|。例如，24 的除数有
    1、2、3、4、6、8、12 和 24。
- en: Every positive integer *a* is divisible by the ***trivial divisors*** 1 and
    *a*. The nontrivial divisors of *a* are the ***factors*** of *a*. For example,
    the factors of 20 are 2, 4, 5, and 10.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 每个正整数 *a* 都能被 ***平凡除数*** 1 和 *a* 整除。*a* 的非平凡除数是 *a* 的 ***因子***。例如，20 的因子有 2、4、5
    和 10。
- en: '**Prime and composite numbers**'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**质数和合数**'
- en: An integer *a* > 1 whose only divisors are the trivial divisors 1 and *a* is
    a ***prime number*** or, more simply, a ***prime***. Primes have many special
    properties and play a critical role in number theory. The first 20 primes, in
    order, are
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 大于 1 且其唯一除数为 1 和 *a* 的整数 *a* 是 ***质数*** 或者更简单地说是 ***质数***。质数具有许多特殊性质，在数字理论中扮演着关键角色。前
    20 个质数依次为
- en: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 2、3、5、7、11、13、17、19、23、29、31、37、41、43、47、53、59、61、67、71。
- en: Exercise 31.1-2 asks you to prove that there are infinitely many primes. An
    integer *a* > 1 that is not prime is a ***composite number*** or, more simply,
    a ***composite***. For example, 39 is composite because 3 | 39\. We call the integer
    1 a ***unit***, and it is neither prime nor composite. Similarly, the integer
    0 and all negative integers are neither prime nor composite.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 31.1-2 要求你证明存在无限多个质数。大于 1 的整数 *a* 如果不是质数，则是 ***合数*** 或者更简单地说是 ***合数***。例如，39
    是合数，因为 3 | 39。我们称整数 1 为 ***单位***，它既不是质数也不是合数。同样地，整数 0 和所有负整数既不是质数也不是合数。
- en: '**The division theorem, remainders, and modular equivalence**'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '**除法定理、余数和模等价**'
- en: Given an integer *n*, we can partition the integers into those that are multiples
    of *n* and those that are not multiples of *n*. Much number theory is based upon
    refining this partition by classifying the integers that are not multiples of
    *n* according to their remainders when divided by *n*. The following theorem provides
    the basis for this refinement. We omit the proof (but see, for example, Niven
    and Zuckerman [[345](bibliography001.xhtml#endnote_345)]).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 给定整数 *n*，我们可以将整数分为是 *n* 的倍数和不是 *n* 的倍数的整数。许多数论基于通过将不是 *n* 的倍数的整数根据它们除以 *n* 时的余数进行细分来完善这一分区。以下定理为这种细分提供了基础。我们省略了证明（但可参见，例如，Niven
    和 Zuckerman [[345](bibliography001.xhtml#endnote_345)]）。
- en: '***Theorem 31.1 (Division theorem)***'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 31.1（除法定理）***'
- en: For any integer *a* and any positive integer *n*, there exist unique integers
    *q* and *r* such that 0 ≤ *r* < *n* and *a* = *qn* + *r*.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何整数 *a* 和任何正整数 *n*，存在唯一的整数 *q* 和 *r*，使得 0 ≤ *r* < *n* 且 *a* = *qn* + *r*。
- en: ▪
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: The value *q* = ⌊*a*/*n*⌋ is the ***quotient*** of the division. The value *r*
    = *a* mod *n* is the ***remainder*** (or ***residue***) of the division, so that
    *n* | *a* if and only if *a* mod *n* = 0.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 值 *q* = ⌊*a*/*n*⌋ 是除法的***商***。值 *r* = *a* mod *n* 是除法的***余数***（或***剩余***），因此
    *n* | *a* 当且仅当 *a* mod *n* = 0。
- en: The integers partition into *n* equivalence classes according to their remainders
    modulo *n*. The ***equivalence class modulo n*** containing an integer *a* is
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 整数根据它们对 *n* 取模的余数分为 *n* 个等价类。包含整数 *a* 的***模 n 等价类***是
- en: '[*a*][*n*] = {*a* + *kn* : *k* ∈ ℤ}.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '[*a*][*n*] = {*a* + *kn* : *k* ∈ ℤ}。'
- en: For example, [3][7] = {…, –11, –4, 3, 10, 17, …}, and [–4][7] and [10][7] also
    denote this set. With the notation defined on page 64, writing *a* ∈ [*b*][*n*]
    is the same as writing *a* = *b* (mod *n*). The set of all such equivalence classes
    is
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，[3][7] = {…, –11, –4, 3, 10, 17, …}，而 [–4][7] 和 [10][7] 也表示这个集合。根据第 64 页定义的符号，写成
    *a* ∈ [*b*][*n*] 等同于写成 *a* = *b* (mod *n*)。所有这种等价类的集合是
- en: '![art](images/Art_P1131.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1131.jpg)'
- en: When you see the definition
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你看到定义
- en: '![art](images/Art_P1132.jpg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1132.jpg)'
- en: you should read it as equivalent to equation (31.1) with the understanding that
    0 represents [0][*n*], 1 represents [1][*n*], and so on. Each class is represented
    by its smallest nonnegative element. You should keep the underlying equivalence
    classes in mind, however. For example, if we refer to –1 as a member of ℤ[*n*],
    we are really referring to [*n* – 1][*n*], since –1 = *n* – 1 (mod *n*).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该将其理解为等同于方程（31.1），并理解 0 代表 [0][*n*]，1 代表 [1][*n*]，依此类推。每个类别由其最小非负元素表示。然而，你应该牢记底层的等价类。例如，如果我们将
    –1 视为 ℤ[*n*] 的成员，实际上我们指的是 [*n* – 1][*n*]，因为 –1 ≡ *n* – 1 (mod *n*)。
- en: '**Common divisors and greatest common divisors**'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**公约数和最大公约数**'
- en: If *d* is a divisor of *a* and *d* is also a divisor of *b*, then *d* is a ***common
    divisor*** of *a* and *b*. For example, the divisors of 30 are 1, 2, 3, 5, 6,
    10, 15, and 30, and so the common divisors of 24 and 30 are 1, 2, 3, and 6\. Any
    pair of integers has a common divisor of 1.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *d* 是 *a* 的约数，且 *d* 也是 *b* 的约数，则 *d* 是 *a* 和 *b* 的***公约数***。例如，30 的约数是 1、2、3、5、6、10、15
    和 30，因此 24 和 30 的公约数是 1、2、3 和 6。任意一对整数都有一个公约数为 1。
- en: An important property of common divisors is that
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 公约数的一个重要性质是
- en: '![art](images/Art_P1133.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1133.jpg)'
- en: More generally, for any integers *x* and *y*,
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，对于任何整数 *x* 和 *y*，
- en: '![art](images/Art_P1134.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1134.jpg)'
- en: Also, if *a* | *b*, then either |*a*| ≤ |*b*| or *b* = 0, which implies that
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果 *a* | *b*，那么要么 |*a*| ≤ |*b*|，要么 *b* = 0，这意味着
- en: '![art](images/Art_P1135.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1135.jpg)'
- en: The ***greatest common divisor*** of two integers *a* and *b* which are not
    both 0, denoted by gcd(*a*, *b*), is the largest of the common divisors of *a*
    and *b*. For example, gcd(24, 30) = 6, gcd(5, 7) = 1, and gcd(0, 9) = 9\. If *a*
    and *b* are both nonzero, then gcd(*a*, *b*) is an integer between 1 and min {|*a*|,
    |*b*|}. We define gcd(0, 0) to be 0, so that standard properties of the gcd function
    (such as equation (31.9) below) hold universally.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 两个不全为 0 的整数 *a* 和 *b* 的***最大公约数***，表示为 gcd(*a*, *b*)，是 *a* 和 *b* 的公约数中最大的。例如，gcd(24,
    30) = 6，gcd(5, 7) = 1，gcd(0, 9) = 9。如果 *a* 和 *b* 都不为零，则 gcd(*a*, *b*) 是介于 1 和
    min {|*a*|, |*b*|} 之间的整数。我们定义 gcd(0, 0) 为 0，以便 gcd 函数的标准性质（如下面的方程（31.9））普遍成立。
- en: 'Exercise 31.1-9 asks you to prove the following elementary properties of the
    gcd function:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 练习 31.1-9 要求你证明 gcd 函数的以下基本性质：
- en: '![art](images/Art_P1136.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1136.jpg)'
- en: The following theorem provides an alternative and useful way to characterize
    gcd(*a*, *b*).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的定理提供了一种替代且有用的方式来表征 gcd(*a*, *b*)。
- en: '***Theorem 31.2***'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 31.2***'
- en: 'If *a* and *b* are any integers, not both zero, then gcd(*a*, *b*) is the smallest
    positive element of the set {*ax* + *by* : *x*, *y* ∈ ℤ} of linear combinations
    of *a* and *b*.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '如果 *a* 和 *b* 是任意整数，且不全为零，则 gcd(*a*, *b*) 是线性组合{*ax* + *by* : *x*, *y* ∈ ℤ}中的最小正元素。'
- en: '***Proof***   Let *s* be the smallest positive such linear combination of *a*
    and *b*, and let *s* = *ax* + *by* for some *x*, *y* ∈ ℤ. Let *q* = ⌊*a*/*s*⌋.
    Equation (3.11) on page 64 then implies'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   设 *s* 是 *a* 和 *b* 的最小正线性组合，且设 *s* = *ax* + *by*，其中 *x*, *y* ∈ ℤ。设
    *q* = ⌊*a*/*s*⌋。然后，第 64 页上的方程（3.11）暗示'
- en: '| *a* mod *s* | = | *a* – *qs* |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| *a* mod *s* | = | *a* – *qs* |'
- en: '|  | = | *a* – *q*(*ax* + *by*) |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *a* – *q*(*ax* + *by*) |'
- en: '|  | = | *a* (1 – *qx*) + *b* (–*qy*), |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *a* (1 – *qx*) + *b* (–*qy*), |'
- en: so that *a* mod *s* is a linear combination of *a* and *b* as well. Because
    *s* is the smallest *positive* such linear combination and 0 ≤ *a* mod *s* < *s*
    (inequality (3.12) on page 64), *a* mod *s* cannot be positive. Hence, *a* mod
    *s* = 0\. Therefore, we have that *s* | *a* and, by analogous reasoning, *s* |
    *b*. Thus, *s* is a common divisor of *a* and *b*, so that gcd(*a*, *b*) ≥ *s*.
    By definition, gcd(*a*, *b*) divides both *a* and *b*, and *s* is defined as a
    linear combination of *a* and *b*. Equation (31.4) therefore implies that gcd(*a*,
    *b*) | *s*. But gcd(*a*, *b*) | *s* and *s* > 0 imply that gcd(*a*, *b*) ≤ *s*.
    Combining gcd(*a*, *b*) ≥ *s* and gcd(*a*, *b*) ≤ *s* yields gcd(*a*, *b*) = *s*.
    We conclude that *s*, the smallest positive linear combination of *a* and *b*,
    is also their greatest common divisor.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此 *a* mod *s* 也是 *a* 和 *b* 的线性组合。由于 *s* 是最小的*正*线性组合，且 0 ≤ *a* mod *s* < *s*（第
    64 页上的不等式（3.12）），*a* mod *s* 不能为正。因此，*a* mod *s* = 0。因此，我们有 *s* | *a*，并且通过类似的推理，*s*
    | *b*。因此，*s* 是 *a* 和 *b* 的公约数，因此 gcd(*a*, *b*) ≥ *s*。根据定义，gcd(*a*, *b*) 同时整除 *a*
    和 *b*，而 *s* 被定义为 *a* 和 *b* 的线性组合。因此，方程（31.4）暗示了 gcd(*a*, *b*) | *s*。但 gcd(*a*,
    *b*) | *s* 且 *s* > 0 暗示了 gcd(*a*, *b*) ≤ *s*。结合 gcd(*a*, *b*) ≥ *s* 和 gcd(*a*,
    *b*) ≤ *s*，得出 gcd(*a*, *b*) = *s*。我们得出结论，*s*，*a* 和 *b* 的最小正线性组合，也是它们的最大公约数。
- en: ▪
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Theorem 31.2 engenders three useful corollaries.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 31.2 导出了三个有用的推论。
- en: '***Corollary 31.3***'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论 31.3***'
- en: For any integers *a* and *b*, if *d* | *a* and *d* | *b*, then *d* | gcd(*a*,
    *b*).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何整数*a*和*b*，如果*d* | *a*且*d* | *b*，则*d* | gcd(*a*, *b*)。
- en: '***Proof***   This corollary follows from equation (31.4) and Theorem 31.2,
    because gcd(*a*, *b*) is a linear combination of *a* and *b*,'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 这个推论是根据方程(31.4)和定理31.2得出的，因为gcd(*a*, *b*)是*a*和*b*的线性组合，'
- en: ▪
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Corollary 31.4***'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论31.4***'
- en: For all integers *a* and *b* and any nonnegative integer *n*, we have
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有整数*a*和*b*以及任何非负整数*n*，我们有
- en: gcd(*an*, *bn*) = *n* gcd(*a*, *b*).
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: gcd(*an*, *bn*) = *n* gcd(*a*, *b*).
- en: '***Proof***   If *n* = 0, the corollary is trivial. If *n* > 0, then gcd(*an*,
    *bn*) is the smallest positive element of the set {*anx* + *bny* : *x*, *y* ∈
    ℤ}, which in turn is *n* times the smallest positive element of the set {*ax*
    + *by* : *x*, *y* ∈ ℤ}.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 如果*n* = 0，则推论是显然的。如果*n* > 0，则gcd(*an*, *bn*)是集合{*anx* + *bny* : *x*,
    *y* ∈ ℤ}的最小正元素，而这个集合又是集合{*ax* + *by* : *x*, *y* ∈ ℤ}的最小正元素的*n*倍。'
- en: ▪
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Corollary 31.5***'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论31.5***'
- en: For all positive integers *n*, *a*, and *b*, if *n* | *ab* and gcd(*a*, *n*)
    = 1, then *n* | *b*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有正整数*n*、*a*和*b*，如果*n* | *ab*且gcd(*a*, *n*) = 1，则*n* | *b*。
- en: '***Proof***   Exercise 31.1-5 asks you to provide the proof.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 练习31.1-5要求你提供证明。'
- en: ▪
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Relatively prime integers**'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '**互质整数**'
- en: Two integers *a* and *b* are ***relatively prime*** if their only common divisor
    is 1, that is, if gcd(*a*, *b*) = 1\. For example, 8 and 15 are relatively prime,
    since the divisors of 8 are 1, 2, 4, and 8, and the divisors of 15 are 1, 3, 5,
    and 15\. The following theorem states that if two integers are each relatively
    prime to an integer *p*, then their product is relatively prime to *p*.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如果两个整数*a*和*b*的唯一公约数是1，即gcd(*a*, *b*) = 1，则它们是***互质的***。例如，8和15是互质的，因为8的约数是1、2、4和8，而15的约数是1、3、5和15。下面的定理说明，如果两个整数分别与整数*p*互质，那么它们的乘积也与*p*互质。
- en: '***Theorem 31.6***'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理31.6***'
- en: For any integers *a*, *b*, and *p*, we have gcd(*ab*, *p*) = 1 if and only if
    gcd(*a*, *p*) = 1 and gcd(*b*, *p*) = 1 both hold.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何整数*a*、*b*和*p*，当且仅当gcd(*a*, *p*) = 1且gcd(*b*, *p*) = 1成立时，gcd(*ab*, *p*)
    = 1。
- en: '***Proof***   If gcd(*a*, *p*) = 1 and gcd(*b*, *p*) = 1, then it follows from
    Theorem 31.2 that there exist integers *x*, *y*, *x*′, and *y*′ such that'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 如果gcd(*a*, *p*) = 1且gcd(*b*, *p*) = 1，则根据定理31.2可知存在整数*x*、*y*、*x*′和*y*′使得'
- en: '| *ax* + *py* | = | 1, |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| *ax* + *py* | = | 1, |'
- en: '| *bx*′ + *py*′ | = | 1. |'
  id: totrans-70
  prefs: []
  type: TYPE_TB
  zh: '| *bx*′ + *py*′ | = | 1. |'
- en: Multiplying these equations and rearranging gives
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 将这些方程相乘并重新排列得到
- en: '*ab*(*xx*′) + *p*(*ybx*′ + *y*′*ax* + *pyy*′) = 1.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '*ab*(*xx*′) + *p*(*ybx*′ + *y*′*ax* + *pyy*′) = 1。'
- en: Since 1 is thus a positive linear combination of *ab* and *p*, it is the smallest
    positive linear combination. Applying Theorem 31.2 implies gcd(*ab*, *p*) = 1,
    completing the proof in this direction.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 因此1是*ab*和*p*的正线性组合，它是最小的正线性组合。应用定理31.2意味着gcd(*ab*, *p*) = 1，完成了这个方向的证明。
- en: Conversely, if gcd(*ab*, *p*) = 1, then Theorem 31.2 implies that there exist
    integers *x* and *y* such that
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 反之，如果gcd(*ab*, *p*) = 1，则根据定理31.2可知存在整数*x*和*y*使得
- en: '*abx* + *py* = 1.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '*abx* + *py* = 1。'
- en: Writing *abx* as *a*(*bx*) and applying Theorem 31.2 again proves that gcd(*a*,
    *p*) = 1\. Proving that gcd(*b*, *p*) = 1 is similar.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 将*abx*写成*a*(*bx*)并再次应用定理31.2证明gcd(*a*, *p*) = 1。证明gcd(*b*, *p*) = 1类似。
- en: ▪
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Integers *n*[1], *n*[2], …, *n*[*k*] are ***pairwise relatively prime*** if
    gcd(*n*[*i*], *n*[*j*]) = 1 for 1 ≤ *i* < *j* ≤ *k*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 如果整数*n*[1]、*n*[2]、…、*n*[*k*]是***两两互质的***，则对于1 ≤ *i* < *j* ≤ *k*，gcd(*n*[*i*],
    *n*[*j*]) = 1。
- en: '**Unique prime factorization**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**唯一素因数分解**'
- en: An elementary but important fact about divisibility by primes is the following.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 关于被素数整除的一个基本但重要的事实是以下内容。
- en: '***Theorem 31.7***'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理31.7***'
- en: For all primes *p* and all integers *a* and *b*, if *p* | *ab*, then *p* | *a*
    or *p* | *b* (or both).
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有素数*p*和所有整数*a*和*b*，如果*p* | *ab*，则*p* | *a*或*p* | *b*（或两者都是）。
- en: '***Proof***   Assume for the purpose of contradiction that *p* | *ab*, but
    that *p* ∤ *a* and *p* ∤ *b*. Because *p* > 1 and *ab* = *kp* for some *k* ∈ ℤ,
    equation (31.10) gives that gcd(*ab*, *p*) = *p*. We also have that gcd(*a*, *p*)
    = 1 and gcd(*b*, *p*) = 1, since the only divisors of *p* are 1 and *p*, and we
    assumed that *p* divides neither *a* nor *b*. Theorem 31.6 then implies that gcd(*ab*,
    *p*) = 1, contradicting gcd(*ab*, *p*) = *p*. This contradiction completes the
    proof.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 假设为了反证法，*p* | *ab*，但*p* ∤ *a*且*p* ∤ *b*。因为*p* > 1且*ab* = *kp*对某个*k*
    ∈ ℤ成立，方程(31.10)给出gcd(*ab*, *p*) = *p*。由于*p*的约数只有1和*p*，且我们假设*p*既不整除*a*也不整除*b*，所以gcd(*a*,
    *p*) = 1且gcd(*b*, *p*) = 1。定理31.6随后暗示gcd(*ab*, *p*) = 1，与gcd(*ab*, *p*) = *p*矛盾。这个矛盾完成了证明。'
- en: ▪
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: A consequence of Theorem 31.7 is that any composite integer can be uniquely
    factored into a product of primes. Exercise 31.1-11 asks you to provide a proof.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 定理31.7的一个推论是任何合数整数都可以唯一地分解为素数的乘积。练习31.1-11要求你提供一个证明。
- en: '***Theorem 31.8 (Unique prime factorization)***'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理31.8（唯一素因数分解）***'
- en: There is exactly one way to write any composite integer *a* as a product of
    the form
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 任何合数��数*a*都有一种形式的乘积表示方式
- en: '![art](images/Art_P1137.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1137.jpg)'
- en: where the *p*[*i*] are prime, *p*[1] < *p*[2] < … < *p*[*r*], and the *e*[*i*]
    are positive integers.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*p*[*i*]是素数，*p*[1] < *p*[2] < … < *p*[*r*]，*e*[*i*]是正整数。
- en: ▪
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: As an example, the unique prime factorization of the number 6000 is 2⁴ · 3¹
    · 5³.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，数字6000的唯一素因数分解是2⁴ · 3¹ · 5³。
- en: '**Exercises**'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***31.1-1***'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.1-1***'
- en: Prove that if *a* > *b* > 0 and *c* = *a* + *b*, then *c* mod *a* = *b*.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 证明如果*a* > *b* > 0且*c* = *a* + *b*，则*c* mod *a* = *b*。
- en: '***31.1-2***'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.1-2***'
- en: Prove that there are infinitely many primes. (*Hint:* Show that none of the
    primes *p*[1], *p*[2], …, *p*[*k*] divide (*p*[1]*p*[2] ⋯ *p*[*k*]) + 1.)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 证明存在无限多个素数。（*提示：*证明*p*[1]、*p*[2]、…、*p*[*k*]都不整除(*p*[1]*p*[2] ⋯ *p*[*k*]) + 1。）
- en: '***31.1-3***'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.1-3***'
- en: Prove that if *a* | *b* and *b* | *c*, then *a* | *c*.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 证明如果*a* | *b*且*b* | *c*，则*a* | *c*。
- en: '***31.1-4***'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.1-4***'
- en: Prove that if *p* is prime and 0 < *k* < *p*, then gcd(*k*, *p*) = 1.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 证明如果*p*是素数且0 < *k* < *p*，则gcd(*k*, *p*) = 1。
- en: '***31.1-5***'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.1-5***'
- en: Prove Corollary 31.5.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 证明推论31.5。
- en: '***31.1-6***'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.1-6***'
- en: Prove that if *p* is prime and 0 < *k* < *p*, then ![art](images/Art_P1138.jpg).
    Conclude that for all integers *a* and *b* and all primes *p*,
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 证明如果*p*是素数且0 < *k* < *p*，那么![art](images/Art_P1138.jpg)。得出结论，对于所有整数*a*和*b*和所有素数*p*，
- en: (*a* + *b*)^(*p*) = *a*^(*p*) + *b*^(*p*) (mod *p*).
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: (*a* + *b*)^(*p*) = *a*^(*p*) + *b*^(*p*) (mod *p*)。
- en: '***31.1-7***'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.1-7***'
- en: Prove that if *a* and *b* are any positive integers such that *a* | *b*, then
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 证明如果*a*和*b*是任何正��数，使得*a* | *b*，那么
- en: (*x* mod *b*) mod *a* = *x* mod *a*
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: (*x* mod *b*) mod *a* = *x* mod *a*
- en: for any *x*. Prove, under the same assumptions, that
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何*x*。在相同的假设下，证明
- en: '*x* = *y* (mod *b*) implies *x* = *y* (mod *a*)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* = *y* (mod *b*)意味着*x* = *y* (mod *a*)'
- en: for any integers *x* and *y*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何整数*x*和*y*。
- en: '***31.1-8***'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.1-8***'
- en: For any integer *k* > 0, an integer *n* is a ***kth power*** if there exists
    an integer *a* such that *a*^(*k*) = *n*. Furthermore, *n* > 1 is a ***nontrivial
    power*** if it is a *k*th power for some integer *k* > 1\. Show how to determine
    whether a given *β*-bit integer *n* is a nontrivial power in time polynomial in
    *β*.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何大于0的整数*k*，如果存在整数*a*使得*a*^(*k*) = *n*，则整数*n*是一个***k次幂***。此外，如果对于某个大于1的整数*k*，*n*
    > 1是一个***非平凡幂***，则它是一个*k*次幂。展示如何在多项式时间内确定给定的*β*-位整数*n*是否是一个非平凡幂。
- en: '***31.1-9***'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.1-9***'
- en: Prove equations (31.6)–(31.10).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 证明方程（31.6）-（31.10）。
- en: '***31.1-10***'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.1-10***'
- en: Show that the gcd operator is associative. That is, prove that for all integers
    *a*, *b*, and *c*, we have
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 证明gcd运算符是可结合的。也就是说，证明对于所有整数*a*、*b*和*c*，我们有
- en: gcd(*a*, gcd(*b*, *c*)) = gcd(gcd(*a*, *b*), *c*).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: gcd(*a*, gcd(*b*, *c*)) = gcd(gcd(*a*, *b*), *c*)。
- en: ★ ***31.1-11***
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***31.1-11***
- en: Prove Theorem 31.8.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 证明定理31.8。
- en: '***31.1-12***'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.1-12***'
- en: Give efficient algorithms for the operations of dividing a *β*-bit integer by
    a shorter integer and of taking the remainder of a *β*-bit integer when divided
    by a shorter integer. Your algorithms should run in Θ(*β*²) time.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 给出将*β*-位整数除以较短整数和在较短整数除以*β*-位整数时取余的操作的高效算法。你的算法应在Θ(*β*²)时间内运行。
- en: '***31.1-13***'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.1-13***'
- en: Give an efficient algorithm to convert a given *β*-bit (binary) integer to a
    decimal representation. Argue that if multiplication or division of integers whose
    length is at most *β* takes *M*(*β*) time, where *M*(*β*) = Ω(*β*), then you can
    convert binary to decimal in *O*(*M*(*β*) 1g *β*) time. (*Hint:* Use a divide-and-conquer
    approach, obtaining the top and bottom halves of the result with separate recursions.)
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个将给定的*β*-位（二进制）整数转换为十进制表示的高效算法。论证如果长度最多为*β*的整数的乘法或除法需要*M*(*β*)时间，其中*M*(*β*)
    = Ω(*β*)，那么你可以在*O*(*M*(*β*) 1g *β*)时间内将二进制转换为十进制。(*提示:* 使用分治方法，通过单独的递归获得结果的上半部分和下半部分。)
- en: '***31.1-14***'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.1-14***'
- en: Professor Marshall sets up *n* lightbulbs in a row. The lightbulbs all have
    switches, so that if he presses a bulb, it toggles on if it was off and off if
    it was on. The lightbulbs all start off. For *i* = 1, 2, 3, …, *n*, the professor
    presses bulb *i*, 2*i*, 3*i*, …. After the last press, which lightbulbs are on?
    Prove your answer.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 马歇尔教授在一排中设置了*n*个灯泡。所有灯泡都有开关，因此如果他按下一个灯泡，它会在关闭时打开，而在打开时关闭。所有灯泡都是关闭的。对于*i* = 1,
    2, 3, …, *n*，教授按下灯泡*i*，2*i*，3*i*，…. 在最后一次按下后，哪些灯泡是开着的？证明你的答案。
- en: '[**31.2    Greatest common divisor**](toc.xhtml#Rh1-178)'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '[**31.2    最大公约数**](toc.xhtml#Rh1-178)'
- en: In this section, we describe Euclid’s algorithm for efficiently computing the
    greatest common divisor of two integers. When we analyze the running time, we’ll
    see a surprising connection with the Fibonacci numbers, which yield a worst-case
    input for Euclid’s algorithm.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们描述了用于高效计算两个整数的最大公约数的欧几里得算法。当我们分析运行时间时，我们将看到与斐波那契数之间的令人惊讶的联系，这些数为欧几里得算法提供了最坏情况输入。
- en: We restrict ourselves in this section to nonnegative integers. This restriction
    is justified by equation (31.8), which states that gcd(*a*, *b*) = gcd(|*a*|,
    |*b*|).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们限制自己只考虑非负整数。这种限制由方程（31.8）证明，即gcd(*a*, *b*) = gcd(|*a*|, |*b*|)。
- en: In principle, for positive integers *a* and *b*, their prime factorizations
    suffice to compute gcd(*a*, *b*). Indeed, if
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 原则上，对于正整数*a*和*b*，它们的质因数分解足以计算gcd(*a*, *b*)。实际上，如果
- en: '![art](images/Art_P1139.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1139.jpg)'
- en: with 0 exponents being used to make the set of primes *p*[1], *p*[2], …, *p*[*r*]
    the same for both *a* and *b*, then, as Exercise 31.2-1 asks you to show,
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 使用0指数使得用于使得素数集*p*[1]，*p*[2]，…，*p*[*r*]对*a*和*b*相同，然后，正如练习31.2-1要求你展示的那样，
- en: '![art](images/Art_P1140.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1140.jpg)'
- en: The best algorithms to date for factoring do not run in polynomial time. Thus,
    this approach to computing greatest common divisors seems unlikely to yield an
    efficient algorithm.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 迄今为止用于因式分解的最佳算法不在多项式时间内运行。因此，这种计算最大公约数的方法似乎不太可能产生高效的算法。
- en: Euclid’s algorithm for computing greatest common divisors relies on the following
    theorem.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得算法用于计算最大公约数依赖于以下定理。
- en: '***Theorem 31.9 (GCD recursion theorem)***'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理31.9（GCD递归定理）***'
- en: For any nonnegative integer *a* and any positive integer *b*,
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何非负整数*a*和任何正整数*b*，
- en: gcd(*a*, *b*) = gcd(*b*, *a* mod *b*).
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: gcd(*a*, *b*) = gcd(*b*, *a* mod *b*)。
- en: '***Proof***   We will show that gcd(*a*, *b*) and gcd(*b*, *a* mod *b*) divide
    each other. Since they are both nonnegative, equation (31.5) then implies that
    they must be equal.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   我们将证明gcd(*a*, *b*)和gcd(*b*, *a* mod *b*)互相整除。由于它们都是非负的，方程（31.5）随后意味着它们必须相等。'
- en: We first show that gcd(*a*, *b*) | gcd(*b*, *a* mod *b*). If we let *d* = gcd(*a*,
    *b*), then *d* | *a* and *d* | *b*. By equation (3.11) on page 64, *a* mod *b*
    = *a* – *qb*, where *q* = ⌊*a*/*b*⌋. Since *a* mod *b* is thus a linear combination
    of *a* and *b*, equation (31.4) implies that *d* | (*a* mod *b*). Therefore, since
    *d* | *b* and *d* | (*a* mod *b*), Corollary 31.3 implies that *d* | gcd(*b*,
    *a* mod *b*), that is,
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先证明gcd(*a*, *b*) | gcd(*b*, *a* mod *b*)。如果我们令*d* = gcd(*a*, *b*)，那么*d* |
    *a*和*d* | *b*。根据第64页的方程（3.11），*a* mod *b* = *a* - *qb*，其中*q* = ⌊*a*/*b*⌋。因此，由于*a*
    mod *b*因此是*a*和*b*的线性组合，方程（31.4）意味着*d* | (*a* mod *b*)。因此，由于*d* | *b*和*d* | (*a*
    mod *b*)，推论31.3意味着*d* | gcd(*b*, *a* mod *b*)，即
- en: '![art](images/Art_P1141.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1141.jpg)'
- en: Showing that gcd(*b*, *a* mod *b*) | gcd(*a*, *b*) is almost the same. If we
    now let *d* = gcd(*b*, *a* mod *b*), then *d* | *b* and *d* | (*a* mod *b*). Since
    *a* = *qb* + (*a* mod *b*), where *q* = ⌊*a*/*b*⌋, we have that *a* is a linear
    combination of *b* and (*a* mod *b*). By equation (31.4), we conclude that *d*
    | *a*. Since *d* | *b* and *d* | *a*, we have that *d* | gcd(*a*, *b*) by Corollary
    31.3, so that
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 显示gcd(*b*, *a* mod *b*) | gcd(*a*, *b*)几乎相同。如果现在让*d* = gcd(*b*, *a* mod *b*)，那么*d*
    | *b*且*d* | (*a* mod *b*)。由于*a* = *qb* + (*a* mod *b*)，其中*q* = ⌊*a*/*b*⌋，我们有*a*是*b*和(*a*
    mod *b*)的线性组合。根据方程（31.4），我们得出*d* | *a*。由于*d* | *b*且*d* | *a*，根据推论31.3，我们有*d* |
    gcd(*a*, *b*)，因此
- en: '![art](images/Art_P1142.jpg)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1142.jpg)'
- en: Using equation (31.5) to combine equations (31.14) and (31.15) completes the
    proof.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 使用方程（31.5）将方程（31.14）和（31.15）组合完成证明。
- en: ▪
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Euclid’s algorithm**'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '**欧几里得算法**'
- en: Euclid’s *Elements* (circa 300 B.C.E.) describes the following gcd algorithm,
    although its origin might be even earlier. The recursive procedure EUCLID implements
    Euclid’s algorithm, based directly on Theorem 31.9\. The inputs *a* and *b* are
    arbitrary nonnegative integers.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得的《几何原本》（公元前约300年）描述了以下gcd算法，尽管其起源可能更早。递归过程欧几里得实现了欧几里得算法，直接基于定理31.9。输入*a*和*b*是任意非负整数。
- en: EUCLID(*a*, *b*)
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得(*a*, *b*)
- en: '| 1 | **if** *b* == 0 |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **如果** *b* == 0 |'
- en: '| 2 | **return** *a* |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **返回** *a* |'
- en: '| 3 | **else return** EUCLID(*b*, *a* mod *b*) |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **否则返回** 欧几里得(*b*, *a* mod *b*) |'
- en: 'For example, here is how the procedure computes gcd(30, 21):'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这里是过程如何计算gcd(30, 21)：
- en: '| EUCLID(30, 21) | = | EUCLID(21, 9) |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '| 欧几里得(30, 21) | = | 欧几里得(21, 9) |'
- en: '|  | = | EUCLID(9, 3) |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 欧几里得(9, 3) |'
- en: '|  | = | EUCLID(3, 0) |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 欧几里得(3, 0) |'
- en: '|  | = | 3. |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 3. |'
- en: This computation calls EUCLID recursively three times.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 这个计算会递归调用欧几里得三次。
- en: The correctness of EUCLID follows from Theorem 31.9 and the property that if
    the algorithm returns *a* in line 2, then *b* = 0, so that by equation (31.9),
    gcd(*a*, *b*) = gcd(*a*, 0) = *a*. The algorithm cannot recurse indefinitely,
    since the second argument strictly decreases in each recursive call and is always
    nonnegative. Therefore, EUCLID always terminates with the correct answer.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 欧几里得的正确性来自定理31.9和算法在第2行返回*a*时，*b* = 0，因此根据方程（31.9），gcd(*a*, *b*) = gcd(*a*,
    0) = *a*。该算法不会无限递归，因为第二个参数在每次递归调用中严格减少且始终为非负。因此，欧几里得总是以正确答案终止。
- en: '**The running time of Euclid’s algorithm**'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**欧几里得算法的运行时间**'
- en: Let’s analyze the worst-case running time of EUCLID as a function of the size
    of *a* and *b*. The overall running time of EUCLID is proportional to the number
    of recursive calls it makes. The analysis assumes that *a* > *b* ≥ 0, that is,
    the first argument is greater than the second argument. Why? If *b* = *a* > 0,
    then *a* mod *b* = 0 and the procedure terminates after one recursive call. If
    *b* > *a* ≥ 0, then the procedure makes just one more recursive call than when
    *a* > *b*, because in this case EUCLID(*a*, *b*) immediately makes the recursive
    call EUCLID(*b*, *a*), and now the first argument is greater than the second.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析欧几里得算法的最坏情况运行时间作为*a*和*b*大小的函数。欧几里得的总运行时间与其进行的递归调用次数成正比。分析假设*a* > *b* ≥
    0，即第一个参数大于第二个参数。为什么？如果*b* = *a* > 0，则*a* mod *b* = 0，程序在一次递归调用后终止。如果*b* > *a*
    ≥ 0，则程序比*a* > *b*多进行一次递归调用，因为在这种情况下，欧几里得(*a*, *b*)立即进行递归调用欧几里得(*b*, *a*)，现在第一个参数大于第二个参数。
- en: Our analysis relies on the Fibonacci numbers *F*[*k*], defined by the recurrence
    equation (3.31) on page 69.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的分析依赖于斐波那契数*F*[*k*]，由第69页上的递推方程（3.31）定义。
- en: '***Lemma 31.10***'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理31.10***'
- en: If *a* > *b* ≥ 1 and the call EUCLID(*a*, *b*) performs *k* ≥ 1 recursive calls,
    then *a* ≥ *F*[*k*+2] and *b* ≥ *F*[*k*+1].
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*a* > *b* ≥ 1且调用欧几里得(*a*, *b*)进行*k* ≥ 1次递归调用，则*a* ≥ *F*[*k*+2]且*b* ≥ *F*[*k*+1]。
- en: '***Proof***   The proof proceeds by induction on *k*. For the base case of
    the induction, let *k* = 1\. Then, *b* ≥ 1 = *F*[2], and since *a* > *b*, we must
    have *a* ≥ 2 = *F*[3]. Since *b* > (*a* mod *b*), in each recursive call the first
    argument is strictly larger than the second. The assumption that *a* > *b* therefore
    holds for each recursive call.'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   证明通过对*k*归纳进行。对归纳的基础情况，让*k* = 1。那么，*b* ≥ 1 = *F*[2]，由于*a* > *b*，我们必须有*a*
    ≥ 2 = *F*[3]。由于*b* > (*a* mod *b*)，在每次递归调用中，第一个参数严格大于第二个参数。因此，假设*a* > *b*对于每次递归调用都成立。'
- en: Assuming inductively that the lemma holds if the procedure makes *k* – 1 recursive
    calls, we shall prove that the lemma holds for *k* recursive calls. Since *k*
    > 0, we have *b* > 0, and EUCLID(*a*, *b*) calls EUCLID(*b*, *a* mod *b*) recursively,
    which in turn makes *k* – 1 recursive calls. The inductive hypothesis then implies
    that *b* ≥ *F*[*k*+1] (thus proving part of the lemma), and *a* mod *b* ≥ *F*[*k*].
    We have
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 假设归纳地假设如果程序进行*k* – 1次递归调用，则引理对*k*次递归调用成立。我们将证明引理对*k*次递归调用成立。由于*k* > 0，我们有*b*
    > 0，并且欧几里得(*a*, *b*)递归调用欧几里得(*b*, *a* mod *b*)，后者又进行*k* – 1次递归调用。归纳假设然后意味着*b*
    ≥ *F*[*k*+1]（从而证明引理的一部分），且*a* mod *b* ≥ *F*[*k*]。我们有
- en: '| *b* + (*a* mod *b*) | = *b* + (*a* – *b* ⌊*a*/*b*⌋) | (by equation (3.11))
    |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| *b* + (*a* mod *b*) | = *b* + (*a* – *b* ⌊*a*/*b*⌋) | (根据方程（3.11）) |'
- en: '|  | ≤ *a*, |  |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ *a*, |  |'
- en: since *a* > *b* > 0 implies ⌊*a*/*b*⌋ ≥ 1\. Thus,
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*a* > *b* > 0意味着⌊*a*/*b*⌋ ≥ 1。因此，
- en: '| *a* | ≥ | *b* + (*a* mod *b*) |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| *a* | ≥ | *b* + (*a* mod *b*) |'
- en: '|  | ≥ | *F*[*k*+1] + *F*[*k*] |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '|  | ≥ | *F*[*k*+1] + *F*[*k*] |'
- en: '|  | = | *F*[*k*+2]. |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *F*[*k*+2]. |'
- en: ▪
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: The following theorem is an immediate corollary of this lemma.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的定理是这个引理的一个直接推论。
- en: '***Theorem 31.11 (Lamé’s theorem)***'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理31.11（拉梅定理）***'
- en: For any integer *k* ≥ 1, if *a* > *b* ≥ 1 and *b* < *F*[*k*+1], then the call
    EUCLID(*a*, *b*) makes fewer than *k* recursive calls.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何整数*k* ≥ 1，如果*a* > *b* ≥ 1且*b* < *F*[*k*+1]，则调用欧几里得(*a*, *b*)进行的递归调用次数少于*k*次。
- en: ▪
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: To show that the upper bound of Theorem 31.11 is the best possible, we’ll show
    that the call EUCLID(*F*[*k*+1], *F*[*k*]) makes exactly *k* – 1 recursive calls
    when *k* ≥ 2\. We use induction on *k*. For the base case, *k* = 2, and the call
    EUCLID(*F*[3], *F*[2]) makes exactly one recursive call, to EUCLID(1, 0). (We
    have to start at *k* = 2, because when *k* = 1 we do not have *F*[2] > *F*[1].)
    For the inductive step, assume that EUCLID(*F*[*k*], *F*[*k*−1]) makes exactly
    *k* – 2 recursive calls. For *k* > 2, we have *F*[*k*] > *F*[*k*−1] > 0 and *F*[*k*+1]
    = *F*[*k*] + *F*[*k*−1], and so by Exercise 31.1-1, we have *F*[*k*+1] mod *F*[*k*]
    = *F*[*k*−1]. Because EUCLID(*a*, *b*) calls EUCLID(*b*, *a* mod *b*) when *b*
    > 0, the call EUCLID(*F*[*k*+1], *F*[*k*]) recurses one time more than the call
    EUCLID(*F*[*k*], *F*[*k*−1]), or exactly *k* – 1 times, which meets the upper
    bound given by Theorem 31.11.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明定理 31.11 的上界是最佳的，我们将展示当 *k* ≥ 2 时，调用 EUCLID(*F*[*k*+1], *F*[*k*]) 正好进行 *k*
    – 1 次递归调用。我们对 *k* 进行归纳。对于基本情况，*k* = 2，调用 EUCLID(*F*[3], *F*[2]) 正好进行一次递归调用，到 EUCLID(1,
    0)。 (我们必须从 *k* = 2 开始，因为当 *k* = 1 时，我们没有 *F*[2] > *F*[1]。) 对于归纳步骤，假设 EUCLID(*F*[*k*],
    *F*[*k*−1]) 正好进行 *k* – 2 次递归调用。对于 *k* > 2，我们有 *F*[*k*] > *F*[*k*−1] > 0 且 *F*[*k*+1]
    = *F*[*k*] + *F*[*k*−1]，因此根据练习 31.1-1，我们有 *F*[*k*+1] mod *F*[*k*] = *F*[*k*−1]���因为当
    *b* > 0 时 EUCLID(*a*, *b*) 调用 EUCLID(*b*, *a* mod *b*)，所以调用 EUCLID(*F*[*k*+1],
    *F*[*k*]) 比调用 EUCLID(*F*[*k*], *F*[*k*−1]) 多递归一次，或者正好 *k* – 1 次，符合定理 31.11 给出的上界。
- en: Since *F*[*k*] is approximately ![art](images/Art_P1143.jpg), where *ϕ* is the
    golden ratio ![art](images/Art_P1144.jpg) defined by equation (3.32) on page 69,
    the number of recursive calls in EUCLID is *O*(1g *b*). (See Exercise 31.2-5 for
    a tighter bound.) Therefore, a call of EUCLID on two *β*-bit numbers performs
    *O*(*β*) arithmetic operations and *O*(*β*³) bit operations (assuming that multiplication
    and division of *β*-bit numbers take *O*(*β*²) bit operations). Problem 31-2 asks
    you to prove an *O*(*β*²) bound on the number of bit operations.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *F*[*k*] 大约为 ![艺术](images/Art_P1143.jpg)，其中 *ϕ* 是黄金比例 ![艺术](images/Art_P1144.jpg)，由第
    69 页的方程 (3.32) 定义，EUCLID 中的递归调用次数为 *O*(1g *b*)。 (参见练习 31.2-5 以获得更紧密的界限。) 因此，对两个
    *β* 位数进行 EUCLID 调用执行 *O*(*β*) 算术运算和 *O*(*β*³) 位运算（假设 *β* 位数的乘法和除法需要 *O*(*β*²)
    位运算）。问题 31-2 要求您证明位运算数量的 *O*(*β*²) 上界。
- en: '**The extended form of Euclid’s algorithm**'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '**欧几里得算法的扩展形式**'
- en: By rewriting Euclid’s algorithm, we can gain additional useful information.
    Specifically, let’s extend the algorithm to compute the integer coefficients *x*
    and *y* such that
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 通过重新编写欧几里得算法，我们可以获得额外有用的信息。具体来说，让我们扩展算法以计算整数系数 *x* 和 *y*，使得
- en: '![art](images/Art_P1145.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1145.jpg)'
- en: where either or both of *x* and *y* may be zero or negative. These coefficients
    will prove useful later for computing modular multiplicative inverses. The procedure
    EXTENDED-EUCLID takes as input a pair of nonnegative integers and returns a triple
    of the form (*d*, *x*, *y*) that satisfies equation (31.16). As an example, [Figure
    31.1](chapter031.xhtml#Fig_31-1) traces out the call EXTENDED-EUCLID(99, 78).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *x* 和/或 *y* 可能为零或负。这些系数稍后将证明在计算模乘法逆元时非常有用。EXTENDED-EUCLID 程序以一对非负整数作为输入，并返回满足方程
    (31.16) 的形式为 (*d*, *x*, *y*) 的三元组。例如，[图 31.1](chapter031.xhtml#Fig_31-1) 追踪调用
    EXTENDED-EUCLID(99, 78)。
- en: EXTENDED-EUCLID(*a*, *b*)
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: EXTENDED-EUCLID(*a*, *b*)
- en: '| 1 | **if** *b* == 0 |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **如果** *b* == 0 |'
- en: '| 2 | **return** (*a*, 1, 0) |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **返回** (*a*, 1, 0) |'
- en: '| 3 | **else** (*d*′, *x*′, *y*′) = EXTENDED-EUCLID(*b*, *a* mod *b*) |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **否则** (*d*′, *x*′, *y*′) = EXTENDED-EUCLID(*b*, *a* mod *b*) |'
- en: '| 4 | (*d*, *x*, *y*) = (*d*′, *y*′, *x*′ – ⌊*a*/*b*⌋ *y*′) |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 4 | (*d*, *x*, *y*) = (*d*′, *y*′, *x*′ – ⌊*a*/*b*⌋ *y*′) |'
- en: '| 5 | **return** (*d*, *x*, *y*) |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **返回** (*d*, *x*, *y*) |'
- en: The EXTENDED-EUCLID procedure is a variation of the EUCLID procedure. Line 1
    is equivalent to the test “*b* == 0” in line 1 of EUCLID. If *b* = 0, then EXTENDED-EUCLID
    returns not only *d* = *a* in line 2, but also the coefficients *x* = 1 and *y*
    = 0, so that *a* = *ax* + *by*. If *b* ≠ 0, EXTENDED-EUCLID first computes (*d*′,
    *x*′, *y*′) such that *d*′ = gcd(*b*, *a* mod *b*) and
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: EXTENDED-EUCLID 程序是 EUCLID 程序的一个变体。第 1 行相当于 EUCLID 的第 1 行中的测试“*b* == 0”。如果 *b*
    = 0，则 EXTENDED-EUCLID 不仅在第 2 行返回 *d* = *a*，还返回系数 *x* = 1 和 *y* = 0，使得 *a* = *ax*
    + *by*。如果 *b* ≠ 0，则 EXTENDED-EUCLID 首先计算 (*d*′, *x*′, *y*′)，使得 *d*′ = gcd(*b*,
    *a* mod *b*)，并且
- en: '![art](images/Art_P1146.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1146.jpg)'
- en: 'As in the EUCLID procedure, we have *d* = gcd(*a*, *b*) = *d*′ = gcd(*b*, *a*
    mod *b*). To obtain *x* and *y* such that *d* = *ax* + *by*, let’s rewrite equation
    (31.17), setting *d* = *d*′ and using equation (3.11):'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如同 EUCLID 程序一样，我们有 *d* = gcd(*a*, *b*) = *d*′ = gcd(*b*, *a* mod *b*)。为了获得 *x*
    和 *y*，使得 *d* = *ax* + *by*，让我们重新写方程 (31.17)，设定 *d* = *d*′ 并使用方程 (3.11)：
- en: '![art](images/Art_P1147.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1147.jpg)'
- en: '**Figure 31.1** How EXTENDED-EUCLID computes gcd(99, 78). Each line shows one
    level of the recursion: the values of the inputs *a* and *b*, the computed value
    ⌊*a*/*b*⌋, and the values *d*, *x*, and *y* returned. The triple (*d*, *x*, *y*)
    returned becomes the triple (*d*′, *x*′, *y*′) used at the next higher level of
    recursion. The call EXTENDED-EUCLID(99, 78) returns (3, –11, 14), so that gcd(99,
    78) = 3 = 99 · (–11) + 78 · 14.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 31.1** EXTENDED-EUCLID 如何计算 gcd(99, 78)。每行显示递归的一个级别：输入 *a* 和 *b* 的值，计算得到的值
    ⌊*a*/*b*⌋，以及返回的值 *d*、*x* 和 *y*。返回的三元组 (*d*, *x*, *y*) 成为下一个更高级递归级别使用的三元组 (*d*′,
    *x*′, *y*′)。调用 EXTENDED-EUCLID(99, 78) 返回 (3, –11, 14)，因此 gcd(99, 78) = 3 = 99
    · (–11) + 78 · 14。'
- en: '| *d* | = | *bx*′ + (*a* – *b* ⌊*a*/*b*⌋)*y*′ |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| *d* | = | *bx*′ + (*a* – *b* ⌊*a*/*b*⌋)*y*′ |'
- en: '|  | = | *ay*′ + *b*(*x*′ – ⌊*a*/*b*⌋ *y*′). |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *ay*′ + *b*(*x*′ – ⌊*a*/*b*⌋ *y*′). |'
- en: Thus, choosing *x* = *y*′ and *y* = *x*′ – ⌊*a*/*b*⌋ *y*′ satisfies the equation
    *d* = *ax* + *by*, thereby proving the correctness of EXTENDED-EUCLID.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，选择 *x* = *y*′ 和 *y* = *x*′ – ⌊*a*/*b*⌋ *y*′ 满足方程 *d* = *ax* + *by*，从而证明了
    EXTENDED-EUCLID 的正确性。
- en: Since the number of recursive calls made in EUCLID is equal to the number of
    recursive calls made in EXTENDED-EUCLID, the running times of EUCLID and EXTENDED-EUCLID
    are the same, to within a constant factor. That is, for *a* > *b* > 0, the number
    of recursive calls is *O*(1g *b*).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 EUCLID 中递归调用的次数等于 EXTENDED-EUCLID 中的递归调用次数，EUCLID 和 EXTENDED-EUCLID 的运行时间相同，仅相差一个常数因子。也就是说，对于
    *a* > *b* > 0，递归调用次数为 *O*(1g *b*)。
- en: '**Exercises**'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***31.2-1***'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.2-1***'
- en: Prove that equations (31.11) and (31.12) imply equation (31.13).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 证明方程 (31.11) 和 (31.12) 暗示方程 (31.13)。
- en: '***31.2-2***'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.2-2***'
- en: Compute the values (*d*, *x*, *y*) that the call EXTENDED-EUCLID(899, 493) returns.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 计算调用 EXTENDED-EUCLID(899, 493) 返回的值 (*d*, *x*, *y*)。
- en: '***31.2-3***'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.2-3***'
- en: Prove that for all integers *a*, *k*, and *n*,
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 证明对于所有整数 *a*, *k*, 和 *n*，
- en: '![art](images/Art_P1148.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1148.jpg)'
- en: Use equation (31.18) to show that *a* = 1 (mod *n*) implies gcd(*a*, *n*) =
    1.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 利用方程 (31.18) 表明 *a* = 1 (mod *n*) 意味着 gcd(*a*, *n*) = 1。
- en: '***31.2-4***'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.2-4***'
- en: Rewrite EUCLID in an iterative form that uses only a constant amount of memory
    (that is, stores only a constant number of integer values).
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 将 EUCLID 重写为一个迭代形式，只使用恒定数量的内存（即，只存储恒定数量的整数值）。
- en: '***31.2-5***'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.2-5***'
- en: If *a* > *b* ≥ 0, show that the call EUCLID (*a*, *b*) makes at most 1 + log[*ϕ*] *b*
    recursive calls. Improve this bound to 1 + log[*ϕ*](*b*/gcd(*a*, *b)*).
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *a* > *b* ≥ 0，证明调用 EUCLID (*a*, *b*) 最多进行 1 + log[*ϕ*] *b* 次递归调用。将此界限改进为
    1 + log[*ϕ*](*b*/gcd(*a*, *b)*)。
- en: '***31.2-6***'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.2-6***'
- en: What does EXTENDED-EUCLID(*F*[*k*+1], *F*[*k*]) return? Prove your answer correct.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: EXTENDED-EUCLID(*F*[*k*+1], *F*[*k*]) 返回什么？证明你的答案正确。
- en: '***31.2-7***'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.2-7***'
- en: Define the gcd function for more than two arguments by the recursive equation
    gcd(*a*[0], *a*[1], …, *a*[*n*]) = gcd(*a*[0], gcd(*a*[1], *a*[2], …, *a*[*n*])).
    Show that the gcd function returns the same answer independent of the order in
    which its arguments are specified. Also show how to find integers *x*[0], *x*[1],
    …, *x*[*n*] such that gcd(*a*[0], *a*[1], …, *a*[*n*]) = *a*[0]*x*[0] + *a*[1]*x*[1]
    + ⋯ + *a*[*n*]*x*[*n*]. Show that the number of divisions performed by your algorithm
    is *O*(*n* + 1g(max {*a*[0], *a*[1], …, *a*[*n*]})).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 通过递归方程 gcd(*a*[0], *a*[1], …, *a*[*n*]) = gcd(*a*[0], gcd(*a*[1], *a*[2], …,
    *a*[*n*])) 定义多于两个参数的 gcd 函数。证明 gcd 函数返回的答案与指定参数顺序无关。同时展示如何找到整数 *x*[0], *x*[1],
    …, *x*[*n*]，使得 gcd(*a*[0], *a*[1], …, *a*[*n*]) = *a*[0]*x*[0] + *a*[1]*x*[1]
    + ⋯ + *a*[*n*]*x*[*n*]。证明你的算法执行的除法次数为 *O*(*n* + 1g(max {*a*[0], *a*[1], …, *a*[*n*]})。
- en: '***31.2-8***'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.2-8***'
- en: The ***least common multiple*** 1cm(*a*[1], *a*[2], …, *a*[*n*]) of integers
    *a*[1], *a*[2], …, *a*[*n*] is the smallest nonnegative integer that is a multiple
    of each *a*[*i*]. Show how to compute 1cm(*a*[1], *a*[2], …, *a*[*n*]) efficiently
    using the (two-argument) gcd operation as a subroutine.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 整数 *a*[1], *a*[2], …, *a*[*n*] 的***最小公倍数*** 1cm(*a*[1], *a*[2], …, *a*[*n*])
    是每个 *a*[*i*] 的倍数中最小的非负整数。展示如何使用 (双参数) gcd 操作作为子程序高效计算 1cm(*a*[1], *a*[2], …, *a*[*n*])。
- en: '***31.2-9***'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.2-9***'
- en: Prove that *n*[1], *n*[2], *n*[3], and *n*[4] are pairwise relatively prime
    if and only if
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 证明当且仅当 *n*[1], *n*[2], *n*[3], 和 *n*[4] 两两互质时，
- en: gcd(*n*[1]*n*[2], *n*[3]*n*[4]) = gcd(*n*[1]*n*[3], *n*[2]*n*[4]) = 1.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: gcd(*n*[1]*n*[2], *n*[3]*n*[4]) = gcd(*n*[1]*n*[3], *n*[2]*n*[4]) = 1。
- en: More generally, show that *n*[1], *n*[2], …, *n*[*k*] are pairwise relatively
    prime if and only if a set of ⌈1g *k*⌉ pairs of numbers derived from the *n*[*i*]
    are relatively prime.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 更一般地，证明当且仅当 *n*[1], *n*[2], …, *n*[*k*] 两两互质时，从 *n*[*i*] 导出的⌈1g *k*⌉对数中的数字集合是互质的。
- en: '[**31.3    Modular arithmetic**](toc.xhtml#Rh1-179)'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '[**31.3    模算术**](toc.xhtml#Rh1-179)'
- en: Informally, you can think of modular arithmetic as arithmetic as usual over
    the integers, except that when working modulo *n*, then every result *x* is replaced
    by the element of {0, 1, …, *n* – 1} that is equivalent to *x*, modulo *n* (so
    that *x* is replaced by *x* mod *n*). This informal model suffices if you stick
    to the operations of addition, subtraction, and multiplication. A more formal
    model for modular arithmetic, which follows, is best described within the framework
    of group theory.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式地，你可以将模算术视为在整数上的常规算术，只是在模 *n* 下工作时，每个结果 *x* 都被等价于 *x* mod *n* 的 {0, 1, …,
    *n* – 1} 中的元素替换（这样 *x* 被替换为 *x* mod *n*）。如果你坚持使用加法、减法和乘法操作，这种非正式模型就足够了。在群论框架内，��正式的模算术模型最好在此描述。
- en: '**Finite groups**'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '**有限群**'
- en: 'A ***group*** (*S*, ⊕) is a set *S* together with a binary operation ⊕ defined
    on *S* for which the following properties hold:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 一个***群*** (*S*, ⊕) 是一个集合 *S* 和定义在 *S* 上的二元运算 ⊕，满足以下性质：
- en: '**Closure:** For all *a*, *b* ∈ *S*, we have *a* ⊕ *b* ∈ *S*.'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**封闭性：** 对于所有 *a*, *b* ∈ *S*，我们有 *a* ⊕ *b* ∈ *S*。'
- en: '**Identity:** There exists an element *e* ∈ *S*, called the ***identity***
    of the group, such that *e* ⊕ *a* = *a* ⊕ *e* = *a* for all *a* ∈ *S*.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**单位元：** 存在一个元素 *e* ∈ *S*，称为群的***单位元***，满足对于所有 *a* ∈ *S*，*e* ⊕ *a* = *a* ⊕
    *e* = *a*。'
- en: '**Associativity:** For all *a*, *b*, *c* ∈ *S*, we have (*a* ⊕ *b*) ⊕ *c* =
    *a* ⊕ (*b* ⊕ *c*).'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**结合律：** 对于所有 *a*, *b*, *c* ∈ *S*，我们有 (*a* ⊕ *b*) ⊕ *c* = *a* ⊕ (*b* ⊕ *c*)。'
- en: '**Inverses:** For each *a* ∈ *S*, there exists a unique element *b* ∈ *S*,
    called the ***inverse*** of *a*, such that *a* ⊕ *b* = *b* ⊕ *a* = *e*.'
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**逆元：** 对于每个 *a* ∈ *S*，存在一个唯一的元素 *b* ∈ *S*，称为 *a* 的***逆元***，满足 *a* ⊕ *b* =
    *b* ⊕ *a* = *e*。'
- en: 'As an example, consider the familiar group (ℤ, +) of the integers ℤ under the
    operation of addition: 0 is the identity, and the inverse of *a* is –*a*. An ***abelian
    group*** (*S*, ⊕) satisfies the ***commutative law*** *a* ⊕ *b* = *b* ⊕ *a* for
    all *a*, *b* ∈ *S*. The ***size*** of group (*S*, ⊕) is |*S*|, and if |*S*| <
    ∞, then (*S*, ⊕) is a ***finite group***.'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 举个例子，考虑整数集 ℤ 下的加法运算构成的熟知群 (ℤ, +)：0 是单位元，*a* 的逆元是 –*a*。一个***阿贝尔群*** (*S*, ⊕)
    满足所有 *a*, *b* ∈ *S* 都有 *a* ⊕ *b* = *b* ⊕ *a* 的***交换律***。群 (*S*, ⊕) 的***大小***为
    |*S*|，如果 |*S*| < ∞，则 (*S*, ⊕) 是一个***有限群***。
- en: '**The groups defined by modular addition and multiplication**'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '**由模加法和乘法定义的群**'
- en: We can form two finite abelian groups by using addition and multiplication modulo
    *n*, where *n* is a positive integer. These groups are based on the equivalence
    classes of the integers modulo *n*, defined in [Section 31.1](chapter031.xhtml#Sec_31.1).
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用模 *n* 的加法和乘法形成两个有限的阿贝尔群，其中 *n* 是正整数。这些群基于模 *n* 的整数的等价类，定义在 [第 31.1 节](chapter031.xhtml#Sec_31.1)
    中。
- en: To define a group on ℤ[*n*], we need suitable binary operations, which we obtain
    by redefining the ordinary operations of addition and multiplication. We can define
    addition and multiplication operations for ℤ[*n*], because the equivalence class
    of two integers uniquely determines the equivalence class of their sum or product.
    That is, if *a* = *a*′ (mod *n*) and *b* = *b*′ (mod *n*), then
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 ℤ[*n*] 上定义一个群，我们需要适当的二元运算，这可以通过重新定义加法和乘法来实现。我们可以为 ℤ[*n*] 定义加法和乘法运算，因为两个整数的等价类唯一确定它们的和或积的等价类。也就是说，如果
    *a* = *a*′ (mod *n*) 和 *b* = *b*′ (mod *n*)，那么
- en: '| *a* + *b* | = | *a*′ + *b*′ | (mod *n*), |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| *a* + *b* | = | *a*′ + *b*′ | (mod *n*), |'
- en: '| *ab* | = | *a*′*b*′ | (mod *n*). |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| *ab* | = | *a*′*b*′ | (mod *n*). |'
- en: Thus, we define addition and multiplication modulo *n*, denoted +[*n*] and ·[*n*],
    by
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们通过以下方式定义模 *n* 的加法和乘法，记作 +[*n*] 和 ·[*n*]：
- en: '![art](images/Art_P1149.jpg)'
  id: totrans-236
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1149.jpg)'
- en: (We can define subtraction similarly on ℤ[*n*] by [*a*][*n*] –[*n*] [*b*][*n*]
    = [*a* – *b*][*n*], but division is more complicated, as we’ll see.) These facts
    justify the common and convenient practice of using the smallest nonnegative element
    of each equivalence class as its representative when performing computations in
    ℤ[*n*]. We add, subtract, and multiply as usual on the representatives, but we
    replace each result *x* by the representative of its class, that is, by *x* mod
    *n*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: (我们可以类似地在ℤ[*n*]上定义减法，即 [*a*][*n*] –[*n*] [*b*][*n*] = [*a* – *b*][*n*]，但是除法更加复杂，我们将在后面看到。)
    这些事实证明了在ℤ[*n*]中进行计算时使用每个等价类的最小非负元素作为其代表是常见且方便的做法。我们在代表元素上像往常一样进行加法、减法和乘法运算，但是将每个结果
    *x* 替换为其等价类的代表元素，即 *x* mod *n*。
- en: '![art](images/Art_P1150.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1150.jpg)'
- en: '**Figure 31.2** Two finite groups. Equivalence classes are denoted by their
    representative elements. **(a)** The group (ℤ[6], +[6]). **(b)** The group ![art](images/Art_P1151.jpg).'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 31.2** 两个有限群。等价类由其代表元素表示。 **(a)** 群 (ℤ[6], +[6])。 **(b)** 群 ![艺术](images/Art_P1151.jpg)。'
- en: Using this definition of addition modulo *n*, we define the ***additive group
    modulo n*** as (ℤ[*n*], +[*n*]). The size of the additive group modulo *n* is
    |ℤ[*n*]| = *n*. [Figure 31.2(a)](chapter031.xhtml#Fig_31-2) gives the operation
    table for the group (ℤ[6], +[6]).
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这个模 *n* 的加法定义，我们将***模 *n* 的加法群***定义为 (ℤ[*n*], +[*n*])。模 *n* 的加法群的大小是 |ℤ[*n*]|
    = *n*。[图 31.2(a)](chapter031.xhtml#Fig_31-2) 给出了群 (ℤ[6], +[6]) 的运算表。
- en: '***Theorem 31.12***'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 31.12***'
- en: The system (ℤ[*n*], +[*n*]) is a finite abelian group.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 系统(ℤ[*n*], +[*n*])是一个有限的阿贝尔群。
- en: '***Proof***   Equation (31.19) shows that (ℤ[*n*], +[*n*]) is closed. Associativity
    and commutativity of +[*n*] follow from the associativity and commutativity of
    +:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   方程 (31.19) 表明 (ℤ[*n*], +[*n*]) 是封闭的。+[*n*] 的结合性和交换性来自于 + 的结合性和交换性：'
- en: '| ([*a*][*n*] +[*n*] [*b*][*n*]) +[*n*] [*c*][*n*] | = | [*a* + *b*][*n*] +[*n*]
    [*c*][*n*] |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| ([*a*][*n*] +[*n*] [*b*][*n*]) +[*n*] [*c*][*n*] | = | [*a* + *b*][*n*] +[*n*]
    [*c*][*n*] |'
- en: '|  | = | [(*a* + *b*) + *c*][*n*] |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '|  | = | [(*a* + *b*) + *c*][*n*] |'
- en: '|  | = | [*a* + (*b* + *c*)][*n*] |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '|  | = | [*a* + (*b* + *c*)][*n*] |'
- en: '|  | = | [*a*][*n*] +[*n*] [*b* + *c*][*n*] |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '|  | = | [*a*][*n*] +[*n*] [*b* + *c*][*n*] |'
- en: '|  | = | [*a*][*n*] +[*n*] ([*b*][*n*] +[*n*] [*c*][*n*]), |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '|  | = | [*a*][*n*] +[*n*] ([*b*][*n*] +[*n*] [*c*][*n*]), |'
- en: '|   |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '|   |'
- en: '| [*a*][*n*] +[*n*] [*b*][*n*] | = | [*a* + *b*][*n*] |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| [*a*][*n*] +[*n*] [*b*][*n*] | = | [*a* + *b*][*n*] |'
- en: '|  | = | [*b* + *a*][*n*] |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '|  | = | [*b* + *a*][*n*] |'
- en: '|  | = | [*b*][*n*] +[*n*] [*a*][*n*]. |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '|  | = | [*b*][*n*] +[*n*] [*a*][*n*]. |'
- en: The identity element of (ℤ[*n*], +[*n*]) is 0 (that is, [0][*n*]). The (additive)
    inverse of an element *a* (that is, of [*a*][*n*]) is the element –*a* (that is,
    [–*a*][*n*] or [*n* – *a*][*n*]), since [*a*][*n*] +[*n*] [–*a*][*n*] = [*a* –
    *a*][*n*] = [0][*n*].
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: (ℤ[*n*], +[*n*])的单位元素是 0 (即 [0][*n*])。元素 *a* (即 [*a*][*n*])的(加法)逆元素是 –*a* (即
    [–*a*][*n*] 或 [*n* – *a*][*n*])，因为 [*a*][*n*] +[*n*] [–*a*][*n*] = [*a* – *a*][*n*]
    = [0][*n*]。
- en: ▪
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: 'Using the definition of multiplication modulo *n*, we define the ***multiplicative
    group modulo n*** as ![art](images/Art_P1152.jpg). The elements of this group
    are the set ![art](images/Art_P1153.jpg) of elements in ℤ[*n*] that are relatively
    prime to *n*, so that each one has a unique inverse, modulo *n*:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 利用模 *n* 的乘法定义，我们将***模 *n* 的乘法群***定义为 ![艺术](images/Art_P1152.jpg)。这个群的元素是集合 ![艺术](images/Art_P1153.jpg)
    中与 *n* 互质的ℤ[*n*]中的元素，因此每个元素在模 *n* 下都有唯一的逆元：
- en: '![art](images/Art_P1154.jpg)'
  id: totrans-256
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1154.jpg)'
- en: 'To see that ![art](images/Art_P1153.jpg) is well defined, note that for 0 ≤
    *a* < *n*, we have *a* = (*a* + *kn*) (mod *n*) for all integers *k*. By Exercise
    31.2-3, therefore, gcd(*a*, *n*) = 1 implies gcd(*a* + *kn*, *n*) = 1 for all
    integers *k*. Since [*a*][*n*] = {*a* + *kn* : *k* ∈ ℤ}, the set ![art](images/Art_P1153.jpg)
    is well defined. An example of such a group is'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '要看到 ![艺术](images/Art_P1153.jpg) 是良定义的，注意对于 0 ≤ *a* < *n*，我们有 *a* = (*a* + *kn*)
    (mod *n*) 对于所有整数 *k*。因此，根据练习 31.2-3，gcd(*a*, *n*) = 1 意味着对于所有整数 *k*，gcd(*a* +
    *kn*, *n*) = 1。由于 [*a*][*n*] = {*a* + *kn* : *k* ∈ ℤ}，集合 ![艺术](images/Art_P1153.jpg)
    是良定义的。这样的一个群的一个例子是'
- en: '![art](images/Art_P1157.jpg)'
  id: totrans-258
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1157.jpg)'
- en: where the group operation is multiplication modulo 15\. (We have denoted an
    element [*a*][15] as *a*, and thus, for example, we denote [7][15] as 7.) [Figure
    31.2(b)](chapter031.xhtml#Fig_31-2) shows the group ![art](images/Art_P1158.jpg).
    For example, 8 · 11 = 13 (mod 15), working in ![art](images/Art_P1159.jpg). The
    identity for this group is 1.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 其中群操作是模 15 的乘法。(我们将元素 [*a*][15] 记为 *a*，因此，例如，我们将 [7][15] 记为 7。) [图 31.2(b)](chapter031.xhtml#Fig_31-2)
    展示了群 ![艺术](images/Art_P1158.jpg)。例如，8 · 11 = 13 (mod 15)，在 ![艺术](images/Art_P1159.jpg)
    中进行计算。这个群的单位元素是 1。
- en: '***Theorem 31.13***'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 31.13***'
- en: The system ![art](images/Art_P1160.jpg) is a finite abelian group.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 系统 ![艺术](images/Art_P1160.jpg) 是一个有限的阿贝尔群。
- en: '***Proof***   Theorem 31.6 implies that ![art](images/Art_P1152.jpg) is closed.
    Associativity and commutativity can be proved for ·[*n*] as they were for +[*n*]
    in the proof of Theorem 31.12\. The identity element is [1][*n*]. To show the
    existence of inverses, let *a* be an element of ![art](images/Art_P1153.jpg) and
    let (*d*, *x*, *y*) be returned by EXTENDED-EUCLID(*a*, *n*). Then we have *d*
    = 1, since ![art](images/Art_P1163.jpg), and'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 定理31.6暗示着![art](images/Art_P1152.jpg)是封闭的。结合律和交换律可以像在定理31.12的证明中对+[*n*]一样对·[*n*]进行证明。单位元素是[1][*n*]。为了显示逆元的存在，让*a*是![art](images/Art_P1153.jpg)的一个元素，让EXTENDED-EUCLID(*a*,
    *n*)返回(*d*, *x*, *y*)。然后我们有*d* = 1，因为![art](images/Art_P1163.jpg)，并且'
- en: '![art](images/Art_P1164.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1164.jpg)'
- en: or equivalently,
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 或者等价地，
- en: '*ax* = 1 (mod *n*).'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '*ax* = 1 (mod *n*)。'
- en: Thus [*x*][*n*] is a multiplicative inverse of [*a*][*n*], modulo *n*. Furthermore,
    we claim that ![art](images/Art_P1165.jpg). To see why, equation (31.20) demonstrates
    that the smallest positive linear combination of *x* and *n* must be 1\. Therefore,
    Theorem 31.2 implies that gcd(*x*, *n*) = 1\. We defer the proof that inverses
    are uniquely defined until Corollary 31.26 in [Section 31.4](chapter031.xhtml#Sec_31.4).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 因此[*x*][*n*]是[*a*][*n*]的乘法逆元，模*n*。此外，我们声称![art](images/Art_P1165.jpg)。为了理解为什么，方程(31.20)表明*x*和*n*的最小正线性组合必须是1。因此，定理31.2暗示gcd(*x*,
    *n*) = 1。我们将推迟证明逆元是唯一定义的，直到[第31.4节](chapter031.xhtml#Sec_31.4)的推论31.26。
- en: ▪
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: As an example of computing multiplicative inverses, suppose that *a* = 5 and
    *n* = 11\. Then EXTENDED-EUCLID(*a*, *n*) returns (*d*, *x*, *y*) = (1, –2, 1),
    so that 1 = 5 · (–2) + 11 · 1\. Thus, [–2][11] (i.e., [9][11]) is the multiplicative
    inverse of [5][11].
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 作为计算乘法逆元的一个例子，假设*a* = 5，*n* = 11。然后EXTENDED-EUCLID(*a*, *n*)返回(*d*, *x*, *y*)
    = (1, –2, 1)，因此1 = 5 · (–2) + 11 · 1。因此，[–2][11]（即[9][11]）是[5][11]的乘法逆元。
- en: 'When working with the groups (ℤ[*n*], +[*n*]) and ![art](images/Art_P1160.jpg)
    in the remainder of this chapter, we follow the convenient practice of denoting
    equivalence classes by their representative elements and denoting the operations
    +[*n*] and ·[*n*] by the usual arithmetic notations + and · (or juxtaposition,
    so that *ab* = *a* · *b*) respectively. Furthermore, equivalences modulo *n* may
    also be interpreted as equations in ℤ[*n*]. For example, the following two statements
    are equivalent:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的其余部分处理(ℤ[*n*], +[*n*])和![art](images/Art_P1160.jpg)群时，我们遵循便利的做法，用其代表元素表示等价类，并用通常的算术符号+和·（或并置，使得*ab*
    = *a* · *b*）表示操作+[*n*]和·[*n*]。此外，模*n*的等价关系也可以解释为ℤ[*n*]中的方程。例如，以下两个陈述是等价的：
- en: '*ax* = *b* (mod *n*)'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '*ax* = *b* (mod *n*)'
- en: and
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '[*a*][*n*] ·[*n*] [*x*][*n*] = [*b*][*n*].'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '[*a*][*n*] ·[*n*] [*x*][*n*] = [*b*][*n*]。'
- en: As a further convenience, we sometimes refer to a group (*S*, ⊕) merely as *S*
    when the operation ⊕ is understood from context. We may thus refer to the groups
    (ℤ[*n*], +[*n*]) and ![art](images/Art_P1160.jpg) as just ℤ[*n*] and ![art](images/Art_P1153.jpg),
    respectively.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 为了进一步方便起见，我们有时仅在上下文中理解操作⊕时将群(*S*, ⊕)简称为*S*。因此，我们可以将群(ℤ[*n*], +[*n*])和![art](images/Art_P1160.jpg)分别简称为ℤ[*n*]和![art](images/Art_P1153.jpg)。
- en: We denote the (multiplicative) inverse of an element *a* by (*a*^(−1) mod *n*).
    Division in ![art](images/Art_P1153.jpg) is defined by the equation *a*/*b* =
    *ab*^(−1) (mod *n*). For example, in ![art](images/Art_P1159.jpg) we have that
    7^(−1) = 13 (mod 15), since 7 · 13 = 91 = 1 (mod 15), so that 2/7 = 2 · 13 = 11
    (mod 15).
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将元素*a*的（乘法）逆元表示为(*a*^(−1) mod *n*)。在![art](images/Art_P1153.jpg)中，除法由等式*a*/*b*
    = *ab*^(−1) (mod *n*)定义。例如，在![art](images/Art_P1159.jpg)中，我们有7^(−1) = 13 (mod
    15)，因为7 · 13 = 91 = 1 (mod 15)，所以2/7 = 2 · 13 = 11 (mod 15)。
- en: The size of ![art](images/Art_P1153.jpg) is denoted *ϕ*(*n*). This function,
    known as ***Euler’s phi function***, satisfies the equation
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![art](images/Art_P1153.jpg)的大小用*ϕ*(*n*)表示。这个函数，被称为***欧拉函数***，满足方程'
- en: '![art](images/Art_P1172.jpg)'
  id: totrans-276
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1172.jpg)'
- en: so that *p* runs over all the primes dividing *n* (including *n* itself, if
    *n* is prime). We won’t prove this formula here. Intuitively, begin with a list
    of the *n* remainders {0, 1, …, *n* – 1} and then, for each prime *p* that divides
    *n*, cross out every multiple of *p* in the list. For example, since the prime
    divisors of 45 are 3 and 5,
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 使得*p*遍历所有除*n*（包括*n*本身，如果*n*是素数）的素数。我们不会在这里证明这个公式。直觉上，从一个余数列表{0, 1, …, *n* –
    1}开始，然后对于每个能整除*n*的素数*p*，在列表中划掉*p*的所有倍数。例如，由于45的素数因子是3和5，
- en: '![art](images/Art_P1173.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1173.jpg)'
- en: If *p* is prime, then ![art](images/Art_P1174.jpg), and
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*p*是素数，则![art](images/Art_P1174.jpg)，且
- en: '![art](images/Art_P1175.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1175.jpg)'
- en: If *n* is composite, then *ϕ*(*n*) < *n* – 1, although it can be shown that
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*n*是合数，则*ϕ*(*n*) < *n* – 1，尽管可以证明
- en: '![art](images/Art_P1176.jpg)'
  id: totrans-282
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1176.jpg)'
- en: for *n* ≥ 3, where *γ* = 0.5772156649 … is ***Euler’s constant***. A somewhat
    simpler (but looser) lower bound for *n* > 5 is
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*n* ≥ 3，其中*γ* = 0.5772156649 … 是***欧拉常数***。对于*n* > 5，一个稍微简单（但更松散）的下界是
- en: '![art](images/Art_P1177.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1177.jpg)'
- en: The lower bound (31.23) is essentially the best possible, since
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 下界(31.23)基本上是最佳的，因为
- en: '![art](images/Art_P1178.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1178.jpg)'
- en: '**Subgroups**'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**子群**'
- en: If (*S*, ⊕) is a group, *S*′ ⊆ *S*, and (*S*′, ⊕) is also a group, then (*S*′,
    ⊕) is a ***subgroup*** of (*S*, ⊕). For example, the even integers form a subgroup
    of the integers under the operation of addition. The following theorem, whose
    proof we leave as Exercise 31.3-3, provides a useful tool for recognizing subgroups.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果(*S*, ⊕)是一个群，*S*′ ⊆ *S*，且(*S*′, ⊕)也是一个群，则(*S*′, ⊕)是(*S*, ⊕)的***子群***。例如，偶整数构成了整数加法运算下的一个子群。下面的定理，我们将其证明留作练习31.3-3，为识别子群提供了一个有用的工具。
- en: '***Theorem 31.14 (A nonempty closed subset of a finite group is a subgroup)***'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理31.14（有限群的非空闭子集是子群）***'
- en: If (*S*, ⊕) is a finite group and *S*′ is any nonempty subset of *S* such that
    *a* ⊕ *b* ∈ *S*′ for all *a*, *b* ∈ *S*′, then (*S*′, ⊕) is a subgroup of (*S*,
    ⊕).
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 如果(*S*, ⊕)是一个有限群，*S*′是*S*的任意非空子集，使得对于所有*a*, *b* ∈ *S*′，*a* ⊕ *b* ∈ *S*′，那么(*S*′,
    ⊕)是(*S*, ⊕)的一个子群。
- en: ▪
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: For example, the set {0, 2, 4, 6} forms a subgroup of ℤ[8], since it is nonempty
    and closed under the operation + (that is, it is closed under +[8]).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，集合 {0, 2, 4, 6} 构成 ℤ[8] 的一个子群，因为它非空且在加法操作 + 下封闭（即，它在 +[8] 下封闭）。
- en: The following theorem, whose proof is omitted, provides an extremely useful
    constraint on the size of a subgroup.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的定理，其证明被省略了，为子群的大小提供了一个极其有用的约束。
- en: '***Theorem 31.15 (Lagrange’s theorem)***'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 31.15（拉格朗日定理）***'
- en: If (*S*, ⊕) is a finite group and (*S*′, ⊕) is a subgroup of (*S*, ⊕), then
    |*S*′| is a divisor of |*S*|.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 (*S*, ⊕) 是一个有限群，而 (*S*′, ⊕) 是 (*S*, ⊕) 的一个子群，则 |*S*′| 是 |*S*| 的一个约数。
- en: ▪
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: A subgroup *S*′ of a group *S* is a ***proper*** subgroup if *S*′ ≠ *S*. We’ll
    use the following corollary in the analysis in [Section 31.8](chapter031.xhtml#Sec_31.8)
    of the Miller-Rabin primality test procedure.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 群 *S* 的子群 *S*′ 如果 *S*′ ≠ *S* 则称为 ***真子群***。我们将在 [第 31.8 节](chapter031.xhtml#Sec_31.8)
    的 Miller-Rabin 素性测试过程分析中使用以下推论。
- en: '***Corollary 31.16***'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论 31.16***'
- en: If *S*′ is a proper subgroup of a finite group *S*, then |*S*′| ≤ |*S*|/2.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *S*′ 是有限群 *S* 的一个真子群，则 |*S*′| ≤ |*S*|/2。
- en: ▪
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Subgroups generated by an element**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**由元素生成的子群**'
- en: 'Theorem 31.14 affords us a straightforward way to produce a subgroup of a finite
    group (*S*, ⊕): choose an element *a* and take all elements that can be generated
    from *a* using the group operation. Specifically, define *a*^((*k*)) for *k* ≥
    1 by'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 定理 31.14 为我们提供了一种简单的方法来生成一个有限群 (*S*, ⊕) 的子群：选择一个元素 *a*，并取所有可以使用群操作从 *a* 生成的元素。具体地，对于
    *k* ≥ 1，定义 *a*^((*k*)) 为
- en: '![art](images/Art_P1179.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1179.jpg)'
- en: For example, taking *a* = 2 in the group ℤ[6] yields the sequence
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在群 ℤ[6] 中取 *a* = 2，得到序列
- en: '*a*^((1)), *a*^((2)), *a*^((3)), … = 2, 4, 0, 2, 4, 0, 2, 4, 0, ….'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*^((1)), *a*^((2)), *a*^((3)), … = 2, 4, 0, 2, 4, 0, 2, 4, 0, ….'
- en: We have *a*^((*k*)) = *ka* mod *n* in the group ℤ[*n*], and *a*^((*k*)) = *a*^(*k*)
    mod *n* in the group ![art](images/Art_P1153.jpg). We define the ***subgroup generated
    by a***, denoted 〈*a*〉 or (〈*a*〉, ⊕), by
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在群 ℤ[*n*] 中，我们有 *a*^((*k*)) = *ka* mod *n*，而在 ![art](images/Art_P1153.jpg) 中，我们有
    *a*^((*k*)) = *a*^(*k*) mod *n*。我们通过以下方式定义 ***由 a 生成的子群***，记为 〈*a*〉 或 (〈*a*〉,
    ⊕)，
- en: '〈*a*〉 = {*a*^((*k*)) : *k* ≥ 1}.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '〈*a*〉 = {*a*^((*k*)) : *k* ≥ 1}.'
- en: We say that *a* ***generates*** the subgroup 〈*a*〉 or that *a* is a ***generator***
    of 〈*a*〉. Since *S* is finite, 〈*a*〉 is a finite subset of *S*, possibly including
    all of *S*. Since the associativity of ⊕ implies
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说 *a* ***生成*** 子群 〈*a*〉 或 *a* 是 〈*a*〉 的 ***生成元***。由于 *S* 是有限的，〈*a*〉 是 *S*
    的一个有限子集，可能包括所有 *S* 中的元素。由于 ⊕ 的结合性意味着
- en: '*a*^((*i*)) ⊕ *a*^((*j*)) = *a*^((*i*+*j*)),'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*^((*i*)) ⊕ *a*^((*j*)) = *a*^((*i*+*j*)),'
- en: 〈*a*〉 is closed and therefore, by Theorem 31.14, 〈*a*〉 is a subgroup of *S*.
    For example, in ℤ[6], we have
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 〈*a*〉 是封闭的，因此根据定理 31.14，〈*a*〉 是 *S* 的一个子群。例如，在 ℤ[6] 中，我们有
- en: '| 〈0〉 | = | {0}, |'
  id: totrans-311
  prefs: []
  type: TYPE_TB
  zh: '| 〈0〉 | = | {0}, |'
- en: '| 〈1〉 | = | {0, 1, 2, 3, 4, 5}, |'
  id: totrans-312
  prefs: []
  type: TYPE_TB
  zh: '| 〈1〉 | = | {0, 1, 2, 3, 4, 5}, |'
- en: '| 〈2〉 | = | {0, 2, 4}. |'
  id: totrans-313
  prefs: []
  type: TYPE_TB
  zh: '| 〈2〉 | = | {0, 2, 4}. |'
- en: Similarly, in ![art](images/Art_P1181.jpg), we have
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，在 ![art](images/Art_P1181.jpg) 中，我们有
- en: '| 〈1〉 | = | {1}, |'
  id: totrans-315
  prefs: []
  type: TYPE_TB
  zh: '| 〈1〉 | = | {1}, |'
- en: '| 〈2〉 | = | {1, 2, 4}, |'
  id: totrans-316
  prefs: []
  type: TYPE_TB
  zh: '| 〈2〉 | = | {1, 2, 4}, |'
- en: '| 〈3〉 | = | {1, 2, 3, 4, 5, 6}. |'
  id: totrans-317
  prefs: []
  type: TYPE_TB
  zh: '| 〈3〉 | = | {1, 2, 3, 4, 5, 6}. |'
- en: The ***order*** of *a* (in the group *S*), denoted ord(*a*), is defined as the
    smallest positive integer *t* such that *a*^((*t*)) = *e*. (Recall that *e* ∈
    *S* is the group identity.)
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '*a* 的 ***阶***（在群 *S* 中），记为 ord(*a*)，被定义为最小正整数 *t*，使得 *a*^((*t*)) = *e*。（回想
    *e* ∈ *S* 是群的单位元。）'
- en: '***Theorem 31.17***'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 31.17***'
- en: For any finite group (*S*, ⊕) and any *a* ∈ *S*, the order of *a* is equal to
    the size of the subgroup it generates, or ord(*a*) = |〈*a*〉|.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意有限群 (*S*, ⊕) 和任意 *a* ∈ *S*，*a* 的阶等于它生成的子群的大小，即 ord(*a*) = |〈*a*〉|。
- en: '***Proof***   Let *t* = ord(*a*). Since *a*^((*t*)) = *e* and *a*^((*t*+*k*))
    = *a*^((*t*)) ⊕ *a*^((*k*)) = *a*^((*k*)) for *k* ≥ 1, if *i* > *t*, then *a*^((*i*))
    = *a*^((*j*)) for some *j* < *i*. Therefore, as we generate elements by *a*, we
    see no new elements after *a*^((*t*)). Thus, 〈*a*〉 = {*a*^((1)), *a*^((2)), …,
    *a*^((*t*))}, and so |〈*a*〉| ≤ *t*. To show that |〈*a*〉| ≥ *t*, we show that each
    element of the sequence *a*^((1)), *a*^((2)), …, *a*^((*t*)) is distinct. Suppose
    for the purpose of contradiction that *a*^((*i*)) = *a*^((*j*)) for some *i* and
    *j* satisfying 1 ≤ *i* < *j* ≤ *t*. Then, *a*^((*i*+*k*)) = *a*^((*j*+*k*)) for
    *k* ≥ 0\. But this equation implies that *a*^((*i*+(*t*–*j*))) = *a*^((*j*+(*t*–*j*)))
    = *e*, a contradiction, since *i* + (*t* – *j*) < *t* but *t* is the least positive
    value such that *a*^((*t*)) = *e*. Therefore, each element of the sequence *a*^((1)),
    *a*^((2)), …, *a*^((*t*)) is distinct, and |〈*a*〉| ≥ *t*. We conclude that ord(*a*)
    = |〈*a*〉|.'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   设 *t* = ord(*a*)。由于 *a*^((*t*)) = *e* 且 *a*^((*t*+*k*)) = *a*^((*t*))
    ⊕ *a*^((*k*)) = *a*^((*k*)) 对于 *k* ≥ 1，如果 *i* > *t*，则 *a*^((*i*)) = *a*^((*j*))
    对于某个 *j* < *i*。因此，当我们通过 *a* 生成元素时，在 *a*^((*t*)) 之后不会看到新元素。因此，〈*a*〉 = {*a*^((1)),
    *a*^((2)), …, *a*^((*t*))}，因此 |〈*a*〉| ≤ *t*。为了证明 |〈*a*〉| ≥ *t*，我们展示序列 *a*^((1)),
    *a*^((2)), …, *a*^((*t*)) 的每个元素都是不同的。假设为了推导矛盾，存在某些 *i* 和 *j* 满足 1 ≤ *i* < *j*
    ≤ *t* 使得 *a*^((*i*)) = *a*^((*j*))。那么，*a*^((*i*+*k*)) = *a*^((*j*+*k*)) 对于 *k*
    ≥ 0。但是这个方程意味着 *a*^((*i*+(*t*–*j*))) = *a*^((*j*+(*t*–*j*))) = *e*，这与事实矛盾，因为 *i*
    + (*t* – *j*) < *t* 但 *t* 是使得 *a*^((*t*)) = *e* 的最小正整数值。因此，序列 *a*^((1)), *a*^((2)),
    …, *a*^((*t*)) 的每个元素都是不同的，且 |〈*a*〉| ≥ *t*。我们得出结论 ord(*a*) = |〈*a*〉|。'
- en: ▪
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Corollary 31.18***'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论 31.18***'
- en: The sequence *a*^((1)), *a*^((2)), … is periodic with period *t* = ord(*a*),
    that is, *a*^((*i*)) = *a*^((*j*)) if and only if *i* = *j* (mod *t*).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 序列 *a*^((1)), *a*^((2)), … 具有周期性，周期为 *t* = ord(*a*)，即，当且仅当 *i* ≡ *j* (mod *t*)
    时，*a*^((*i*)) = *a*^((*j*))。
- en: ▪
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Consistent with the above corollary, we define *a*^((0)) as *e* and *a*^((*i*))
    as *a*^((*i* mod *t*)), where *t* = ord(*a*), for all integers *i*.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 与上述推论一致，我们将 *a*^((0)) 定义为 *e*，将 *a*^((*i*)) 定义为 *a*^((*i* mod *t*))，其中 *t* =
    ord(*a*)，对于所有整数 *i*。
- en: '***Corollary 31.19***'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论 31.19***'
- en: If (*S*, ⊕) is a finite group with identity *e*, then for all *a* ∈ *S*,
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 (*S*, ⊕) 是一个带单位元 *e* 的有限群，则对于所有 *a* ∈ *S*，
- en: '*a*^((|*S*|)) = *e*.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*^((|*S*|)) = *e*.'
- en: '***Proof***   Lagrange’s theorem (Theorem 31.15) implies that ord(*a*) | |*S*|,
    and so |*S*| = 0 (mod *t*), where *t* = ord(*a*). Therefore, *a*^((|*S*|)) = *a*^((0))
    = *e*.'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   拉格朗日定理（定理 31.15）意味着 ord(*a*) | |*S*|，因此 |*S*| = 0 (mod *t*)，其中 *t*
    = ord(*a*)。因此，*a*^((|*S*|)) = *a*^((0)) = *e*。'
- en: ▪
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Exercises**'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题**'
- en: '***31.3-1***'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.3-1***'
- en: Draw the group operation tables for the groups (ℤ[4], +[4]) and ![art](images/Art_P1182.jpg).
    Show that these groups are isomorphic by exhibiting a one-to-one correspondence
    *f* between ℤ[4] and ![art](images/Art_P1183.jpg) such that *a*+*b* = *c* (mod
    4) if and only if *f*(*a*)·*f*(*b*) = *f*(*c*) (mod 5).
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制群操作表格，分别为(ℤ[4], +[4])和![art](images/Art_P1182.jpg)。通过展示ℤ[4]和![art](images/Art_P1183.jpg)之间的一一对应关系*f*，使得*a*+*b*
    = *c* (mod 4)当且仅当*f*(*a*)·*f*(*b*) = *f*(*c*) (mod 5)来展示这些群是同构的。
- en: '***31.3-2***'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.3-2***'
- en: List all subgroups of ℤ[9] and of ![art](images/Art_P1184.jpg).
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 列出ℤ[9]和![art](images/Art_P1184.jpg)的所有子群。
- en: '***31.3-3***'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.3-3***'
- en: Prove Theorem 31.14.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 证明定理31.14。
- en: '***31.3-4***'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.3-4***'
- en: Show that if *p* is prime and *e* is a positive integer, then
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*p*是质数，*e*是正整数，则证明
- en: '*ϕ*(*p*^(*e*)) = *p*^(*e*–1)(*p* – 1).'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '*ϕ*(*p*^(*e*)) = *p*^(*e*–1)(*p* – 1)。'
- en: '***31.3-5***'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.3-5***'
- en: Show that for any integer *n* > 1 and for any ![art](images/Art_P1185.jpg),
    the function ![art](images/Art_P1186.jpg) defined by *f*[*a*](*x*) = *ax* mod
    *n* is a permutation of ![art](images/Art_P1153.jpg).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 证明对于任何整数*n* > 1和任何![art](images/Art_P1185.jpg)，由*f*[*a*](*x*) = *ax* mod *n*定义的函数![art](images/Art_P1186.jpg)是![art](images/Art_P1153.jpg)的置换。
- en: '[**31.4    Solving modular linear equations**](toc.xhtml#Rh1-180)'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '[**31.4    解模线性方程**](toc.xhtml#Rh1-180)'
- en: We now consider the problem of finding solutions to the equation
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们考虑解方程的问题
- en: '![art](images/Art_P1188.jpg)'
  id: totrans-346
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1188.jpg)'
- en: where *a* > 0 and *n* > 0\. This problem has several applications. For example,
    we’ll use it in [Section 31.7](chapter031.xhtml#Sec_31.7) as part of the procedure
    to find keys in the RSA public-key cryptosystem. We assume that *a*, *b*, and
    *n* are given, and we wish to find all values of *x*, modulo *n*, that satisfy
    equation (31.26). The equation may have zero, one, or more than one such solution.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*a* > 0且*n* > 0。这个问题有几个应用。例如，我们将在[第31.7节](chapter031.xhtml#Sec_31.7)中将其用作RSA公钥加密系统中查找密钥的一部分。我们假设给定*a*、*b*和*n*，我们希望找到满足方程(31.26)的所有*x*模*n*的值。该方程可能有零个、一个或多个这样的解。
- en: 'Let 〈*a*〉 denote the subgroup of ℤ[*n*] generated by *a*. Since 〈*a*〉 = {*a*^((*x*))
    : *x* > 0} = {*ax* mod *n* : *x* > 0}, equation (31.26) has a solution if and
    only if [*b*] ∈ 〈*a*〉. Lagrange’s theorem (Theorem 31.15) tells us that |〈*a*〉|
    must be a divisor of *n*. The following theorem gives us a precise characterization
    of 〈*a*〉.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '让〈*a*〉表示由*a*生成的ℤ[*n*]的子群。由于〈*a*��� = {*a*^((*x*)) : *x* > 0} = {*ax* mod *n*
    : *x* > 0}，方程(31.26)有解当且仅当[*b*] ∈ 〈*a*〉。拉格朗日定理(定理31.15)告诉我们|〈*a*〉|必须是*n*的一个除数。以下定理给出了对〈*a*〉的精确刻画。'
- en: '***Theorem 31.20***'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理31.20***'
- en: For any positive integers *a* and *n*, if *d* = gcd(*a*, *n*), then we have
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何正整数*a*和*n*，如果*d* = gcd(*a*, *n*)，那么我们有
- en: '| 〈*a*〉 | = | 〈*d*〉 |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| 〈*a*〉 | = | 〈*d*〉 |'
- en: '|  | = | {0, *d*, 2*d*, …, ((*n*/*d*) – 1)*d*} |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '|  | = | {0, *d*, 2*d*, …, ((*n*/*d*) – 1)*d*} |'
- en: in ℤ[*n*], and thus
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在ℤ[*n*]中，因此
- en: '|〈*a*〉| = *n*/*d*.'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '|〈*a*〉| = *n*/*d*。'
- en: '***Proof***   We begin by showing that *d* ∈ 〈*a*〉. Recall that EXTENDED-EUCLID(*a*,
    *n*) returns a triple (*d*, *x*, *y*) such that *ax* + *ny* = *d*. Thus, *ax*
    = *d* (mod *n*), so that *d* ∈ 〈*a*〉. In other words, *d* is a multiple of *a*
    in ℤ[*n*].'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   我们首先展示*d* ∈ 〈*a*〉。回想一下EXTENDED-EUCLID(*a*, *n*)返回一个三元组(*d*, *x*,
    *y*)，使得*ax* + *ny* = *d*。因此，*ax* = *d* (mod *n*)，所以*d* ∈ 〈*a*〉。换句话说，*d*是ℤ[*n*]中*a*的倍数。'
- en: Since *d* ∈ 〈*a*〉, it follows that every multiple of *d* belongs to 〈*a*〉, because
    any multiple of a multiple of *a* is itself a multiple of *a*. Thus, 〈*a*〉 contains
    every element in {0, *d*, 2*d*, …, ((*n*/*d*) – 1)*d*}. That is, 〈*d*〉 ⊆ 〈*a*〉.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*d* ∈ 〈*a*〉，因此每个*d*的倍数都属于〈*a*〉，因为*a*的倍数的任何倍数本身也是*a*的倍数。因此，〈*a*〉包含{0, *d*,
    2*d*, …, ((*n*/*d*) – 1)*d*}中的每个元素。也就是说，〈*d*〉 ⊆ 〈*a*〉。
- en: We now show that 〈*a*〉 ⊆ 〈*d*〉. If *m* ∈ 〈*a*〉, then *m* = *ax* mod *n* for
    some integer *x*, and so *m* = *ax* + *ny* for some integer *y*. Because *d* =
    gcd(*a*, *n*), we know that *d* | *a* and *d* | *n*, and so *d* | *m* by equation
    (31.4). Therefore, *m* ∈ 〈*d*〉.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们展示〈*a*〉 ⊆ 〈*d*〉。如果*m* ∈ 〈*a*〉，那么*m* = *ax* mod *n*对于某个整数*x*成立，因此*m* = *ax*
    + *ny*对于某个整数*y*成立。因为*d* = gcd(*a*, *n*)，我们知道*d* | *a*和*d* | *n*，所以根据方程(31.4)，*d*
    | *m*。因此，*m* ∈ 〈*d*〉。
- en: Combining these results, we have that 〈*a*〉 = 〈*d*〉. To see that |〈*a*〉| = *n*/*d*,
    observe that there are exactly *n*/*d* multiples of *d* between 0 and *n* – 1,
    inclusive.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 结合这些结果，我们有〈*a*〉 = 〈*d*〉。要看到|〈*a*〉| = *n*/*d*，请注意在0和*n* – 1之间，包括*n*/*d*个*d*的倍数。
- en: ▪
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Corollary 31.21***'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论31.21***'
- en: The equation *ax* = *b* (mod *n*) is solvable for the unknown *x* if and only
    if *d* | *b*, where *d* = gcd(*a*, *n*).
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 方程*ax* = *b* (mod *n*)对未知数*x*可解当且仅当*d* | *b*，其中*d* = gcd(*a*, *n*)。
- en: '***Proof***   The equation *ax* = *b* (mod *n*) is solvable if and only if
    [*b*] ∈ 〈*a*〉, which is the same as saying'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   方程*ax* = *b* (mod *n*)可解当且仅当[*b*] ∈ 〈*a*〉，这等同于说'
- en: (*b* mod *n*) ∈ {0, *d*, 2*d*, …, ((*n*/*d*) – 1)*d*},
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: (*b* mod *n*) ∈ {0, *d*, 2*d*, …, ((*n*/*d*) – 1)*d*}，
- en: by Theorem 31.20\. If 0 ≤ *b* < *n*, then *b* ∈ 〈*a*〉 if and only if *d* | *b*,
    since the members of 〈*a*〉 are precisely the multiples of *d*. If *b* < 0 or *b*
    ≥ *n*, the corollary then follows from the observation that *d* | *b* if and only
    if *d* | (*b* mod *n*), since *b* and *b* mod *n* differ by a multiple of *n*,
    which is itself a multiple of *d*.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 根据定理31.20。如果0 ≤ *b* < *n*，那么*b* ∈ 〈*a*〉当且仅当*d* | *b*，因为〈*a*〉的成员恰好是*d*的倍数。如果*b*
    < 0或*b* ≥ *n*，则由于*d* | *b*当且仅当*d* | (*b* mod *n*)，由于*b*和*b* mod *n*之间相差*n*的倍数，而*n*本身是*d*的倍数，因此推论成立。
- en: ▪
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Corollary 31.22***'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论31.22***'
- en: The equation *ax* = *b* (mod *n*) either has *d* distinct solutions modulo *n*,
    where *d* = gcd(*a*, *n*), or it has no solutions.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 方程*ax* = *b* (mod *n*)在模*n*下要么有*d*个不同的解，其中*d* = gcd(*a*, *n*)，要么没有解。
- en: '***Proof***   If *ax* = *b* (mod *n*) has a solution, then *b* ∈ 〈*a*〉. By
    Theorem 31.17, ord(*a*) = |〈*a*〉|, and so Corollary 31.18 and Theorem 31.20 imply
    that the sequence *ai* mod *n*, for *i* = 0, 1, …, is periodic with period |〈*a*〉|
    = *n*/*d*. If *b* ∈ 〈*a*〉, then *b* appears exactly *d* times in the sequence
    *ai* mod *n*, for *i* = 0, 1, …, *n* – 1, since the length-(*n*/*d*) block of
    values 〈*a*〉 repeats exactly *d* times as *i* increases from 0 to *n*–1\. The
    indices *x* of the *d* positions for which *ax* mod *n* = *b* are the solutions
    of the equation *ax* = *b* (mod *n*).'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   如果 *ax* = *b* (mod *n*) 有解，那么 *b* ∈ 〈*a*〉。根据定理 31.17，ord(*a*) =
    |〈*a*〉|，因此推论 31.18 和定理 31.20 暗示，对于 *i* = 0, 1, …，序列 *ai* mod *n* 是周期性的，周期为 |〈*a*〉|
    = *n*/*d*。如果 *b* ∈ 〈*a*〉，那么在序列 *ai* mod *n* 中，*i* = 0, 1, …，*n* – 1，*b* 出现了恰好
    *d* 次，因为值为 *n*/*d* 的长度为 *d* 的块在 *i* 从 0 增加到 *n*–1 时恰好重复 *d* 次。对于满足 *ax* mod *n*
    = *b* 的 *d* 个位置的索引 *x* 是方程 *ax* = *b* (mod *n*) 的解。'
- en: ▪
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Theorem 31.23***'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 31.23***'
- en: Let *d* = gcd(*a*, *n*), and suppose that *d* = *ax*′ + *ny*′ for some integers
    *x*′ and *y*′ (for example, as computed by EXTENDED-EUCLID). If *d* | *b*, then
    the equation *ax* = *b* (mod *n*) has as one of its solutions the value *x*[0],
    where
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 设 *d* = gcd(*a*, *n*)，并假设 *d* = *ax*′ + *ny*′ 对于某些整数 *x*′ 和 *y*′ 成立（例如，由 EXTENDED-EUCLID
    计算得到）。如果 *d* | *b*，那么方程 *ax* = *b* (mod *n*) 的一个解是值 *x*[0]，其中
- en: '*x*[0] = *x*′(*b*/*d*) mod *n*.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*[0] = *x*′(*b*/*d*) mod *n*.'
- en: '***Proof***   We have'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   我们有'
- en: '| *ax*[0] | = *ax*′(*b*/*d*) | (mod *n*) |  |'
  id: totrans-374
  prefs: []
  type: TYPE_TB
  zh: '| *ax*[0] | = *ax*′(*b*/*d*) | (mod *n*) |  |'
- en: '|  | = *d*(*b*/*d*) | (mod *n*) | (because *ax*′ = *d* (mod *n*)) |'
  id: totrans-375
  prefs: []
  type: TYPE_TB
  zh: '|  | = *d*(*b*/*d*) | (mod *n*) | (因为 *ax*′ = *d* (mod *n*)) |'
- en: '|  | = *b* | (mod *n*), |  |'
  id: totrans-376
  prefs: []
  type: TYPE_TB
  zh: '|  | = *b* | (mod *n*), |  |'
- en: and thus *x*[0] is a solution to *ax* = *b* (mod *n*).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 因此 *x*[0] 是方程 *ax* = *b* (mod *n*) 的一个解。
- en: ▪
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Theorem 31.24***'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 31.24***'
- en: Suppose that the equation *ax* = *b* (mod *n*) is solvable (that is, *d* | *b*,
    where *d* = gcd(*a*, *n*)) and that *x*[0] is any solution to this equation. Then,
    this equation has exactly *d* distinct solutions, modulo *n*, given by *x*[*i*]
    = *x*[0] + *i*(*n*/*d*) for *i* = 0, 1, …, *d* – 1.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 假设方程 *ax* = *b* (mod *n*) 是可解的（即 *d* | *b*，其中 *d* = gcd(*a*, *n*)），且 *x*[0]
    是该方程的任意解。那么，这个方程在模 *n* 下恰好有 *d* 个不同的解，由 *x*[*i*] = *x*[0] + *i*(*n*/*d*)，*i* =
    0, 1, …，*d* – 1 给出。
- en: '***Proof***   Because *n*/*d* > 0 and 0 ≤ *i*(*n*/*d*) < *n* for *i* = 0, 1,
    …, *d* – 1, the values *x*[0], *x*[1], …, *x*[*d*–1] are all distinct, modulo
    *n*. Since *x*[0] is a solution of *ax* = *b* (mod *n*), we have *ax*[0] mod *n*
    = *b* (mod *n*). Thus, for *i* = 0, 1, …, *d* – 1, we have'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   因为 *n*/*d* > 0 且 0 ≤ *i*(*n*/*d*) < *n* 对于 *i* = 0, 1, …，*d* – 1，值
    *x*[0]、*x*[1]、…、*x*[*d*–1] 在模 *n* 下都是不同的。由于 *x*[0] 是方程 *ax* = *b* (mod *n*) 的解，我们有
    *ax*[0] mod *n* = *b* (mod *n*)。因此，对于 *i* = 0, 1, …，*d* – 1，我们有'
- en: '| *ax*[*i*] mod *n* | = | *a*(*x*[0] + *in*/*d*) mod *n* |'
  id: totrans-382
  prefs: []
  type: TYPE_TB
  zh: '| *ax*[*i*] mod *n* | = | *a*(*x*[0] + *in*/*d*) mod *n* |'
- en: '|  | = | (*ax*[0] + *ain*/*d*) mod *n* |'
  id: totrans-383
  prefs: []
  type: TYPE_TB
  zh: '|  | = | (*ax*[0] + *ain*/*d*) mod *n* |'
- en: '|  | = | *ax*[0] mod *n* (because *d* &#124; *a* implies that *ain*/*d* is
    a multiple of *n*) |'
  id: totrans-384
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *ax*[0] mod *n*（因为 *d* &#124; *a* 意味着 *ain*/*d* 是 *n* 的倍数） |'
- en: '|  | = | *b* (mod *n*), |'
  id: totrans-385
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *b* (mod *n*), |'
- en: and hence *ax*[*i*] = *b* (mod *n*), making *x*[*i*] a solution, too. By Corollary
    31.22, the equation *ax* = *b* (mod *n*) has exactly *d* solutions, so that *x*[0],
    *x*[1], …, *x*[*d*–1] must be all of them.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 因此 *ax*[*i*] = *b* (mod *n*)，也使得 *x*[*i*] 成为一个解。根据推论 31.22，方程 *ax* = *b* (mod
    *n*) 恰好有 *d* 个解，因此 *x*[0]、*x*[1]、…、*x*[*d*–1] 必须是所有解。
- en: ▪
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: We have now developed the mathematics needed to solve the equation *ax* = *b*
    (mod *n*). The procedure MODULAR-LINEAR-EQUATION-SOLVER prints all solutions to
    this equation. The inputs *a* and *n* are arbitrary positive integers, and *b*
    is an arbitrary integer.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经发展出解方程 *ax* = *b* (mod *n*) 所需的数学知识。MODULAR-LINEAR-EQUATION-SOLVER 过程打印出这个方程的所有解。输入
    *a* 和 *n* 是任意正整数，*b* 是任意整数。
- en: MODULAR-LINEAR-EQUATION-SOLVER(*a*, *b*, *n*)
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: MODULAR-LINEAR-EQUATION-SOLVER(*a*, *b*, *n*)
- en: '| 1 | (*d*, *x*′, *y*′) = EXTENDED-EUCLID(*a*, *n*) |'
  id: totrans-390
  prefs: []
  type: TYPE_TB
  zh: '| 1 | (*d*, *x*′, *y*′) = EXTENDED-EUCLID(*a*, *n*) |'
- en: '| 2 | **if** *d* &#124; *b* |'
  id: totrans-391
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **如果** *d* &#124; *b* |'
- en: '| 3 | *x*[0] = *x*′(*b*/*d*) mod *n* |'
  id: totrans-392
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *x*[0] = *x*′(*b*/*d*) mod *n* |'
- en: '| 4 | **for** *i* = 0 **to** *d* – 1 |'
  id: totrans-393
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **对于** *i* = 0 **到** *d* – 1 |'
- en: '| 5 | print (*x*[0] + *i*(*n*/*d*)) mod *n* |'
  id: totrans-394
  prefs: []
  type: TYPE_TB
  zh: '| 5 | 打印 (*x*[0] + *i*(*n*/*d*)) mod *n* |'
- en: '| 6 | **else** print “no solutions” |'
  id: totrans-395
  prefs: []
  type: TYPE_TB
  zh: '| 6 | **否则** 打印“无解” |'
- en: As an example of the operation of MODULAR-LINEAR-EQUATION-SOLVER, consider the
    equation 14*x* = 30 (mod 100) (and thus *a* = 14, *b* = 30, and *n* = 100). Calling
    EXTENDED-EUCLID in line 1 gives (*d*, *x*′, *y*′) = (2, –7, 1). Since 2 | 30,
    lines 3–5 execute. Line 3 computes *x*[0] = (–7)(15) mod 100 = 95\. The **for**
    loop of lines 4–5 prints the two solutions, 95 and 45.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 作为 MODULAR-LINEAR-EQUATION-SOLVER 操作的一个示例，考虑方程 14*x* = 30 (mod 100)（因此 *a* =
    14，*b* = 30，*n* = 100）。在第 1 行调用 EXTENDED-EUCLID 得到 (*d*, *x*′, *y*′) = (2, –7,
    1)。由于 2 | 30，第 3–5 行执行。第 3 行计算 *x*[0] = (–7)(15) mod 100 = 95。第 4–5 行的 **for**
    循环打印出两个解，95 和 45。
- en: The procedure MODULAR-LINEAR-EQUATION-SOLVER works as follows. The call to EXTENDED-EUCLID
    in line 1 returns a triple (*d*, *x*′, *y*′) such that *d* = gcd(*a*, *n*) and
    *d* = *ax*′ + *ny*′. Therefore, *x*′ is a solution to the equation *ax*′ = *d*
    (mod *n*). If *d* does not divide *b*, then the equation *ax* = *b* (mod *n*)
    has no solution, by Corollary 31.21\. Line 2 checks to see whether *d* | *b*,
    and if not, line 6 reports that there are no solutions. Otherwise, line 3 computes
    a solution *x*[0] to *ax* = *b* (mod *n*), as Theorem 31.23 suggests. Given one
    solution, Theorem 31.24 states that adding multiples of (*n*/*d*), modulo *n*,
    yields the other *d* – 1 solutions. The **for** loop of lines 4–5 prints out all
    *d* solutions, beginning with *x*[0] and spaced *n*/*d* apart, modulo *n*.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: MODULAR-LINEAR-EQUATION-SOLVER 过程的工作方式如下。第 1 行调用 EXTENDED-EUCLID 返回一个三元组 (*d*,
    *x*′, *y*′)，使得 *d* = gcd(*a*, *n*) 且 *d* = *ax*′ + *ny*′。因此，*x*′ 是方程 *ax*′ = *d*
    (mod *n*) 的解。如果 *d* 不整除 *b*，则根据推论 31.21，方程 *ax* = *b* (mod *n*) 没有解。第 2 行检查 *d*
    | *b*，如果不是，则第 6 行报告没有解。否则，第 3 行计算方程 *ax* = *b* (mod *n*) 的一个解 *x*[0]，正如定理 31.23
    所建议的。根据定理 31.24，给定一个解，添加 (*n*/*d*) 的倍数，模 *n*，得到另外 *d* – 1 个解。第 4–5 行的 **for**
    循环打印出所有 *d* 个解，从 *x*[0] 开始，间隔为 *n*/*d*，模 *n*。
- en: MODULAR-LINEAR-EQUATION-SOLVER performs *O*(1g *n* + gcd(*a*, *n*)) arithmetic
    operations, since EXTENDED-EUCLID performs *O*(1g *n*) arithmetic operations,
    and each iteration of the **for** loop of lines 4–5 performs a constant number
    of arithmetic operations.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: MODULAR-LINEAR-EQUATION-SOLVER执行*O*(1g *n* + gcd(*a*, *n*))个算术操作，因为EXTENDED-EUCLID执行*O*(1g
    *n*)个算术操作，而行4-5的**for**循环的每次迭代执行恒定数量的算术操作。
- en: The following corollaries of Theorem 31.24 give specializations of particular
    interest.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 定理31.24的以下推论给出了一些特别感兴趣的特例。
- en: '***Corollary 31.25***'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论 31.25***'
- en: For any *n* > 1, if gcd(*a*, *n*) = 1, then the equation *ax* = *b* (mod *n*)
    has a unique solution, modulo *n*.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意*n* > 1，如果gcd(*a*, *n*) = 1，则方程*ax* = *b* (mod *n*)在模*n*下有唯一解。
- en: ▪
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: If *b* = 1, a common case of considerable interest, the *x* that solves the
    equation is a ***multiplicative inverse*** of *a*, modulo *n*.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*b* = 1，一个非常有趣的常见情况，解方程的*x*是*a*的一个***乘法逆元***，在模*n*下。
- en: '***Corollary 31.26***'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论 31.26***'
- en: For any *n* > 1, if gcd(*a*, *n*) = 1, then the equation *ax* = 1 (mod *n*)
    has a unique solution, modulo *n*. Otherwise, it has no solution.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意*n* > 1，如果gcd(*a*, *n*) = 1，则方程*ax* = 1 (mod *n*)在模*n*下有唯一解。否则，它没有解。
- en: ▪
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Thanks to Corollary 31.26, the notation *a*^(−1) mod *n* refers to *the* multiplicative
    inverse of *a*, modulo *n*, when *a* and *n* are relatively prime. If gcd(*a*,
    *n*) = 1, then the unique solution to the equation *ax* = 1 (mod *n*) is the integer
    *x* returned by EXTENDED-EUCLID, since the equation
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: 多亏了推论31.26，当*a*和*n*互质时，记号*a*^(−1) mod *n*指的是*a*的乘法逆元，模*n*。如果gcd(*a*, *n*) =
    1，则方程*ax* = 1 (mod *n*)的唯一解是扩展欧几里得算法返回的整数*x*，因为方程
- en: gcd(*a*, *n*) = 1 = *ax* + *ny*
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: gcd(*a*, *n*) = 1 = *ax* + *ny*
- en: implies *ax* = 1 (mod *n*). Thus, EXTENDED-EUCLID can compute *a*^(−1) mod *n*
    efficiently.
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 意味着*ax* = 1 (mod *n*)。因此，扩展欧几里得算法可以高效地计算*a*^(−1) mod *n*。
- en: '**Exercises**'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***31.4-1***'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.4-1***'
- en: Find all solutions to the equation 35*x* = 10 (mod 50).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 找出方程35*x* = 10 (mod 50)的所有解。
- en: '***31.4-2***'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.4-2***'
- en: Prove that the equation *ax* = *ay* (mod *n*) implies *x* = *y* (mod *n*) whenever
    gcd(*a*, *n*) = 1\. Show that the condition gcd(*a*, *n*) = 1 is necessary by
    supplying a counterexample with gcd(*a*, *n*) > 1.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 证明方程*ax* = *ay* (mod *n*)意味着当gcd(*a*, *n*) = 1时，*x* = *y* (mod *n*)。通过提供一个gcd(*a*,
    *n*) > 1的反例来展示gcd(*a*, *n*) = 1的条件是必要的。
- en: '***31.4-3***'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.4-3***'
- en: 'Consider the following change to line 3 of the procedure MODULAR-LINEAR-EQUATION-SOLVER:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑对MODULAR-LINEAR-EQUATION-SOLVER过程的第3行进行以下更改：
- en: '| 3 | *x*[0] = *x*′(*b*/*d*) mod (*n*/*d*) |'
  id: totrans-417
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *x*[0] = *x*′(*b*/*d*) mod (*n*/*d*) |'
- en: With this change, will the procedure still work? Explain why or why not.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这个变化，这个过程还会起作用吗？解释为什么或为什么不。
- en: ★ ***31.4-4***
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***31.4-4***
- en: Let *p* be prime and *f*(*x*) = (*f*[0] + *f*[1]*x* + ⋯ + *f*[*t*]*x*^(*t*))
    (mod *p*) be a polynomial of degree *t*, with coefficients *f*[*i*] drawn from
    ℤ[*p*]. We say that *a* ∈ ℤ[*p*] is a ***zero*** of *f* if *f*(*a*) = 0 (mod *p*).
    Prove that if *a* is a zero of *f*, then *f*(*x*) = (*x* – *a*)*g*(*x*) (mod *p*)
    for some polynomial *g*(*x*) of degree *t* – 1\. Prove by induction on *t* that
    if *p* is prime, then a polynomial *f*(*x*) of degree *t* can have at most *t*
    distinct zeros modulo *p*.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 设*p*为素数，*f*(*x*) = (*f*[0] + *f*[1]*x* + ⋯ + *f*[*t*]*x*^(*t*)) (mod *p*) 是一个系数取自ℤ[*p*]的次数为*t*的多项式，我们称*∈
    ℤ[*p*]的*a*是*f*的一个***零点***，如果*f*(*a*) = 0 (mod *p*)。证明如果*a*是*f*的一个零点，那么*f*(*x*)
    = (*x* – *a*)*g*(*x*) (mod *p*)对于某个次数为*t* – 1的多项式*g*(*x*)成立。通过对*t*进行归纳证明，如果*p*是素数，则次数为*t*的多项式*f*(*x*)在模*p*下最多有*t*个不同的零点。
- en: '[**31.5    The Chinese remainder theorem**](toc.xhtml#Rh1-181)'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: '[**31.5    中国余数定理**](toc.xhtml#Rh1-181)'
- en: Around 100 C.E., the Chinese mathematician Sun-Tsŭ solved the problem of finding
    those integers *x* that leave remainders 2, 3, and 2 when divided by 3, 5, and
    7 respectively. One such solution is *x* = 23, and all solutions are of the form
    23+105*k* for arbitrary integers *k*. The “Chinese remainder theorem” provides
    a correspondence between a system of equations modulo a set of pairwise relatively
    prime moduli (for example, 3, 5, and 7) and an equation modulo their product (for
    example, 105).
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 大约在公元100年，中国数学家孙子解决了找出那些整数*x*，当被3、5和7分别除以时余数为2、3和2的问题。这样的一个解是*x* = 23，所有解的形式为23+105*k*，其中*k*是任意整数。《中国余数定理》提供了一种在一组两两互质的模数（例如3、5和7）上的方程与模它们的乘积（例如105）上的方程之间的对应关系。
- en: The Chinese remainder theorem has two major applications. Let the integer *n*
    be factored as *n* = *n*[1]*n*[2] ⋯ *n*[*k*], where the factors *n*[*i*] are pairwise
    relatively prime. First, the Chinese remainder theorem is a descriptive “structure
    theorem” that describes the structure of ℤ[*n*] as identical to that of the Cartesian
    product ![art](images/Art_P1189.jpg) with componentwise addition and multiplication
    modulo *n*[*i*] in the *i*th component. Second, this description helps in designing
    efficient algorithms, since working in each of the systems ![art](images/Art_P1190.jpg)
    can be more efficient (in terms of bit operations) than working modulo *n*.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 中国余数定理有两个主要应用。将整数*n*分解为*n* = *n*[1]*n*[2] ⋯ *n*[*k*]，其中因子*n*[*i*]两两互质。首先，中国余数定理是一种描述性的“结构定理”，描述了ℤ[*n*]的结构与笛卡尔积![艺术](images/Art_P1189.jpg)的结构相同，��中在第*i*个分量中模*n*[*i*]的加法和乘法。其次，这种描述有助于设计高效的算法，因为在每个系统![艺术](images/Art_P1190.jpg)中工作可能比在模*n*下更有效（就位操作而言）。
- en: '***Theorem 31.27 (Chinese remainder theorem)***'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 31.27（中国余数定理）***'
- en: Let *n* = *n*[1]*n*[2] ⋯ *n*[*k*], where the *n*[*i*] are pairwise relatively
    prime. Consider the correspondence
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 设*n* = *n*[1]*n*[2] ⋯ *n*[*k*]，其中*n*[*i*]两两互质。考虑对应关系
- en: '![art](images/Art_P1191.jpg)'
  id: totrans-426
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1191.jpg)'
- en: where ![art](images/Art_P1192.jpg), and
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 其中![艺术](images/Art_P1192.jpg)，以及
- en: '*a*[*i*] = *a* mod *n*[*i*]'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*[*i*] = *a* mod *n*[*i*]'
- en: for *i* = 1, 2, …, *k*. Then, mapping (31.27) is a one-to-one mapping (bijection)
    between ℤ[*n*] and the Cartesian product ![art](images/Art_P1193.jpg). Operations
    performed on the elements of ℤ[*n*] can be equivalently performed on the corresponding
    *k*-tuples by performing the operations independently in each coordinate position
    in the appropriate system. That is, if
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *i* = 1, 2, …, *k*。然后，映射（31.27）是 ℤ[*n*] 和笛卡尔积 ![art](images/Art_P1193.jpg)
    之间的一一映射（双射）。在 ℤ[*n*] 的元素上执行的操作可以通过在适当的系统中独立在每个坐标位置执行操作来等效地在相应的 *k* 元组上执行。也就是说，如果
- en: '| *a* | ↔ | (*a*[1], *a*[2], …, *a*[*k*]), |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '| *a* | ↔ | (*a*[1], *a*[2], …, *a*[*k*]), |'
- en: '| *b* | ↔ | (*b*[1], *b*[2], …, *b*[*k*]), |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '| *b* | ↔ | (*b*[1], *b*[2], …, *b*[*k*]), |'
- en: then
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 然后
- en: '![art](images/Art_P1194.jpg)'
  id: totrans-433
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1194.jpg)'
- en: '***Proof***   Let’s see how to translate between the two representations. Going
    from *a* to (*a*[1], *a*[2], …, *a*[*k*]) requires only *k* “mod” operations.
    The reverse—computing *a* from inputs (*a*[1], *a*[2], …, *a*[*k*])—is only slightly
    more complicated.'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   让我们看看如何在两种表示之间转换。从 *a* 转换为 (*a*[1], *a*[2], …, *a*[*k*]) 只需要 *k*
    次“mod”运算。反之——从输入 (*a*[1], *a*[2], …, *a*[*k*]) 计算 *a*——稍微复杂一些。'
- en: 'We begin by defining *m*[*i*] = *n*/*n*[*i*] for *i* = 1, 2, …, *k*. Thus,
    *m*[*i*] is the product of all of the *n*[*j*]’s other than *n*[*i*]: *m*[*i*]
    = *n*[1]*n*[2] ⋯ *n*[*i*−1]*n*[*i*+1] ⋯ *n*[*k*]. We next define'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义 *m*[*i*] = *n*/*n*[*i*] 对于 *i* = 1, 2, …, *k*。因此，*m*[*i*] 是除了 *n*[*i*]
    之外所有 *n*[*j*] 的乘积：*m*[*i*] = *n*[1]*n*[2] ⋯ *n*[*i*−1]*n*[*i*+1] ⋯ *n*[*k*]。接下来我们定义
- en: '![art](images/Art_P1195.jpg)'
  id: totrans-436
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1195.jpg)'
- en: 'for *i* = 1, 2, …, *k*. Equation (31.31) is well defined: since *m*[*i*] and
    *n*[*i*] are relatively prime (by Theorem 31.6), Corollary 31.26 guarantees that
    ![art](images/Art_P1196.jpg) mod *n*[*i*] exists. Here is how to compute *a* as
    a function of the *a*[*i*] and *c*[*i*]:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *i* = 1, 2, …, *k*。方程（31.31）是良定义的：因为 *m*[*i*] 和 *n*[*i*] 是互质的（根据定理 31.6），推论
    31.26 保证了 ![art](images/Art_P1196.jpg) mod *n*[*i*] 存在。这里是如何根据 *a*[*i*] 和 *c*[*i*]
    计算 *a* 的方法：
- en: '![art](images/Art_P1197.jpg)'
  id: totrans-438
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1197.jpg)'
- en: We now show that equation (31.32) ensures that *a* = *a*[*i*] (mod *n*[*i*])
    for *i* = 1, 2, …, *k*. If *j* ≠ *i*, then *m*[*j*] = 0 (mod *n*[*i*]), which
    implies that *c*[*j*] = *m*[*j*] = 0 (mod *n*[*i*]). Note also that *c*[*i*] =
    1 (mod *n*[*i*]), from equation (31.31). We thus have the appealing and useful
    correspondence
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们展示方程（31.32）确保了 *a* = *a*[*i*] (mod *n*[*i*]) 对于 *i* = 1, 2, …, *k*。如果 *j*
    ≠ *i*，那么 *m*[*j*] = 0 (mod *n*[*i*])，这意味着 *c*[*j*] = *m*[*j*] = 0 (mod *n*[*i*])。还要注意方程（31.31）中
    *c*[*i*] = 1 (mod *n*[*i*])。因此，我们有一个吸引人且有用的对应关系
- en: '*c*[*i*] ↔ (0, 0, …, 0, 1, 0, …, 0),'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: '*c*[*i*] ↔ (0, 0, …, 0, 1, 0, …, 0),'
- en: a vector that has 0s everywhere except in the *i*th coordinate, where it has
    a 1\. The *c*[*i*] thus form a “basis” for the representation, in a certain sense.
    For each *i*, therefore, we have
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 一个向量在除了第 *i* 个坐标处为 1 外，其他地方都为 0。因此，*c*[*i*] 在某种意义上形成了表示的“基础”。因此，对于每个 *i*，我们有
- en: '![art](images/Art_P1198.jpg)'
  id: totrans-442
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1198.jpg)'
- en: 'which is what we wished to show: our method of computing *a* from the *a*[*i*]’s
    produces a result *a* that satisfies the constraints *a* = *a*[*i*] (mod *n*[*i*])
    for *i* = 1, 2, …, *k*. The correspondence is one-to-one, since we can transform
    in both directions. Finally, equations (31.28)–(31.30) follow directly from Exercise
    31.1-7, since *x* mod *n*[*i*] = (*x* mod *n*) mod *n*[*i*] for any *x* and *i*
    = 1, 2, …, *k*.'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这正是我们希望展示的：我们从 *a*[*i*] 计算 *a* 的方法产生了满足约束条件 *a* = *a*[*i*] (mod *n*[*i*]) 的结果，对于
    *i* = 1, 2, …, *k*。这种对应是一一对应的，因为我们可以在两个方向上进行转换。最后，方程（31.28）–（31.30）直接由练习 31.1-7
    推导而来，因为对于任意 *x* 和 *i* = 1, 2, …, *k*，*x* mod *n*[*i*] = (*x* mod *n*) mod *n*[*i*]。
- en: ▪
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: We’ll use the following corollaries later in this chapter.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章后面使用以下推论。
- en: '***Corollary 31.28***'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论 31.28***'
- en: If *n*[1], *n*[2], …, *n*[*k*] are pairwise relatively prime and *n* = *n*[1]*n*[2]
    ⋯ *n*[*k*], then for any integers *a*[1], *a*[2], …, *a*[*k*], the set of simultaneous
    equations
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *n*[1], *n*[2], …, *n*[*k*] 两两互质且 *n* = *n*[1]*n*[2] ⋯ *n*[*k*]，那么对于任意整数
    *a*[1], *a*[2], …, *a*[*k*]，同时方程组
- en: '| *x* = *a*[*i*] | (mod *n*[*i*]), |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '| *x* = *a*[*i*] | (mod *n*[*i*]), |'
- en: for *i* = 1, 2, …, *k*, has a unique solution modulo *n* for the unknown *x*.
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *i* = 1, 2, …, *k*，在模 *n* 下具有未知数 *x* 的唯一解。
- en: ▪
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Corollary 31.29***'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论 31.29***'
- en: If *n*[1], *n*[2], …, *n*[*k*] are pairwise relatively prime and *n* = *n*[1]*n*[2]
    ⋯ *n*[*k*], then for all integers *x* and *a*,
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *n*[1], *n*[2], …, *n*[*k*] 两两互质且 *n* = *n*[1]*n*[2] ⋯ *n*[*k*]，那么对于所有整数
    *x* 和 *a*，
- en: '*x* = *a* (mod *n*[*i*])'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* = *a* (mod *n*[*i*])'
- en: for *i* = 1, 2, …, *k* if and only if
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 *i* = 1, 2, …, *k* 当且仅当
- en: '*x* = *a* (mod *n*).'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '*x* = *a* (mod *n*).'
- en: ▪
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: As an example of the application of the Chinese remainder theorem, suppose that
    you are given the two equations
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 作为中国剩余定理应用的一个例子，假设给定两个方程
- en: '| *a* = 2 | (mod 5), |'
  id: totrans-458
  prefs: []
  type: TYPE_TB
  zh: '| *a* = 2 | (mod 5), |'
- en: '| *a* = 3 | (mod 13), |'
  id: totrans-459
  prefs: []
  type: TYPE_TB
  zh: '| *a* = 3 | (mod 13), |'
- en: so that *a*[1] = 2, *n*[1] = *m*[2] = 5, *a*[2] = 3, and *n*[2] = *m*[1] = 13,
    and you wish to compute *a* mod 65, since *n* = *n*[1]*n*[2] = 65\. Because 13^(−1)
    = 2 (mod 5) and 5^(−1) = 8 (mod 13), you compute
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 所以 *a*[1] = 2, *n*[1] = *m*[2] = 5, *a*[2] = 3, 而 *n*[2] = *m*[1] = 13，你希望计算
    *a* mod 65，因为 *n* = *n*[1]*n*[2] = 65\. 因为 13^(−1) = 2 (mod 5) 和 5^(−1) = 8 (mod
    13)，你计算
- en: '| *c*[1] | = 13 · (2 mod 5) = 26, |'
  id: totrans-461
  prefs: []
  type: TYPE_TB
  zh: '| *c*[1] | = 13 · (2 mod 5) = 26, |'
- en: '| *c*[2] | = 5 · (8 mod 13) = 40, |'
  id: totrans-462
  prefs: []
  type: TYPE_TB
  zh: '| *c*[2] | = 5 · (8 mod 13) = 40, |'
- en: and
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '| *a* | = | 2 · 26 + 3 · 40 | (mod 65) |'
  id: totrans-464
  prefs: []
  type: TYPE_TB
  zh: '| *a* | = | 2 · 26 + 3 · 40 | (mod 65) |'
- en: '|  | = | 52 + 120 | (mod 65) |'
  id: totrans-465
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 52 + 120 | (mod 65) |'
- en: '|  | = | 42 | (mod 65). |'
  id: totrans-466
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 42 | (mod 65). |'
- en: '![art](images/Art_P1199.jpg)'
  id: totrans-467
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1199.jpg)'
- en: '**Figure 31.3** An illustration of the Chinese remainder theorem for *n*[1]
    = 5 and *n*[2] = 13\. For this example, *c*[1] = 26 and *c*[2] = 40\. In row *i*,
    column *j* is shown the value of *a*, modulo 65, such that *a* mod 5 = *i* and
    *a* mod 13 = *j*. Note that row 0, column 0 contains a 0\. Similarly, row 4, column
    12 contains a 64 (equivalent to −1). Since *c*[1] = 26, moving down a row increases
    *a* by 26\. Similarly, *c*[2] = 40 means that moving right by a column increases
    *a* by 40\. Increasing *a* by 1 corresponds to moving diagonally downward and
    to the right, wrapping around from the bottom to the top and from the right to
    the left.'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '**图31.3** 演示了*n*[1] = 5和*n*[2] = 13的中国剩余定理。对于这个例子，*c*[1] = 26，*c*[2] = 40。在第*i*行，第*j*列显示了模65下的*a*的值，使得*a*
    mod 5 = *i*且*a* mod 13 = *j*。请注意，第0行第0列包含一个0。类似地，第4行第12列包含一个64（等同于-1）。由于*c*[1]
    = 26，向下移动一行会使*a*增加26。同样，*c*[2] = 40意味着向右移动一列会使*a*增加40。增加1对应于向右下对角线移动，从底部到顶部，从右侧到左侧环绕。'
- en: See [Figure 31.3](chapter031.xhtml#Fig_31-3) for an illustration of the Chinese
    remainder theorem, modulo 65.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 参见[图31.3](chapter031.xhtml#Fig_31-3)以说明模65的中国剩余定理。
- en: Thus, you can work modulo *n* by working modulo *n* directly or by working in
    the transformed representation using separate modulo *n*[*i*] computations, as
    convenient. The computations are entirely equivalent.
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以通过直接在模*n*中工作或者在使用单独的模*n*[i]计算的转换表示中工作来在模*n*下工作。这些计算是完全等价的。
- en: '**Exercises**'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '**习题**'
- en: '***31.5-1***'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.5-1***'
- en: Find all solutions to the equations *x* = 4 (mod 5) and *x* = 5 (mod 11).
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 找出方程*x* = 4 (mod 5)和*x* = 5 (mod 11)的所有解。
- en: '***31.5-2***'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.5-2***'
- en: Find all integers *x* that leave remainders 1, 2, and 3 when divided by 9, 8,
    and 7, respectively.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 找出所有整数*x*，当被9、8和7整除时余数分别为1、2和3。
- en: '***31.5-3***'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.5-3***'
- en: Argue that, under the definitions of Theorem 31.27, if gcd(*a*, *n*) = 1, then
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 论证，在定理31.27的定义下，如果gcd(*a*, *n*) = 1，则
- en: '![art](images/Art_P1200.jpg)'
  id: totrans-478
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1200.jpg)'
- en: '***31.5-4***'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.5-4***'
- en: Under the definitions of Theorem 31.27, prove that for any polynomial *f*, the
    number of roots of the equation *f*(*x*) = 0 (mod *n*) equals the product of the
    number of roots of each of the equations *f*(*x*) = 0 (mod *n*[1]), *f*(*x*) =
    0 (mod *n*[2]), …, *f*(*x*) = 0 (mod *n*[*k*]).
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在定理31.27的定义下，证明对于任意多项式*f*，方程*f*(*x*) = 0 (mod *n*)的根数等于每个方程*f*(*x*) = 0 (mod
    *n*[1])、*f*(*x*) = 0 (mod *n*[2])，…，*f*(*x*) = 0 (mod *n*[*k*])的根数的乘积。
- en: '[**31.6    Powers of an element**](toc.xhtml#Rh1-182)'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: '[**31.6    元素的幂**](toc.xhtml#Rh1-182)'
- en: 'Along with considering the multiples of a given element *a*, modulo *n*, we
    often consider the sequence of powers of *a*, modulo *n*, where ![art](images/Art_P1201.jpg):'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 除了考虑模*n*下给定元素*a*的倍数外，我们经常考虑模*n*下*a*的幂的序列，其中![art](images/Art_P1201.jpg)：
- en: '*a*⁰, *a*¹, *a*², *a*³, …,'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: '*a*⁰，*a*¹，*a*²，*a*³，…，'
- en: modulo *n*. Indexing from 0, the 0th value in this sequence is *a*⁰ mod *n*
    = 1, and the *i*th value is *a*^(*i*) mod *n*. For example, the powers of 3 modulo
    7 are
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 模*n*。从0开始索引，这个序列中的第0个值是*a*⁰ mod *n* = 1，第*i*个值是*a*^(*i*) mod *n*。例如，模7的3的幂是
- en: '![art](images/Art_P1201a.jpg)'
  id: totrans-485
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1201a.jpg)'
- en: and the powers of 2 modulo 7 are
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 以及模7的2的幂是
- en: '![art](images/Art_P1201b.jpg)'
  id: totrans-487
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1201b.jpg)'
- en: In this section, let 〈*a*〉 denote the subgroup of ![art](images/Art_Zastn.jpg)
    generated by *a* through repeated multiplication, and let ord[*n*](*a*) (the “order
    of *a*, modulo *n*”) denote the order of *a* in ![art](images/Art_Zastn.jpg).
    For example, 〈2〉 = {1, 2, 4} in ![art](images/Art_P1202.jpg), and ord[7](2) =
    3\. Using the definition of the Euler phi function *ϕ*(*n*) as the size of ![art](images/Art_Zastn.jpg)
    (see [Section 31.3](chapter031.xhtml#Sec_31.3)), we now translate Corollary 31.19
    into the notation of ![art](images/Art_Zastn.jpg) to obtain Euler’s theorem and
    specialize it to ![art](images/Art_Zastp.jpg), where *p* is prime, to obtain Fermat’s
    theorem.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，让〈*a*〉表示通过重复乘法生成的![art](images/Art_Zastn.jpg)中的子群，让ord[*n*](*a*)（“模*n*中*a*的阶”）表示![art](images/Art_Zastn.jpg)中*a*的阶。例如，在![art](images/Art_P1202.jpg)中，〈2〉
    = {1, 2, 4}，ord[7](2) = 3。使用欧拉phi函数*ϕ*(*n*)的定义作为![art](images/Art_Zastn.jpg)的大小（参见[第31.3节](chapter031.xhtml#Sec_31.3)），我们现在将推论31.19转换为![art](images/Art_Zastn.jpg)的符号以获得欧拉定理，并将其专门化为![art](images/Art_Zastp.jpg)，其中*p*是质数，以获得费马定理。
- en: '***Theorem 31.30 (Euler’s theorem)***'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理31.30（欧拉定理）***'
- en: For any integer *n* > 1,
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何整数*n* > 1，
- en: '![art](images/Art_P1203.jpg)'
  id: totrans-491
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1203.jpg)'
- en: ▪
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Theorem 31.31 (Fermat’s theorem)***'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理31.31（费马定理）***'
- en: If *p* is prime, then
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*p*是质数，则
- en: '![art](images/Art_P1204.jpg)'
  id: totrans-495
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1204.jpg)'
- en: '***Proof***   By equation (31.22), *ϕ*(*p*) = *p* – 1 if *p* is prime.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   根据方程(31.22)，如果*p*是质数，则*ϕ*(*p*) = *p* – 1。'
- en: ▪
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Fermat’s theorem applies to every element in ℤ[*p*] except 0, since ![art](images/Art_P1205.jpg).
    For all *a* ∈ ℤ[*p*], however, we have *a*^(*p*) = *a* (mod *p*) if *p* is prime.
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 对于ℤ[*p*]中的每个元素，费马定理都适用，除了0，因为![art](images/Art_P1205.jpg)。然而，对于所有*a* ∈ ℤ[*p*]，如果*p*是质数，则我们有*a*^(*p*)
    = *a* (mod *p*)。
- en: If ![art](images/Art_P1206.jpg), then every element in ![art](images/Art_Zastn.jpg)
    is a power of *g*, modulo *n*, and *g* is a ***primitive root*** or a ***generator***
    of ![art](images/Art_Zastn.jpg). For example, 3 is a primitive root, modulo 7,
    but 2 is not a primitive root, modulo 7\. If ![art](images/Art_Zastn.jpg) possesses
    a primitive root, the group ![art](images/Art_Zastn.jpg) is ***cyclic***. We omit
    the proof of the following theorem, which is proven by Niven and Zuckerman [[345](bibliography001.xhtml#endnote_345)].
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 如果![art](images/Art_P1206.jpg)，那么![art](images/Art_Zastn.jpg)中的每个元素都是*g*的幂，模*n*，*g*是***原根***或***生成元***。例如，3是原根，模7，但2不是原根，模7。如果![art](images/Art_Zastn.jpg)具有原根，则群![art](images/Art_Zastn.jpg)是***循环***的。我们省略以下定理的证明，该定理由Niven和Zuckerman证明[[345](bibliography001.xhtml#endnote_345)]。
- en: '***Theorem 31.32***'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理31.32***'
- en: The values of *n* > 1 for which ![art](images/Art_Zastn.jpg) is cyclic are 2,
    4, *p*^(*e*), and 2*p*^(*e*), for all primes *p* > 2 and all positive integers
    *e*.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 使得![art](images/Art_Zastn.jpg)是循环的*n* > 1的值为2、4、*p*^(*e*)和2*p*^(*e*)，对于所有大于2的质数*p*和所有正整数*e*。
- en: ▪
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: If *g* is a primitive root of ![art](images/Art_Zastn.jpg) and *a* is any element
    of ![art](images/Art_Zastn.jpg), then there exists a *z* such that *g*^(*z*) =
    *a* (mod *n*). This *z* is a ***discrete logarithm*** or an ***index*** of *a*,
    modulo *n*, to the base *g*. We denote this value as ind[*n*,*g*](*a*).
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*g*是![艺术](images/Art_Zastn.jpg)的一个原根，*a*是![艺术](images/Art_Zastn.jpg)的任意元素，则存在��个*z*使得*g*^(*z*)
    = *a* (mod *n*)。这个*z*是*模n*的***离散对数***或*基于g*的***指数***。我们将这个值表示为ind[*n*,*g*](*a*)。
- en: '***Theorem 31.33 (Discrete logarithm theorem)***'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理31.33（离散对数定理）***'
- en: If *g* is a primitive root of ![art](images/Art_Zastn.jpg), then the equation
    *g*^(*x*) = *g*^(*y*) (mod *n*) holds if and only if the equation *x* = *y* (mod
    *ϕ*(*n*)) holds.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*g*是![艺术](images/Art_Zastn.jpg)的一个原根，则方程*g*^(*x*) = *g*^(*y*) (mod *n*)成立当且仅当方程*x*
    = *y* (mod *ϕ*(*n*))成立。
- en: '***Proof***   Suppose first that *x* = *y* (mod *ϕ*(*n*)). Then, we have *x*
    = *y* + *kϕ*(*n*) for some integer *k*, and thus'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 假设首先*x* = *y* (mod *ϕ*(*n*))。那么，我们有*x* = *y* + *kϕ*(*n*)，其中*k*是某个整数，因此'
- en: '| *g*^(*x*) | = *g*^(*y*+*kϕ*(*n*)) | (mod *n*) |  |'
  id: totrans-507
  prefs: []
  type: TYPE_TB
  zh: '| *g*^(*x*) | = *g*^(*y*+*kϕ*(*n*)) | (mod *n*) |  |'
- en: '|  | = *g*^(*y*) · (*g*^(*ϕ*(*n*)))^(*k*) | (mod *n*) |  |'
  id: totrans-508
  prefs: []
  type: TYPE_TB
  zh: '|  | = *g*^(*y*) · (*g*^(*ϕ*(*n*)))^(*k*) | (mod *n*) |  |'
- en: '|  | = *g*^(*y*) · 1^(*k*) | (mod *n*) | (by Euler’s theorem) |'
  id: totrans-509
  prefs: []
  type: TYPE_TB
  zh: '|  | = *g*^(*y*) · 1^(*k*) | (mod *n*) | (根据欧拉定理) |'
- en: '|  | = *g*^(*y*) | (mod *n*). |  |'
  id: totrans-510
  prefs: []
  type: TYPE_TB
  zh: '|  | = *g*^(*y*) | (mod *n*)。 |  |'
- en: Conversely, suppose that *g*^(*x*) = *g*^(*y*) (mod *n*). Because the sequence
    of powers of *g* generates every element of 〈*g*〉 and |〈*g*〉| = *ϕ*(*n*), Corollary
    31.18 implies that the sequence of powers of *g* is periodic with period *ϕ*(*n*).
    Therefore, if *g*^(*x*) = *g*^(*y*) (mod *n*), we must have *x* = *y* (mod *ϕ*(*n*)).
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，假设*g*^(*x*) = *g*^(*y*) (mod *n*)。因为*g*的幂生成〈*g*〉的每个元素且|〈*g*〉| = *ϕ*(*n*)，推论31.18暗示*g*的幂序列以周期*ϕ*(*n*)重复。因此，如果*g*^(*x*)
    = *g*^(*y*) (mod *n*)，我们必须有*x* = *y* (mod *ϕ*(*n*))。
- en: ▪
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Let’s now turn our attention to the square roots of 1, modulo a prime power.
    The following properties will be useful to justify the primality-testing algorithm
    in [Section 31.8](chapter031.xhtml#Sec_31.8).
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们关注于模素数幂的1的平方根。以下性质将有助于证明[第31.8节](chapter031.xhtml#Sec_31.8)中的素性测试算法。
- en: '***Theorem 31.34***'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理31.34***'
- en: If *p* is an odd prime and *e* ≥ 1, then the equation
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*p*是一个奇素数且*e*≥1，则方程
- en: '![art](images/Art_P1207.jpg)'
  id: totrans-516
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1207.jpg)'
- en: has only two solutions, namely *x* = 1 and *x* = −1.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 只有两个解，即*x* = 1和*x* = −1。
- en: '***Proof***   By Exercise 31.6-2, equation (31.33) is equivalent to'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 根据练习31.6-2，方程(31.33)等价于'
- en: '*p*^(*e*) | (*x* − 1)(*x* + 1).'
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: '*p*^(*e*) | (*x* − 1)(*x* + 1).'
- en: Since *p* > 2, we can have *p* | (*x* − 1) or *p* | (*x* + 1), but not both.
    (Otherwise, by property (31.3), *p* would also divide their difference (*x* +
    1) – (*x* − 1) = 2.) If *p* ∤ (*x* – 1), then gcd(*p*^(*e*), *x* − 1) = 1, and
    by Corollary 31.5, we would have *p*^(*e*) | (*x* + 1). That is, *x* = −1 (mod
    *p*^(*e*)). Symmetrically, if *p* ∤ (*x* + 1), then gcd(*p*^(*e*), *x* + 1) =
    1, and Corollary 31.5 implies that *p*^(*e*) | (*x* − 1), so that *x* = 1 (mod
    *p*^(*e*)). Therefore, either *x* = −1 (mod *p*^(*e*)) or *x* = 1 (mod *p*^(*e*)).
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*p*>2，我们可以有*p*|(*x* − 1)或*p*|(*x* + 1)，但不能同时成立（否则，根据性质（31.3），*p*也会整除它们的差值(*x*
    + 1) – (*x* − 1) = 2）。如果*p*∤(*x* – 1)，那么gcd(*p*^(*e*), *x* − 1) = 1，根据推论31.5，我们会有*p*^(*e*)|(*x*
    + 1)。也就是说，*x* = −1 (mod *p*^(*e*))。对称地，如果*p*∤(*x* + 1)，那么gcd(*p*^(*e*), *x* +
    1) = 1，根据推论31.5，我们会有*p*^(*e*)|(*x* − 1)，所以*x* = 1 (mod *p*^(*e*))。因此，要么*x* = −1
    (mod *p*^(*e*))，要么*x* = 1 (mod *p*^(*e*))。
- en: ▪
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: 'A number *x* is a ***nontrivial square root of* 1, *modulo n***, if it satisfies
    the equation *x*² = 1 (mod *n*) but *x* is equivalent to neither of the two “trivial”
    square roots: 1 or −1, modulo *n*. For example, 6 is a nontrivial square root
    of 1, modulo 35\. We’ll use the following corollary to Theorem 31.34 in [Section
    31.8](chapter031.xhtml#Sec_31.8) to prove the Miller-Rabin primality-testing procedure
    correct.'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个数*x*是模*n*的***非平凡平方根* 1***，那么它满足方程*x*² = 1 (mod *n*)，但*x*既不等价于1也不等价于−1，模*n*。例如，6是模35的1的非平凡平方根。我们将使用[第31.8节](chapter031.xhtml#Sec_31.8)中定理31.34的推论来证明Miller-Rabin素性测试过程的正确性。
- en: '***Corollary 31.35***'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '***推论31.35***'
- en: If there exists a nontrivial square root of 1, modulo *n*, then *n* is composite.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 如果存在模*n*的非平凡平方根* 1，则*n*是合数。
- en: '***Proof***   By the contrapositive of Theorem 31.34, if there exists a nontrivial
    square root of 1, modulo *n*, then *n* cannot be an odd prime or a power of an
    odd prime. Nor can *n* be 2, because if *x*² = 1 (mod 2), then *x* = 1 (mod 2),
    and therefore, all square roots of 1, modulo 2, are trivial. Thus, *n* cannot
    be prime. Finally, we must have *n* > 1 for a nontrivial square root of 1 to exist.
    Therefore, *n* must be composite.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 根据定理31.34的逆否命题，如果存在模*n*的非平凡平方根* 1，则*n*不能是奇素数或奇素数的幂。*n*也不能是2，因为如果*x*²
    = 1 (mod 2)，那么*x* = 1 (mod 2)，因此，模2的所有平方根都是平凡的。因此，*n*不能是素数。最后，我们必须有*n*>1才能存在非平凡的1的平方根。因此，*n*必须是合数。'
- en: ▪
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Raising to powers with repeated squaring**'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: '**使用重复平方法进行幂运算**'
- en: A frequently occurring operation in number-theoretic computations is raising
    one number to a power modulo another number, also known as ***modular exponentiation***.
    More precisely, we would like an efficient way to compute *a*^(*b*) mod *n*, where
    *a* and *b* are nonnegative integers and *n* is a positive integer. Modular exponentiation
    is an essential operation in many primality-testing routines and in the RSA public-key
    cryptosystem. The method of ***repeated squaring*** solves this problem efficiently.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 数论计算中经常出现的一个操作是对一个数取模另一个数的幂，也称为***模指数运算***。更准确地说，我们希望以高效的方式计算*a*^(*b*) mod *n*，其中*a*和*b*是非负整数，*n*是正整数。模指数运算是许多素性测试程序和RSA公钥加密系统中的重要操作。***重复平方法***解决了这个问题。
- en: 'Repeated squaring is based on the following formula to compute *a*^(*b*) for
    nonnegative integers *a* and *b*:'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 重复平方法基于以下公式来计算非负整数*a*和*b*的*a*^(*b*)：
- en: '![art](images/Art_P1208.jpg)'
  id: totrans-530
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1208.jpg)'
- en: The last case, where *b* is odd, reduces to the one of the first two cases,
    since if *b* is odd, then *b* − 1 is even. The recursive procedure MODULAR-EXPONENTIATION
    on the next page computes *a*^(*b*) mod *n* using equation (31.34), but performing
    all computations modulo *n*. The term “repeated squaring” comes from squaring
    the intermediate result *d* = *a*^(*b*/2) in line 5\. [Figure 31.4](chapter031.xhtml#Fig_31-4)
    shows the values of the parameter *b*, the local variable *d*, and the value returned
    at each level of the recursion for the call MODULAR-EXPONENTIATION(7,560,561),
    which returns the result 1.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一种情况，当 *b* 是奇数时，会简化为前两种情况之一，因为如果 *b* 是奇数，那么 *b* − 1 就是偶数。下一页的递归过程 MODULAR-EXPONENTIATION
    使用方程（31.34）计算 *a*^(*b*) mod *n*，但所有计算都在模 *n* 下进行。术语“重复平方”来自于在第5行平方中间结果 *d* = *a*^(*b*/2)。[图
    31.4](chapter031.xhtml#Fig_31-4) 展示了参数 *b*、局部变量 *d* 以及每个递归调用返回的值，用于调用 MODULAR-EXPONENTIATION(7,560,561)，返回结果为
    1。
- en: '![art](images/Art_P1209.jpg)'
  id: totrans-532
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1209.jpg)'
- en: '**Figure 31.4** The values of the parameter *b*, the local variable *d*, and
    the value returned for recursive calls of MODULAR-EXPONENTIATION with parameter
    values *a* = 7, *b* = 560, and *n* = 561\. The value returned by each recursive
    call is assigned directly to *d*. The result of the call with *a* = 7, *b* = 560,
    and *n* = 561 is 1.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 31.4** 参数 *b*、局部变量 *d* 以及递归调用 MODULAR-EXPONENTIATION 的返回值，参数值为 *a* = 7,
    *b* = 560, *n* = 561。每个递归调用返回的值直接赋给 *d*。调用 *a* = 7, *b* = 560, *n* = 561 的结果为
    1。'
- en: MODULAR-EXPONENTIATION(*a*, *b*, *n*)
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: MODULAR-EXPONENTIATION(*a*, *b*, *n*)
- en: '| 1 | **if** *b* == 0 |  |'
  id: totrans-535
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **如果** *b* == 0 |  |'
- en: '| 2 | **return** 1 |  |'
  id: totrans-536
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **返回** 1 |  |'
- en: '| 3 | **elseif** *b* mod 2 == 0 |  |'
  id: totrans-537
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **否则如果** *b* mod 2 == 0 |  |'
- en: '| 4 | *d* = MODULAR-EXPONENTIATION(*a*, *b*/2, *n*) | **//** *b* is even |'
  id: totrans-538
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *d* = 模幂(*a*, *b*/2, *n*) | **//** *b* 是偶数 |'
- en: '| 5 | **return** (*d* · *d*) mod *n* |  |'
  id: totrans-539
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **返回** (*d* · *d*) mod *n* |  |'
- en: '| 6 | **else** *d* = MODULAR-EXPONENTIATION(*a*, *b* − 1, *n*) | **//** *b*
    is odd |'
  id: totrans-540
  prefs: []
  type: TYPE_TB
  zh: '| 6 | **否则** *d* = MODULAR-EXPONENTIATION(*a*, *b* − 1, *n*) | **//** *b* 是奇数
    |'
- en: '| 7 | **return** (*a* · *d*) mod *n* |  |'
  id: totrans-541
  prefs: []
  type: TYPE_TB
  zh: '| 7 | **返回** (*a* · *d*) mod *n* |  |'
- en: The total number of recursive calls depends on the number of bits of *b* and
    the values of these bits. Assume that *b* > 0 and that the most significant bit
    of *b* is a 1\. Each 0 generates one recursive call (in line 4), and each 1 generates
    two recursive calls (one in line 6 followed by one in line 4 because if *b* is
    odd, then *b* − 1 is even). If the inputs *a*, *b*, and *n* are *β*-bit numbers,
    then there are between *β* and 2*β* − 1 recursive calls altogether, the total
    number of arithmetic operations required is *O*(*β*), and the total number of
    bit operations required is *O*(*β*³).
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 递归调用的总次数取决于 *b* 的位数和这些位的值。假设 *b* > 0 并且 *b* 的最高位是 1。每个 0 生成一个递归调用（在第4行），每个 1
    生成两个递归调用（一个在第6行，然后一个在第4行，因为如果 *b* 是奇数，那么 *b* − 1 就是偶数）。如果输入 *a*、*b* 和 *n* 是 *β*
    位数，那么总共有 *β* 到 2*β* − 1 个递归调用，所需的算术操作总数为 *O*(*β*)，所��的位操作总数为 *O*(*β*³)。
- en: '**Exercises**'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***31.6-1***'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.6-1***'
- en: Draw a table showing the order of every element in ![art](images/Art_P1210.jpg).
    Pick the smallest primitive root *g* and compute a table giving ind[11,*g*](*x*)
    for all ![art](images/Art_P1211.jpg).
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 绘制一张表，显示 ![art](images/Art_P1210.jpg) 中每个元素的顺序。选择最小的原根 *g* 并计算给出所有 ![art](images/Art_P1211.jpg)
    的 ind[11,*g*](*x*) 的表。
- en: '***31.6-2***'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.6-2***'
- en: Show that *x*² = 1 (mod *p*^(*e*)) is equivalent to *p*^(*e*) | (*x* − 1)(*x*
    + 1).
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 证明 *x*² = 1 (mod *p*^(*e*)) 等价于 *p*^(*e*) | (*x* − 1)(*x* + 1)。
- en: '***31.6-3***'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.6-3***'
- en: Rewrite the third case of MODULAR-EXPONENTIATION, where *b* is odd, so that
    if *b* has *β* bits and the most significant bit is 1, then there are always exactly
    *β* recursive calls.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 重写 MODULAR-EXPONENTIATION 的第三种情况，其中 *b* 是奇数，以便如果 *b* 有 *β* 位且最高位为 1，则总是恰好有 *β*
    个递归调用。
- en: '***31.6-4***'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.6-4***'
- en: Give a nonrecursive (i.e., iterative) version of MODULAR-EXPONENTIATION.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 给出 MODULAR-EXPONENTIATION 的非递归（即迭代）版本。
- en: '***31.6-5***'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.6-5***'
- en: Assuming that you know *ϕ*(*n*), explain how to compute *a*^(−1) mod *n* for
    any ![art](images/Art_P1212.jpg) using the procedure MODULAR-EXPONENTIATION.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你知道 *ϕ*(*n*)，解释如何使用 MODULAR-EXPONENTIATION 过程计算任何 ![art](images/Art_P1212.jpg)
    的 *a*^(−1) mod *n*。
- en: '[**31.7    The RSA public-key cryptosystem**](toc.xhtml#Rh1-183)'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '[**31.7    RSA 公钥密码系统**](toc.xhtml#Rh1-183)'
- en: With a public-key cryptosystem, you can ***encrypt*** messages sent between
    two communicating parties so that an eavesdropper who overhears the encrypted
    messages will not be able to decode, or ***decrypt***, them. A public-key cryptosystem
    also enables a party to append an unforgeable “digital signature” to the end of
    an electronic message. Such a signature is the electronic version of a handwritten
    signature on a paper document. It can be easily checked by anyone, forged by no
    one, yet loses its validity if any bit of the message is altered. It therefore
    provides authentication of both the identity of the signer and the contents of
    the signed message. It is the perfect tool for electronically signed business
    contracts, electronic checks, electronic purchase orders, and other electronic
    communications that parties wish to authenticate.
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 使用公钥密码系统，你可以加密两个通信方之间发送的消息，以便窃听者无法解码或解密加密的消息。公钥密码系统还使一方能够在电子消息的末尾附加一个不可伪造的“数字签名”。这样的签名是纸质文件上手写签名的电子版本。任何人都可以轻松验证，但没有人可以伪造，如果消息的任何位被更改，它将失去有效性。因此，它提供了签署者身份和签署消息内容的认证。这是用于电子签署的商业合同、电子支票、电子采购订单和其他希望进行身份验证的电子通信的完美工具。
- en: The RSA public-key cryptosystem relies on the dramatic difference between the
    ease of finding large prime numbers and the difficulty of factoring the product
    of two large prime numbers. [Section 31.8](chapter031.xhtml#Sec_31.8) describes
    an efficient procedure for finding large prime numbers.
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: RSA 公钥密码系统依赖于找到大素数的容易性和分解两个大素数乘积的困难性之间的显著差异。[第 31.8 节](chapter031.xhtml#Sec_31.8)
    描述了一种有效的找到大素数的过程。
- en: '**Public-key cryptosystems**'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: '**公钥密码系统**'
- en: In a public-key cryptosystem, each participant has both a ***public key*** and
    a ***secret key***. Each key is a piece of information. For example, in the RSA
    cryptosystem, each key consists of a pair of integers. The participants “Alice”
    and “Bob” are traditionally used in cryptography examples. We denote the public
    keys for Alice and Bob as *P*[*A*] and *P*[*B*], respectively, and likewise the
    secret keys are *S*[*A*] for Alice and *S*[*B*] for Bob.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: 在公钥加密系统中，每个参与者都有一个***公钥***和一个***私钥***。每个密钥都是一段信息。例如，在RSA加密系统中，每个密钥由一对整数组成。在密码学示例中，传统上使用“爱丽丝”和“鲍勃”这两个名称。我们分别将爱丽丝和鲍勃的公钥表示为*P*[A]和*P*[B]，同样私钥为爱丽丝的*S*[A]和鲍勃的*S*[B]。
- en: Each participant creates his or her own public and secret keys. Secret keys
    are kept secret, but public keys can be revealed to anyone or even published.
    In fact, it is often convenient to assume that everyone’s public key is available
    in a public directory, so that any participant can easily obtain the public key
    of any other participant.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 每个参与者都创建自己的公钥和私钥。私钥保密，但公钥可以向任何人公开甚至发布。事实上，通常方便假设每个人的公钥都可以在公共目录中获得，以便任何参与者都可以轻松获取任何其他参与者的公钥。
- en: '![art](images/Art_P1213.jpg)'
  id: totrans-560
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1213.jpg)'
- en: '**Figure 31.5** Encryption in a public key system. Bob encrypts the message
    *M* using Alice’s public key *P*[*A*] and transmits the resulting ciphertext *C*
    = *P*[*A*](*M*) over a communication channel to Alice. An eavesdropper who captures
    the transmitted ciphertext gains no information about *M*. Alice receives *C*
    and decrypts it using her secret key to obtain the original message *M* = *S*[*A*](*C*).'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '**图31.5** 公钥系统中的加密。鲍勃使用爱丽丝的公钥*P*[A]加密消息*M*，并将生成的密文*C* = *P*[A](*M*)通过通信渠道传输给爱丽丝。捕获传输密文的窃听者对*M*没有任何信息。爱丽丝接收*C*并使用她的私钥解密，以获得原始消息*M*
    = *S*[A](*C*)。'
- en: The public and secret keys specify functions that can be applied to any message.
    Let D denote the set of permissible messages. For example, D might be the set
    of all finite-length bit sequences. The simplest, and original, formulation of
    public-key cryptography requires one-to-one functions from D to itself, based
    on the public and secret keys. We denote the function based on Alice’s public
    key *P*[*A*] by *P*[*A*]() and the function based on her secret key *S*[*A*] by
    *S*[*A*](). The functions *P*[*A*]() and *S*[*A*]() are thus permutations of D.
    We assume that the functions *P*[*A*]() and *S*[*A*]() are efficiently computable
    given the corresponding keys *P*[*A*] and *S*[*A*].
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥和私钥指定了可以应用于任何消息的函数。让D表示可允许的消息集。例如，D可能是所有有限长度比特序列的集合。公钥加密的最简单和最初的公式要求从D到自身的一对一函数，基于公钥和私钥。我们用基于爱丽丝的公钥*P*[A]的函数表示为*P*[A]()，用基于她的私钥*S*[A]的函数表示为*S*[A]()。因此，*P*[A]()和*S*[A]()是D的排列。我们假设在给定相应的密钥*P*[A]和*S*[A]*的情况下，函数*P*[A]()和*S*[A]()是可以高效计算的。
- en: The public and secret keys for any participant are a “matched pair” in that
    they specify functions that are inverses of each other. That is,
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: 任何参与者的公钥和私钥都是“匹配对”，因为它们指定了彼此的反函数。也就是说，
- en: '![art](images/Art_P1214.jpg)'
  id: totrans-564
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1214.jpg)'
- en: for any message *M* ∈ D. Transforming *M* with the two keys *P*[*A*] and *S*[*A*]
    successively, in either order, yields back the original message *M*.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任何消息*M* ∈ D。使用两个密钥*P*[A]和*S*[A]*对*M*进行连续变换，无论顺序如何，都会得到原始消息*M*。
- en: A public-key cryptosystem requires that Alice, and only Alice, be able to compute
    the function *S*[*A*]() in any practical amount of time. This assumption is crucial
    to keeping encrypted messages sent to Alice private and to knowing that Alice’s
    digital signatures are authentic. Alice must keep her key *S*[*A*] secret. If
    she does not, whoever else has access to *S*[*A*] can decrypt messages intended
    only for Alice and can also forge her digital signature. The assumption that only
    Alice can reasonably compute *S*[*A*]() must hold even though everyone knows *P*[*A*]
    and can compute *P*[*A*](), the inverse function to *S*[*A*](), efficiently. These
    requirements appear formidable, but we’ll see how to satisfy them.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥加密系统要求爱丽丝，且仅爱丽丝，能够在任何实际时间内计算函数*S*[A]()。这一假设对于保持发送给爱丽丝的加密消息私密以及知道爱丽丝的数字签名是真实的至关重要。爱丽丝必须保密她的密钥*S*[A]。如果她没有保密，那么其他人访问*S*[A]，就可以解密仅供爱丽丝阅读的消息，并且还可以伪造她的数字签名。即使每个人都知道*P*[A]并且可以高效计算*P*[A]()的逆函数*S*[A]()，也必须假设只有爱丽丝能够合理计算*S*[A]()。这些要求看起来很严峻，但我们将看到如何满足它们。
- en: In a public-key cryptosystem, encryption works as shown in [Figure 31.5](chapter031.xhtml#Fig_31-5).
    Suppose that Bob wishes to send Alice a message *M* encrypted so that it looks
    like
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在公钥加密系统中，加密如[图31.5](chapter031.xhtml#Fig_31-5)所示。假设鲍勃希望发送给爱丽丝一个加密的消息*M*，使其看起来像
- en: '![art](images/Art_P1215.jpg)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1215.jpg)'
- en: '**Figure 31.6** Digital signatures in a public-key system. Alice signs the
    message *M*′ by appending her digital signature *σ* = *S*[*A*](*M*′) to it. She
    transmits the message/signature pair (*M*′, *σ*) to Bob, who verifies it by checking
    the equation *M*′ = *P*[*A*](*σ*). If the equation holds, he accepts (*M*′, *σ*)
    as a message that Alice has signed.'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '**图31.6** 公钥系统中的数字签名。爱丽丝通过将她的数字签名*σ* = *S*[A](*M*′)附加到消息*M*′上来签署消息。她将消息/签名对(*M*′，*σ*)发送给鲍勃，鲍勃通过检查等式*M*′
    = *P*[A](*σ*)来验证它。如果等式成立，他接受(*M*′，*σ*)作为爱丽丝签署的消息。'
- en: unintelligible gibberish to an eavesdropper. The scenario for sending the message
    goes as follows.
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: 对窃听者来说是无法理解的胡言乱语。发送消息的场景如下。
- en: Bob obtains Alice’s public key *P*[*A*], perhaps from a public directory or
    perhaps directly from Alice.
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鲍勃获取爱丽丝的公钥*P*[A]，可能是从公共目录中获取，也可能直接从爱丽丝那里获取。
- en: Bob computes the ***ciphertext*** *C* = *P*[*A*](*M*) corresponding to the message
    *M* and sends *C* to Alice.
  id: totrans-572
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 鲍勃计算与消息*M*对应的***密文*** *C* = *P*[A](*M*)，并将*C*发送给爱丽丝。
- en: 'When Alice receives the ciphertext *C*, she applies her secret key *S*[*A*]
    to retrieve the original message: *S*[*A*](*C*) = *S*[*A*](*P*[*A*](*M*)) = *M*.'
  id: totrans-573
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Alice接收到密文*C*时，她应用她的秘钥*S*[*A*]来检索原始消息：*S*[*A*](*C*) = *S*[*A*](*P*[*A*](*M*))
    = *M*。
- en: Because *S*[*A*]() and *P*[*A*]() are inverse functions, Alice can compute *M*
    from *C*. Because only Alice is able to compute *S*[*A*](), only Alice can compute
    *M* from *C*. Because Bob encrypts *M* using *P*[*A*](), only Alice can understand
    the transmitted message.
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*S*[*A*]()和*P*[*A*]()是互为反函数，Alice可以从*C*计算*M*。因为只有Alice能够计算*S*[*A*]()，所以只有Alice能够从*C*计算*M*。因为Bob使用*P*[*A*]()加密*M*，所以只有Alice能够理解传输的消息。
- en: Digital signatures can be implemented within this formulation of a public-key
    cryptosystem. (There are other ways to construct digital signatures, but we won’t
    go into them here.) Suppose now that Alice wishes to send Bob a digitally signed
    response *M*′. [Figure 31.6](chapter031.xhtml#Fig_31-6) shows how the digital-signature
    scenario proceeds.
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名可以在这种公钥密码系统的框架内实现。（还有其他构建数字签名的方法，但我们在这里不详细介绍。）现在假设Alice希望向Bob发送一个数字签名响应*M*′。[图31.6](chapter031.xhtml#Fig_31-6)展示了数字签名场景的进行过程。
- en: Alice computes her ***digital signature*** *σ* for the message *M*′ using her
    secret key *S*[*A*] and the equation *σ* = *S*[*A*](*M*′).
  id: totrans-576
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice使用她的秘钥*S*[*A*]和方程*σ* = *S*[*A*](*M*′)计算她的***数字签名*** *σ*。
- en: Alice sends the message/signature pair (*M*′, *σ*) to Bob.
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Alice将消息/签名对(*M*′, *σ*)发送给Bob。
- en: When Bob receives (*M*′, *σ*), he can verify that it originated from Alice by
    using Alice’s public key to verify the equation *M*′ = *P*[*A*](*σ*). (Presumably,
    *M*′ contains Alice’s name, so that Bob knows whose public key to use.) If the
    equation holds, then Bob concludes that the message *M*′ was actually signed by
    Alice. If the equation fails to hold, Bob concludes either that the information
    he received was corrupted by transmission errors or that the pair (*M*′, *σ*)
    is an attempted forgery.
  id: totrans-578
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当Bob接收(*M*′, *σ*)时，他可以使用Alice的公钥验证方程*M*′ = *P*[*A*](*σ*)，从而验证它是由Alice发出的。（假设*M*′包含Alice的名字，这样Bob就知道要使用谁的公钥。）如果方程成立，那么Bob得出结论，消息*M*′实际上是由Alice签名的。如果方程不成立，Bob则得出结论，他收到的信息可能被传输错误损坏，或者(*M*′,
    *σ*)是一次尝试的伪造。
- en: Because a digital signature provides both authentication of the signer’s identity
    and authentication of the contents of the signed message, it is analogous to a
    handwritten signature at the end of a written document.
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 因为数字签名既提供了签名者身份的认证，又提供了签名消息内容的认证，类似于手写签名在书面文件末尾的作用。
- en: A digital signature must be verifiable by anyone who has access to the signer’s
    public key. A signed message can be verified by one party and then passed on to
    other parties who can also verify the signature. For example, the message might
    be an electronic check from Alice to Bob. After Bob verifies Alice’s signature
    on the check, he can give the check to his bank, who can then also verify the
    signature and effect the appropriate funds transfer.
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 数字签名必须能够被任何拥有签名者公钥的人验证。一方验证了签名的消息后，可以将其传递给其他方也进行验证签名。例如，消息可能是Alice给Bob的电子支票。Bob在验证Alice在支票上的签名后，可以将支票交给他的银行，银行也可以验证签名并进行适当的资金转移。
- en: A signed message may or may not be encrypted. The message can be “in the clear”
    and not protected from disclosure. By composing the above protocols for encryption
    and for signatures, Alice can create a message to Bob that is both signed and
    encrypted. Alice first appends her digital signature to the message and then encrypts
    the resulting message/signature pair with Bob’s public key. Bob decrypts the received
    message with his secret key to obtain both the original message and its digital
    signature. Bob can then verify the signature using Alice’s public key. The corresponding
    combined process using paper-based systems would be to sign the paper document
    and then seal the document inside a paper envelope that is opened only by the
    intended recipient.
  id: totrans-581
  prefs: []
  type: TYPE_NORMAL
  zh: 签名消息可以加密也可以不加密。消息可以是“明文”，没有受到保护免受披露。通过组合上述加密和签名协议，Alice可以创建一个既签名又加密的消息发送给Bob。Alice首先将她的数字签名附加到消息上，然后使用Bob的公��加密结果的消息/签名对。Bob使用他的秘钥解密接收到的消息，以获取原始消息和数字签名。然后Bob可以使用Alice的公钥验证签名。使用纸质系统的相应组合过程是在纸质文件上签名，然后将文件封装在只有预期接收者才能打开的纸质信封中。
- en: '**The RSA cryptosystem**'
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: '**RSA密码系统**'
- en: 'In the ***RSA public-key cryptosystem***, a participant creates a public key
    and a secret key with the following procedure:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 在***RSA公钥密码系统***中，参与者通过以下过程创建公钥和秘钥：
- en: Select at random two large prime numbers *p* and *q* such that *p* ≠ *q*. The
    primes *p* and *q* might be, say, 1024 bits each.
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 随机选择两个大素数*p*和*q*，使得*p* ≠ *q*。这些素数*p*和*q*可能是，比如，每个1024位。
- en: Compute *n* = *pq*.
  id: totrans-585
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算*n* = *pq*。
- en: Select a small odd integer *e* that is relatively prime to *ϕ*(*n*), which,
    by equation (31.21), equals (*p* – 1)(*q* – 1).
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个与*ϕ*(*n*)互质的小奇整数*e*，根据方程(31.21)，*ϕ*(*n*)等于(*p* – 1)(*q* – 1)。
- en: Compute *d* as the multiplicative inverse of *e*, modulo *ϕ*(*n*). (Corollary
    31.26 guarantees that *d* exists and is uniquely defined. You can use the technique
    of [Section 31.4](chapter031.xhtml#Sec_31.4) to compute *d*, given *e* and *ϕ*(*n*).)
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算*d*作为*e*的模*ϕ*(*n*)的乘法逆元。（推论31.26保证*d*存在且唯一定义。可以使用[第31.4节](chapter031.xhtml#Sec_31.4)的技术，根据*e*和*ϕ*(*n*)计算*d*。）
- en: Publish the pair *P* = (*e*, *n*) as the participant’s ***RSA public key***.
  id: totrans-588
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*P* = (*e*, *n*)发布为参与者的***RSA公钥***。
- en: Keep secret the pair *S* = (*d*, *n*) as the participant’s ***RSA secret key***.
  id: totrans-589
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*S* = (*d*, *n*)作为参与者的***RSA秘钥***保密。
- en: For this scheme, the domain D is the set ℤ[*n*]. To transform a message *M*
    associated with a public key *P* = (*e*, *n*), compute
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个方案，域D是集合ℤ[*n*]。要将与公钥*P* = (*e*, *n*)相关联的消息*M*转换，计算
- en: '![art](images/Art_P1216.jpg)'
  id: totrans-591
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1216.jpg)'
- en: To transform a ciphertext *C* associated with a secret key *S* = (*d*, *n*),
    compute
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 要将与秘钥*S* = (*d*, *n*)相关联的密文*C*转换，计算
- en: '![art](images/Art_P1217.jpg)'
  id: totrans-593
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1217.jpg)'
- en: These equations apply to both encryption and signatures. To create a signature,
    the signer’s secret key is applied to the message to be signed, rather than to
    a ciphertext. To verify a signature, the public key of the signer is applied to
    the signature rather than to a message to be encrypted.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 这些方程适用于加密和签名。要创建签名，签名者的私钥应用于要签名的消息，而不是应用于密文。要验证签名，签名者的公钥应用于签名，而不是应用于要加密的消息。
- en: To implement the public-key and secret-key operations (31.37) and (31.38), you
    can use the procedure MODULAR-EXPONENTIATION described in [Section 31.6](chapter031.xhtml#Sec_31.6).
    To analyze the running time of these operations, assume that the public key (*e*,
    *n*) and secret key (*d*, *n*) satisfy 1g *e* = *O*(1), 1g *d* ≤ *β*, and 1g *n*
    ≤ *β*. Then, applying a public key requires *O*(1) modular multiplications and
    uses *O*(*β*²) bit operations. Applying a secret key requires *O*(*β*) modular
    multiplications, using *O*(*β*³) bit operations.
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现公钥和私钥操作（31.37）和（31.38），你可以使用[第31.6节](chapter031.xhtml#Sec_31.6)中描述的MODULAR-EXPONENTIATION过程。为了分析这些操作的运行时间，假设公钥（*e*,
    *n*）和私钥（*d*, *n*）满足 1g *e* = *O*(1)，1g *d* ≤ *β*，1g *n* ≤ *β*。那么，应用公钥需要 *O*(1)
    模乘法，并使用 *O*(*β*²) 位运算。应用私钥需要 *O*(*β*) 模乘法，并使用 *O*(*β*³) 位运算。
- en: '***Theorem 31.36 (Correctness of RSA)***'
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理31.36（RSA的正确性）***'
- en: The RSA equations (31.37) and (31.38) define inverse transformations of ℤ[*n*]
    satisfying equations (31.35) and (31.36).
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: RSA方程（31.37）和（31.38）定义了满足方程（31.35）和（31.36）的ℤ[*n*]的逆变换。
- en: '***Proof***   From equations (31.37) and (31.38), we have that for any *M*
    ∈ ℤ[*n*],'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 从方程（31.37）和（31.38）中，我们知道对于任意的 *M* ∈ ℤ[*n*]，'
- en: '*P*(*S*(*M*)) = *S*(*P*(*M*)) = *M*^(*ed*) (mod *n*).'
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*(*S*(*M*)) = *S*(*P*(*M*)) = *M*^(*ed*) (mod *n*)。'
- en: Since *e* and *d* are multiplicative inverses modulo *ϕ*(*n*) = (*p* – 1)(*q*
    – 1),
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 *e* 和 *d* 是模 *ϕ*(*n*) = (*p* – 1)(*q* – 1) 的乘法逆元，
- en: '*ed* = 1 + *k*(*p* – 1)(*q* – 1)'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: '*ed* = 1 + *k*(*p* – 1)(*q* – 1)'
- en: for some integer *k*. But then, if *M* ≠ 0 (mod *p*), we have
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 对于某个整数 *k*。但是，如果 *M* ≠ 0 (mod *p*)，我们有
- en: '| *M*^(*ed*) | = *M*(*M*^(*p*–1))^(*k*(*q*–1)) | (mod *p*) |  |'
  id: totrans-603
  prefs: []
  type: TYPE_TB
  zh: '| *M*^(*ed*) | = *M*(*M*^(*p*–1))^(*k*(*q*–1)) | (mod *p*) |  |'
- en: '|  | = *M*((*M* mod *p*)^(*p*–1))^(*k*(*q*–1)) | (mod *p*) |  |'
  id: totrans-604
  prefs: []
  type: TYPE_TB
  zh: '|  | = *M*((*M* mod *p*)^(*p*–1))^(*k*(*q*–1)) | (mod *p*) |  |'
- en: '|  | = *M*(1)^(*k*(*q*–1)) | (mod *p*) | (by Theorem 31.31) |'
  id: totrans-605
  prefs: []
  type: TYPE_TB
  zh: '|  | = *M*(1)^(*k*(*q*–1)) | (mod *p*) | (根据定理31.31) |'
- en: '|  | = *M* | (mod *p*) |  |'
  id: totrans-606
  prefs: []
  type: TYPE_TB
  zh: '|  | = *M* | (mod *p*) |  |'
- en: Also, *M*^(*ed*) = *M* (mod *p*) if *M* = 0 (mod *p*). Thus,
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果 *M* = 0 (mod *p*)，那么 *M*^(*ed*) = *M* (mod *p*)。因此，
- en: '*M*^(*ed*) = *M* (mod *p*)'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: '*M*^(*ed*) = *M* (mod *p*)'
- en: for all *M*. Similarly,
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有的 *M*。同样地，
- en: '*M*^(*ed*) = *M* (mod *q*)'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: '*M*^(*ed*) = *M* (mod *q*)'
- en: for all *M*. Thus, by Corollary 31.29 to the Chinese remainder theorem,
  id: totrans-611
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有的 *M*。因此，根据中国剩余定理的推论31.29，
- en: '*M*^(*ed*) = *M* (mod *n*)'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: '*M*^(*ed*) = *M* (mod *n*)'
- en: for all *M*.
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有的 *M*。
- en: ▪
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: The security of the RSA cryptosystem rests in large part on the difficulty of
    factoring large integers. If an adversary can factor the modulus *n* in a public
    key, then the adversary can derive the secret key from the public key, using the
    knowledge of the factors *p* and *q* in the same way that the creator of the public
    key used them. Therefore, if factoring large integers is easy, then breaking the
    RSA cryptosystem is easy. The converse statement, that if factoring large integers
    is hard, then breaking RSA is hard, is unproven. After two decades of research,
    however, no easier method has been found to break the RSA public-key cryptosystem
    than to factor the modulus *n*. And factoring large integers is surprisingly difficult.
    By randomly selecting and multiplying together two 1024-bit primes, you can create
    a public key that cannot be “broken” in any feasible amount of time with current
    technology. In the absence of a fundamental breakthrough in the design of number-theoretic
    algorithms, and when implemented with care following recommended standards, the
    RSA cryptosystem is capable of providing a high degree of security in applications.
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: RSA密码系统的安全性在很大程度上取决于大整数的因数分解难度。如果对手可以因数分解公钥中的模 *n*，那么对手可以从公钥中推导出私钥，使用因子 *p*
    和 *q* 的知识，就像公钥的创建者使用它们一样。因此，如果因数分解大整数很容易，那么破解RSA密码系统也很容易。然而，反之命题，即如果因数分解大整数很困难，那么破解RSA也很困难，尚未得到证明。然而，经过两十年的研究，没有比因数分解模
    *n* 更容易破解RSA公钥密码系统的方法被发现。而且，因数分解大整数是令人惊讶地困难。通过随机选择并将两个1024位素数相乘，你可以创建一个在当前技术下无法在任何可行的时间内“破解”的公钥。在没有在数论算法设计方面的基本突破，并在遵循推荐标准的情况下实施时，RSA密码系统能够在应用中提供高度的安全性。
- en: In order to achieve security with the RSA cryptosystem, however, you should
    use integers that are quite long—more than 1000 bits—to resist possible advances
    in the art of factoring. In 2021, RSA moduli are commonly in the range of 2048
    to 4096 bits. To create moduli of such sizes, you must find large primes efficiently.
    [Section 31.8](chapter031.xhtml#Sec_31.8) addresses this problem.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用RSA密码系统实现安全性，你应该使用相当长的整数——超过1000位——以抵抗在因数分解领域的可能进展。在2021年，RSA模数通常在2048到4096位之间。要创建这样大小的模数，你必须有效地找到大素数。[第31.8节](chapter031.xhtml#Sec_31.8)解决了这个问题。
- en: For efficiency, RSA is often used in a “hybrid” or “key-management” mode with
    fast cryptosystems that are not public-key cryptosystems. With such a ***symmetric-key***
    system, the encryption and decryption keys are identical. If Alice wishes to send
    a long message *M* to Bob privately, she selects a random key *K* for the fast
    symmetric-key cryptosystem and encrypts *M* using *K*, obtaining ciphertext *C*,
    where *C* is as long as *M*, but *K* is quite short. Then she encrypts *K* using
    Bob’s public RSA key. Since *K* is short, computing *P*[*B*](*K*) is fast (much
    faster than computing *P*[*B*](*M*)). She then transmits (*C*, *P*[*B*](*K*))
    to Bob, who decrypts *P*[*B*](*K*) to obtain *K* and then uses *K* to decrypt
    *C*, obtaining *M*.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 为了效率起见，RSA通常与快速加密系统一起以“混合”或“密钥管理”模式使用，这些系统不是公钥加密系统。使用这种***对称密钥***系统，加密和解密密钥是相同的。如果Alice想要私密地向Bob发送一条长消息
    *M*，她为快速对称密钥加密系统选择一个随机密钥 *K* 并使用 *K* 加密 *M*，得到密文 *C*，其中 *C* 和 *M* 一样长，但 *K* 很短。然后她使用Bob的公共RSA密钥加密
    *K*。由于 *K* 很短，计算 *P*[*B*](*K*) 很快（比计算 *P*[*B*](*M*) 快得多）。然后她将 (*C*, *P*[*B*](*K*))
    传输给Bob，Bob解密 *P*[*B*](*K*) 以获得 *K*，然后使用 *K* 解密 *C*，得到 *M*。
- en: A similar hybrid approach creates digital signatures efficiently. This approach
    combines RSA with a public ***collision-resistant hash function*** *h*—a function
    that is easy to compute but for which it is computationally infeasible to find
    two messages *M* and *M*′ such that *h*(*M*) = *h*(*M*′). The value *h*(*M*) is
    a short (say, 256-bit) “fingerprint” of the message *M*. If Alice wishes to sign
    a message *M*, she first applies *h* to *M* to obtain the fingerprint *h*(*M*),
    which she then encrypts with her secret key. She sends (*M*, *S*[*A*](*h*(*M*)))
    to Bob as her signed version of *M*. Bob can verify the signature by computing
    *h*(*M*) and verifying that *P*[*A*] applied to *S*[*A*](*h*(*M*)) as received
    equals *h*(*M*). Because no one can create two messages with the same fingerprint,
    it is computationally infeasible to alter a signed message and preserve the validity
    of the signature.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类似的混合方法可以高效地创建数字签名。这种方法将RSA与一个公共***抗碰撞哈希函数*** *h* 结合在一起——这是一个易于计算但在计算上不可能找到两条消息
    *M* 和 *M*′，使得 *h*(*M*) = *h*(*M*′)。值 *h*(*M*) 是消息 *M* 的一个短（比如，256位）“指纹”。如果Alice想要签署一条消息
    *M*，她首先将 *h* 应用于 *M* 以获得指纹 *h*(*M*)，然后用她的秘钥对其进行加密。她将 (*M*, *S*[*A*](*h*(*M*)))
    发送给Bob作为她对 *M* 的签名版本。Bob可以通过计算 *h*(*M*) 并验证接收到的 *P*[*A*] 应用于 *S*[*A*](*h*(*M*))
    是否等于 *h*(*M*) 来验证签名。因为没有人可以创建具有相同指纹的两条消息，修改已签名消息并保留签名的有效性在计算上是不可行的。
- en: One way to distribute public keys uses ***certificates***. For example, assume
    that there is a “trusted authority” *T* whose public key is known by everyone.
    Alice can obtain from *T* a signed message (her certificate) stating that “Alice’s
    public key is *P*[*A*].” This certificate is “self-authenticating” since everyone
    knows *P*[*T*]. Alice can include her certificate with her signed messages, so
    that the recipient has Alice’s public key immediately available in order to verify
    her signature. Because her key was signed by *T*, the recipient knows that Alice’s
    key is really Alice’s.
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 分发公钥的一种方法使用***证书***。例如，假设有一个“受信任的权威” *T*，其公钥为所有���所知。Alice可以从 *T* 获取一条签名消息（她的证书），声明“Alice的公钥是
    *P*[*A*]”。这个证书是“自认证”的，因为每个人都知道 *P*[*T*]。Alice可以在她的签名消息中包含她的证书，这样接收者就可以立即使用Alice的公钥来验证她的签名。因为她的密钥是由
    *T* 签名的，接收者知道Alice的密钥确实是Alice的。
- en: '**Exercises**'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***31.7-1***'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.7-1***'
- en: Consider an RSA key set with *p* = 11, *q* = 29, *n* = 319, and *e* = 3\. What
    value of *d* should be used in the secret key? What is the encryption of the message
    *M* = 100?
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个RSA密钥集，其中 *p* = 11，*q* = 29，*n* = 319，*e* = 3。秘密密钥应该使用什么值的 *d*？消息 *M* =
    100 的加密是什么？
- en: '***31.7-2***'
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.7-2***'
- en: Prove that if Alice’s public exponent *e* is 3 and an adversary obtains Alice’s
    secret exponent *d*, where 0 < *d* < *ϕ*(*n*), then the adversary can factor Alice’s
    modulus *n* in time polynomial in the number of bits in *n*. (Although you are
    not asked to prove it, you might be interested to know that this result remains
    true even if the condition *e* = 3 is removed. See Miller [[327](bibliography001.xhtml#endnote_327)].)
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 证明如果Alice的公共指数 *e* 为3，一个对手获得了Alice的秘密指数 *d*，其中 0 < *d* < *ϕ*(*n*)，那么对手可以在多项式时间内分解Alice的模
    *n*。（虽然你没有被要求证明，但你可能会感兴趣知道，即使条件 *e* = 3 被移除，这个结果仍然成立。参见米勒[[327](bibliography001.xhtml#endnote_327)]。）
- en: ★ ***31.7-3***
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***31.7-3***
- en: Prove that RSA is multiplicative in the sense that
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 证明RSA是乘法的，即
- en: '*P*[*A*](*M*[1])*P*[*A*](*M*[2]) = *P*[*A*](*M*[1]*M*[2]) (mod *n*).'
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: '*P*[*A*](*M*[1])*P*[*A*](*M*[2]) = *P*[*A*](*M*[1]*M*[2]) (mod *n*).'
- en: Use this fact to prove that if an adversary had a procedure that could efficiently
    decrypt 1% of messages from ℤ[*n*] encrypted with *P*[*A*], then the adversary
    could employ a probabilistic algorithm to decrypt every message encrypted with
    *P*[*A*] with high probability.
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这个事实证明，如果一个对手有一个可以有效解密1%使用 *P*[*A*] 加密的ℤ[*n*]中的消息的程序，那么对手可以使用概率算法高概率地解密使用
    *P*[*A*] 加密的每条消息。
- en: '[★ **31.8    Primality testing**](toc.xhtml#Rh1-184)'
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: '[★ **31.8    素性测试**](toc.xhtml#Rh1-184)'
- en: This section shows how to find large primes. We begin with a discussion of the
    density of primes, proceed to examine a plausible, but incomplete, approach to
    primality testing, and then present an effective randomized primality test due
    to Miller and Rabin.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 本节展示了如何找到大素数。我们从素数的密度讨论开始，继续检查一个合理但不完整的素性测试方法，然后介绍了由米勒和拉宾提出的有效的随机素性测试。
- en: '**The density of prime numbers**'
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: '**素数的密度**'
- en: Many applications, such as cryptography, call for finding large “random” primes.
    Fortunately, large primes are not too rare, so that it is feasible to test random
    integers of the appropriate size until you find one that is prime. The ***prime
    distribution function*** *π*(*n*) specifies the number of primes that are less
    than or equal to *n*. For example, *π*(10) = 4, since there are 4 prime numbers
    less than or equal to 10, namely, 2, 3, 5, and 7\. The prime number theorem gives
    a useful approximation to *π*(*n*).
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用，如密码学，需要找到大的“随机”质数。幸运的是，大质数并不太罕见，因此可以测试适当大小的随机整数，直到找到一个质数。***质数分布函数*** *π*(*n*)指定小于或等于*n*的质数的数量。例如，*π*(10)
    = 4，因为小于或等于10的质数有4个，即2、3、5和7。素数定理给出了对*π*(*n*)的有用近似。
- en: '***Theorem 31.37 (Prime number theorem)***'
  id: totrans-633
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理31.37（素数定理）***'
- en: '![art](images/Art_P1218.jpg)'
  id: totrans-634
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1218.jpg)'
- en: ▪
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: The approximation *n*/ln *n* gives reasonably accurate estimates of *π*(*n*)
    even for small *n*. For example, it is off by less than 6% at *n* = 10⁹, where
    *π*(*n*) = 50,847,534 and *n*/ln *n* ≈ 48,254,942\. (To a number theorist, 10⁹
    is a small number.)
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 近似值*n*/ln *n* 可以为小*n*提供相当准确的*π*(*n*)估计。例如，在*n* = 10⁹时，它的偏差小于6%，其中*π*(*n*) =
    50,847,534，而*n*/ln *n* ≈ 48,254,942。 （对于数论家来说，10⁹是一个小数。）
- en: The process of randomly selecting an integer *n* and determining whether it
    is prime is really just a Bernoulli trial (see [Section C.4](appendix003.xhtml#Sec_C.4)).
    By the prime number theorem, the probability of a success—that is, the probability
    that *n* is prime—is approximately 1/ln *n*. The geometric distribution says how
    many trials must occur to obtain a success, and by equation (C.36) on page 1197,
    the expected number of trials is approximately ln *n*. Thus, in order to find
    a prime that has the same length as *n* by testing integers chosen randomly near
    *n*, the expected number examined would be approximately ln *n*. For example,
    the expectation is that finding a 1024-bit prime would require testing approximately
    ln 2^(1024) ≈ 710 randomly chosen 1024-bit numbers for primality. (Of course,
    to cut this figure in half, choose only odd integers.)
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 随机选择一个整数*n*并确定它是否为质数的过程实际上只是一个伯努利试验（见[第C.4节](appendix003.xhtml#Sec_C.4)）。根据素数定理，成功的概率即*n*是质数的概率约为1/ln
    *n*。几何分布说明需要多少次试验才能获得成功，根据第1197页的方程式(C.36)，预期的试验次数约为ln *n*。因此，为了通过测试随机选择的接近*n*的整数来找到与*n*长度相同的质数，预期检查的数量约为ln
    *n*。例如，预期找到一个1024位质数需要测试大约ln 2^(1024) ≈ 710个随机选择的1024位数字以确定其是否为质数。（当然，为了将这个数字减半，只选择奇整数。）
- en: The remainder of this section shows how to determine whether a large odd integer
    *n* is prime. For notational convenience, we assume that *n* has the prime factorization
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的其余部分展示了如何确定一个大奇整数*n*是否为质数。为了方便表示，我们假设*n*有质因数分解
- en: '![art](images/Art_P1219.jpg)'
  id: totrans-639
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1219.jpg)'
- en: where *r* ≥ 1, *p*[1], *p*[2], …, *p*[*r*] are the prime factors of *n*, and
    *e*[1], *e*[2], …, *e*[*r*] are positive integers. The integer *n* is prime if
    and only if *r* = 1 and *e*[1] = 1.
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*r* ≥ 1，*p*[1]、*p*[2]、…、*p*[*r*]是*n*的质因数，*e*[1]、*e*[2]、…、*e*[*r*]是正整数。整数*n*是质数当且仅当*r*
    = 1且*e*[1] = 1。
- en: 'One simple approach to the problem of testing for primality is ***trial division***:
    try dividing *n* by each integer 2, 3, 5, 7, 9, …, ![art](images/Art_P1220.jpg),
    skipping even integers greater than 2\. We can conclude that *n* is prime if and
    only if none of the trial divisors divides *n*. Assuming that each trial division
    takes constant time, the worst-case running time is ![art](images/Art_P1221.jpg),
    which is exponential in the length of *n*. (Recall that if *n* is encoded in binary
    using *β* bits, then *β* = ⌈1g(*n* + 1)⌉, and so ![art](images/Art_P1222.jpg).)
    Thus, trial division works well only if *n* is very small or happens to have a
    small prime factor. When it works, trial division has the advantage that it not
    only determines whether *n* is prime or composite, it also determines one of *n*’s
    prime factors if *n* is composite.'
  id: totrans-641
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单的检测质数的方法是***试除法***：尝试用每个整数2、3、5、7、9、…、![art](images/Art_P1220.jpg)去除*n*，跳过大于2的偶数。我们可以得出结论，只有当没有任何试除数能整除*n*时，*n*才是质数。假设每次试除都需要恒定时间，最坏情况下的运行时间是![art](images/Art_P1221.jpg)，这在*n*的长度上是指数级的。（回想一下，如果*n*用*β*位二进制编码，那么*β*
    = ⌈1g(*n* + 1)⌉，因此![art](images/Art_P1222.jpg)。）因此，试除法只在*n*很小或恰好有一个小质因子时才有效。当试除法有效时，它的优势在于不仅确定了*n*是质数还是合数，如果*n*是合数，还确定了*n*的一个质因子。
- en: This section focuses on finding out whether a given number *n* is prime. If
    *n* is composite, we won’t worry about finding its prime factorization. Computing
    the prime factorization of a number is computationally expensive. You might be
    surprised that it turns out to be much easier to ascertain whether a given number
    is prime than it is to determine the prime factorization of the number if it is
    not prime.
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 本节重点是确定给定数字*n*是否为质数。如果*n*是合数，我们不会担心找出它的质因数分解。计算一个数字的质因数分解是计算密集型的。您可能会惊讶地发现，确定给定数字是否为质数比确定该数字的质因数分解要容易得多，如果它不是质数的话。
- en: '**Pseudoprimality testing**'
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: '**伪质数测试**'
- en: 'We’ll start with a method for primality testing that “almost works” and, in
    fact, is good enough for many practical applications. Later on, we’ll refine this
    method to remove the small defect. Let ![art](images/Art_P1223.jpg) denote the
    nonzero elements of ℤ[*n*]:'
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从一个“几乎有效”的素性测试方法开始，实际上，对于许多实际应用来说，这已经足够好了。稍后，我们将改进这种方法以消除小缺陷。让![art](images/Art_P1223.jpg)表示ℤ[*n*]的非零元素：
- en: '![art](images/Art_P1224.jpg)'
  id: totrans-645
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1224.jpg)'
- en: If *n* is prime, then ![art](images/Art_P1225.jpg).
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*n*是质数，则![art](images/Art_P1225.jpg)。
- en: We say that *n* is a ***base-a pseudoprime*** if *n* is composite and
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说*n*是一个***基于a的伪质数***，如果*n*是合数且
- en: '![art](images/Art_P1226.jpg)'
  id: totrans-648
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1226.jpg)'
- en: Fermat’s theorem (Theorem 31.31 on page 932) implies that if *n* is prime, then
    *n* satisfies equation (31.39) for every *a* in ![art](images/Art_P1227.jpg).
    Thus, if there is any ![art](images/Art_P1228.jpg) such that *n* does *not* satisfy
    equation (31.39), then *n* is certainly composite. Surprisingly, the converse
    *almost* holds, so that this criterion forms an almost perfect test for primality.
    Instead of trying every value of ![art](images/Art_P1228.jpg), test to see whether
    *n* satisfies equation (31.39) for just *a* = 2\. If not, then declare *n* to
    be composite by returning COMPOSITE. Otherwise, return PRIME, guessing that *n*
    is prime (when, in fact, all we know is that *n* is either prime or a base-2 pseudoprime).
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 费马定理（第932页的定理31.31）意味着如果*n*是质数，则*n*对于![art](images/Art_P1227.jpg)中的每个*a*都满足方程（31.39）。因此，如果存在任何![art](images/Art_P1228.jpg)使得*n*不满足方程（31.39），那么*n*肯定是合数。令人惊讶的是，反过来*几乎*成立，因此这个准则形成了一个几乎完美的素性测试。不必尝试每个![art](images/Art_P1228.jpg)的值，只需测试*n*是否满足*a*=2时的方程（31.39）。如果不满足，则通过返回COMPOSITE来声明*n*为合数。否则，返回PRIME，猜测*n*是素数（实际上我们只知道*n*要么是素数，要么是基于2的伪素数）。
- en: The procedure PSEUDOPRIME on the next page pretends in this manner to check
    whether *n* is prime. It uses the procedure MODULAR-EXPONENTIATION from [Section
    31.6](chapter031.xhtml#Sec_31.6). It assumes that the input *n* is an odd integer
    greater than 2\. This procedure can make errors, but only of one type. That is,
    if it says that *n* is composite, then it is always correct. If it says that *n*
    is prime, however, then it makes an error only if *n* is a base-2 pseudoprime.
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 下一页的PSEUDOPRIME程序以这种方式假装检查*n*是否为素数。它使用来自[第31.6节](chapter031.xhtml#Sec_31.6)的MODULAR-EXPONENTIATION过程。它假设输入的*n*是大于2的奇整数。这个程序可能会出错，但只有一种类型的错误。也就是说，如果它说*n*是合数，那么它总是正确的。然而，如果它说*n*是素数，那么只有当*n*是基于2的伪素数时才会出错。
- en: How often does PSEUDOPRIME err? Surprisingly rarely. There are only 22 values
    of *n* less than 10,000 for which it errs, the first four of which are 341, 561,
    645,
  id: totrans-651
  prefs: []
  type: TYPE_NORMAL
  zh: PSEUDOPRIME出错的频率有多少？令人惊讶地很少。小于10,000的*n*值中只有22个值会出错，前四个值分别是341、561、645，
- en: PSEUDOPRIME(*n*)
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: PSEUDOPRIME(*n*)
- en: '| 1 | **if** MODULAR-EXPONENTIATION(2, *n* – 1, *n*) ≠ 1 (mod *n*) |'
  id: totrans-653
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **如果** MODULAR-EXPONENTIATION(2, *n* – 1, *n*) ≠ 1 (mod *n*) |'
- en: '| 2 | **return** COMPOSITE | **//** definitely |'
  id: totrans-654
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **返回** COMPOSITE | **//** 明确 |'
- en: '| 3 | **else return** PRIME | **//** we hope! |'
  id: totrans-655
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **否则返回** PRIME | **//** 我们希望！ |'
- en: and 1105\. We won’t prove it, but the probability that this program makes an
    error on a randomly chosen *β*-bit number goes to 0 as *β* approaches ∞. Using
    more precise estimates due to Pomerance [[361](bibliography001.xhtml#endnote_361)]
    of the number of base-2 pseudoprimes of a given size, a randomly chosen 512-bit
    number that is called prime by PSEUDOPRIME has less than one chance in 10^(20)
    of being a base-2 pseudoprime, and a randomly chosen 1024-bit number that is called
    prime has less than one chance in 10^(41) of being a base-2 pseudoprime. Thus,
    if you are merely trying to find a large prime for some application, for all practical
    purposes you almost never go wrong by choosing large numbers at random until one
    of them causes PSEUDOPRIME to return PRIME. But when the numbers being tested
    for primality are not randomly chosen, you might need a better approach for testing
    primality. As we’ll see, a little more cleverness, and some randomization, will
    yield a primality-testing method that works well on all inputs.
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 以及1105。我们不会证明，但是这个程序在随机选择的*β*位数上出错的概率随着*β*趋近∞而趋近于0。根据Pomerance的更精确估计[[361](bibliography001.xhtml#endnote_361)]，给定大小的基于2的伪素数的数量，一个随机选择的512位数，通过PSEUDOPRIME被称为素数的概率小于10^(20)，而一个随机选择的1024位数，通过PSEUDOPRIME被称为素数的概率小于10^(41)。因此，如果你只是想为某些应用程序找到一个大素数，那么几乎永远不会选择随机大数，直到其中一个导致PSEUDOPRIME返回PRIME。但是，当被测试的素性数不是随机选择时，你可能需要更好的方法来测试素性。正如我们将看到的，稍微聪明一点，再加上一些随机化，将会产生一个在所有输入上表现良好的素性测试方法。
- en: Since PSEUDOPRIME checks equation (31.39) for only *a* = 2, you might think
    that you could eliminate all the errors by simply checking equation (31.39) for
    a second base number, say *a* = 3\. Better yet, you could check equation (31.39)
    for even more values of *a*. Unfortunately, even checking for several values of
    *a* does not eliminate all errors, because there exist composite integers *n*,
    known as ***Carmichael numbers***, that satisfy equation (31.39) for *all* ![art](images/Art_P1230.jpg).
    (The equation does fail when gcd(*a*, *n*) > 1—that is, when ![art](images/Art_P1231.jpg)—but
    demonstrating that *n* is composite by finding such an *a* can be difficult if
    *n* has only large prime factors.) The first three Carmichael numbers are 561,
    1105, and 1729\. Carmichael numbers are extremely rare. For example, only 255
    of them are less than 100,000,000\. Exercise 31.8-2 helps explain why they are
    so rare.
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 由于PSEUDOPRIME仅检查*a*=2时的方程（31.39），你可能认为通过简单地检查第二个基数，比如*a*=3，你可以消除所有错误。更好的是，你可以检查更多值的*a*的方程（31.39）。不幸的是，即使检查几个值的*a*也不能消除所有错误，因为存在一些合数*n*，被称为***卡迈克尔数***，它们对*所有*的![art](images/Art_P1230.jpg)都满足方程（31.39）。
    （当gcd(*a*, *n*) > 1时方程会失败——也就是说，当![art](images/Art_P1231.jpg)时——但是如果*n*只有大素数因子，通过找到这样的*a*来证明*n*是合数可能会很困难。）前三个卡迈克尔数是561、1105和1729。卡迈克尔数非常罕见。例如，小于100,000,000的卡迈克尔数只有255个。练习31.8-2有助于解释它们为什么如此罕见。
- en: Let’s see how to improve the primality test so that Carmichael numbers won’t
    fool it.
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何改进素性测试，以便卡迈克尔数不会欺骗它。
- en: '**The Miller-Rabin randomized primality test**'
  id: totrans-659
  prefs: []
  type: TYPE_NORMAL
  zh: '**米勒-拉宾随机素性测试**'
- en: 'The Miller-Rabin primality test overcomes the problems of the simple procedure
    PSEUDOPRIME with two modifications:'
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 米勒-拉宾素性测试通过两个修改克服了简单程序PSEUDOPRIME的问题：
- en: It tries several randomly chosen base values *a* instead of just one base value.
  id: totrans-661
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它尝试几个随机选择的基值*a*，而不仅仅是一个基值。
- en: While computing each modular exponentiation, it looks for a nontrivial square
    root of 1, modulo *n*, during the final set of squarings. If it finds one, it
    stops and returns COMPOSITE. Corollary 31.35 from [Section 31.6](chapter031.xhtml#Sec_31.6)
    justifies detecting composites in this manner.
  id: totrans-662
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在计算每个模指数时，在最后一组平方中寻找 1 的非平凡平方根，模 *n*。如果找到一个，它会停止并返回 COMPOSITE。来自 [第 31.6 节](chapter031.xhtml#Sec_31.6)
    的推论 31.35 证明了以这种方式检测合数的正确性。
- en: 'The pseudocode for the Miller-Rabin primality test appears in the procedures
    MILLER-RABIN and WITNESS. The input *n* > 2 to MILLER-RABIN is the odd number
    to be tested for primality, and *s* is the number of randomly chosen base values
    from ![art](images/Art_P1232.jpg) to be tried. The code uses the random-number
    generator RANDOM described on page 129: RANDOM(2, *n* – 2) returns a randomly
    chosen integer *a* satisfying 2 ≤ *a* ≤ *n* – 2\. (This range of values avoids
    having *a* = ≥1 (mod *n*).) The call of the auxiliary procedure WITNESS(*a*, *n*)
    returns TRUE if and only if *a* is a “witness” to the compositeness of *n*—that
    is, if it is possible using *a* to prove (in a manner that we will see) that *n*
    is composite. The test WITNESS(*a*, *n*) is an extension of, but more effective
    than, the test in equation (31.39) that formed the basis for PSEUDOPRIME, using
    *a* = 2.'
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: Miller-Rabin 素性测试的伪代码出现在 MILLER-RABIN 和 WITNESS 过程中。输入 *n* > 2 到 MILLER-RABIN
    是要测试素性的奇数，*s* 是从 ![art](images/Art_P1232.jpg) 中随机选择的基值的数量。代码使用第 129 页上描述的随机数生成器
    RANDOM：RANDOM(2, *n* – 2) 返回一个满足 2 ≤ *a* ≤ *n* – 2 的随机整数。 （这个值范围避免了 *a* = ≥1 (mod
    *n*)。）辅助过程 WITNESS(*a*, *n*) 的调用仅当 *a* 是 *n* 的合数的“证人”时才返回 TRUE，即使用 *a* 可以证明 *n*
    是合数（我们将看到的方式）。 WITNESS(*a*, *n*) 测试是方程式 (31.39) 的扩展，它是 PSEUDOPRIME 的基础，使用 *a*
    = 2。
- en: Let’s first understand how WITNESS works, and then we’ll see how the Miller-Rabin
    primality test uses it. Let *n* – 1 = 2^(*t*)*u* where *t* ≥ 1 and *u* is odd.
    That is, the binary representation of *n* – 1 is the binary representation of
    the odd integer *u* followed by exactly *t* zeros. Therefore, ![art](images/Art_P1233.jpg),
    so that one way to compute *a*^(*n*−1) mod *n* is to first compute *a*^(*u*) mod
    *n* and then square the result *t* times successively.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们首先了解 WITNESS 的工作原理，然后我们将看到 Miller-Rabin 素性测试如何使用它。设 *n* – 1 = 2^(*t*)*u*，其中
    *t* ≥ 1，*u* 是奇数。也就是说，*n* – 1 的二进制表示是奇整数 *u* 的二进制表示，后面紧跟着 *t* 个零。因此，![art](images/Art_P1233.jpg)，这样计算
    *a*^(*n*−1) mod *n* 的一种方法是先计算 *a*^(*u*) mod *n*，然后连续平方结果 *t* 次。
- en: '| MILLER-RABIN(*n*, *s*) | **//** *n* > 2 is odd |'
  id: totrans-665
  prefs: []
  type: TYPE_TB
  zh: '| MILLER-RABIN(*n*, *s*) | **//** *n* > 2 是奇数 |'
- en: '| 1 | **for** *j* = 1 **to** *s* |'
  id: totrans-666
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **对于** *j* = 1 **到** *s* |'
- en: '| 2 | *a* = RANDOM(2, *n* – 2) |'
  id: totrans-667
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *a* = RANDOM(2, *n* – 2) |'
- en: '| 3 | **if** WITNESS(*a*, *n*) |'
  id: totrans-668
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **如果** WITNESS(*a*, *n*) |'
- en: '| 4 | **return** COMPOSITE | **//** definitely |'
  id: totrans-669
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **返回** COMPOSITE | **//** 明确 |'
- en: '| 5 | **return** PRIME | **//** almost surely |'
  id: totrans-670
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **返回** PRIME | **//** 几乎肯定是质数 |'
- en: '| WITNESS(*a*, *n*) |'
  id: totrans-671
  prefs: []
  type: TYPE_TB
  zh: '| WITNESS(*a*, *n*) |'
- en: '| 1 | let *t* and *u* be such that *t* ≥ 1, *u* is odd, and *n* – 1 = 2^(*t*)*u*
    |'
  id: totrans-672
  prefs: []
  type: TYPE_TB
  zh: '| 1 | 令 *t* 和 *u* 满足 *t* ≥ 1，*u* 是奇数，并且 *n* – 1 = 2^(*t*)*u* |'
- en: '| 2 | *x*[0] = MODULAR-EXPONENTIATION(*a*, *u*, *n*) |'
  id: totrans-673
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *x*[0] = MODULAR-EXPONENTIATION(*a*, *u*, *n*) |'
- en: '| 3 | **for** *i* = 1 **to** *t* |'
  id: totrans-674
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **对于** *i* = 1 **到** *t* |'
- en: '| 4 | ![art](images/Art_P1234.jpg) |'
  id: totrans-675
  prefs: []
  type: TYPE_TB
  zh: '| 4 | ![art](images/Art_P1234.jpg) |'
- en: '| 5 | **if** *x*[*i*] == 1 and *x*[*i*–1] ≠ 1 and *x*[*i*–1] ≠ *n* – 1 |'
  id: totrans-676
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **如果** *x*[*i*] == 1 并且 *x*[*i*–1] ≠ 1 并且 *x*[*i*–1] ≠ *n* – 1 |'
- en: '| 6 | **return** TRUE | **//** found a nontrivial square root of 1 |'
  id: totrans-677
  prefs: []
  type: TYPE_TB
  zh: '| 6 | **返���** TRUE | **//** 找到了 1 的非平凡平方根 |'
- en: '| 7 | **if** *x*[*t*] ≠ 1 |'
  id: totrans-678
  prefs: []
  type: TYPE_TB
  zh: '| 7 | **如果** *x*[*t*] ≠ 1 |'
- en: '| 8 | **return** TRUE | **//** composite, as in PSEUDOPRIME |'
  id: totrans-679
  prefs: []
  type: TYPE_TB
  zh: '| 8 | **返回** TRUE | **//** 合数，如伪素数 |'
- en: '| 9 | **return** FALSE |'
  id: totrans-680
  prefs: []
  type: TYPE_TB
  zh: '| 9 | **返回** FALSE |'
- en: This pseudocode for WITNESS computes *a*^(*n*–1) mod *n* by first computing
    the value *x*[0] = *a*^(*u*) mod *n* in line 2 and then repeatedly squaring the
    result *t* times in the **for** loop of lines 3–6\. By induction on *i*, the sequence
    *x*[0], *x*[1], …, *x*[*t*] of values computed satisfies the equation ![art](images/Art_P1235.jpg)
    for *i* = 0, 1, …, *t*, so that in particular *x*[*t*] = *a*^(*n*–1) (mod *n*).
    After line 4 performs a squaring step, however, the loop will terminate early
    if lines 5–6 detect that a nontrivial square root of 1 has just been discovered.
    (We’ll explain these tests shortly.) If so, the procedure stops and returns TRUE.
    Lines 7–8 return TRUE if the value computed for *x*[*t*] = *a*^(*n*–1) (mod *n*)
    is not equal to 1, just as the PSEUDOPRIME procedure returns COMPOSITE in this
    case. Line 9 returns FALSE if lines 6 or 8 have not returned TRUE.
  id: totrans-681
  prefs: []
  type: TYPE_NORMAL
  zh: WITNESS 的这个伪代码通过首先计算值 *x*[0] = *a*^(*u*) mod *n*（第 2 行）来计算 *a*^(*n*–1) mod *n*，然后在第
    3–6 行的 **for** 循环中重复平方结果 *t* 次。通过对 *i* 进行归纳，计算的值序列 *x*[0]、*x*[1]、…、*x*[*t*] 满足方程式
    ![art](images/Art_P1235.jpg) 对于 *i* = 0, 1, …, *t*，因此特别地 *x*[*t*] = *a*^(*n*–1)
    (mod *n*)。然而，在第 4 行执行平方步骤后，如果第 5–6 行检测到刚刚发现了 1 的非平凡平方根，循环将提前终止。 （我们将很快解释这些测试。）如果是这样，该过程将停止并返回
    TRUE。如果计算的 *x*[*t*] = *a*^(*n*–1) (mod *n*) 的值不等于 1，就像 PSEUDOPRIME 过程在这种情况下返回
    COMPOSITE 一样，第 7–8 行返回 TRUE。如果第 6 或第 8 行没有返回 TRUE，则第 9 行返回 FALSE。
- en: The following lemma proves the correctness of WITNESS.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 以下引理证明了 WITNESS 的正确性。
- en: '***Lemma 31.38***'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 31.38***'
- en: If WITNESS(*a*, *n*) returns TRUE, then a proof that *n* is composite can be
    constructed using *a* as a witness.
  id: totrans-684
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 WITNESS(*a*, *n*) 返回 TRUE，则可以使用 *a* 作为证人构建 *n* 是合数的证明。
- en: '***Proof***   If WITNESS returns TRUE from line 8, it’s because line 7 determined
    that *x*[*t*] = *a*^(*n*–1) mod *n* ≠ 1\. If *n* is prime, however, Fermat’s theorem
    (Theorem 31.31) says that *a*^(*n*–1) = 1 (mod *n*) for all ![art](images/Art_P1236.jpg).
    Since ![art](images/Art_P1237.jpg) if *n* is prime, Fermat’s theorem also says
    that *a*^(*n*–1) = 1 (mod *n*) for all ![art](images/Art_P1238.jpg). Therefore,
    *n* cannot be prime, and the equation *a*^(*n*–1) mod *n* ≠ 1 proves this fact.'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 如果第 8 行的 WITNESS 返回 TRUE，那是因为第 7 行确定 *x*[*t*] = *a*^(*n*–1) mod *n*
    ≠ 1。然而，如果 *n* 是质数，费马定理（定理 31.31）表明对于所有 ![art](images/Art_P1236.jpg)，*a*^(*n*–1)
    = 1 (mod *n*)。由于 ![art](images/Art_P1237.jpg)，如果 *n* 是质数，费马定理也表明对于所有 ![art](images/Art_P1238.jpg)，*a*^(*n*–1)
    = 1 (mod *n*)。因此，*n* 不能是质数，而方程 *a*^(*n*–1) mod *n* ≠ 1 证明了这一事实。'
- en: If WITNESS returns TRUE from line 6, then it has discovered that *x*[*i*–1]
    is a nontrivial square root of 1, modulo *n*, since we have that *x*[*i*–1] ≠
    ±1 (mod *n*) yet ![art](images/Art_P1239.jpg). Corollary 31.35 on page 934 states
    that only if *n* is composite can there exist a nontrivial square root of 1, modulo
    *n*, so that demonstrating that *x*[*i*–1] is a nontrivial square root of 1, modulo
    *n* proves that *n* is composite.
  id: totrans-686
  prefs: []
  type: TYPE_NORMAL
  zh: 如果WITNESS从第6行返回TRUE，则它发现*x*[*i*–1]是1的一个非平凡平方根，模*n*，因为我们有*x*[*i*–1] ≠ ±1（mod
    *n*），但是![art](images/Art_P1239.jpg)。第934页的推论31.35表明，只有*n*是合数时，模*n*才可能存在1的一个非平凡平方根，因此证明*x*[*i*–1]是1的一个非平凡平方根，模*n*证明了*n*是合数。
- en: ▪
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Thus, if the call WITNESS(*a*, *n*) returns TRUE, then *n* is surely composite,
    and the witness *a*, along with the reason that the procedure returns TRUE (did
    it return from line 6 or from line 8?), provides a proof that *n* is composite.
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果调用WITNESS(*a*, *n*)返回TRUE，则*n*肯定是合数，证明了*n*是合数的证据是WITNESS返回TRUE的原因（是从第6行返回还是从第8行返回？）。
- en: 'Let’s explore an alternative view of the behavior of WITNESS as a function
    of the sequence *X* = 〈*x*[0], *x*[1], …, *x*[*t*]〉. We’ll find this view useful
    later on, when we analyze the error rate of the Miller-Rabin primality test. Note
    that if *x*[*i*] = 1 for some 0 ≤ *i* < *t*, WITNESS might not compute the rest
    of the sequence. If it were to do so, however, each value *x*[*i*+1], *x*[*i*+2],
    …, *x*[*t*] would be 1, so we can consider these positions in the sequence *X*
    as being all 1s. There are four cases:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探讨WITNESS的行为作为序列*X* = 〈*x*[0], *x*[1], …, *x*[*t*]〉的函数的另一种观点。当我们分析Miller-Rabin素性测试的错误率时，我们将发现这种观点很有用。请注意，如果对于某个0
    ≤ *i* < *t*，*x*[*i*] = 1，WITNESS可能不会计算序列的其余部分。然而，如果它这样做了，每个值*x*[*i*+1]，*x*[*i*+2]，…，*x*[*t*]将是1，因此我们可以将序列*X*中的这些位置视为全是1。有四种情况：
- en: '*X* = 〈…, *d*〉, where *d* ≠ 1: the sequence *X* does not end in 1\. Return
    TRUE in line 8, since *a* is a witness to the compositeness of *n* (by Fermat’s
    Theorem).'
  id: totrans-690
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*X* = 〈…, *d*〉，其中 *d* ≠ 1：序列 *X* 不以1结尾。在第8行返回TRUE，因为*a*是*n*的合数的证明（根据费马定理）。'
- en: '*X* = 〈1, 1, …, 1〉: the sequence *X* is all 1s. Return FALSE, since *a* is
    not a witness to the compositeness of *n*.'
  id: totrans-691
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*X* = 〈1, 1, …, 1〉：序列 *X* 全是1。返回FALSE，因为*a*不是*n*的合数的证明。'
- en: '*X* = 〈…, –1, 1, …, 1〉: the sequence *X* ends in 1, and the last non-1 is equal
    to –1\. Return FALSE, since *a* is not a witness to the compositeness of *n*.'
  id: totrans-692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*X* = 〈…, –1, 1, …, 1〉：序列 *X* 以1结尾，最后一个非1等于-1。返回FALSE，因为*a*不是*n*的合数的证明。'
- en: '*X* = 〈…, *d*, 1, …, 1〉, where *d* ≠ ±1: the sequence *X* ends in 1, but the
    last non-1 is not –1\. Return TRUE in line 6: *a* is a witness to the compositeness
    of *n*, since *d* is a nontrivial square root of 1.'
  id: totrans-693
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*X* = 〈…, *d*, 1, …, 1〉，其中 *d* ≠ ±1：序列 *X* 以1结尾，但最后一个非1不是-1。在第6行返回TRUE：*a*是*n*的合数的证明，因为*d*是1的一个非平凡平方根。'
- en: Now, let’s examine the Miller-Rabin primality test based on how it uses the
    WITNESS procedure. As before, assume that *n* is an odd integer greater than 2.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们根据WITNESS过程的使用方式来检查基于Miller-Rabin素性测试。与以前一样，假设*n*是大于2的奇整数。
- en: The procedure MILLER-RABIN is a probabilistic search for a proof that *n* is
    composite. The main loop (beginning on line 1) picks up to *s* random values of
    *a* from ![art](images/Art_P1240.jpg), except for 1 and *n* – 1 (line 2). If it
    picks a value of *a* that is a witness to the compositeness of *n*, then MILLER-RABIN
    returns COMPOSITE on line 4\. Such a result is always correct, by the correctness
    of WITNESS. If MILLER-RABIN finds no witness in *s* trials, then the procedure
    assumes that it found no witness because no witnesses exist, and therefore it
    assumes that *n* is prime. We’ll see that this result is likely to be correct
    if *s* is large enough, but there is still a tiny chance that the procedure could
    be unlucky in its choice of *s* random values of *a*, so that even though the
    procedure failed to find a witness, at least one witness exists.
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: MILLER-RABIN过程是对*n*是合数的证明的概率性搜索。主循环（从第1行开始）从![art](images/Art_P1240.jpg)中选择最多*s*个随机值的*a*，除了1和*n*
    - 1（第2行）。如果选择的*a*是*n*的合数的证明，那么MILLER-RABIN在第4行返回COMPOSITE。由于WITNESS的正确性，这样的结果总是正确的。如果MILLER-RABIN在*s*次尝试中找不到证人，则该过程假定找不到证人是因为不存在证人，因此假定*n*是素数。如果*s*足够大，这个结果很可能是正确的，但是过程在选择*s*个随机值的*a*时仍有微小的机会，因此即使过程未能找到证人，至少存在一个证人。
- en: To illustrate the operation of MILLER-RABIN, let *n* be the Carmichael number
    561, so that *n* – 1 = 560 = 2⁴ · 35, *t* = 4, and *u* = 35\. If the procedure
    chooses *a* = 7 as a base, the column for *b* = 35 in [Figure 31.4](chapter031.xhtml#Fig_31-4)
    ([Section 31.6](chapter031.xhtml#Sec_31.6)) shows that WITNESS computes *x*[0]
    = *a*^(35) = 241 (mod 561). Because of how the MODULAR-EXPONENTIATION procedure
    operates recursively on its parameter *b*, the first four columns in [Figure 31.4](chapter031.xhtml#Fig_31-4)
    represent the factor 2⁴ of 560—the rightmost four zeros in the binary representation
    of 560—reading these four zeros from right to left in the binary representation.
    Thus WITNESS computes the sequence *X* = 〈241, 298, 166, 67, 1〉. Then, in the
    last squaring step, WITNESS discovers that *a*^(280) is a nontrivial square root
    of 1 since *a*^(280) = 67 (mod *n*) and (*a*^(280))² = *a*^(560) = 1 (mod *n*).
    Therefore, *a* = 7 is a witness to the compositeness of *n*, WITNESS(7, *n*) returns
    TRUE, and MILLER-RABIN returns COMPOSITE.
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明MILLER-RABIN的操作，让*n*为卡迈克尔数561，使得*n* - 1 = 560 = 2⁴ · 35，*t* = 4，*u* = 35��如果过程选择*a*
    = 7作为基数，在[图31.4](chapter031.xhtml#Fig_31-4)（[第31.6节](chapter031.xhtml#Sec_31.6)）中*b*
    = 35的列显示WITNESS计算*x*[0] = *a*^(35) = 241（mod 561）。由于MODULAR-EXPONENTIATION过程如何递归地作用于其参数*b*，[图31.4](chapter031.xhtml#Fig_31-4)中的前四列代表560的因子2⁴——560的二进制表示中最右边的四个零——从右向左读取这四个零。因此，WITNESS计算序列*X*
    = 〈241, 298, 166, 67, 1〉。然后，在最后的平方步骤中，WITNESS发现*a*^(280)是1的一个非平凡平方根，因为*a*^(280)
    = 67（mod *n*），而（*a*^(280))² = *a*^(560) = 1（mod *n*）。因此，*a* = 7是*n*的合数的证明，WITNESS(7,
    *n*)返回TRUE，MILLER-RABIN返回COMPOSITE。
- en: If *n* is a *β*-bit number, MILLER-RABIN requires *O*(*sβ*) arithmetic operations
    and *O*(*sβ*³) bit operations, since it requires asymptotically no more work than
    *s* modular exponentiations.
  id: totrans-697
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *n* 是一个 *β* 位数，MILLER-RABIN 需要 *O*(*sβ*) 算术运算和 *O*(*sβ*³) 位运算，因为它需要的工作量渐近地不超过
    *s* 模指数运算。
- en: '**Error rate of the Miller-Rabin primality test**'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: '**米勒-拉宾素性测试的错误率**'
- en: 'If MILLER-RABIN returns PRIME, then there is a very slim chance that it has
    made an error. Unlike PSEUDOPRIME, however, the chance of error does not depend
    on *n*: there are no bad inputs for this procedure. Rather, it depends on the
    size of *s* and the “luck of the draw” in choosing base values *a*. Moreover,
    since each test is more stringent than a simple check of equation (31.39), we
    can expect on general principles that the error rate should be small for randomly
    chosen integers *n*. The following theorem presents a more precise argument.'
  id: totrans-699
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 MILLER-RABIN 返回 PRIME，则它出错的几率非常小。然而，与 PSEUDOPRIME 不同，错误的几率不取决于 *n*：对于此过程没有坏输入。相反，它取决于
    *s* 的大小和在选择基值 *a* 时的“运气”。此外，由于每个测试比简单检查方程式(31.39)更严格，我们可以根据一般原则预期对于随机选择的整数 *n*，错误率应该很小。以下定理提供了更精确的论证。
- en: '***Theorem 31.39***'
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理31.39***'
- en: If *n* is an odd composite number, then the number of witnesses to the compositeness
    of *n* is at least (*n* – 1)/2.
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *n* 是一个奇合数，那么对于 *n* 的合数性的见证数量至少为 (*n* – 1)/2。
- en: '***Proof***   The proof shows that the number of nonwitnesses is at most (*n*
    – 1)/2, which implies the theorem.'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 证明表明非见证的数量最多为 (*n* – 1)/2，这意味着定理成立。'
- en: We start by claiming that any nonwitness must be a member of ![art](images/Art_Zastn.jpg).
    Why? Consider any nonwitness *a*. It must satisfy *a*^(*n*–1) = 1 (mod *n*) or,
    equivalently, *a* · *a*^(*n*−2) = 1 (mod *n*). Thus the equation *ax* = 1 (mod
    *n*) has a solution, namely *a*^(*n*−2). By Corollary 31.21 on page 924, gcd(*a*,
    *n*) | 1, which in turn implies that gcd(*a*, *n*) = 1\. Therefore, *a* is a member
    of ![art](images/Art_Zastn.jpg), and all nonwitnesses belong to ![art](images/Art_Zastn.jpg).
  id: totrans-703
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先声称任何非见证必须是 ![艺术](images/Art_Zastn.jpg) 的成员。为什么？考虑任何非见证 *a*。它必须满足 *a*^(*n*–1)
    = 1 (mod *n*) 或者等价地，*a* · *a*^(*n*−2) = 1 (mod *n*)。因此方程 *ax* = 1 (mod *n*) 有一个解，即
    *a*^(*n*−2)。根据第924页的推论31.21，gcd(*a*, *n*) | 1，这进而意味着 gcd(*a*, *n*) = 1。因此，*a*
    是 ![��术](images/Art_Zastn.jpg) 的成员，所有非见证都属于 ![艺术](images/Art_Zastn.jpg)。
- en: To complete the proof, we show that not only are all nonwitnesses contained
    in ![art](images/Art_Zastn.jpg), they are all contained in a proper subgroup *B*
    of ![art](images/Art_Zastn.jpg) (recall that *B* is a *proper* subgroup of ![art](images/Art_Zastn.jpg)
    when *B* is subgroup of ![art](images/Art_Zastn.jpg) but *B* is not equal to ![art](images/Art_Zastn.jpg)).
    By Corollary 31.16 on page 921, we then have ![art](images/Art_P1241.jpg). Since
    ![art](images/Art_P1242.jpg), we obtain |*B*| ≤ (*n* – 1)/2\. Therefore, if all
    nonwitnesses are contained in a proper subgroup of ![art](images/Art_Zastn.jpg),
    then the number of nonwitnesses is at most (*n* – 1)/2, so that the number of
    witnesses must be at least (*n* – 1)/2.
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成证明，我们展示所有非见证不仅包含在 ![艺术](images/Art_Zastn.jpg) 中，它们都包含在 ![艺术](images/Art_Zastn.jpg)
    的一个真子群 *B* 中（回想一下，当 *B* 是 ![艺术](images/Art_Zastn.jpg) 的子群但 *B* 不等于 ![艺术](images/Art_Zastn.jpg)
    时，*B* 是一个*真*子群）。根据第921页的推论31.16，我们有 ![艺术](images/Art_P1241.jpg)。由于 ![艺术](images/Art_P1242.jpg)，我们得到
    |*B*| ≤ (*n* – 1)/2。因此，如果所有非见证都包含在 ![艺术](images/Art_Zastn.jpg) 的一个真子群中，那么非见证的数量最多为
    (*n* – 1)/2，因此见证的数量至少为 (*n* – 1)/2。
- en: To find a proper subgroup *B* of ![art](images/Art_Zastn.jpg) containing all
    of the nonwitnesses, we consider two cases.
  id: totrans-705
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到 ![艺术](images/Art_Zastn.jpg) 的一个真子群 *B*，其中包含所有非见证，我们考虑两种情况。
- en: '*Case 1:* There exists an ![art](images/Art_P1243.jpg) such that'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '*情况1:* 存在一个 ![艺术](images/Art_P1243.jpg)，使得'
- en: '*x*^(*n*–1) ≠ 1 (mod *n*).'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: '*x*^(*n*–1) ≠ 1 (mod *n*)。'
- en: In other words, *n* is not a Carmichael number. Since, as noted earlier, Carmichael
    numbers are extremely rare, case 1 is the more typical case (e.g., when *n* has
    been chosen randomly and is being tested for primality).
  id: totrans-708
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*n* 不是卡迈克尔数。正如前面提到的，卡迈克尔数极为罕见，情况1是更典型的情况（例如，当 *n* 被随机选择并被测试为素数时）。
- en: Let ![art](images/Art_P1244.jpg). The set *B* must be nonempty, since 1 ∈ *B*.
    The set *B* is closed under multiplication modulo *n*, and so *B* is a subgroup
    of ![art](images/Art_Zastn.jpg) by Theorem 31.14\. Every nonwitness belongs to
    *B*, since a nonwitness *a* satisfies *a*^(*n*–1) = 1 (mod *n*). Since ![art](images/Art_P1245.jpg),
    we have that *B* is a proper subgroup of ![art](images/Art_Zastn.jpg).
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 让 ![艺术](images/Art_P1244.jpg)。集合 *B* 必须非空，因为1 ∈ *B*。集合 *B* 在模 *n* 下乘法运算封闭，因此根据定理31.14，*B*
    是 ![艺术](images/Art_Zastn.jpg) 的一个子群。每个非见证都属于 *B*，因为非见证 *a* 满足 *a*^(*n*–1) = 1
    (mod *n*)。由于 ![艺术](images/Art_P1245.jpg)，我们得知 *B* 是 ![艺术](images/Art_Zastn.jpg)
    的一个真子群。
- en: '*Case 2:* For all ![art](images/Art_P1246.jpg),'
  id: totrans-710
  prefs: []
  type: TYPE_NORMAL
  zh: '*情况2:* 对于所有 ![艺术](images/Art_P1246.jpg)，'
- en: '![art](images/Art_P1247.jpg)'
  id: totrans-711
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1247.jpg)'
- en: In other words, *n* is a Carmichael number. This case is extremely rare in practice.
    Unlike a pseudoprimality test, however, the Miller-Rabin test can efficiently
    determine that Carmichael numbers are composite, as we’re about to see.
  id: totrans-712
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，*n* 是一个卡迈克尔数。在实践中，这种情况极为罕见。然而，与伪素性测试不同，米勒-拉宾测试可以有效地确定卡迈克尔数是合数，正如我们将要看到的。
- en: 'In this case, *n* cannot be a prime power. To see why, suppose to the contrary
    that *n* = *p*^(*e*), where *p* is a prime and *e* > 1\. We derive a contradiction
    as follows. Since we assume that *n* is odd, *p* must also be odd. Theorem 31.32
    on page 933 implies that ![art](images/Art_Zastn.jpg) is a cyclic group: it contains
    a generator *g* such that ![art](images/Art_P1248.jpg). (The formula for *ϕ*(*n*)
    comes from equation (31.21) on page 920.) By equation (31.40), we have *g*^(*n*–1)
    = 1 (mod *n*). Then the discrete logarithm theorem (Theorem 31.33 on page 933,
    taking *y* = 0) implies that *n* – 1 = 0 (mod *ϕ* (*n*)), or'
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，*n*不能是素数幂。为了看到为什么，假设相反，*n* = *p*^(*e*)，其中*p*是一个素数且*e* > 1。我们通过以下方式推导出矛盾。由于我们假设*n*是奇数，*p*也必须是奇数。第933页的定理31.32暗示![art](images/Art_Zastn.jpg)是一个循环群：它包含一个生成元*g*，使得![art](images/Art_P1248.jpg)。（*ϕ*(*n*)的公式来自第920页的方程(31.21)。）根据方程(31.40)，我们有*g*^(*n*–1)
    = 1 (mod *n*)。然后离散对数定理（第933页的定理31.33，取*y* = 0）意味着*n* – 1 = 0 (mod *ϕ* (*n*))，或
- en: (*p* – 1)*p*^(*e*−1) | *p*^(*e*) – 1.
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: (*p* – 1)*p*^(*e*−1) | *p*^(*e*) – 1.
- en: This statement is a contradiction for *e* > 1, since (*p* – 1)*p*^(*e*−1) is
    divisible by the prime *p*, but *p*^(*e*) – 1 is not. Thus *n* is not a prime
    power.
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*e* > 1，这个陈述是一个矛盾，因为(*p* – 1)*p*^(*e*−1)能被素数*p*整除，但*p*^(*e*) – 1不能。因此*n*不是素数幂。
- en: Since the odd composite number *n* is not a prime power, we decompose it into
    a product *n*[1]*n*[2], where *n*[1] and *n*[2] are odd numbers greater than 1
    that are relatively prime to each other. (There may be several ways to decompose
    *n*, and it does not matter which one we choose. For example, if ![art](images/Art_P1249.jpg),
    then we can choose ![art](images/Art_P1250.jpg) and ![art](images/Art_P1251.jpg).)
  id: totrans-716
  prefs: []
  type: TYPE_NORMAL
  zh: 由于奇合数*n*不是素数幂，我们将其分解为乘积*n*[1]*n*[2]，其中*n*[1]和*n*[2]*是大于1的奇数，它们互质。（我们可以有几种分解*n*的方式，我们选择哪一种并不重要。例如，如果![art](images/Art_P1249.jpg)，那么我们可以选择![art](images/Art_P1250.jpg)和![art](images/Art_P1251.jpg)。）
- en: Recall that *t* and *u* are such that *n* – 1 = 2^(*t*)*u*, where *t* ≥ 1 and
    *u* is odd, and that for an input *a*, the procedure WITNESS computes the sequence
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，*t*和*u*满足*n* – 1 = 2^(*t*)*u*，其中*t* ≥ 1且*u*是奇数，并且对于输入*a*，过程WITNESS计算序列
- en: '![art](images/Art_P1252.jpg)'
  id: totrans-718
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1252.jpg)'
- en: where all computations are performed modulo *n*.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 所有计算都是在模*n*下进行的。
- en: Let us call a pair (*v*, *j*) of integers ***acceptable*** if ![art](images/Art_P1253.jpg),
    and
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们称一对整数(*v*, *j*)为***可接受***，如果![art](images/Art_P1253.jpg)，且
- en: '![art](images/Art_P1254.jpg)'
  id: totrans-721
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1254.jpg)'
- en: Acceptable pairs certainly exist, since *u* is odd. Choose *v* = *n* – 1 and
    *j* = 0, and let *u* = 2*k* + 1, so that ![art](images/Art_P1255.jpg). Taking
    this number modulo *n* gives (*n* – 1)^(2*k*+1) = (*n* – 1)^(2*k*) · (*n* – 1)
    = (–1)^(2*k*) · –1 = −1 (mod *n*). Thus, (*n* – 1, 0) is an acceptable pair. Now
    pick the largest possible *j* such that there exists an acceptable pair (*v*,
    *j*), and fix *v* so that (*v*, *j*) is an acceptable pair. Let
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 可接受的对肯定存在，因为*u*是奇数。选择*v* = *n* – 1和*j* = 0，并且让*u* = 2*k* + 1，以便![art](images/Art_P1255.jpg)。对这个数取模*n*得到(*n*
    – 1)^(2*k*+1) = (*n* – 1)^(2*k*) · (*n* – 1) = (–1)^(2*k*) · –1 = −1 (mod *n*)。因此，(*n*
    – 1, 0)是一个可接受的对。现在选择最大可能的*j*，使得存在一个可接受的对(*v*, *j*)，并固定*v*以便(*v*, *j*)是一个可接受的对。让
- en: '![art](images/Art_P1256.jpg)'
  id: totrans-723
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1256.jpg)'
- en: Since *B* is closed under multiplication modulo *n*, it is a subgroup of ![art](images/Art_Zastn.jpg).
    By Theorem 31.15 on page 921, therefore, |*B*| divides ![art](images/Art_P1257.jpg).
    Every nonwitness must be a member of *B*, since the sequence *X* produced by a
    nonwitness must either be all 1s or else contain a –1 no later than the *j*th
    position, by the maximality of *j*. (If (*a*, *j*′) is acceptable, where *a* is
    a nonwitness, we must have *j*′ ≤ *j* by how we chose *j*.)
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*B*在模*n*下乘法封闭，它是![art](images/Art_Zastn.jpg)的一个子群。根据第921页的定理31.15，因此，|*B*|能整除![art](images/Art_P1257.jpg)。每个非见证必须是*B*的成员，因为非见证产生的序列*X*要么全为1，要么在第*j*个位置之前包含一个-1，由于*j*的极大性。（如果(*a*,
    *j*′)是可接受的，其中*a*是一个非见证，我们必须根据我们选择*j*的方式，有*j*′ ≤ *j*。）
- en: We now use the existence of *v* to demonstrate that there exists a ![art](images/Art_P1258.jpg),
    and hence that *B* is a proper subgroup of ![art](images/Art_Zastn.jpg). Since
    ![art](images/Art_P1259.jpg), we also have ![art](images/Art_P1260.jpg) by Corollary
    31.29 to the Chinese remainder theorem. By Corollary 31.28, there exists a *w*
    simultaneously satisfying the equations
  id: totrans-725
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们利用存在的*v*来证明存在一个![art](images/Art_P1258.jpg)，因此*B*是![art](images/Art_Zastn.jpg)的一个适当子群。由于![art](images/Art_P1259.jpg)，根据中国余数定理的推论31.29，我们也有![art](images/Art_P1260.jpg)。根据推论31.28，存在一个*w*同时满足方程
- en: '| *w* | = *v* (mod *n*[1]), |'
  id: totrans-726
  prefs: []
  type: TYPE_TB
  zh: '| *w* | = *v* (mod *n*[1]), |'
- en: '| *w* | = 1 (mod *n*[2]). |'
  id: totrans-727
  prefs: []
  type: TYPE_TB
  zh: '| *w* | = 1 (mod *n*[2]). |'
- en: Therefore,
  id: totrans-728
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，
- en: '![art](images/Art_P1261.jpg)'
  id: totrans-729
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1261.jpg)'
- en: Corollary 31.29 gives that ![art](images/Art_P1262.jpg) implies ![art](images/Art_P1263.jpg)
    and also that ![art](images/Art_P1264.jpg) implies ![art](images/Art_P1265.jpg).
    Hence, we conclude that ![art](images/Art_P1266.jpg), and so *w* ∉ *B*.
  id: totrans-730
  prefs: []
  type: TYPE_NORMAL
  zh: 推论31.29给出![art](images/Art_P1262.jpg)意味着![art](images/Art_P1263.jpg)，并且![art](images/Art_P1264.jpg)意味着![art](images/Art_P1265.jpg)。因此，我们得出结论![art](images/Art_P1266.jpg)，因此*w*
    ∉ *B*。
- en: It remains to show that ![art](images/Art_P1267.jpg). We start by working separately
    modulo *n*[1] and modulo *n*[2]. Working modulo *n*[1], since ![art](images/Art_P1268.jpg),
    we have that gcd(*v*, *n*) = 1\. Also, we have gcd(*v*, *n*[1]) = 1, since if
    *v* does not have any common divisors with *n*, then it certainly does not have
    any common divisors with *n*[1]. Since *w* = *v* (mod *n*[1]), we see that gcd(*w*,
    *n*[1]) = 1\. Working modulo *n*[2], we have *w* = 1 (mod *n*[2]) implies gcd(*w*,
    *n*[2]) = 1 by Exercise 31.2-3\. Since gcd(*w*, *n*[1]) = 1 and gcd(*w*, *n*[2])
    = 1, Theorem 31.6 on page 908 yields gcd(*w*, *n*[1]*n*[2]) = gcd(*w*, *n*) =
    1\. That is, ![art](images/Art_P1269.jpg).
  id: totrans-731
  prefs: []
  type: TYPE_NORMAL
  zh: 还需要证明 ![art](images/Art_P1267.jpg)。我们首先分别在模 *n*[1] 和模 *n*[2] 下进行工作。在模 *n*[1]
    下工作，由于 ![art](images/Art_P1268.jpg)，我们有 gcd(*v*, *n*) = 1。此外，我们有 gcd(*v*, *n*[1])
    = 1，因为如果 *v* 与 *n* 没有任何公共因子，那么它肯定也与 *n*[1] 没有任何公共因子。由于 *w* = *v* (mod *n*[1])，我们看到
    gcd(*w*, *n*[1]) = 1。在模 *n*[2] 下工作，我们有 *w* = 1 (mod *n*[2]) 意味着 gcd(*w*, *n*[2])
    = 1，根据练习 31.2-3。由于 gcd(*w*, *n*[1]) = 1 和 gcd(*w*, *n*[2]) = 1，第 908 页的定理 31.6
    得出 gcd(*w*, *n*[1]*n*[2]) = gcd(*w*, *n*) = 1。也就是说，![art](images/Art_P1269.jpg)。
- en: Therefore, we have ![art](images/Art_P1270.jpg), and we can conclude in case
    2 that *B*, which includes all nonwitnesses, is a proper subgroup of ![art](images/Art_Zastn.jpg)
    and therefore has size at most (*n* – 1)/2.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们有 ![art](images/Art_P1270.jpg)，并且我们可以得出结论，在情况 2 中 *B*，包括所有非见证者，是 ![art](images/Art_Zastn.jpg)
    的一个适当子群，因此大小最多为 (*n* – 1)/2。
- en: In either case, the number of witnesses to the compositeness of *n* is at least
    (*n* – 1)/2.
  id: totrans-733
  prefs: []
  type: TYPE_NORMAL
  zh: 无论哪种情况，对于 *n* 的合数性至少有 (*n* – 1)/2 个见证者。
- en: ▪
  id: totrans-734
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '***Theorem 31.40***'
  id: totrans-735
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 31.40***'
- en: For any odd integer *n* > 2 and positive integer *s*, the probability that MILLER-RABIN(*n*,
    *s*) errs is at most 2^(–*s*).
  id: totrans-736
  prefs: []
  type: TYPE_NORMAL
  zh: 对于任意奇数 *n* > 2 和正整数 *s*，MILLER-RABIN(*n*, *s*) 出错的概率最多为 2^(–*s*)。
- en: '***Proof***   By Theorem 31.39, if *n* is composite, then each execution of
    the **for** loop of lines 1–4 of MILLER-RABIN has a probability of at least 1/2
    of discovering a witness to the compositeness of *n*. MILLER-RABIN makes an error
    only if it is so unlucky as to miss discovering a witness to the compositeness
    of *n* on each of the *s* iterations of the main loop. The probability of such
    a sequence of misses is at most 2^(–*s*).'
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   根据定理 31.39，如果 *n* 是合数，那么 MILLER-RABIN 的第 1-4 行的 **for** 循环的每次执行都有至少
    1/2 的概率发现 *n* 的合数性的见证者。MILLER-RABIN 只有在在主循环的 *s* 次迭代中每次都不幸错过发现 *n* 的合数性的见证者时才会出错。这样一连串错过的概率最多为
    2^(–*s*)。'
- en: ▪
  id: totrans-738
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: If *n* is prime, MILLER-RABIN always reports PRIME, and if *n* is composite,
    the chance that MILLER-RABIN reports PRIME is at most 2^(−*s*).
  id: totrans-739
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *n* 是素数，MILLER-RABIN 总是报告 PRIME，如果 *n* 是合数，MILLER-RABIN 报告 PRIME 的概率最多为 2^(−*s*)。
- en: When applying MILLER-RABIN to a large randomly chosen integer *n*, however,
    we need to consider as well the prior probability that *n* is prime, in order
    to correctly interpret MILLER-RABIN’s result. Suppose that we fix a bit length
    *β* and choose at random an integer *n* of length *β* bits to be tested for primality,
    so that *β* ≈ 1g *n* ≈ 1.443 ln *n*. Let *A* denote the event that *n* is prime.
    By the prime number theorem (Theorem 31.37), the probability that *n* is prime
    is approximately
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当将 MILLER-RABIN 应用于大随机选择的整数 *n* 时，我们还需要考虑 *n* 是素数的先验概率，以便正确解释 MILLER-RABIN
    的结果。假设我们固定一个比特长度 *β* 并随机选择一个长度为 *β* 位的整数 *n* 进行素性测试，使得 *β* ≈ 1g *n* ≈ 1.443 ln
    *n*。让 *A* 表示 *n* 是素数的事件。根据素数定理（定理 31.37），*n* 是素数的概率约为
- en: '| Pr {*A*} | ≈ | 1/ln *n* |'
  id: totrans-741
  prefs: []
  type: TYPE_TB
  zh: '| Pr {*A*} | ≈ | 1/ln *n* |'
- en: '|  | ≈ | 1.443/*β*. |'
  id: totrans-742
  prefs: []
  type: TYPE_TB
  zh: '|  | ≈ | 1.443/*β*. |'
- en: Now let *B* denote the event that MILLER-RABIN returns PRIME. We have that ![art](images/Art_P1271.jpg)
    (or equivalently, that Pr{*B* | *A*} = 1) and ![art](images/Art_P1272.jpg) (or
    equivalently, that ![art](images/Art_P1273.jpg)).
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让 *B* 表示 MILLER-RABIN 返回 PRIME 的事件。我们有 ![art](images/Art_P1271.jpg)（或者等价地，Pr{*B*
    | *A*} = 1）和 ![art](images/Art_P1272.jpg)（或者等价地，![art](images/Art_P1273.jpg)）。
- en: But what is Pr{*A* | *B*}, the probability that *n* is prime, given that MILLER-RABIN
    has returned PRIME? By the alternate form of Bayes’s theorem (equation (C.20)
    on page 1189) and approximating ![art](images/Art_P1274.jpg), we have
  id: totrans-744
  prefs: []
  type: TYPE_NORMAL
  zh: 但是 Pr{*A* | *B*} 是多少，即给定 MILLER-RABIN 返回 PRIME 的情况下 *n* 是素数的概率？根据贝叶斯定理的另一种形式（第
    1189 页的方程（C.20））和近似 ![art](images/Art_P1274.jpg)，我们有
- en: '![art](images/Art_P1275.jpg)'
  id: totrans-745
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1275.jpg)'
- en: This probability does not exceed 1/2 until *s* exceeds 1g(ln *n* – 1). Intuitively,
    that many initial trials are needed just for the confidence derived from failing
    to find a witness to the compositeness of *n* to overcome the prior bias in favor
    of *n* being composite. For a number with *β* = 1024 bits, this initial testing
    requires about
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 直到 *s* 超过 1g(ln *n* – 1)，这个概率不会超过 1/2。直觉上，需要这么多的初始试验仅仅是为了通过未能找到 *n* 的合数性的见证者来克服对
    *n* 是合数的先验偏见。对于具有 *β* = 1024 位的数字，这种初始测试需要大约
- en: '| lg(ln *n* – 1) | ≈ | lg(*β*/1.443) |'
  id: totrans-747
  prefs: []
  type: TYPE_TB
  zh: '| lg(ln *n* – 1) | ≈ | lg(*β*/1.443) |'
- en: '|  | ≈ | 9 |'
  id: totrans-748
  prefs: []
  type: TYPE_TB
  zh: '|  | ≈ | 9 |'
- en: trials. In any case, choosing *s* = 50 should suffice for almost any imaginable
    application.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 次数。无论如何，选择 *s* = 50 应该适用于几乎任何想象得到的应用。
- en: In fact, the situation is much better. If you are trying to find large primes
    by applying MILLER-RABIN to large randomly chosen odd integers, then choosing
    a small value of *s* (say 3) is unlikely to lead to erroneous results, though
    we won’t prove it here. The reason is that for a randomly chosen odd composite
    integer *n*, the expected number of nonwitnesses to the compositeness of *n* is
    likely to be considerably smaller than (*n* – 1)/2.
  id: totrans-750
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，情况要好得多。如果你试图通过将 MILLER-RABIN 应用于大随机选择的奇整数来找到大素数，那么选择一个小的 *s* 值（比如 3）不太可能导致错误的结果，尽管我们在这里不会证明。原因是对于随机选择的奇合数整数
    *n*，非见证者的预期数量可能远小于 (*n* – 1)/2。
- en: If the integer *n* is not chosen randomly, however, the best that can be proven
    is that the number of nonwitnesses is at most (*n* – 1)/4, using an improved version
    of Theorem 31.39\. Furthermore, there do exist integers *n* for which the number
    of nonwitnesses is (*n* – 1)/4.
  id: totrans-751
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果整数 *n* 不是随机选择的，那么最好的证明是非见证者的数量最多为 (*n* – 1)/4，使用定理 31.39 的改进版本。此外，确实存在整数
    *n*，其中非见证者的数量为 (*n* – 1)/4。
- en: '**Exercises**'
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***31.8-1***'
  id: totrans-753
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.8-1***'
- en: Prove that if an odd integer *n* > 1 is not a prime or a prime power, then there
    exists a nontrivial square root of 1, modulo *n*.
  id: totrans-754
  prefs: []
  type: TYPE_NORMAL
  zh: 证明如果一个大于1的奇整数*n*不是素数或素数幂，则在模*n*下存在一个非平凡的平方根1。
- en: ★ ***31.8-2***
  id: totrans-755
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***31.8-2***
- en: It is possible to strengthen Euler’s theorem (Theorem 31.30) slightly to the
    form
  id: totrans-756
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将欧拉定理（定理31.30）略微加强为以下形式
- en: '![art](images/Art_P1276.jpg)'
  id: totrans-757
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1276.jpg)'
- en: where ![art](images/Art_P1277.jpg) and λ(*n*) is defined by
  id: totrans-758
  prefs: []
  type: TYPE_NORMAL
  zh: 其中![art](images/Art_P1277.jpg)，λ(*n*)由以下定义
- en: '![art](images/Art_P1278.jpg)'
  id: totrans-759
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1278.jpg)'
- en: Prove that *λ*(*n*) | *ϕ*(*n*). A composite number *n* is a Carmichael number
    if *λ*(*n*) | *n* – 1\. The smallest Carmichael number is 561 = 3 · 11 · 17, for
    which *λ*(*n*) = 1cm(2, 10, 16) = 80, which divides 560\. Prove that Carmichael
    numbers must be both “square-free” (not divisible by the square of any prime)
    and the product of at least three primes. (For this reason, they are not common.)
  id: totrans-760
  prefs: []
  type: TYPE_NORMAL
  zh: 证明*λ*(*n*) | *ϕ*(*n*)。如果一个合数*n*是卡迈克尔数，则*λ*(*n*) | *n* – 1。最小的卡迈克尔数是561 = 3 ·
    11 · 17，其中*λ*(*n*) = 1cm(2, 10, 16) = 80，可以整除560。证明卡迈克尔数必须是“无平方因子”（不可被任何质数的平方整除）且至少由三个质数的乘积组成。（因此，它们并不常见。）
- en: '***31.8-3***'
  id: totrans-761
  prefs: []
  type: TYPE_NORMAL
  zh: '***31.8-3***'
- en: Prove that if *x* is a nontrivial square root of 1, modulo *n*, then gcd(*x*
    − 1, *n*) and gcd(*x* + 1, *n*) are both nontrivial divisors of *n*.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 证明如果*x*是模*n*下的一个非平凡平方根，则gcd(*x* − 1, *n*)和gcd(*x* + 1, *n*)都是*n*的非平凡因子。
- en: '**Problems**'
  id: totrans-763
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '***31-1     Binary gcd algorithm***'
  id: totrans-764
  prefs: []
  type: TYPE_NORMAL
  zh: '***31-1     二进制最大公约数算法***'
- en: Most computers can perform the operations of subtraction, testing the parity
    (odd or even) of a binary integer, and halving more quickly than computing remainders.
    This problem investigates the ***binary gcd algorithm***, which avoids the remainder
    computations used in Euclid’s algorithm.
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数计算机可以比计算余数更快地执行减法、测试二进制整数的奇偶性（奇数或偶数）以及对一半进行操作。这个问题研究了***二进制最大公约数算法***，该算法避免了欧几里德算法中使用的余数计算。
- en: '***a.*** Prove that if *a* and *b* are both even, then gcd(*a*, *b*) = 2 ·
    gcd(*a*/2, *b*/2).'
  id: totrans-766
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 证明如果*a*和*b*都是偶数，则gcd(*a*, *b*) = 2 · gcd(*a*/2, *b*/2)。'
- en: '***b.*** Prove that if *a* is odd and *b* is even, then gcd(*a*, *b*) = gcd(*a*,
    *b*/2).'
  id: totrans-767
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 证明如果*a*是奇数且*b*是偶数，则gcd(*a*, *b*) = gcd(*a*, *b*/2)。'
- en: '***c.*** Prove that if *a* and *b* are both odd, then gcd(*a*, *b*) = gcd((*a*
    – *b*)/2, *b*).'
  id: totrans-768
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 证明如果*a*和*b*都是奇数，则gcd(*a*, *b*) = gcd((*a* – *b*)/2, *b*)。'
- en: '***d.*** Design an efficient binary gcd algorithm for input integers *a* and
    *b*, where *a* ≥ *b*, that runs in *O*(1g *a*) time. Assume that each subtraction,
    parity test, and halving takes unit time.'
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 设计一个高效的二进制最大公约数算法，用于输入整数*a*和*b*，其中*a* ≥ *b*，运行时间为*O*(1g *a*)。假设每���减法、奇偶性测试和对一半的操作都需要单位时间。'
- en: '***31-2     Analysis of bit operations in Euclid’s algorithm***'
  id: totrans-770
  prefs: []
  type: TYPE_NORMAL
  zh: '***31-2     欧几里德算法中的位操作分析***'
- en: '***a.*** Consider the ordinary “paper and pencil” algorithm for long division:
    dividing *a* by *b*, which yields a quotient *q* and remainder *r*. Show that
    this method requires *O*((1 + 1g *q*)1g *b*) bit operations.'
  id: totrans-771
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 考虑长除法的普通“纸和笔”算法：将*a*除以*b*，得到商*q*和余数*r。展示这种方法需要*O*((1 + 1g *q*)1g *b*)位操作。'
- en: '***b.*** Define *μ*(*a*, *b*) = (1 + 1g *a*)(1 + 1g *b*). Show that the number
    of bit operations performed by EUCLID in reducing the problem of computing gcd(*a*,
    *b*) to that of computing gcd(*b*, *a* mod *b*) is at most *c*(*μ*(*a*, *b*) –
    *μ*(*b*, *a* mod *b*)) for some sufficiently large constant *c* > 0.'
  id: totrans-772
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 定义*μ*(*a*, *b*) = (1 + 1g *a*)(1 + 1g *b*)。展示EUCLID在将计算gcd(*a*, *b*)的问题简化为计算gcd(*b*,
    *a* mod *b*)的问题时执行的位操作数量最多为*c*(*μ*(*a*, *b*) – *μ*(*b*, *a* mod *b*))，其中*c* >
    0是一个足够大的常数。'
- en: '***c.*** Show that EUCLID(*a*, *b*) requires *O*(*μ*(*a*, *b*)) bit operations
    in general and *O*(*β*²) bit operations when applied to two *β*-bit inputs.'
  id: totrans-773
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 展示EUCLID(*a*, *b*)通常需要*O*(*μ*(*a*, *b*))位操作，当应用于两个*β*位输入时，需要*O*(*β*²)位操作。'
- en: '***31-3     Three algorithms for Fibonacci numbers***'
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: '***31-3     斐波那契数的三种算法***'
- en: This problem compares the efficiency of three methods for computing the *n*th
    Fibonacci number *F*[*n*], given *n*. Assume that the cost of adding, subtracting,
    or multiplying two numbers is *O*(1), independent of the size of the numbers.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题比较了三种计算第*n*个斐波那契数*F*[*n*]的方法的效率，给定*n*。假设两个数相加、相减或相乘的成本是*O*(1)，与数字的大小无关。
- en: '***a.*** Show that the running time of the straightforward recursive method
    for computing *F*[*n*] based on recurrence (3.31) on page 69 is exponential in
    *n*. (See, for example, the FIB procedure on page 751.)'
  id: totrans-776
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 证明基于第69页上的递归关系（3.31）计算*F*[*n*]的直接递归方法的运行时间是指数级的。（例如，查看第751页上的FIB过程。）'
- en: '***b.*** Show how to compute *F*[*n*] in *O*(*n*) time using memoization.'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 展示如何使用记忆化在*O*(*n*)时间内计算*F*[*n*]。'
- en: '***c.*** Show how to compute *F*[*n*] in *O*(1g *n*) time using only integer
    addition and multiplication. (*Hint:* Consider the matrix ![art](images/Art_P1279.jpg)
    and its powers.)'
  id: totrans-778
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 展示如何仅使用整数加法和乘法在*O*(1g *n*)时间内计算*F*[*n*]。（*提示：*考虑矩阵![art](images/Art_P1279.jpg)及其幂。）'
- en: '***d.*** Assume now that adding two *β*-bit numbers takes Θ(*β*) time and that
    multiplying two *β*-bit numbers takes Θ(*β*²) time. What is the running time of
    these three methods under this more reasonable cost measure for the elementary
    arithmetic operations?'
  id: totrans-779
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 现在假设两个*β*位数相加需要Θ(*β*)时间，两个*β*位数相乘需要Θ(*β*²)时间。在这种更合理的成本度量下，这三种方法的运行时间是多少？'
- en: '***31-4     Quadratic residues***'
  id: totrans-780
  prefs: []
  type: TYPE_NORMAL
  zh: '***31-4     二次剩余***'
- en: Let *p* be an odd prime. A number ![art](images/Art_P1280.jpg) is a ***quadratic
    residue*** modulo *p*, if the equation *x*² = *a* (mod *p*) has a solution for
    the unknown *x*.
  id: totrans-781
  prefs: []
  type: TYPE_NORMAL
  zh: 设*p*是一个奇素数。如果方程*x*² = *a* (mod *p*)对未知数*x*有解，则数![art](images/Art_P1280.jpg)是模*p*下的一个***二次剩余***。
- en: '***a.*** Show that there are exactly (*p* – 1)/2 quadratic residues, modulo
    *p*.'
  id: totrans-782
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 证明模*p*下存在(*p* – 1)/2个二次剩余。'
- en: '***b.*** If *p* is prime, we define the ***Legendre symbol*** ![art](images/Art_P1281.jpg),
    for ![art](images/Art_P1282.jpg), to be 1 if *a* is a quadratic residue, modulo
    *p*, and –1 otherwise. Prove that if ![art](images/Art_P1283.jpg), then'
  id: totrans-783
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 如果*p*是素数，我们定义***勒让德符号*** ![art](images/Art_P1281.jpg)，对于![art](images/Art_P1282.jpg)，如果*a*在模*p*下是二次剩余，则为1，否则为-1。证明如果![art](images/Art_P1283.jpg)，那么'
- en: '![art](images/Art_P1284.jpg)'
  id: totrans-784
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1284.jpg)'
- en: Give an efficient algorithm that determines whether a given number *a* is a
    quadratic residue, modulo *p*. Analyze the efficiency of your algorithm.
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 给出一个有效的算法，确定给定数字*a*是否是模*p*的二次剩余。分析你的算法��效率。
- en: '***c.*** Prove that if *p* is a prime of the form 4*k* + 3 and *a* is a quadratic
    residue in ![art](images/Art_P1285.jpg), then *a*^(*k*+1) mod *p* is a square
    root of *a*, modulo *p*. How much time is required to find the square root of
    a quadratic residue *a*, modulo *p*?'
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 证明如果*p*是形式为4*k* + 3的素数，*a*在![art](images/Art_P1285.jpg)中是二次剩余，则*a*^(*k*+1)
    mod *p*是*a*的平方根，模*p*。找到模*p*的二次剩余*a*的平方根需要多少时间？'
- en: '***d.*** Describe an efficient randomized algorithm for finding a nonquadratic
    residue, modulo an arbitrary prime *p*, that is, a member of ![art](images/Art_Zastp.jpg)
    that is not a quadratic residue. How many arithmetic operations does your algorithm
    require on average?'
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 描述一种有效的随机算法，用于找到模一个任意素数*p*的非二次剩余，即不是二次剩余的![art](images/Art_Zastp.jpg)的成员。你的算法平均需要多少算术运算？'
- en: '**Chapter notes**'
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节注释**'
- en: Knuth [[260](bibliography001.xhtml#endnote_260)] contains a good discussion
    of algorithms for finding the greatest common divisor, as well as other basic
    number-theoretic algorithms. Dixon [[121](bibliography001.xhtml#endnote_121)]
    gives an overview of factorization and primality testing. Bach [[33](bibliography001.xhtml#endnote_33)],
    Riesel [[378](bibliography001.xhtml#endnote_378)], and Bach and Shallit [[34](bibliography001.xhtml#endnote_34)]
    provide overviews of the basics of computational number theory; Shoup [[411](bibliography001.xhtml#endnote_411)]
    provides a more recent survey. The conference proceedings edited by Pomerance
    [[362](bibliography001.xhtml#endnote_362)] contains several excellent survey articles.
  id: totrans-789
  prefs: []
  type: TYPE_NORMAL
  zh: Knuth[[260](bibliography001.xhtml#endnote_260)]包含了一个很好的讨论，涉及寻找最大公约数的算法，以及其他基本的数论算法。Dixon[[121](bibliography001.xhtml#endnote_121)]概述了因子分解和素性测试。Bach[[33](bibliography001.xhtml#endnote_33)]，Riesel[[378](bibliography001.xhtml#endnote_378)]和Bach和Shallit[[34](bibliography001.xhtml#endnote_34)]提供了计算数论基础的概述；Shoup[[411](bibliography001.xhtml#endnote_411)]提供了一个更近期的调查。由Pomerance编辑的会议记录[[362](bibliography001.xhtml#endnote_362)]包含了几篇优秀的调查文章。
- en: Knuth [[260](bibliography001.xhtml#endnote_260)] discusses the origin of Euclid’s
    algorithm. It appears in Book 7, Propositions 1 and 2, of the Greek mathematician
    Euclid’s *Elements*, which was written around 300 B.C.E. Euclid’s description
    may have been derived from an algorithm due to Eudoxus around 375 B.C.E. Euclid’s
    algorithm may hold the honor of being the oldest nontrivial algorithm, rivaled
    only by an algorithm for multiplication known to the ancient Egyptians. Shallit
    [[407](bibliography001.xhtml#endnote_407)] chronicles the history of the analysis
    of Euclid’s algorithm.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: Knuth[[260](bibliography001.xhtml#endnote_260)]讨论了欧几里德算法的起源。它出现在希腊数学家欧几里德的《几何原本》第7卷第1和第2命题中，该书约写于公元前300年。欧几里德的描述可能源自公元前375年左右的欧多克索斯的算法。欧几里德算法可能是最古老的非平凡算法，仅次于古埃及人所知的乘法算法。Shallit[[407](bibliography001.xhtml#endnote_407)]记录了对欧几里德算法分析的历史。
- en: Knuth attributes a special case of the Chinese remainder theorem (Theorem 31.27)
    to the Chinese mathematician Sun-Tsŭ, who lived sometime between 200 B.C.E. and
    200 C.E.—the date is quite uncertain. The same special case was given by the Greek
    mathematician Nichomachus around 100 C.E. It was generalized by Qin Jiushao in
    1247\. The Chinese remainder theorem was finally stated and proved in its full
    generality by L. Euler in 1734.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: Knuth将中国剩余定理的一个特殊情况（定理31.27）归因于中国数学家孙子，他生活在公元前200年至公元200年之间——日期非常不确定。同样的特殊情况在公元100年左右由希腊数学家尼科马库斯给出。1247年，秦九韶对其进行了推广。中国剩余定理最终由L·欧拉在1734年以其完整的一般性陈述和证明。
- en: The randomized primality-testing algorithm presented here is due to Miller [[327](bibliography001.xhtml#endnote_327)]
    and Rabin [[373](bibliography001.xhtml#endnote_373)] and is the fastest randomized
    primality-testing algorithm known, to within constant factors. The proof of Theorem
    31.40 is a slight adaptation of one suggested by Bach [[32](bibliography001.xhtml#endnote_32)].
    A proof of a stronger result for MILLER-RABIN was given by Monier [[332](bibliography001.xhtml#endnote_332),
    [333](bibliography001.xhtml#endnote_333)]. For many years primality-testing was
    the classic example of a problem where randomization appeared to be necessary
    to obtain an efficient (polynomial-time) algorithm. In 2002, however, Agrawal,
    Kayal, and Saxena [[4](bibliography001.xhtml#endnote_4)] surprised everyone with
    their deterministic polynomial-time primality-testing algorithm. Until then, the
    fastest deterministic primality testing algorithm known, due to Cohen and Lenstra
    [[97](bibliography001.xhtml#endnote_97)], ran in (1g *n*)^(*O*(1g1g1g *n*)) time
    on input *n*, which is just slightly superpolynomial. Nonetheless, for practical
    purposes, randomized primality-testing algorithms remain more efficient and are
    generally preferred.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 这里介绍的随机素性测试算法归功于Miller[[327](bibliography001.xhtml#endnote_327)]和Rabin[[373](bibliography001.xhtml#endnote_373)]，是已知的最快的随机素性测试算法，仅在常数因子内。定理31.40的证明是Bach[[32](bibliography001.xhtml#endnote_32)]建议的一个轻微改编。Monier[[332](bibliography001.xhtml#endnote_332)，[333](bibliography001.xhtml#endnote_333)]给出了MILLER-RABIN更强结果的证明。多年来，素性测试一直是随机化似乎是必要的以获得高效（多项式时间）算法的经典例子。然而，直到2002年，Agrawal，Kayal和Saxena[[4](bibliography001.xhtml#endnote_4)]以他们的确定性多项式时间素性测试算法使所有人感到惊讶。直到那时，已知的最快确定性素性测试算法，由Cohen和Lenstra[[97](bibliography001.xhtml#endnote_97)]提出，对输入*n*的运行时间为(1g
    *n*)^(*O*(1g1g1g *n*))，略高于超多项式。尽管如此，对于实际目的，随机素性测试算法仍然更有效，通常更受青睐。
- en: Beauchemin, Brassard, Crépeau, Goutier, and Pomerance [[40](bibliography001.xhtml#endnote_40)]
    nicely discuss the problem of finding large “random” primes.
  id: totrans-793
  prefs: []
  type: TYPE_NORMAL
  zh: Beauchemin、Brassard、Crépeau、Goutier和Pomerance[[40](bibliography001.xhtml#endnote_40)]很好地讨论了寻找大“随机”素数的问题。
- en: The concept of a public-key cryptosystem is due to Diffie and Hellman [[115](bibliography001.xhtml#endnote_115)].
    The RSA cryptosystem was proposed in 1977 by Rivest, Shamir, and Adleman [[380](bibliography001.xhtml#endnote_380)].
    Since then, the field of cryptography has blossomed. Our understanding of the
    RSA cryptosystem has deepened, and modern implementations use significant refinements
    of the basic techniques presented here. In addition, many new techniques have
    been developed for proving cryptosystems to be secure. For example, Goldwasser
    and Micali [[190](bibliography001.xhtml#endnote_190)] show that randomization
    can be an effective tool in the design of secure public-key encryption schemes.
    For signature schemes, Goldwasser, Micali, and Rivest [[191](bibliography001.xhtml#endnote_191)]
    present a digital-signature scheme for which every conceivable type of forgery
    is provably as difficult as factoring. Katz and Lindell [[253](bibliography001.xhtml#endnote_253)]
    provide an overview of modern cryptography.
  id: totrans-794
  prefs: []
  type: TYPE_NORMAL
  zh: 公钥密码系统的概念归功于Diffie和Hellman[[115](bibliography001.xhtml#endnote_115)]。RSA密码系统是由Rivest、Shamir和Adleman于1977年提出的[[380](bibliography001.xhtml#endnote_380)]。从那时起，密码学领域蓬勃发展。我们对RSA密码系统的理解加深了，现代实现使用了本文介绍的基本技术的重要改进。此外，为了证明密码系统的安全性，许多新技术已经被开发出来。例如，Goldwasser和Micali[[190](bibliography001.xhtml#endnote_190)]表明随机化可以成为设计安全公钥加密方案的有效工具。对于签名方案，Goldwasser、Micali和Rivest[[191](bibliography001.xhtml#endnote_191)]提出了一个数字签名方案，其中每种可能的伪造都被证明与因子分解一样困难。Katz和Lindell[[253](bibliography001.xhtml#endnote_253)]概述了现代密码学。
- en: The best algorithms for factoring large numbers have a running time that grows
    roughly exponentially with the cube root of the length of the number *n* to be
    factored. The general number-field sieve factoring algorithm (as developed by
    Buhler, Lenstra, and Pomerance [[77](bibliography001.xhtml#endnote_77)] as an
    extension of the ideas in the number-field sieve factoring algorithm by Pollard
    [[360](bibliography001.xhtml#endnote_360)] and Lenstra et al. [[295](bibliography001.xhtml#endnote_295)]
    and refined by Coppersmith [[102](bibliography001.xhtml#endnote_102)] and others)
    is perhaps the most efficient such algorithm in general for large inputs. Although
    it is difficult to give a rigorous analysis of this algorithm, under reasonable
    assumptions we can derive a running-time estimate of *L*(1/3, *n*)^(1.902+*o*(1)),
    where ![art](images/Art_P1286.jpg).
  id: totrans-795
  prefs: []
  type: TYPE_NORMAL
  zh: 用于分解大数的最佳算法的运行时间大致呈指数增长，与待分解数*n*的长度的立方根成正比。一般数域筛法分解算法（由Buhler、Lenstra和Pomerance[[77](bibliography001.xhtml#endnote_77)]作为Pollard[[360](bibliography001.xhtml#endnote_360)]和Lenstra等人[[295](bibliography001.xhtml#endnote_295)]的数域筛法分解算法思想的延伸，并由Coppersmith[[102](bibliography001.xhtml#endnote_102)]等人完善）可能是一般大输入情况下最有效的算法。虽然对于这个算法很难给出严格的分析，但在合理的假设下，我们可以得出一个运行时间估计为*L*(1/3,
    *n*)^(1.902+*o*(1))的结果，其中![art](images/Art_P1286.jpg)。
- en: The elliptic-curve method due to Lenstra [[296](bibliography001.xhtml#endnote_296)]
    may be more effective for some inputs than the number-field sieve method, since
    it can find a small prime factor *p* quite quickly. With this method, the time
    to find *p* is estimated to be ![art](images/Art_P1287.jpg).
  id: totrans-796
  prefs: []
  type: TYPE_NORMAL
  zh: 由Lenstra提出的椭圆曲线方法[[296](bibliography001.xhtml#endnote_296)]对于某些输入可能比数域筛法更有效，因为它可以相当快速地找到一个小素数*p*。使用这种方法，找到*p*的时间估计为![art](images/Art_P1287.jpg)。
