- en: '[**34        NP-Completeness**](toc.xhtml#chap-34)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[**34        NP完全性**](toc.xhtml#chap-34)'
- en: 'Almost all the algorithms we have studied thus far have been ***polynomial-time
    algorithms***: on inputs of size *n*, their worst-case running time is *O*(*n^k*)
    for some constant *k*. You might wonder whether *all* problems can be solved in
    polynomial time. The answer is no. For example, there are problems, such as Turing’s
    famous “Halting Problem,” that cannot be solved by any computer, no matter how
    long you’re willing to wait for an answer.^([1](#footnote_1)) There are also problems
    that can be solved, but not in *O*(*n^k*) time for any constant *k*. Generally,
    we think of problems that are solvable by polynomial-time algorithms as being
    tractable, or “easy,” and problems that require superpolynomial time as being
    intractable, or “hard.”'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们研究的几乎所有算法都是***多项式时间算法***：对于大小为*n*的输入，它们的最坏情况运行时间是*O*(*n^k*)，其中*k*是某个常数。你可能会想知道是否*所有*问题都可以在多项式时间内解决。答案是否定的。例如，有些问题，如图灵著名的“停机问题”，无论你愿意等待多长时间，都无法由任何计算机解决。[^1]
    还有一些问题是可以解决的，但不是在任何常数*k*的*O*(*n^k*)时间内解决的。通常，我们认为可以通过多项式时间算法解决的问题是可处理的，或者“容易”，而需要超多项式时间的问题是不可处理的，或者“困难”。
- en: The subject of this chapter, however, is an interesting class of problems, called
    the “NP-complete” problems, whose status is unknown. No polynomial-time algorithm
    has yet been discovered for an NP-complete problem, nor has anyone yet been able
    to prove that no polynomial-time algorithm can exist for any one of them. This
    so-called P ≠ NP question has been one of the deepest, most perplexing open research
    problems in theoretical computer science since it was first posed in 1971.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，本章的主题是一类有趣的问题，称为“NP完全”问题，其状态未知。尚未发现任何NP完全问题的多项式时间算法，也尚未有人能够证明任何一个NP完全问题不存在多项式时间算法。自1971年首次提出以来，这个所谓的P
    ≠ NP问题一直是理论计算机科学中最深刻、最令人困惑的开放研究问题之一。
- en: 'Several NP-complete problems are particularly tantalizing because they seem
    on the surface to be similar to problems that we know how to solve in polynomial
    time. In each of the following pairs of problems, one is solvable in polynomial
    time and the other is NP-complete, but the difference between the problems appears
    to be slight:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 一些NP完全问题特别令人心动，因为它们表面上似乎与我们知道如何在多项式时间内解决的问题相似。在以下每对问题中，一个可以在多项式时间内解决，另一个是NP完全的，但问题之间的差异似乎很小：
- en: '**Shortest versus longest simple paths:** In [Chapter 22](chapter022.xhtml),
    we saw that even with negative edge weights, we can find *shortest* paths from
    a single source in a directed graph *G* = (*V*, *E*) in *O*(*VE*) time. Finding
    a *longest* simple path between two vertices is difficult, however. Merely determining
    whether a graph contains a simple path with at least a given number of edges is
    NP-complete.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '**最短与最长简单路径：** 在[第22章](chapter022.xhtml)中，我们看到即使有负边权，我们也可以在有向图*G* = (*V*, *E*)中以*O*(*VE*)时间找到从单个源到达��*最短*路径。然而，找到两个顶点之间的*最长*简单路径是困难的。仅仅确定一个图是否包含至少给定数量的边的简单路径是NP完全的。'
- en: '**Euler tour versus hamiltonian cycle:** An ***Euler tour*** of a strongly
    connected, directed graph *G* = (*V*, *E*) is a cycle that traverses each *edge*
    of *G* exactly once, although it is allowed to visit each vertex more than once.
    Problem 20-3 on page 583 asks you to show how to determine whether a strongly
    connected, directed graph has an Euler tour and, if it does, the order of the
    edges in the Euler tour, all in *O*(*E*) time. A ***hamiltonian cycle*** of a
    directed graph *G* = (*V*, *E*) is a simple cycle that contains each *vertex*
    in *V*. Determining whether a directed graph has a hamiltonian cycle is NP-complete.
    (Later in this chapter, we’ll prove that determining whether an *undirected* graph
    has a hamiltonian cycle is NP-complete.)'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**欧拉回路与哈密顿圈：** 强连通的有向图*G* = (*V*, *E*)的一个***欧拉回路***是一个遍历*G*的每条*边*恰好一次的循环，尽管允许多次访问每个顶点。第583页的问题20-3要求您展示如何确定一个强连通的有向图是否有欧拉回路，如果有的话，在*O*(*E*)时间内确定欧拉回路中边的顺序。一个有向图是否有哈密顿圈是NP完全的。（本章后面，我们将证明确定一个*无向*图是否有哈密顿圈也是NP完全的。）'
- en: '**2-CNF satisfiability versus 3-CNF satisfiability:** Boolean formulas contain
    binary variables whose values are 0 or 1; boolean connectives such as ∧ (AND),
    ∨ (OR), and ¬ (NOT); and parentheses. A boolean formula is ***satisfiable*** if
    there exists some assignment of the values 0 and 1 to its variables that causes
    it to evaluate to 1\. We’ll define terms more formally later in this chapter,
    but informally, a boolean formula is in ***k-conjunctive normal form***, or *k*-CNF
    if it is the AND of clauses of ORs of exactly *k* variables or their negations.
    For example, the boolean formula (*x*[1] ∨ *x*[2]) ∧ (¬*x*[1] ∨ *x*[3]) ∧ (¬*x*[2]
    ∨ ¬*x*[3]) is in 2-CNF (with satisfying assignment *x*[1] = 1, *x*[2] = 0, and
    *x*[3] = 1). Although there is a polynomial-time algorithm to determine whether
    a 2-CNF formula is satisfiable, we’ll see later in this chapter that determining
    whether a 3-CNF formula is satisfiable is NP-complete.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**2-CNF可满足性与3-CNF可满足性：** 布尔公式包含二进制变量，其值为0或1；布尔连接词如∧（AND）、∨（OR）和¬（NOT）；以及括号。如果存在某种变量值的赋值使得布尔公式的值为1，则该布尔公式是***可满足的***。我们稍后会更正式地定义这些术语，但非正式地，如果布尔公式是*与范式*，或*k*-CNF，那么它是OR的子句的AND，其中每个子句包含正好*k*个变量或它们的否定。例如，布尔公式（*x*[1]
    ∨ *x*[2]) ∧ (¬*x*[1] ∨ *x*[3]) ∧ (¬*x*[2] ∨ ¬*x*[3]) 是2-CNF（具有满足赋值 *x*[1] = 1，*x*[2]
    = 0 和 *x*[3] = 1）。尽管存在一个多项式时间算法来确定2-CNF公式是否可满足，但我们将在本章后面看到确定3-CNF公式是否可满足是NP完全的。'
- en: '**NP-completeness and the classes P and NP**'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**NP完全性和P和NP类**'
- en: 'Throughout this chapter, we refer to three classes of problems: P, NP, and
    NPC, the latter class being the NP-complete problems. We describe them informally
    here, with formal definitions to appear later on.'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们提到三类问题：P、NP和NPC，后一类是NP完全问题。我们在这里非正式地描述它们，正式定义将在稍后出现。
- en: The class P consists of those problems that are solvable in polynomial time.
    More specifically, they are problems that can be solved in *O*(*n^k*) time for
    some constant *k*, where *n* is the size of the input to the problem. Most of
    the problems examined in previous chapters belong to P.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: P类包括那些可以在多项式时间内解决的问题。更具体地说，它们是可以在*O*(*n^k*)时间内解决的问题，其中*k*是常数，*n*是问题输入的大小。在前几章中研究的大多数问题属于P。
- en: The class NP consists of those problems that are “verifiable” in polynomial
    time. What do we mean by a problem being verifiable? If you were somehow given
    a “certificate” of a solution, then you could verify that the certificate is correct
    in time polynomial in the size of the input to the problem. For example, in the
    hamiltonian-cycle problem, given a directed graph *G* = (*V*, *E*), a certificate
    would be a sequence 〈*v*[1], *v*[2], *v*[3], …, *v*[|*V*|]〉 of |*V*| vertices.
    You could check in polynomial time that the sequence contains each of the |*V*|
    vertices exactly once, that (*v[i]*, *v*[*i*+1]) ∈ *E* for *i* = 1, 2, 3, …, |*V*|
    − 1, and that (*v*[|*V*|], *v*[1]) ∈ *E*. As another example, for 3-CNF satisfiability,
    a certificate could be an assignment of values to variables. You could check in
    polynomial time that this assignment satisfies the boolean formula.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: NP类包括那些可以在多项式时间内“验证”的问题。什么是可验证的问题？如果你以某种方式得到了一个解的“证书”，那么你可以在问题输入的大小的多项式时间内验证这个证书是否正确。例如，在哈密顿回路问题中，给定一个有向图*G*
    = (*V*, *E*)，一个证书将是一个包含|*V*|个顶点的序列〈*v*[1], *v*[2], *v*[3], …, *v*[|*V*|]〉。你可以在多项式时间内检查这个序列是否包含每个顶点恰好一次，对于*i*
    = 1, 2, 3, …, |*V*| − 1，(*v[i]*, *v*[*i*+1]) ∈ *E*，以及(*v*[|*V*|], *v*[1]) ∈ *E*。另一个例子，对于3-CNF可满足性问题，一个证书可以是对变量的值的赋值。你可以在多项式时间内检查这个赋值是否满足布尔公式。
- en: Any problem in P also belongs to NP, since if a problem belongs to P then it
    is solvable in polynomial time without even being supplied a certificate. We’ll
    formalize this notion later in this chapter, but for now you can believe that
    P ⊆ NP. The famous open question is whether P is a proper subset of NP.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: P中的任何问题也属于NP，因为如果一个问题属于P，那么它可以在多项式时间内解决，甚至不需要提供证书。我们将在本章后面正式化这个概念，但现在你可以相信P
    ⊆ NP。著名的未解问题是P是否是NP的真子集。
- en: Informally, a problem belongs to the class NPC—and we call it ***NP-complete***—if
    it belongs to NP and is as “hard” as any problem in NP. We’ll formally define
    what it means to be as hard as any problem in NP later in this chapter. In the
    meantime, we state without proof that if *any* NP-complete problem can be solved
    in polynomial time, then *every* problem in NP has a polynomial-time algorithm.
    Most theoretical computer scientists believe that the NP-complete problems are
    intractable, since given the wide range of NP-complete problems that have been
    studied to date—without anyone having discovered a polynomial-time solution to
    any of them—it would be truly astounding if all of them could be solved in polynomial
    time. Yet, given the effort devoted thus far to proving that NP-complete problems
    are intractable—without a conclusive outcome—we cannot rule out the possibility
    that the NP-complete problems could turn out to be solvable in polynomial time.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 非正式地，一个问题属于NPC类——我们称之为***NP完全***——如果它属于NP并且和NP中的任何问题一样“难”。我们将在本章后面正式定义什么是和NP中的任何问题一样难。与此同时，我们在没有证明的情况下陈述，如果*任何*NP完全问题可以在多项式时间内解决，那么*每个*NP中的问题都有一个多项式时间算法。大多数理论计算机科学家认为NP完全问题是难以解决的，因为鉴于迄今为止研究过的广泛范围的NP完全问题——没有人发现其中任何一个问题的多项式时间解决方案——如果所有这些问题都可以在多项式时间内解决，那将是真正令人惊讶的。然而，鉴于迄今为止致力于证明NP完全问题是难以解决的努力——没有一个确定的结果——我们不能排除NP完全问题最终可能在多项式时间内可解的可能性。
- en: To become a good algorithm designer, you must understand the rudiments of the
    theory of NP-completeness. If you can establish a problem as NP-complete, you
    provide good evidence for its intractability. As an engineer, you would then do
    better to spend your time developing an approximation algorithm (see [Chapter
    35](chapter035.xhtml)) or solving a tractable special case, rather than searching
    for a fast algorithm that solves the problem exactly. Moreover, many natural and
    interesting problems that on the surface seem no harder than sorting, graph searching,
    or network flow are in fact NP-complete. Therefore, you should become familiar
    with this remarkable class of problems.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要成为一个优秀的算法设计师，你必须了解NP完全性理论的基础��识。如果你能证明一个问题是NP完全的，那么你为其难以解决提供了很好的证据。作为一名工程师，你最好花时间开发一个近似算法（参见[第35章](chapter035.xhtml)）或解决一个可处理的特殊情况，而不是寻找一个快速精确解决问题的算法。此外，许多在表面上看起来不比排序、图搜索或网络流更难的自然而有趣的问题实际上是NP完全的。因此，你应该熟悉这个引人注目的问题类。
- en: '**Overview of showing problems to be NP-complete**'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**展示问题为NP完全的概述**'
- en: The techniques used to show that a particular problem is NP-complete differ
    fundamentally from the techniques used throughout most of this book to design
    and analyze algorithms. If you can demonstrate that a problem is NP-complete,
    you are making a statement about how hard it is (or at least how hard we think
    it is), rather than about how easy it is. If you prove a problem NP-complete,
    you are saying that searching for efficient algorithm is likely to be a fruitless
    endeavor. In this way, NP-completeness proofs bear some similarity to the proof
    in [Section 8.1](chapter008.xhtml#Sec_8.1) of an Ω(*n* lg *n*)-time lower bound
    for any comparison sort algorithm, although the specific techniques used for showing
    NP-completeness differ from the decision-tree method used in [Section 8.1](chapter008.xhtml#Sec_8.1).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 用于证明特定问题是NP完全的技术与本书大部分内容中用于设计和分析算法的技术有根本的区别。如果你能证明一个问题是NP完全的，那么你在说这个问题有多难（或者至少我们认为它有多难），而不是有多容易。如果你证明一个问题是NP完全的，那么你在说寻找高效算法很可能是徒劳的。从这个角度看，NP完全性证明与[第8.1节](chapter008.xhtml#Sec_8.1)中对于任何比较排序算法的Ω(*n*
    lg *n*)时间下界的证明有些相似，尽管用于展示NP完全性的具体技术与第8.1节中使用的决策树方法不同。
- en: 'We rely on three key concepts in showing a problem to be NP-complete:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在展示一个问题为NP完全时，我们依赖于三个关键概念：
- en: '***Decision problems versus optimization problems***'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '***决策问题与优化问题***'
- en: Many problems of interest are ***optimization problems***, in which each feasible
    (i.e., “legal”) solution has an associated value, and the goal is to find a feasible
    solution with the best value. For example, in a problem that we call SHORTEST-PATH,
    the input is an undirected graph *G* and vertices *u* and *v*, and the goal is
    to find a path from *u* to *v* that uses the fewest edges. In other words, SHORTEST-PATH
    is the single-pair shortest-path problem in an unweighted, undirected graph. NP-completeness
    applies directly not to optimization problems, however, but to ***decision problems***,
    in which the answer is simply “yes” or “no” (or, more formally, “1” or “0”).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 许多感兴趣的问题是***优化问题***，在这些问题中，每个可行（即“合法”）解都有一个相关值，目标是找到一个具有最佳值的可行解。例如，在一个我们称之为SHORTEST-PATH的问题中，输入是一个无向图*G*和顶点*u*和*v*，目标是找到从*u*到*v*的路径，使用最少的边。换句话说，SHORTEST-PATH是无权无向图中的单对最短路径问题。然而，NP完全性直接适用于***决策问题***，其中答案只是“是”或“否”（或更正式地说，“1”或“0”）。
- en: 'Although NP-complete problems are confined to the realm of decision problems,
    there is usually a way to cast a given optimization problem as a related decision
    problem by imposing a bound on the value to be optimized. For example, a decision
    problem related to SHORTEST-PATH is PATH: given an undirected graph *G*, vertices
    *u* and *v*, and an integer *k*, does a path exist from *u* to *v* consisting
    of at most *k* edges?'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管NP完全问题局限于决策问题领域，通常可以通过对要优化的值施加限制，将给定的优化问题转化为相关的决策问题。例如，与SHORTEST-PATH相关的一个决策问题是PATH：给定一个无向图*G*，顶点*u*和*v*，以及一个整数*k*，是否存在一条从*u*到*v*的路径，由最多*k*条边组成？
- en: The relationship between an optimization problem and its related decision problem
    works in your favor when you try to show that the optimization problem is “hard.”
    That is because the decision problem is in a sense “easier,” or at least “no harder.”
    As a specific example, you can solve PATH by solving SHORTEST-PATH and then comparing
    the number of edges in the shortest path found to the value of the decision-problem
    parameter *k*. In other words, if an optimization problem is easy, its related
    decision problem is easy as well. Stated in a way that has more relevance to NP-completeness,
    if you can provide evidence that a decision problem is hard, you also provide
    evidence that its related optimization problem is hard. Thus, even though it restricts
    attention to decision problems, the theory of NP-completeness often has implications
    for optimization problems as well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当你试图展示一个优化问题“困难”时，优化问题与其相关的决策问题之间的关系对你有利。这是因为决策问题在某种意义上“更容易”，或者至少“不更困难”。举个具体的例子，你可以通过解决SHORTEST-PATH来解决PATH，然后比较找到的最短路径中的边数与决策问题参数*k*的值。换句话说，如果一个优化问题很容易，那么与之相关的决策问题也很容易。以更与NP完全性相关的方式陈述，如果你能提供一个决策问题很困难的证据，那么你也提供了其相关优化问题很困难的证据。因此，即使它将注意力限制在决策问题��，NP完全性理论通常也对优化问题有影响。
- en: '***Reductions***'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '***归约***'
- en: 'The above notion of showing that one problem is no harder or no easier than
    another applies even when both problems are decision problems. Almost every NP-completeness
    proof takes advantage of this idea, as follows. Consider a decision problem *A*,
    which you would like to solve in polynomial time. We call the input to a particular
    problem an ***instance*** of that problem. For example, in PATH, an instance is
    a particular graph *G*, particular vertices *u* and *v* of *G*, and a particular
    integer *k*. Now suppose that you already know how to solve a different decision
    problem *B* in polynomial time. Finally, suppose that you have a procedure that
    transforms any instance *α* of *A* into some instance *β* of *B* with the following
    characteristics:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 即使两个问题都是决策问题，展示一个问题不比另一个更难或更容易的上述概念也适用。几乎每个NP完全性证明都利用了这个想法，如下所示。考虑一个你想在多项式时间内解决的决策问题*A*。我们称特定问题的输入为该问题的一个***实例***。例如，在PATH中，一个实例是一个特定的图*G*，图*G*的特定顶点*u*和*v*，以及一个特定的整数*k*。现在假设你已经知道如何在多项式时间内解决另一个决策问题*B*。最后，假设你有一个过程，可以将问题*A*的任何实例*α*转换为问题*B*的某个实例*β*，具有以下特征：
- en: '![art](images/Art_P1430.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1430.jpg)'
- en: '**Figure 34.1** How to use a polynomial-time reduction algorithm to solve a
    decision problem *A* in polynomial time, given a polynomial-time decision algorithm
    for another problem *B*. In polynomial time, transform an instance *α* of *A*
    into an instance *β* of *B*, solve *B* in polynomial time, and use the answer
    for *β* as the answer for *α*.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**图34.1** 如何使用多项式时间归约算法在多项式时间内解决决策问题*A*，假设已经有了另一个问题*B*的多项式时间决策算法。在多项式时间内，将问题*A*的实例*α*转换为问题*B*的实例*β*，在多项式时间内解决问题*B*，并将*β*的答案作为*α*的答案。'
- en: The transformation takes polynomial time.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转换需要多项式时间。
- en: The answers are the same. That is, the answer for *α* is “yes” if and only if
    the answer for *β* is also “yes.”
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 答案是相同的。也就是说，如果*β*的答案是“是”，那么*α*的答案也是“是”。
- en: 'We call such a procedure a polynomial-time ***reduction algorithm*** and, as
    [Figure 34.1](chapter034.xhtml#Fig_34-1) shows, it provides us a way to solve
    problem *A* in polynomial time:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们称这样的过程为多项式时间***归约算法***，正如[图34.1](chapter034.xhtml#Fig_34-1)所示，它为我们提供了一种在多项式时间内解决问题*A*的方法：
- en: Given an instance *α* of problem *A*, use a polynomial-time reduction algorithm
    to transform it to an instance *β* of problem *B*.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给定问题*A*的一个实例*α*，使用多项式时间归约算法将其转换为问题*B*的一个实例*β*。
- en: Run the polynomial-time decision algorithm for *B* on the instance *β*.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行问题*B*的多项式时间决策算法在实例*β*上。
- en: Use the answer for *β* as the answer for *α*.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将*β*的答案作为*α*的答案。
- en: As long as each of these steps takes polynomial time, all three together do
    also, and so you have a way to decide on *α* in polynomial time. In other words,
    by “reducing” solving problem *A* to solving problem *B*, you use the “easiness”
    of *B* to prove the “easiness” of *A*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 只要这些步骤都需要多项式时间，三者一起也是，因此你有一种方法在多项式时间内决定*α*。换句话说，通过将解决问题*A*简化为解决问题*B*，你利用*B*的“易解性”来证明*A*的“易解性”。
- en: Recalling that NP-completeness is about showing how hard a problem is rather
    than how easy it is, you use polynomial-time reductions in the opposite way to
    show that a problem is NP-complete. Let’s take the idea a step further and show
    how you can use polynomial-time reductions to show that no polynomial-time algorithm
    can exist for a particular problem *B*. Suppose that you have a decision problem
    *A* for which you already know that no polynomial-time algorithm can exist. (Ignore
    for the moment how to find such a problem *A*.) Suppose further that you have
    a polynomial-time reduction transforming instances of *A* to instances of *B*.
    Now you can use a simple proof by contradiction to show that no polynomial-time
    algorithm can exist for *B*. Suppose otherwise, that is, suppose that *B* has
    a polynomial-time algorithm. Then, using the method shown in [Figure 34.1](chapter034.xhtml#Fig_34-1),
    you would have a way to solve problem *A* in polynomial time, which contradicts
    the assumption that there is no polynomial-time algorithm for *A*.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，NP完全性是关于展示问题有多难而不是有多容易，你可以使用多项式时间简化来展示一个问题是NP完全的。让我们进一步展示如何使用多项式时间简化来证明某个问题*B*不存在多项式时间算法。假设你有一个决策问题*A*，你已经知道没有多项式时间算法可以解决它。（暂时忽略如何找到这样的问题*A*。）进一步假设你有一个多项式时间简化，将问题*A*的实例转换为问题*B*的实例。现在你可以使用简单的反证法来证明问题*B*不存在多项式时间算法。假设相反，也就是说，假设问题*B*有一个多项式时间算法。然后，使用[图34.1](chapter034.xhtml#Fig_34-1)中显示的方法，你将有一种方法在多项式时间内解决问题*A*，这与假设问题*A*没有多项式时间算法的假设相矛盾。
- en: To prove that a problem *B* is NP-complete, the methodology is similar. Although
    you cannot assume that there is absolutely no polynomial-time algorithm for problem
    *A*, you prove that problem *B* is NP-complete on the assumption that problem
    *A* is also NP-complete.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要证明问题*B*是NP完全的，方法类似。虽然你不能假设问题*A*绝对没有多项式时间算法，但你证明问题*B*是NP完全的，假设问题*A*也是NP完全的。
- en: '***A first NP-complete problem***'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '***第一个NP完全问题***'
- en: Because the technique of reduction relies on having a problem already known
    to be NP-complete in order to prove a different problem NP-complete, there must
    be some “first” NP-complete problem. We’ll use the circuit-satisfiability problem,
    in which the input is a boolean combinational circuit composed of AND, OR, and
    NOT gates, and the question is whether there exists some set of boolean inputs
    to this circuit that causes its output to be 1\. [Section 34.3](chapter034.xhtml#Sec_34.3)
    will prove that this first problem is NP-complete.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 因为简化技术依赖于已知为NP完全的问题来证明不同问题为NP完全，必须有一些“第一个”NP完全问题。我们将使用电路可满足性问题，其中输入是由AND、OR和NOT门组成的布尔组合电路，问题是是否存在一些布尔输入使得其输出为1。[第34.3节](chapter034.xhtml#Sec_34.3)将证明这个第一个问题是NP完全的。
- en: '**Chapter outline**'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节大纲**'
- en: This chapter studies the aspects of NP-completeness that bear most directly
    on the analysis of algorithms. [Section 34.1](chapter034.xhtml#Sec_34.1) formalizes
    the notion of “problem” and defines the complexity class P of polynomial-time
    solvable decision problems. We’ll also see how these notions fit into the framework
    of formal-language theory. [Section 34.2](chapter034.xhtml#Sec_34.2) defines the
    class NP of decision problems whose solutions are verifiable in polynomial time.
    It also formally poses the P ≠ NP question.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 本章研究了与算法分析最直接相关的NP完全性方面。[第34.1节](chapter034.xhtml#Sec_34.1)将“问题”的概念形式化，并定义了多项式时间可解决决策问题的复杂类P。我们还将看到这些概念如何适用于形式语言理论的框架。[第34.2节](chapter034.xhtml#Sec_34.2)定义了决策问题的复杂类NP，其解可以在多项式时间内验证。它还正式提出了P
    ≠ NP问题。
- en: '[Section 34.3](chapter034.xhtml#Sec_34.3) shows how to relate problems via
    polynomial-time “reductions.” It defines NP-completeness and sketches a proof
    that the circuit-satisfiability problem is NP-complete. With one problem proven
    NP-complete, [Section 34.4](chapter034.xhtml#Sec_34.4) demonstrates how to prove
    other problems to be NP-complete much more simply by the methodology of reductions.
    To illustrate this methodology, the section shows that two formula-satisfiability
    problems are NP-complete. [Section 34.5](chapter034.xhtml#Sec_34.5) proves a variety
    of other problems to be NP-complete by using reductions. You will probably find
    several of these reductions to be quite creative, because they convert a problem
    in one domain to a problem in a completely different domain.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '[第34.3节](chapter034.xhtml#Sec_34.3)展示了如何通过多项式时间“简化”来关联问题。它定义了NP完全性并勾勒了电路可满足性问题是NP完全的证明。通过证明一个问题是NP完全，[第34.4节](chapter034.xhtml#Sec_34.4)演示了如何通过简化的方法更简单地证明其他问题是NP完全的。为了说明这种方法，该部分展示了两个公式可满足性问题是NP完全的。[第34.5节](chapter034.xhtml#Sec_34.5)通过简化证明了其他各种问题是NP完全的。你可能会发现其中几个简化方法非常有创意，因为它们将一个领域中的问题转换为完全不同领域中的��题。'
- en: '[**34.1    Polynomial time**](toc.xhtml#Rh1-199)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '[**34.1    多项式时间**](toc.xhtml#Rh1-199)'
- en: Since NP-completeness relies on notions of solving a problem and verifying a
    certificate in polynomial time, let’s first examine what it means for a problem
    to be solvable in polynomial time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于NP完全性依赖于在多项式时间内解决问题和验证证书的概念，让我们首先看看问题在多项式时间内可解的含义。
- en: 'Recall that we generally regard problems that have polynomial-time solutions
    as tractable. Here are three reasons why:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，我们通常认为有多项式时间解的问题是可处理的。以下是三个原因：
- en: Although no reasonable person considers a problem that requires Θ(*n*^(100))
    time to be tractable, few practical problems require time on the order of such
    a high-degree polynomial. The polynomial-time computable problems encountered
    in practice typically require much less time. Experience has shown that once the
    first polynomial-time algorithm for a problem has been discovered, more efficient
    algorithms often follow. Even if the current best algorithm for a problem has
    a running time of Θ(*n*^(100)), an algorithm with a much better running time will
    likely soon be discovered.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管没有一个理智的人认为需要 Θ(*n*^(100)) 时间的问题是可处理的，但很少有实际问题需要这么高次多项式阶的时间。实践中遇到的多项式时间可计算问题通常需要更少的时间。经验表明，一旦为一个问题发现了第一个多项式时间算法，通常会随之出现更高效的算法。即使当前最佳算法的运行时间为
    Θ(*n*^(100))，很可能很快就会发现一个运行时间更好的算法。
- en: For many reasonable models of computation, a problem that can be solved in polynomial
    time in one model can be solved in polynomial time in another. For example, the
    class of problems solvable in polynomial time by the serial random-access machine
    used throughout most of this book is the same as the class of problems solvable
    in polynomial time on abstract Turing machines.^([2](#footnote_2)) It is also
    the same as the class of problems solvable in polynomial time on a parallel computer
    when the number of processors grows polynomially with the input size.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于许多合理的计算模型，一个在其中一个模型中可以在多项式时间内解决的问题，在另一个模型中也可以在多项式时间内解决。例如，本书中大部分使用的串行随机访问机器可以在多项式时间内解决的问题类与在抽象图灵机上可以在多项式时间内解决的问题类是相同的。[^2](#footnote_2)
    当处理器数量随着输入规模多项式增长时，这也与在并行计算机上可以在多项式时间内解决的问题类相同。
- en: The class of polynomial-time solvable problems has nice closure properties,
    since polynomials are closed under addition, multiplication, and composition.
    For example, if the output of one polynomial-time algorithm is fed into the input
    of another, the composite algorithm is polynomial. Exercise 34.1-5 asks you to
    show that if an algorithm makes a constant number of calls to polynomial-time
    subroutines and performs an additional amount of work that also takes polynomial
    time, then the running time of the composite algorithm is polynomial.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以在多项式时间内解决的问题类具有良好的封闭性质，因为多项式在加法、乘法和复合下是封闭的。例如，如果一个多项式时间算法的输出被馈送到另一个算法的输入中，那么组合算法是多项式的。练习
    34.1-5 要求你证明，如果一个算法对多项式时间子程序作出恒定次数的调用，并且执行额外的同样需要多项式时间的工作，那么组合算法的运行时间是多项式的。
- en: '**Abstract problems**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象问题**'
- en: To understand the class of polynomial-time solvable problems, you must first
    have a formal notion of what a “problem” is. We define an ***abstract problem*** *Q*
    to be a binary relation on a set *I* of problem ***instances*** and a set *S*
    of problem ***solutions***. For example, an instance for SHORTEST-PATH is a triple
    consisting of a graph and two vertices. A solution is a sequence of vertices in
    the graph, with perhaps the empty sequence denoting that no path exists. The problem
    SHORTEST-PATH itself is the relation that associates each instance of a graph
    and two vertices with a shortest path in the graph that connects the two vertices.
    Since shortest paths are not necessarily unique, a given problem instance may
    have more than one solution.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解可以在多项式时间内解决的问题类，首先必须对“问题”有一个正式的概念。我们将一个***抽象问题*** *Q* 定义为问题***实例***集合 *I*
    和问题***解决方案***集合 *S* 上的二元关系。例如，SHORTEST-PATH 的一个实例是由图和两个顶点组成的三元组。解决方案是图中的顶点序列，可能为空序列表示不存在路径。SHORTEST-PATH
    问题本身是将图的每个实例和两个顶点与连接这两个顶点的图中最短路径相关联的关系。由于最短路径不一定是唯一的，一个给定的问题实例可能有多个解决方案。
- en: 'This formulation of an abstract problem is more general than necessary for
    our purposes. As we saw above, the theory of NP-completeness restricts attention
    to ***decision problems***: those having a yes/no solution. In this case, we can
    view an abstract decision problem as a function that maps the instance set *I*
    to the solution set {0, 1}. For example, a decision problem related to SHORTEST-PATH
    is the problem PATH that we saw earlier. If *i* = 〈*G, u, v, k*〉 is an instance
    of PATH, then PATH(*i*) = 1 (yes) if *G* contains a path from *u* to *v* with
    at most *k* edges, and PATH(*i*) = 0 (no) otherwise. Many abstract problems are
    not decision problems, but rather ***optimization problems***, which require some
    value to be minimized or maximized. As we saw above, however, you can usually
    recast an optimization problem as a decision problem that is no harder.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这种抽象问题的表述比我们的目的更一般。正如我们上面看到的，NP-完全性理论将注意力集中在***决策问题***上：那些有是/否解的问题。在这种情况下，我们可以将一个抽象决策问题视为将实例集合
    *I* 映射到解集合 {0, 1} 的函数。例如，与 SHORTEST-PATH 相关的一个决策问题是我们之前看到的 PATH 问题。如果 *i* = 〈*G,
    u, v, k*〉 是 PATH 的一个实例，那么 PATH(*i*) = 1（是）如果 *G* 包含从 *u* 到 *v* 的路径，最多有 *k* 条边，否则为
    0（否）。许多抽象问题不是决策问题，而是***优化问题***，需要最小化或最大化某个值。然而，正如我们上面看到的，通常可以将一个优化问题重新表述为一个不更难的决策问题。
- en: '**Encodings**'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码**'
- en: In order for a computer program to solve an abstract problem, its problem instances
    must appear in a way that the program understands. An ***encoding*** of a set
    *S* of abstract objects is a mapping *e* from *S* to the set of binary strings.^([3](#footnote_3))
    For example, we are all familiar with encoding the natural numbers ℕ = {0, 1,
    2, 3, 4,…} as the strings {0, 1, 10, 11, 100,…}. Using this encoding, *e*(17)
    = 10001\. If you have looked at computer representations of keyboard characters,
    you probably have seen the ASCII code, where, for example, the encoding of A is
    01000001\. You can encode a compound object as a binary string by combining the
    representations of its constituent parts. Polygons, graphs, functions, ordered
    pairs, programs—all can be encoded as binary strings.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使计算机程序解决抽象问题，其问题实例必须以程序理解的方式出现。抽象对象集合*S*的***编码***是从*S*到二进制字符串集合的映射*e*。^([3](#footnote_3))
    例如，我们都熟悉将自然数ℕ = {0, 1, 2, 3, 4,…}编码为字符串{0, 1, 10, 11, 100,…}。使用这种编码，*e*(17) =
    10001。如果你看过键盘字符的计算机表示，你可能见过ASCII码，例如，A的编码是01000001。你可以通过组合其组成部分的表示来将复合对象编码为二进制字符串。多���形、图形、函数、有序对、程序——都可以编码为二进制字符串。
- en: Thus, a computer algorithm that “solves” some abstract decision problem actually
    takes an encoding of a problem instance as input. The ***size*** of an instance
    *i* is just the length of its string, which we denote by |*i*|. We call a problem
    whose instance set is the set of binary strings a ***concrete problem***. We say
    that an algorithm ***solves*** a concrete problem in *O*(*T* (*n*)) time if, when
    it is provided a problem instance *i* of length *n* = |*i*|, the algorithm can
    produce the solution in *O*(*T* (*n*)) time.^([4](#footnote_4)) A concrete problem
    is ***polynomial-time solvable***, therefore, if there exists an algorithm to
    solve it in *O*(*n^k*) time for some constant *k*.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个“解决”某个抽象决策问题的计算机算法实际上将问题实例的编码作为输入。实例*i*的***大小***只是其字符串的长度，我们用|*i*|表示。我们称其实例集为二进制字符串集的问题为***具体问题***。如果算法在*O*(*T*(*n*))时间内解决了具体问题，那么当它提供长度为*n*
    = |*i*|的问题实例*i*时，算法可以在*O*(*T*(*n*))时间内产生解。^([4](#footnote_4)) 因此，如果存在一个算法可以在*O*(*n^k*)时间内解决具体问题，那么该问题是***多项式时间可解***的。
- en: We can now formally define the ***complexity class* P** as the set of concrete
    decision problems that are polynomial-time solvable.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以正式定义***P复杂性类***为多项式时间可解的具体决策问题集合。
- en: 'Encodings map abstract problems to concrete problems. Given an abstract decision
    problem *Q* mapping an instance set *I* to {0, 1}, an encoding *e* : *I* → {0,
    1}^* can induce a related concrete decision problem, which we denote by *e*(*Q*).^([5](#footnote_5))
    If the solution to an abstract-problem instance *i* ∈ *I* is *Q*(*i*) ∈ {0, 1},
    then the solution to the concrete-problem instance *e*(*i*) ∈ {0, 1}^* is also
    *Q*(*i*). As a technicality, some binary strings might represent no meaningful
    abstract-problem instance. For convenience, assume that any such string maps arbitrarily
    to 0\. Thus, the concrete problem produces the same solutions as the abstract
    problem on binary-string instances that represent the encodings of abstract-problem
    instances.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 编码将抽象问题映射到具体问题。给定一个将实例集*I*映射到{0, 1}的抽象决策问题*Q*，一个编码*e*：*I* → {0, 1}^*可以引出一个相关的具体决策问题，我们将其表示为*e*(*Q*)。^([5](#footnote_5))
    如果抽象问题实例*i* ∈ *I*的解是*Q*(*i*) ∈ {0, 1}，那么具体问题实例*e*(*i*) ∈ {0, 1}^*的解也是*Q*(*i*)。作为一个技术细节，一些二进制字符串可能不代表任何有意义的抽象问题实例。为方便起见，假设任何这样的字符串都随机映射到0。因此，具体问题在表示抽象问题实例的二进制字符串上产生与抽象问题相同的解。
- en: We would like to extend the definition of polynomial-time solvability from concrete
    problems to abstract problems by using encodings as the bridge, ideally with the
    definition independent of any particular encoding. That is, the efficiency of
    solving a problem should not depend on how the problem is encoded. Unfortunately,
    it depends quite heavily on the encoding. For example, suppose that the sole input
    to an algorithm is an integer *k*, and suppose that the running time of the algorithm
    is Θ(*k*). If the integer *k* is provided in ***unary***—a string of *k* 1s—then
    the running time of the algorithm is *O*(*n*) on length-*n* inputs, which is polynomial
    time. If the input *k* is provided using the more natural binary representation,
    however, then the input length is *n* = ⌊lg *k*⌋ + 1, so the size of the unary
    encoding is exponential in the size of the binary encoding. With the binary representation,
    the running time of the algorithm is Θ(*k*) = Θ(2^(*n*)), which is exponential
    in the size of the input. Thus, depending on the encoding, the algorithm runs
    in either polynomial or superpolynomial time.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望通过使用编码作为桥梁，将多项式时间可解性的定义从具体问题扩展到抽象问题，理想情况下，定义不依赖于任何特定编码。也就是说，解决问题的效率不应取决于问题如何编码。不幸的是，它在很大程度上取决于编码。例如，假设算法的唯一输入是一个整数*k*，并且假设算法的运行时间是Θ(*k*)。如果整数*k*以***一元***形式提供——一个*k*个1组成的字符串——那么算法在长度为*n*的输入上的运行时间是*O*(*n*)，即多项式时间。然而，如果使用更自然的二进制表示提供输入*k*，那么输入长度为*n*
    = ⌊lg *k*⌋ + 1，因此一元编码的大小在二进制编码的大小上呈指数增长。使用二进制表示，算法的运行时间是Θ(*k*) = Θ(2^(*n*))，即与输入大小呈指数关系。因此，根据编码的不同，算法运行在多项式或超多项式时间内。
- en: The encoding of an abstract problem matters quite a bit to how we understand
    polynomial time. We cannot really talk about solving an abstract problem without
    first specifying an encoding. Nevertheless, in practice, if we rule out “expensive”
    encodings such as unary ones, the actual encoding of a problem makes little difference
    to whether the problem can be solved in polynomial time. For example, representing
    integers in base 3 instead of binary has no effect on whether a problem is solvable
    in polynomial time, since we can convert an integer represented in base 3 to an
    integer represented in base 2 in polynomial time.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们理解多项式时间的抽象问题，抽象问题的编码方式非常重要。在没有首先指定编码的情况下，我们实际上无法谈论解决抽象问题。然而，在实践中，如果我们排除“昂贵”的编码，比如一元编码，那么问题的实际编码对于问题是否可以在多项式时间内解决几乎没有影响。例如，将整数表示为3进制而不是二进制对于问题是否可以在多项式时间内解决没有影响，因为我们可以将以3进制表示的整数转换为以2进制表示的整数，而这可以在多项式时间内完成。
- en: 'We say that a function *f* : {0, 1}^* → {0, 1}^* is ***polynomial-time computable***
    if there exists a polynomial-time algorithm *A* that, given any input *x* ∈ {0,
    1}^*, produces as output *f* (*x*). For some set *I* of problem instances, we
    say that two encodings *e*[1] and *e*[2] are ***polynomially related*** if there
    exist two polynomial-time computable functions *f*[12] and *f*[21] such that for
    any *i* ∈ *I*, we have *f*[12](*e*[1](*i*)) = *e*[2](*i*) and *f*[21](*e*[2](*i*))
    = *e*[1](*i*).^([6](#footnote_6)) That is, a polynomial-time algorithm can compute
    the encoding *e*[2](*i*) from the encoding *e*[1](*i*), and vice versa. If two
    encodings *e*[1] and *e*[2] of an abstract problem are polynomially related, whether
    the problem is polynomial-time solvable or not is independent of which encoding
    we use, as the following lemma shows.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说一个函数*f*：{0, 1}^* → {0, 1}^*是***多项式时间可计算的***，如果存在一个多项式时间算法*A*，对于任何输入*x* ∈
    {0, 1}^*，产生*f*(*x*)作为输出。对于问题实例集合*I*，我们说两个编码*e*[1]和*e*[2]是***多项式相关的***，如果存在两个多项式时间可计算的函数*f*[12]和*f*[21]，对于任何*i*
    ∈ *I*，我们有*f*[12](*e*[1](*i*)) = *e*[2](*i*)和*f*[21](*e*[2](*i*)) = *e*[1](*i*)。也就是说，多项式时间算法可以从编码*e*[1](*i*)计算出编码*e*[2](*i*)，反之亦然。如果一个抽象问题的两个编码*e*[1]和*e*[2]*是多项式相关的，那么问题是否可以在多项式时间内解决与我们使用哪种编码无关，正如以下引理所示。
- en: '***Lemma 34.1***'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 34.1***'
- en: Let *Q* be an abstract decision problem on an instance set *I*, and let *e*[1]
    and *e*[2] be polynomially related encodings on *I*. Then, *e*[1](*Q*) ∈ P if
    and only if *e*[2](*Q*) ∈ P.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 设*Q*是一个抽象决策问题，其实例集合为*I*，*e*[1]和*e*[2]是*I*上多项式相关的编码。那么，如果*e*[1](*Q*) ∈ P，则*e*[2](*Q*)
    ∈ P。
- en: '***Proof***   We need only prove the forward direction, since the backward
    direction is symmetric. Suppose, therefore, that *e*[1](*Q*) can be solved in
    *O*(*n^k*) time for some constant *k*. Furthermore, suppose that for any problem
    instance *i*, the encoding *e*[1](*i*) can be computed from the encoding *e*[2](*i*)
    in *O*(*n^c*) time for some constant *c*, where *n* = |*e*[2](*i*)|. To solve
    problem *e*[2](*Q*) on input *e*[2](*i*), first compute *e*[1](*i*) and then run
    the algorithm for *e*[1](*Q*) on *e*[1](*i*). How long does this procedure take?
    Converting encodings takes *O*(*n^c*) time, and therefore |*e*[1](*i*)| = *O*(*n^c*),
    since the output of a serial computer cannot be longer than its running time.
    Solving the problem on *e*[1](*i*) takes *O*(|*e*[1](*i*)|^(*k*)) = *O*(*n^(ck)*)
    time, which is polynomial since both *c* and *k* are constants.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   我们只需要证明正向方向，因为反向方向是对称的。因此，假设*e*[1](*Q*)可以在*O*(*n^k*)时间内解决某个常数*k*。此���，假设对于任何问题实例*i*，编码*e*[1](*i*)可以在*O*(*n^c*)时间内从编码*e*[2](*i*)计算出来，其中*n*
    = |*e*[2](*i*)|。要在*e*[2](*i*)上解决问题*e*[2](*Q*)，首先计算*e*[1](*i*)，然后在*e*[1](*i*)上运行*e*[1](*Q*)的算法。这个过程需要多长时间？转换编码需要*O*(*n^c*)时间，因此|*e*[1](*i*)|
    = *O*(*n^c*)，因为串行计算机的输出长度不能超过其运行时间。在*e*[1](*i*)上解决问题需要*O*(|*e*[1](*i*)|^(*k*))
    = *O*(*n^(ck)*)时间，由于*c*和*k*都是常数，所以这是多项式的。'
- en: ▪
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Thus, whether an abstract problem has its instances encoded in binary or base
    3 does not affect its “complexity,” that is, whether it is polynomial-time solvable
    or not. If instances are encoded in unary, however, its complexity may change.
    In order to be able to converse in an encoding-independent fashion, we generally
    assume that problem instances are encoded in any reasonable, concise fashion,
    unless we specifically say otherwise. To be precise, we assume that the encoding
    of an integer is polynomially related to its binary representation, and that the
    encoding of a finite set is polynomially related to its encoding as a list of
    its elements, enclosed in braces and separated by commas. (ASCII is one such encoding
    scheme.) With such a “standard” encoding in hand, we can derive reasonable encodings
    of other mathematical objects, such as tuples, graphs, and formulas. To denote
    the standard encoding of an object, we enclose the object in angle brackets. Thus,
    〈*G*〉 denotes the standard encoding of a graph *G*.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，一个抽象问题的实例是以二进制还是3进制编码并不影响其“复杂性”，即它是否可以在多项式时间内解决。然而，如果实例是以一元编码的方式编码，那么其复杂性可能会发生变化。为了能够以与编码无关的方式进行交流，我们通常假设问题实例以任何合理、简洁的方式进行编码，除非我们明确说明。准确地说，我们假设整数的编码与其二进制表示多项式相关联，并且有限集的编码与其作为元素列表（用大括号括起来，用逗号分隔）的编码多项式相关联。（ASCII是一种这样的编码方案。）有了这样一个“标准”编码，我们可以推导出其他数学对象的合理编码，比如元组、图和公式。为了表示对象的标准编码，我们用尖括号括起对象。因此，〈*G*〉表示图*G*的标准编码。
- en: As long as the encoding implicitly used is polynomially related to this standard
    encoding, we can talk directly about abstract problems without reference to any
    particular encoding, knowing that the choice of encoding has no effect on whether
    the abstract problem is polynomial-time solvable. From now on, we will generally
    assume that all problem instances are binary strings encoded using the standard
    encoding, unless we explicitly specify the contrary. We’ll also typically neglect
    the distinction between abstract and concrete problems. You should watch out for
    problems that arise in practice, however, in which a standard encoding is not
    obvious and the encoding does make a difference.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 只要所使用的编码与标准编码多项式相关，我们可以直接讨论抽象问题，而不需要参考任何特定编码，知道编码的选择不会影响抽象问题是否可以在多项式时间内解决。从现在开始，我们通常假设所有问题实例都是使用标准编码编码的二进制字符串，除非我们明确指定相反。我们也通常忽略抽象和具体问题之间的区别。然而，你应该注意到在实践中可能出现的问题，其中标准编码不明显，编码确实会产生影响。
- en: '**A formal-language framework**'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '**一个形式语言框架**'
- en: By focusing on decision problems, we can take advantage of the machinery of
    formal-language theory. Let’s review some definitions from that theory. An ***alphabet***
    Σ is a finite set of symbols. A ***language*** *L* over Σ is any set of strings
    made up of symbols from Σ. For example, if Σ = {0, 1}, the set *L* = {10, 11,
    101, 111, 1011, 1101, 10001,…} is the language of binary representations of prime
    numbers. We denote the ***empty string*** by *ε*, the ***empty language*** by
    Ø, and the language of all strings over Σ by Σ*. For example, if Σ = {0, 1}, then
    Σ* = {*ε*, 0, 1, 00, 01, 10, 11, 000,…} is the set of all binary strings. Every
    language *L* over Σ is a subset of Σ*.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 通过专注于决策问题，我们可以利用形式语言理论的机制。让我们回顾一些来自该理论的定义。一个***字母表*** Σ 是一组有限的符号。在Σ上的一个***语言***
    *L* 是由Σ中的符号组成的字符串集合。例如，如果Σ = {0, 1}，那么集合 *L* = {10, 11, 101, 111, 1011, 1101,
    10001,…} 是素数的二进制表示的语言。我们用 *ε* 表示***空字符串***，用Ø表示***空语言***，用Σ*表示Σ上的所有字符串的语言。例如，如果Σ
    = {0, 1}，那么Σ* = {*ε*, 0, 1, 00, 01, 10, 11, 000,…} 是所有二进制字符串的集合。Σ上的每个语言 *L* 都是Σ*的子集。
- en: Languages support a variety of operations. Set-theoretic operations, such as
    ***union*** and ***intersection***, follow directly from the set-theoretic definitions.
    We define the ***complement*** of a language *L* by *L* = Σ* − *L*. The ***concatenation*** *L*[1]*L*[2]
    of two languages *L*[1] and *L*[2] is the language
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 语言支持各种操作。集合论操作，如***并集***和***交集***，直接遵循集合论的定义。我们通过 *L* = Σ* − *L* 定义语言 *L* 的***补集***。两个语言
    *L*[1] 和 *L*[2] 的***连接*** *L*[1]*L*[2] 是语言
- en: '*L* = {*x*[1]*x*[2] : *x*[1] ∈ *L*[1] and *x*[2] ∈ *L*[2]}.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '*L* = {*x*[1]*x*[2] : *x*[1] ∈ *L*[1] and *x*[2] ∈ *L*[2]}.'
- en: The ***closure*** or ***Kleene star*** of a language *L* is the language
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 语言 *L* 的***闭包***或***Kleene星***是语言
- en: '*L** = {*ε*} ∪ *L* ∪ *L*² ∪ *L*³ ∪ …,'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: '*L** = {*ε*} ∪ *L* ∪ *L*² ∪ *L*³ ∪ …,'
- en: where *L^k* is the language obtained by concatenating *L* to itself *k* times.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *L^k* 是通过将 *L* 与自身连接 *k* 次得到的语言。
- en: From the point of view of language theory, the set of instances for any decision
    problem *Q* is simply the set Σ*, where Σ = {0, 1}. Since *Q* is entirely characterized
    by those problem instances that produce a 1 (yes) answer, we can view *Q* as a
    language *L* over Σ = {0, 1}, where
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从语言理论的角度看，任何决策问题 *Q* 的实例集仅仅是集合 Σ* 的集合，其中 Σ = {0, 1}。由于 *Q* 完全由那些产生 1（是）答案的问题实例所描述，我们可以将
    *Q* 视为 Σ = {0, 1} 上的语言 *L*，其中
- en: '*L* = {*x* ∈ Σ* : *Q*(*x*) = 1}.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '*L* = {*x* ∈ Σ* : *Q*(*x*) = 1}.'
- en: For example, the decision problem PATH has the corresponding language
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，决策问题 PATH 有对应的语言
- en: '| PATH = {〈*G, u, v, k*〉: | *G* = (*V*, *E*) is an undirected graph, |'
  id: totrans-72
  prefs: []
  type: TYPE_TB
  zh: '| 路径 = {〈*G, u, v, k*〉: | *G* = (*V*, *E*) 是一个无向图， |'
- en: '|  | *u, v* ∈ *V*, |'
  id: totrans-73
  prefs: []
  type: TYPE_TB
  zh: '|  | *u, v* ∈ *V*, |'
- en: '|  | *k* ≥ 0 is an integer, and |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '|  | *k* ≥ 0 是一个整数，且 |'
- en: '|  | *G* contains a path from *u* to *v* with at most *k* edges}. |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '|  | *G* 包含从 *u* 到 *v* 的路径，最多经过 *k* 条边}. |'
- en: (Where convenient, we’ll sometimes use the same name—PATH in this case—to refer
    to both a decision problem and its corresponding language.)
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: （在方便的情况下，我们有时会使用相同的名称—在这种情况下是 PATH—来指代一个决策问题及其对应的语言。）
- en: 'The formal-language framework allows us to express concisely the relation between
    decision problems and algorithms that solve them. We say that an algorithm *A
    **accepts*** a string *x* ∈ {0, 1}* if, given input *x*, the algorithm’s output
    *A*(*x*) is 1\. The language ***accepted*** by an algorithm *A* is the set of
    strings *L* = {*x* ∈ {0, 1}* : *A*(*x*) = 1}, that is, the set of strings that
    the algorithm accepts. An algorithm *A **rejects*** a string *x* if *A*(*x*) =
    0.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '形式语言框架使我们能够简洁地表达决策问题与解决它们的算法之间的关系。我们说一个算法 *A* **接受*** 字符串 *x* ∈ {0, 1}*，如果给定输入
    *x*，算法的输出 *A*(*x*) 为 1。算法 *A* ***接受*** 的语言是字符串集合 *L* = {*x* ∈ {0, 1}* : *A*(*x*)
    = 1}，也就是算法接受的字符串集合。如果 *A*(*x*) = 0，算法 *A* ***拒绝*** 字符串 *x*。'
- en: Even if language *L* is accepted by an algorithm *A*, the algorithm does not
    necessarily reject a string *x* ∉ *L* provided as input to it. For example, the
    algorithm might loop forever. A language *L* is ***decided*** by an algorithm
    *A* if every binary string in *L* is accepted by *A* and every binary string not
    in *L* is rejected by *A*. A language *L* is ***accepted in polynomial time***
    by an algorithm *A* if it is accepted by *A* and if in addition there exists a
    constant *k* such that for any length-*n* string *x* ∈ *L*, algorithm *A* accepts
    *x* in *O*(*n^k*) time. A language *L* is ***decided in polynomial time*** by
    an algorithm *A* if there exists a constant *k* such that for any length-*n* string
    *x* ∈ {0, 1}*, the algorithm correctly decides whether *x* ∈ *L* in *O*(*n^k*)
    time. Thus, to accept a language, an algorithm need only produce an answer when
    provided a string in *L*, but to decide a language, it must correctly accept or
    reject every string in {0, 1}*.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 即使语言*L*被算法*A*接受，该算法也不一定会拒绝作为输入提供的不属于*L*的字符串*x*。例如，该算法可能会无限循环。如果算法*A*接受*L*中的每个二进制字符串并拒绝不在*L*中的每个二进制字符串，则语言*L*由算法*A****决定***。如果算法*A*接受*L*中的每个二进制字符串并且对于任何长度为*n*的字符串*x*
    ∈ *L*，算法*A*在*O*(*n^k*)时间内接受*x*，则语言*L*由算法*A****多项式时间内接受***。如果存在常数*k*，使得对于任何长度为*n*的字符串*x*
    ∈ {0, 1}*，算法*A*在*O*(*n^k*)时间内正确决定*x* ∈ *L*，则语言*L*由算法*A****多项式时间内决定***。因此，要接受一种语言，算法只需在提供*L*中的字符串时产生答案，但要决定一种语言，它必须正确接受或拒绝{0,
    1}*中的每个字符串。
- en: 'As an example, the language PATH can be accepted in polynomial time. One polynomial-time
    accepting algorithm verifies that *G* encodes an undirected graph, verifies that
    *u* and *v* are vertices in *G*, uses breadth-first search to compute a path from
    *u* to *v* in *G* with the fewest edges, and then compares the number of edges
    on the path obtained with *k*. If *G* encodes an undirected graph and the path
    found from *u* to *v* has at most *k* edges, the algorithm outputs 1 and halts.
    Otherwise, the algorithm runs forever. This algorithm does not decide PATH, however,
    since it does not explicitly output 0 for instances in which a shortest path has
    more than *k* edges. A decision algorithm for PATH must explicitly reject binary
    strings that do not belong to PATH. For a decision problem such as PATH, such
    a decision algorithm is straightforward to design: instead of running forever
    when there is not a path from *u* to *v* with at most *k* edges, it outputs 0
    and halts. (It must also output 0 and halt if the input encoding is faulty.) For
    other problems, such as Turing’s Halting Problem, there exists an accepting algorithm,
    but no decision algorithm exists.'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 举例来说，语言PATH可以在多项式时间内被接受。一个多项式时间接受算法验证*G*是否编码了一个无向图，验证*u*和*v*是*G*中的顶点，使用广度优先搜索在*G*中计算从*u*到*v*的边数最少的路径，然后比较所得路径的边数与*k*。如果*G*编码了一个无向图且从*u*到*v*找到的路径最多有*k*条边，则算法输出1并停止。否则，算法永远运行。然而，该算法并不决定PATH，因为对于路径边数超过*k*的实例，它并没有明确输出0。对于像PATH这样的决策问题，设计这样一个决策算法是直接的：当从*u*到*v*没有最多有*k*条边的路径时，它不会永远运行，而是输出0并停止。（如果输入编码有误，则它也会输出0并停止。）对于其他问题，如图灵的停机问题，存在一个接受算法，但不存在决策算法。
- en: We can informally define a ***complexity class*** as a set of languages, membership
    in which is determined by a ***complexity measure***, such as running time, of
    an algorithm that determines whether a given string *x* belongs to language *L*.
    The actual definition of a complexity class is somewhat more technical.^([7](#footnote_7))
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以非正式地将***复杂度类***定义为一组语言，其成员资格由算法的***复杂度度量***（例如运行时间）确定，该算法确定给定字符串*x*是否属于语言*L*。复杂度类的实际定义略微更为技术性。^([7](#footnote_7))
- en: 'Using this language-theoretic framework, we can provide an alternative definition
    of the complexity class P:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 利用这种语言理论框架，我们可以提供复杂度类P的另一种定义：
- en: '| P = {*L* ⊆ {0, 1}*: | there exists an algorithm *A* that decides *L* in polynomial
    time}. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| P = {*L* ⊆ {0, 1}*：| 存在一个算法*A*，它在多项式时间内决定*L*}。|'
- en: In fact, as the following theorem shows, P is also the class of languages that
    can be accepted in polynomial time.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，正如下面的定理所示，P也是可以在多项式时间内被接受的语言类。
- en: '***Theorem 34.2***'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 34.2***'
- en: 'P = {*L* : *L* is accepted by a polynomial-time algorithm}.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: P = {*L*：*L*由多项式时间算法接受}。
- en: '***Proof*** Because the class of languages decided by polynomial-time algorithms
    is a subset of the class of languages accepted by polynomial-time algorithms,
    we need only show that if *L* is accepted by a polynomial-time algorithm, it is
    decided by a polynomial-time algorithm. Let *L* be the language accepted by some
    polynomial-time algorithm *A*. We use a classic “simulation” argument to construct
    another polynomial-time algorithm *A*′ that decides *L*. Because *A* accepts *L*
    in *O*(*n^k*) time for some constant *k*, there also exists a constant *c* such
    that *A* accepts *L* in at most *cn^k* steps. For any input string *x*, the algorithm
    *A*′ simulates *cn^k* steps of *A*. After simulating *cn^k* steps, algorithm *A*′
    inspects the behavior of *A*. If *A* has accepted *x*, then *A*′ accepts *x* by
    outputting a 1\. If *A* has not accepted *x*, then *A*′ rejects *x* by outputting
    a 0\. The overhead of *A*′ simulating *A* does not increase the running time by
    more than a polynomial factor, and thus *A*′ is a polynomial-time algorithm that
    decides *L*.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 因为由多项式时间算法决定的语言类是由多项式时间算法接受的语言类的子集，我们只需证明如果*L*被多项式时间算法接受，则它被多项式时间算法决定。设*L*是某个多项式时间算法*A*接受的语言。我们使用经典的“模拟”论证构造另一个多项式时间算法*A*′来决定*L*。因为*A*以*O*(*n^k*)时间接受*L*，所以也存在常数*c*，使得*A*最多在*cn^k*步内接受*L*。对于任何输入字符串*x*，算法*A*′模拟*A*的*cn^k*步。在模拟*cn^k*步后，算法*A*′检查*A*的行为。如果*A*接受*x*，则*A*′通过输出1接受*x*。如果*A*没有接受*x*，则*A*′通过输出0拒绝*x*。*A*′模拟*A*的开销不会使运行时间增加超过多项式因子，因此*A*′是一个多项式时间算法，决定*L*。'
- en: ▪
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: The proof of Theorem 34.2 is nonconstructive. For a given language *L* ∈ P,
    we may not actually know a bound on the running time for the algorithm *A* that
    accepts *L*. Nevertheless, we know that such a bound exists, and therefore, that
    an algorithm *A*′ exists that can check the bound, even though we may not be able
    to find the algorithm *A*′ easily.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 定理34.2的证明是非构造性的。对于属于P的语言*L*，我们可能实际上并不知道接受*L*的算法*A*的运行时间上限。尽管如此，我们知道这样的上限存在，因此，存在一个算法*A*′可以检查这个上限，尽管我们可能不容易找到算法*A*′。
- en: '**Exercises**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***34.1-1***'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.1-1***'
- en: 'Define the optimization problem LONGEST-PATH-LENGTH as the relation that associates
    each instance of an undirected graph and two vertices with the number of edges
    in a longest simple path between the two vertices. Define the decision problem
    LONGEST-PATH = {〈*G, u, v, k*〉 : *G* = (*V*, *E*) is an undirected graph, *u,
    v* ∈ *V*, *k* ≥ 0 is an integer, and there exists a simple path from *u* to *v*
    in *G* consisting of at least *k* edges}. Show that the optimization problem LONGEST-PATH-LENGTH
    can be solved in polynomial time if and only if LONGEST-PATH ∈ P.'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '将优化问题LONGEST-PATH-LENGTH定义为将无向图的每个实例和两个顶点关联到两个顶点之间最长简单路径中的边数的关系。将决策问题LONGEST-PATH定义为{〈*G,
    u, v, k*〉 : *G* = (*V*, *E*)是无向图，*u, v* ∈ *V*，*k* ≥ 0是整数，并且在*G*中存在一个由至少*k*条边组成的从*u*到*v*的简单路径}。证明如果且仅当LONGEST-PATH
    ∈ P时，优化问题LONGEST-PATH-LENGTH可以在多项式时间内解决。'
- en: '***34.1-2***'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.1-2***'
- en: Give a formal definition for the problem of finding the longest simple cycle
    in an undirected graph. Give a related decision problem. Give the language corresponding
    to the decision problem.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 给出在无向图中找到最长简单循环的问题的正式定义。给出一个相关的决策问题。给出与决策问题对应的语言。
- en: '***34.1-3***'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.1-3***'
- en: Give a formal encoding of directed graphs as binary strings using an adjacency-matrix
    representation. Do the same using an adjacency-list representation. Argue that
    the two representations are polynomially related.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 使用邻接矩阵表示法给出有向图的正式编码为二进制字符串。使用邻接表表示法做同样的事情。论证这两种表示是多项式相关的。
- en: '***34.1-4***'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.1-4***'
- en: Is the dynamic-programming algorithm for the 0-1 knapsack problem that is asked
    for in Exercise 15.2-2 a polynomial-time algorithm? Explain your answer.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 0-1背包问题的动态规划算法是一个多项式时间算法吗？解释你的答案。
- en: '***34.1-5***'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.1-5***'
- en: Show that if an algorithm makes at most a constant number of calls to polynomial-time
    subroutines and performs an additional amount of work that also takes polynomial
    time, then it runs in polynomial time. Also show that a polynomial number of calls
    to polynomial-time subroutines may result in an exponential-time algorithm.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 证明如果一个算法最多调用常数次多项式时间子程序并执行额外需要多项式时间的工作，那么它将在多项式时间内运行。同时证明多项式次调用多项式时间子程序可能导致指数时间算法。
- en: '***34.1-6***'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.1-6***'
- en: Show that the class P, viewed as a set of languages, is closed under union,
    intersection, concatenation, complement, and Kleene star. That is, if *L*[1],
    *L*[2] ∈ P, then *L*[1] ∪ *L*[2] ∈ P, *L*[1] ∩ *L*[2] ∈ P, *L*[1]*L*[2] ∈ P, *L*[1]
    ∈ *P*, and ![art](images/Art_P1430a.jpg).
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 证明P类作为一组语言，在并集、交集、连接、补集和Kleene星下是封闭的。也就是说，如果*L*[1]，*L*[2] ∈ P，则*L*[1] ∪ *L*[2]
    ∈ P，*L*[1] ∩ *L*[2] ∈ P，*L*[1]*L*[2] ∈ P，*L*[1] ∈ *P*，以及![art](images/Art_P1430a.jpg)。
- en: '[**34.2    Polynomial-time verification**](toc.xhtml#Rh1-200)'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '[**34.2    多项式时间验证**](toc.xhtml#Rh1-200)'
- en: Now, let’s look at algorithms that verify membership in languages. For example,
    suppose that for a given instance 〈*G, u, v, k*〉 of the decision problem PATH,
    you are also given a path *p* from *u* to *v*. You can check whether *p* is a
    path in *G* and whether the length of *p* is at most *k*, and if so, you can view
    *p* as a “certificate” that the instance indeed belongs to PATH. For the decision
    problem PATH, this certificate doesn’t seem to buy much. After all, PATH belongs
    to P—in fact, you can solve PATH in linear time—and so verifying membership from
    a given certificate takes as long as solving the problem from scratch. Instead,
    let’s examine a problem for which we know of no polynomial-time decision algorithm
    and yet, given a certificate, verification is easy.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看验证语言成员资格的算法。例如，假设对于决策问题PATH的给定实例〈*G, u, v, k*〉，你还给出了从*u*到*v*的路径*p*。你可以检查*p*是否是*G*中的路径，以及*p*的长度是否最多为*k*，如果是的话，你可以将*p*视为证明该实例确实属于PATH的“证书”。对于决策问题PATH，这个证书似乎并没有太多用处。毕竟，PATH属于P——事实上，你可以在线性时间内解决PATH——因此，从给定证书验证成员资格所需的时间与从头开始解决问题的时间一样长。相反，让我们研究一个我们不知道多项式时间决策算法的问题，然而，给定证书后，验证却很容易。
- en: '**Hamiltonian cycles**'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈密顿循环**'
- en: The problem of finding a hamiltonian cycle in an undirected graph has been studied
    for over a hundred years. Formally, a ***hamiltonian cycle*** of an undirected
    graph *G* = (*V*, *E*) is a simple cycle that contains each vertex in *V*. A graph
    that contains a hamiltonian cycle is said to be ***hamiltonian***, and otherwise,
    it is ***nonhamiltonian***. The name honors W. R. Hamilton, who described a mathematical
    game on the dodecahedron ([Figure 34.2(a)](chapter034.xhtml#Fig_34-2)) in which
    one player sticks five pins in any five consecutive vertices and the other player
    must complete the path to form a cycle containing all the vertices.^([8](#footnote_8))
    The dodecahedron is hamiltonian, and [Figure 34.2(a)](chapter034.xhtml#Fig_34-2)
    shows one hamiltonian cycle. Not all graphs are hamiltonian, however. For example,
    [Figure 34.2(b)](chapter034.xhtml#Fig_34-2) shows a bipartite graph with an odd
    number of vertices. Exercise 34.2-2 asks you to show that all such graphs are
    nonhamiltonian.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 寻找无向图中的哈密顿回路问题已经研究了一百多年。形式上，无向图*G* = (*V*, *E*)的一个***哈密顿回路***是一个包含*V*中每个顶点的简单回路。包含哈密顿回路的图被称为***哈密顿图***，否则被称为***非哈密顿图***。这个名字是为了纪念W.
    R. Hamilton，他在十二面体上描述了一个数学游戏（[图 34.2(a)](chapter034.xhtml#Fig_34-2)），其中一名玩家在任意五个连续顶点上插入五根针，另一名玩家必须完成路径以形成包含所有顶点的回路。十二面体是哈密顿的，[图
    34.2(a)](chapter034.xhtml#Fig_34-2)展示了一个哈密顿回路。然而，并非所有图都是哈密顿的。例如，[图 34.2(b)](chapter034.xhtml#Fig_34-2)展示了一个具有奇数顶点的二分图。练习
    34.2-2 要求你证明所有这样的图都是非哈密顿的。
- en: 'Here is how to define the ***hamiltonian-cycle problem***, “Does a graph *G*
    have a hamiltonian cycle?” as a formal language:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何将***哈密顿回路问题***，“图*G*是否有哈密顿回路���”定义为一个形式语言：
- en: 'HAM-CYCLE = {〈*G*〉 : *G* is a hamiltonian graph}.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 'HAM-CYCLE = {〈*G*〉 : *G* 是哈密顿图}。'
- en: How might an algorithm decide the language HAM-CYCLE? Given a problem instance
    〈*G*〉, one possible decision algorithm lists all permutations of the vertices
    of *G* and then checks each permutation to see whether it is a hamiltonian cycle.
    What is the running time of this algorithm? It depends on the encoding of the
    graph *G*. Let’s say that *G* is encoded as its adjacency matrix. If the adjacency
    matrix contains *n* entries, so that the length of the encoding of *G* equals
    *n*, then the number *m* of vertices in the graph is ![art](images/Art_P1431.jpg).
    There are *m*! possible permutations of the vertices, and therefore the running
    time is ![art](images/Art_P1432.jpg), which is not *O*(*n^k*) for any constant
    *k*. Thus, this naive algorithm does not run in polynomial time. In fact, the
    hamiltonian-cycle problem is NP-complete, as we’ll prove in [Section 34.5](chapter034.xhtml#Sec_34.5).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 一个算法如何决定语言 HAM-CYCLE？给定一个问题实例 〈*G*〉，一个可能的决策算法列出*G*的所有顶点的排列，然后检查每个排列以查看它是否是一个哈密顿回路。这个算法的运行时间是多少？这取决于图*G*的编码。假设*G*被编码为其邻接矩阵。如果邻接矩阵包含*n*个条目，使得*G*的编码长度等于*n*，那么图中的顶点数*m*为
    ![art](images/Art_P1431.jpg)。顶点有*m*! 种可能的排列，因此运行时间是 ![art](images/Art_P1432.jpg)，这不是对于任何常数*k*都是*O*(*n^k*)。因此，这个朴素算法不在多项式时间内运行。事实上，哈密顿回路问题是
    NP 完全的，我们将在[第 34.5 节](chapter034.xhtml#Sec_34.5)中证明。
- en: '![art](images/Art_P1433.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1433.jpg)'
- en: '**Figure 34.2 (a)** A graph representing the vertices, edges, and faces of
    a dodecahedron, with a hamiltonian cycle shown by edges highlighted in blue. **(b)**
    A bipartite graph with an odd number of vertices. Any such graph is nonhamiltonian.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 34.2 (a)** 代表十二面体的顶点、边和面的图，其中用蓝色突出显示的边表示一个哈密顿回路。**(b)** 具有奇数顶点的二分图。任何这样的图都是非哈密顿的。'
- en: '**Verification algorithms**'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '**验证算法**'
- en: 'Consider a slightly easier problem. Suppose that a friend tells you that a
    given graph *G* is hamiltonian, and then the friend offers to prove it by giving
    you the vertices in order along the hamiltonian cycle. It would certainly be easy
    enough to verify the proof: simply verify that the provided cycle is hamiltonian
    by checking whether it is a permutation of the vertices of *V* and whether each
    of the consecutive edges along the cycle actually exists in the graph. You could
    certainly implement this verification algorithm to run in *O*(*n*²) time, where
    *n* is the length of the encoding of *G*. Thus, a proof that a hamiltonian cycle
    exists in a graph can be verified in polynomial time.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个稍微简单的问题。假设一个朋友告诉你一个给定的图*G*是哈密顿的，然后朋友提出通过按照哈密顿回路中的顶点顺序给你来证明。验证这个证明肯定很容易：只需验证提供的回路是否是哈密顿的，方法是检查它是否是*V*的顶点的排列，以及沿着回路的每个连续边是否实际存在于图中。你肯定可以实现这个验证算法以在*O*(*n*²)时间内运行，其中*n*是*G*的编码长度。因此，证明图中存在哈密顿回路可以在多项式时间内验证。
- en: We define a ***verification algorithm*** as being a two-argument algorithm *A*,
    where one argument is an ordinary input string *x* and the other is a binary string
    *y* called a ***certificate***. A two-argument algorithm *A **verifies*** an input
    string *x* if there exists a certificate *y* such that *A*(*x, y*) = 1\. The ***language
    verified*** by a verification algorithm *A* is
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将一个***验证算法***定义为一个具有两个参数的算法*A*，其中一个参数是普通输入字符串*x*，另一个是称为***证书***的二进制字符串*y*。如果存在一个证书*y*使得*A*(*x,
    y*) = 1，则一个具有两个参数的算法*A* ***验证*** 输入字符串*x*。被验证的语言由验证算法*A*验证。
- en: '*L* = {*x* ∈ {0, 1}* : there exists *y* ∈ {0, 1}* such that *A*(*x, y*) = 1}.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*L* = {*x* ∈ {0, 1}* : 存在*y* ∈ {0, 1}* 使得*A*(*x, y*) = 1}。'
- en: Think of an algorithm *A* as verifying a language *L* if, for any string *x*
    ∈ *L*, there exists a certificate *y* that *A* can use to prove that *x* ∈ *L*.
    Moreover, for any string *x* ∉ *L*, there must be no certificate proving that
    *x* ∈ *L*. For example, in the hamiltonian-cycle problem, the certificate is the
    list of vertices in some hamiltonian cycle. If a graph is hamiltonian, the hamiltonian
    cycle itself offers enough information to verify that the graph is indeed hamiltonian.
    Conversely, if a graph is not hamiltonian, there can be no list of vertices that
    fools the verification algorithm into believing that the graph is hamiltonian,
    since the verification algorithm carefully checks the so-called cycle to be sure.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将算法 *A* 视为验证语言 *L* 的工具，那么对于任何 *x* ∈ *L*，都存在一个证书 *y*，使得 *A* 可以用来证明 *x* ∈ *L*。此外，对于任何
    *x* ∉ *L* 的字符串，都不应该有证书证明 *x* ∈ *L*。例如，在哈密顿回路问题中，证书是某个哈密顿回路中的顶点列表。如果一个图是哈密顿的，那么哈密顿回路本身提供了足够的信息来验证该图确实是哈密顿的。反之，如果一个图不是哈密顿的，那么就不可能有任何顶点列表愚弄验证算法，使其相信该图是哈密顿的，因为验证算法会仔细检查所谓的回路以确保其正确性。
- en: '**The complexity class NP**'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '**复杂性类 NP**'
- en: The ***complexity class* NP** is the class of languages that can be verified
    by a polynomial-time algorithm.^([9](#footnote_9)) More precisely, a language
    *L* belongs to NP if and only if there exist a two-input polynomial-time algorithm
    *A* and a constant *c* such that
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '***复杂性类* NP** 是可以通过多项式时间算法验证的语言类别。^([9](#footnote_9)) 更确切地说，如果存在一个两输入多项式时间算法
    *A* 和一个常数 *c*，那么语言 *L* 属于 NP。'
- en: '| *L* = {*x* ∈ {0, 1}*: | there exists a certificate *y* with &#124;*y*&#124;
    = *O*(&#124;*x*&#124;^(*c*)) |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| *L* = {*x* ∈ {0, 1}*: | 存在一个证书 *y*，使得 &#124;*y*&#124; = *O*(&#124;*x*&#124;^(*c*))
    |'
- en: '|  | such that *A*(*x*, *y*) = 1}. |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '|  | 使得 *A*(*x*, *y*) = 1}。 |'
- en: We say that algorithm *A **verifies*** language *L **in polynomial time***.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们说算法 *A* **在多项式时间内验证** 语言 *L*。
- en: From our earlier discussion about the hamiltonian-cycle problem, you can see
    that HAM-CYCLE ∈ NP. (It is always nice to know that an important set is nonempty.)
    Moreover, if *L* ∈ P, then *L* ∈ NP, since if there is a polynomial-time algorithm
    to decide *L*, the algorithm can be converted to a two-argument verification algorithm
    that simply ignores any certificate and accepts exactly those input strings it
    determines to belong to *L*. Thus, P ⊆ NP.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 从我们之前关于哈密顿回路问题的讨论中，您可以看到 HAM-CYCLE ∈ NP。 （知道一个重要集合是非空总是好的。）此外，如果 *L* ∈ P，则 *L*
    ∈ NP，因为如果存在一个多项式时间算法来决定 *L*，则该算法可以转换为一个忽略任何证书并仅接受那些确定属于 *L* 的输入字符串的两参数验证算法。因此，P
    ⊆ NP。
- en: That leaves the question of whether P = NP. A definitive answer is unknown,
    but most researchers believe that P and NP are not the same class. Think of the
    class P as consisting of problems that can be solved quickly and the class NP
    as consisting of problems for which a solution can be verified quickly. You may
    have learned from experience that it is often more difficult to solve a problem
    from scratch than to verify a clearly presented solution, especially when working
    under time constraints. Theoretical computer scientists generally believe that
    this analogy extends to the classes P and NP, and thus that NP includes languages
    that do not belong to P.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这就留下了 P = NP 的问题。目前尚无明确答案，但大多数研究人员认为 P 和 NP 不是同一类。将类 P 视为可以快速解决的问题，将类 NP 视为可以快速验证解决方案的问题。您可能从经验中了解到，从头开始解决问题通常比验证清晰呈现的解决方案更困难，尤其是在时间限制下工作时。理论计算机科学家普遍认为这种类比适用于类
    P 和 NP，并且 NP 包括不属于 P 的语言。
- en: '![art](images/Art_P1434.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1434.jpg)'
- en: '**Figure 34.3** Four possibilities for relationships among complexity classes.
    In each diagram, one region enclosing another indicates a proper-subset relation.
    **(a)** P = NP = co-NP. Most researchers regard this possibility as the most unlikely.
    **(b)** If NP is closed under complement, then NP = co-NP, but it need not be
    the case that P = NP. **(c)** P = NP ∩ co-NP, but NP is not closed under complement.
    **(d)** NP ≠ co-NP and P ≠ NP ∩ co-NP. Most researchers regard this possibility
    as the most likely.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 34.3** 复杂性类之间关系的四种可能性。在每个图中，一个包含另一个的区域表示一个真子集关系。 **(a)** P = NP = co-NP。大多数研究人员认为这种可能性最不可能。
    **(b)** 如果 NP 在补集下封闭，则 NP = co-NP，但不一定是 P = NP。 **(c)** P = NP ∩ co-NP，但 NP 在补集下不封闭。
    **(d)** NP ≠ co-NP 且 P ≠ NP ∩ co-NP。大多数研究人认为这种可能性最有可能。'
- en: There is more compelling, though not conclusive, evidence that P ≠ NP—the existence
    of languages that are “NP-complete.” [Section 34.3](chapter034.xhtml#Sec_34.3)
    will study this class.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更有说服力但不是决定性的证据表明 P ≠ NP——存在“NP完全”语言。[第 34.3 节](chapter034.xhtml#Sec_34.3)
    将研究这一类。
- en: Many other fundamental questions beyond the P ≠ NP question remain unresolved.
    [Figure 34.3](chapter034.xhtml#Fig_34-3) shows some possible scenarios. Despite
    much work by many researchers, no one even knows whether the class NP is closed
    under complement. That is, does *L* ∈ NP imply *L* ∈ NP? We define the ***complexity
    class* co-NP** as the set of languages *L* such that *L* ∈ NP, so that the question
    of whether NP is closed under complement is also whether NP = co-NP. Since P is
    closed under complement (Exercise 34.1-6), it follows from Exercise 34.2-9 (P
    ⊆ co-NP) that P ⊆ NP ∩ co-NP. Once again, however, no one knows whether P = NP
    ∩ co-NP or whether there is some language in (NP ∩ co-NP) − P.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 P ≠ NP 问题之外，许多其他基本问题仍未解决。[图 34.3](chapter034.xhtml#Fig_34-3) 展示了一些可能的情景。尽管许多研究人员做了大量工作，但没有人知道类
    NP 是否在补集下封闭。也就是说，*L* ∈ NP 是否意味着 *L* ∈ NP？我们将***复杂性类* co-NP** 定义为语言 *L* 属于 NP 的集合，因此
    NP 是否在补集下封闭的问题也就是 NP = co-NP 的问题。由于 P 在补集下封闭（练习 34.1-6），根据练习 34.2-9（P ⊆ co-NP），可得出
    P ⊆ NP ∩ co-NP。然而，没有人知道 P = NP ∩ co-NP 还是 (NP ∩ co-NP) − P 中是否存在某种语言。
- en: Thus our understanding of the precise relationship between P and NP is woefully
    incomplete. Nevertheless, even though we might not be able to prove that a particular
    problem is intractable, if we can prove that it is NP-complete, then we have gained
    valuable information about it.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们对P和NP之间的确切关系的理解是非常不完整的。然而，即使我们可能无法证明某个问题是难解的，如果我们能证明它是NP完全的，那么我们就获得了有关它的宝贵信息。
- en: '**Exercises**'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***34.2-1***'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.2-1***'
- en: 'Consider the language GRAPH-ISOMORPHISM = {〈*G*[1], *G*[2]〉 : *G*[1] and *G*[2]
    are isomorphic graphs}. Prove that GRAPH-ISOMORPHISM ∈ NP by describing a polynomial-time
    algorithm to verify the language.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑语言GRAPH-ISOMORPHISM = {〈*G*[1], *G*[2]〉：*G*[1]和*G*[2]是同构图}。通过描述一个验证该语言的多项式时间算法，证明GRAPH-ISOMORPHISM
    ∈ NP。
- en: '***34.2-2***'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.2-2***'
- en: Prove that if *G* is an undirected bipartite graph with an odd number of vertices,
    then *G* is nonhamiltonian.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 证明如果*G*是一个具有奇数个顶点的无向二分图，则*G*是非哈密顿图。
- en: '***34.2-3***'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.2-3***'
- en: Show that if HAM-CYCLE ∈ P, then the problem of listing the vertices of a hamiltonian
    cycle, in order, is polynomial-time solvable.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如果HAM-CYCLE ∈ P，则按顺序列出哈密顿循环的顶点的问题是多项式时间可解的。
- en: '***34.2-4***'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.2-4***'
- en: Prove that the class NP of languages is closed under union, intersection, concatenation,
    and Kleene star. Discuss the closure of NP under complement.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 证明NP语言类在并集、交集、连接和Kleene星下是封闭的。讨论NP在补集下的封闭性。
- en: '***34.2-5***'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.2-5***'
- en: Show that any language in NP can be decided by an algorithm with a running time
    of ![art](images/Art_P1434a.jpg) for some constant *k*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 展示NP中的任何语言都可以通过一个运行时间为![art](images/Art_P1434a.jpg)的算法来决定。
- en: '***34.2-6***'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.2-6***'
- en: 'A ***hamiltonian path*** in a graph is a simple path that visits every vertex
    exactly once. Show that the language HAM-PATH = {〈*G, u, v*〉 : there is a hamiltonian
    path from *u* to *v* in graph *G*} belongs to NP.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的***哈密顿路径***是一个简单路径，它恰好访问每个顶点一次。展示语言HAM-PATH = {〈*G, u, v*〉：图*G*中从*u*到*v*存在哈密顿路径}属于NP。
- en: '***34.2-7***'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.2-7***'
- en: Show that the hamiltonian-path problem from Exercise 34.2-6 can be solved in
    polynomial time on directed acyclic graphs. Give an efficient algorithm for the
    problem.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 展示了在有向无环图上可以在多项式时间内解决练习34.2-6中的哈密顿路径问题。给出该问题的高效算法。
- en: '***34.2-8***'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.2-8***'
- en: Let *ϕ* be a boolean formula constructed from the boolean input variables *x*[1],
    *x*[2], … , *x[k]*, negations (¬), ANDs (∧), ORs (∨), and parentheses. The formula
    *ϕ* is a ***tautology*** if it evaluates to 1 for every assignment of 1 and 0
    to the input variables. Define TAUTOLOGY as the language of boolean formulas that
    are tautologies. Show that TAUTOLOGY ∈ co-NP.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 设*ϕ*是由布尔输入变量*x*[1]，*x*[2]，…，*x[k]*，否定（¬），与（∧），或（∨）和括号构造的布尔公式。如果对输入变量的每个赋值*ϕ*都评估为1，则该公式是一个***永真式***。将TAUTOLOGY定义为布尔公式的语言，这些公式是永真式。证明TAUTOLOGY
    ∈ co-NP。
- en: '***34.2-9***'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.2-9***'
- en: Prove that P ⊆ co-NP.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 证明P ⊆ co-NP。
- en: '***34.2-10***'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.2-10***'
- en: Prove that if NP ≠ co-NP, then P ≠ NP.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 证明如果NP ≠ co-NP，则P ≠ NP。
- en: '***34.2-11***'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.2-11***'
- en: Let *G* be a connected, undirected graph with at least three vertices, and let
    *G*³ be the graph obtained by connecting all pairs of vertices that are connected
    by a path in *G* of length at most 3\. Prove that *G*³ is hamiltonian. (*Hint:*
    Construct a spanning tree for *G*, and use an inductive argument.)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 设*G*是一个至少有三个顶点的连通无向图，令*G*³是通过连接*G*中长度最多为3的路径连接的所有顶点对而得到的图。证明*G*³是哈密顿图。（*提示：构建*G*的生成树，并使用归纳论证。）
- en: '[**34.3    NP-completeness and reducibility**](toc.xhtml#Rh1-201)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: '[**34.3    NP完全性和可归约性**](toc.xhtml#Rh1-201)'
- en: Perhaps the most compelling reason why theoretical computer scientists believe
    that P ≠ NP comes from the existence of the class of NP-complete problems. This
    class has the intriguing property that if *any* NP-complete problem can be solved
    in polynomial time, then *every* problem in NP has a polynomial-time solution,
    that is, P = NP. Despite decades of study, though, no polynomial-time algorithm
    has ever been discovered for any NP-complete problem.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 或许理论计算机科学家相信P ≠ NP的最具说服力的原因来自于NP完全问题的存在。这个类别具有一个有趣的特性，即如果*任何*NP完全问题可以在多项式时间内解决，那么NP中的*每个*问题都有一个多项式时间的解决方案，也就是说，P
    = NP。尽管经过几十年的研究，但从未为任何NP完全问题发现过多项式时间算法。
- en: The language HAM-CYCLE is one NP-complete problem. If there were an algorithm
    to decide HAM-CYCLE in polynomial time, then every problem in NP could be solved
    in polynomial time. The NP-complete languages are, in a sense, the “hardest” languages
    in NP. In fact, if NP − P turns out to be nonempty, we will be able to say with
    certainty that HAM-CYCLE ∈ NP − P.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 语言HAM-CYCLE是一个NP完全问题。如果有一个算法可以在多项式时间内决定HAM-CYCLE，那么NP中的每个问题都可以在多项式时间内解决。NP完全语言在某种意义上是NP中“最难”的语言。实际上，如果NP
    − P是非空的，我们将能够确定HAM-CYCLE ∈ NP − P。
- en: This section starts by showing how to compare the relative “hardness” of languages
    using a precise notion called “polynomial-time reducibility.” It then formally
    defines the NP-complete languages, finishing by sketching a proof that one such
    language, called CIRCUIT-SAT, is NP-complete. [Sections 34.4](chapter034.xhtml#Sec_34.4)
    and [34.5](chapter034.xhtml#Sec_34.5) will use the notion of reducibility to show
    that many other problems are NP-complete.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 本节首先展示了如何使用称为“多项式时间可归约性”的精确概念来比较语言的相对“难度”。然后正式定义了NP完全语言，并最后勾勒了一个证明，证明了其中一种语言，称为CIRCUIT-SAT，是NP完全的。[第34.4节](chapter034.xhtml#Sec_34.4)和[第34.5节](chapter034.xhtml#Sec_34.5)将使用可归约性的概念来展示许多其他问题是NP完全的。
- en: '**Reducibility**'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**可归约性**'
- en: One way that sometimes works for solving a problem is to recast it as a different
    problem. We call that strategy “reducing” one problem to another. Think of a problem
    *Q* as being reducible to another problem *Q*′ if any instance of *Q* can be recast
    as an instance of *Q*′, and the solution to the instance of *Q*′ provides a solution
    to the instance of *Q*. For example, the problem of solving linear equations in
    an indeterminate *x* reduces to the problem of solving quadratic equations. Given
    a linear-equation instance *ax* + *b* = 0 (with solution *x* = −*b*/*a*), you
    can transform it to the quadratic equation *ax*² + *bx* + 0 = 0\. This quadratic
    equation has the solutions ![art](images/Art_P1435.jpg), where *c* = 0, so that
    ![art](images/Art_P1436.jpg). The solutions are then *x* = (−*b* + *b*)/2*a* =
    0 and *x* = (−*b* − *b*)/2*a* = −*b*/*a*, thereby providing a solution to *ax*
    + *b* = 0\. Thus, if a problem *Q* reduces to another problem *Q*′, then *Q* is,
    in a sense, “no harder to solve” than *Q*′.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 有时解决问题的一种方法是将其重新构造为另一个问题。我们称这种策略为将一个问题减少到另一个问题。如果问题 *Q* 可以减少为另一个问题 *Q*��，则将问题
    *Q* 的任何实例重新构造为问题 *Q*′ 的实例，并且问题 *Q*′ 的实例的解决方案提供了问题 *Q* 的实例的解决方案。例如，解决不定方程 *x* 的问题可以减少为解决二次方程的问题。给定线性方程实例
    *ax* + *b* = 0（解为 *x* = −*b*/*a*），您可以将其转换为二次方程 *ax*² + *bx* + 0 = 0。这个二次方程的解为
    ![艺术](images/Art_P1435.jpg)，其中 *c* = 0，因此 ![艺术](images/Art_P1436.jpg)。然后解为 *x*
    = (−*b* + *b*)/2*a* = 0 和 *x* = (−*b* − *b*)/2*a* = −*b*/*a*，从而提供了解决 *ax* + *b*
    = 0 的解。因此，如果问题 *Q* 减少为另一个问题 *Q*′，那么 *Q* 在某种意义上“不比” *Q*′ 更难解决。
- en: '![art](images/Art_P1437.jpg)'
  id: totrans-157
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1437.jpg)'
- en: '**Figure 34.4** A function *f* that reduces language *L*[1] to language *L*[2].
    For any input *x* ∈ {0, 1}*, the question of whether *x* ∈ *L*[1] has the same
    answer as the question of whether *f* (*x*) ∈ *L*[2].'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 34.4** 将语言 *L*[1] 减少到语言 *L*[2] 的函数 *f*。对于任何输入 *x* ∈ {0, 1}*，问题 *x* ∈ *L*[1]
    的答案与问题 *f* (*x*) ∈ *L*[2] 的答案相同。'
- en: 'Returning to our formal-language framework for decision problems, we say that
    a language *L*[1] is ***polynomial-time reducible*** to a language *L*[2], written
    *L*[1] ≤[P] *L*[2], if there exists a polynomial-time computable function *f*
    : {0, 1}* → {0, 1}* such that for all *x* ∈ {0, 1}*,'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '回到我们的形式语言框架，对于决策问题，我们说语言 *L*[1] ***多项式时间可减少*** 到语言 *L*[2]，写作 *L*[1] ≤[P] *L*[2]，如果存在一个多项式时间可计算的函数
    *f* : {0, 1}* → {0, 1}*，使得对于所有 *x* ∈ {0, 1}*，'
- en: '![art](images/Art_P1438.jpg)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1438.jpg)'
- en: We call the function *f* the ***reduction function***, and a polynomial-time
    algorithm *F* that computes *f* is a ***reduction algorithm***.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将函数 *f* 称为***减少函数***，计算 *f* 的多项式时间算法 *F* 称为***减少算法***。
- en: '[Figure 34.4](chapter034.xhtml#Fig_34-4) illustrates the idea of a reduction
    from a language *L*[1] to another language *L*[2]. Each language is a subset of
    {0, 1}*. The reduction function *f* provides a mapping such that if *x* ∈ *L*[1],
    then *f* (*x*) ∈ *L*[2]. Moreover, if *x* ∉ *L*[1], then *f* (*x*) ∉ *L*[2]. Thus,
    the reduction function maps any instance *x* of the decision problem represented
    by the language *L*[1] to an instance *f* (*x*) of the problem represented by
    *L*[2]. Providing an answer to whether *f* (*x*) ∈ *L*[2] directly provides the
    answer to whether *x* ∈ *L*[1]. If, in addition, *f* can be computed in polynomial
    time, it is a polynomial-time reduction function.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 34.4](chapter034.xhtml#Fig_34-4) 说明了从语言 *L*[1] 到另一语言 *L*[2] 的减少的概念。每种语言都是
    {0, 1}* 的子集。减少函数 *f* 提供了这样一个映射，即如果 *x* ∈ *L*[1]，则 *f* (*x*) ∈ *L*[2]。此外，如果 *x*
    ∉ *L*[1]，则 *f* (*x*) ∉ *L*[2]。因此，减少函数将由语言 *L*[1] 表示的决策问题的任何实例 *x* 映射到由 *L*[2]
    表示的问题的实例 *f* (*x*)。直接提供 *f* (*x*) ∈ *L*[2] 的答案也提供了 *x* ∈ *L*[1] 的答案。此外，如果 *f*
    可以在多项式时间内计算，则它是一个多项式时间减少函数。'
- en: Polynomial-time reductions give us a powerful tool for proving that various
    languages belong to P.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式时间减少为我们提供了一个强大的工具，用于证明各种语言属于 P。
- en: '***Lemma 34.3***'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 34.3***'
- en: If *L*[1], *L*[2] ⊆ {0, 1}* are languages such that *L*[1] ≤[P] *L*[2], then
    *L*[2] ∈ P implies *L*[1] ∈ P.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 *L*[1]，*L*[2] ⊆ {0, 1}* 是语言，使得 *L*[1] ≤[P] *L*[2]，那么 *L*[2] ∈ P 意味着 *L*[1]
    ∈ P。
- en: '![art](images/Art_P1439.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1439.jpg)'
- en: '**Figure 34.5** The proof of Lemma 34.3\. The algorithm *F* is a reduction
    algorithm that computes the reduction function *f* from *L*[1] to *L*[2] in polynomial
    time, and *A*[2] is a polynomial-time algorithm that decides *L*[2]. Algorithm
    *A*[1] decides whether *x* ∈ *L*[1] by using *F* to transform any input *x* into
    *f* (*x*) and then using *A*[2] to decide whether *f* (*x*) ∈ *L*[2].'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 34.5** 引理 34.3 的证明。算法 *F* 是一个减少算法，它在多项式时间内计算从 *L*[1] 到 *L*[2] 的减少函数 *f*，*A*[2]
    是一个在多项式时间内决定 *L*[2] 的算法。算法 *A*[1] 通过使用 *F* 将任何输入 *x* 转换为 *f* (*x*)，然后使用 *A*[2]
    来决定 *f* (*x*) ∈ *L*[2]，来决定 *x* ∈ *L*[1]。'
- en: '***Proof***   Let *A*[2] be a polynomial-time algorithm that decides *L*[2],
    and let *F* be a polynomial-time reduction algorithm that computes the reduction
    function *f*. We show how to construct a polynomial-time algorithm *A*[1] that
    decides *L*[1].'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   设 *A*[2] 是一个决定 *L*[2] 的多项式时间算法，*F* 是一个计算减少函数 *f* 的多项式时间减少算法。我们展示如何构建一个决定
    *L*[1] 的多项式时间算法 *A*[1]。'
- en: '[Figure 34.5](chapter034.xhtml#Fig_34-5) illustrates how we construct *A*[1].
    For a given input *x* ∈ {0, 1}*, algorithm *A*[1] uses *F* to transform *x* into
    *f* (*x*), and then it uses *A*[2] to test whether *f* (*x*) ∈ *L*[2]. Algorithm
    *A*[1] takes the output from algorithm *A*[2] and produces that answer as its
    own output.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 34.5](chapter034.xhtml#Fig_34-5) 说明了我们如何构建 *A*[1]。对于给定的输入 *x* ∈ {0, 1}*，算法
    *A*[1] 使用 *F* 将 *x* 转换为 *f* (*x*)，然后使用 *A*[2] 来测试 *f* (*x*) ∈ *L*[2]。算法 *A*[1]
    接受来自算法 *A*[2] 的输出，并将该答案作为自己的输出。'
- en: The correctness of *A*[1] follows from condition (34.1). The algorithm runs
    in polynomial time, since both *F* and *A*[2] run in polynomial time (see Exercise
    34.1-5).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '*A*[1] 的正确性来自条件（34.1）。该算法在多项式时间内运行，因为 *F* 和 *A*[2] 都在多项式时间内运行（参见练习 34.1-5）。'
- en: ▪
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**NP-completeness**'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '**NP-完全性**'
- en: Polynomial-time reductions allow us to formally show that one problem is at
    least as hard as another, to within a polynomial-time factor. That is, if *L*[1]
    ≤[P] *L*[2], then *L*[1] is not more than a polynomial factor harder than *L*[2],
    which is why the “less than or equal to” notation for reduction is mnemonic. We
    can now define the set of NP-complete languages, which are the hardest problems
    in NP.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 多项式时间归约允许我们正式显示一个问题至少与另一个问题一样困难，至多相差一个多项式时间因子。也就是说，如果 *L*[1] ≤[P] *L*[2]，那么
    *L*[1] 不会比 *L*[2] 更困难一个多项式因子，这就是为什么减少的“小于或等于”符号是助记符。现在我们可以定义 NP 完全语言的集合，它们是 NP
    中最困难的问题。
- en: A language *L* ⊆ {0, 1}* is ***NP-complete*** if
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个语言 *L* ⊆ {0, 1}* 是***NP 完全***的，如果
- en: '*L* ∈ NP, and'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*L* ∈ NP，并且'
- en: '*L*′ ≤[P] *L* for every *L*′ ∈ NP.'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*L*′ ≤[P] *L* 对于每个 *L*′ ∈ NP。'
- en: If a language *L* satisfies property 2, but not necessarily property 1, we say
    that *L* is ***NP-hard***. We also define NPC to be the class of NP-complete languages.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个语言 *L* 满足属性 2，但不一定满足属性 1，我们称 *L* 为***NP-难***。我们还定义 NPC 为 NP 完全语言的类。
- en: As the following theorem shows, NP-completeness is at the crux of deciding whether
    P is in fact equal to NP.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 正如下面的定理所示，NP 完全性是决定 P 是否实际上等于 NP 的关键。
- en: '***Theorem 34.4***'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 34.4***'
- en: If any NP-complete problem is polynomial-time solvable, then P = NP. Equivalently,
    if any problem in NP is not polynomial-time solvable, then no NP-complete problem
    is polynomial-time solvable.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任何 NP 完全问题是多项式时间可解的，则 P = NP。换句话说，如果 NP 中的任何问题不是多项式时间可解的，则没有 NP 完全问题是多项式时间可解的。
- en: '![art](images/Art_P1440.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1440.jpg)'
- en: '**Figure 34.6** How most theoretical computer scientists view the relationships
    among P, NP, and NPC. Both P and NPC are wholly contained within NP, and P ∩ NPC
    = Ø.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 34.6** 大多数理论计算机科学家如何看待 P、NP 和 NPC 之间的关系。P 和 NPC 都完全包含在 NP 中，且 P ∩ NPC =
    Ø。'
- en: '***Proof***   Suppose that *L* ∈ P and also that *L* ∈ NPC. For any *L*′ ∈
    NP, we have *L*′ ≤[P] *L* by property 2 of the definition of NP-completeness.
    Thus, by Lemma 34.3, we also have that *L*′ ∈ P, which proves the first statement
    of the theorem.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   假设 *L* ∈ P 并且 *L* ∈ NPC。对于任何 *L*′ ∈ NP，根据 NP 完全性定义的属性 2，我们有 *L*′
    ≤[P] *L*。因此，根据引理 34.3，我们也有 *L*′ ∈ P，这证明了定理的第一个陈述。'
- en: 'To prove the second statement, consider the contrapositive of the first statement:
    if P ≠ NP, then there does not exist an NP-complete problem that is polynomial-time
    solvable. But P ≠ NP means that there is some problem in NP that is not polynomial-time
    solvable, and hence the second statement is the contrapositive of the first statement.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 要证明第二个陈述，考虑第一个陈述的逆否命题：如果 P ≠ NP，则不存在一个多项式时间可解的 NP 完全问题。但是 P ≠ NP 意味着存在一个 NP
    中不可多项式时间可解的问题，因此第二个陈述是第一个陈述的逆否命题。
- en: ▪
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: It is for this reason that research into the P ≠ NP question centers around
    the NP-complete problems. Most theoretical computer scientists believe that P
    ≠ NP, which leads to the relationships among P, NP, and NPC shown in [Figure 34.6](chapter034.xhtml#Fig_34-6).
    For all we know, however, someone may yet come up with a polynomial-time algorithm
    for an NP-complete problem, thus proving that P = NP. Nevertheless, since no polynomial-time
    algorithm for any NP-complete problem has yet been discovered, a proof that a
    problem is NP-complete provides excellent evidence that it is intractable.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 正是因为这个原因，对 P ≠ NP 问题的研究集中在 NP 完全问题上。大多数理论计算机科学家相信 P ≠ NP，这导致了 P、NP 和 NPC 之间的关系，如[图
    34.6](chapter034.xhtml#Fig_34-6)所示。然而，据我们所知，有人可能会为 NP 完全问题提出多项式时间算法，从而证明 P = NP。然而，由于尚未发现任何
    NP 完全问题的多项式时间算法，证明一个问题是 NP 完全的提供了它是难以解决的极好证据。
- en: '**Circuit satisfiability**'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '**电路可满足性**'
- en: 'We have defined the notion of an NP-complete problem, but up to this point,
    we have not actually proved that any problem is NP-complete. Once we prove that
    at least one problem is NP-complete, polynomial-time reducibility becomes a tool
    to prove other problems to be NP-complete. Thus, we now focus on demonstrating
    the existence of an NP-complete problem: the circuit-satisfiability problem.'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了 NP 完全问题的概念，但到目前为止，我们实际上还没有证明任何问题是 NP 完全的。一旦我们证明至少一个问题是 NP 完全的，多项式时间可减性就成为证明其他问题是
    NP 完全的工具。因此，我们现在专注于证明存在一个 NP 完全问题：电路可满足性问题。
- en: Unfortunately, the formal proof that the circuit-satisfiability problem is NP-complete
    requires technical detail beyond the scope of this text. Instead, we’ll informally
    describe a proof that relies on a basic understanding of boolean combinational
    circuits.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，证明电路可满足性问题是 NP 完全需要超出本文范围的技术细节。相反，我们将非正式地描述一个依赖于布尔组合电路基本理解的证明。
- en: '![art](images/Art_P1441.jpg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1441.jpg)'
- en: '**Figure 34.7** Three basic logic gates, with binary inputs and outputs. Under
    each gate is the truth table that describes the gate’s operation. **(a)** The
    NOT gate. **(b)** The AND gate. **(c)** The OR gate.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 34.7** 三个基本逻辑门，具有二进制输入和输出。在每个门下面是描述门操作的真值表。**(a)** NOT 门。**(b)** AND 门。**(c)**
    OR 门。'
- en: Boolean combinational circuits are built from boolean combinational elements
    that are interconnected by wires. A ***boolean combinational element*** is any
    circuit element that has a constant number of boolean inputs and outputs and that
    performs a well-defined function. Boolean values are drawn from the set {0, 1},
    where 0 represents FALSE and 1 represents TRUE.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔组合电路是由互相连接的布尔组合元件构建的。***布尔组合元件*** 是任何具有固定数量的布尔输入和输出并执行明确定义功能的电路元件。布尔值来自集合
    {0, 1}，其中 0 表示 FALSE，1 表示 TRUE。
- en: 'The boolean combinational elements appearing in the circuit-satisfiability
    problem compute simple boolean functions, and they are known as ***logic gates***.
    [Figure 34.7](chapter034.xhtml#Fig_34-7) shows the three basic logic gates used
    in the circuit-satisfiability problem: the ***NOT gate*** (or ***inverter***),
    the ***AND gate***, and the ***OR gate***. The NOT gate takes a single binary
    ***input*** *x*, whose value is either 0 or 1, and produces a binary ***output*** *z*
    whose value is opposite that of the input value. Each of the other two gates takes
    two binary inputs *x* and *y* and produces a single binary output *z*.'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 电路可满足性问题中出现的布尔组合元素计算简单的布尔函数，它们被称为***逻辑门***。[图 34.7](chapter034.xhtml#Fig_34-7)展示了电路可满足性问题中使用的三种基本逻辑门：***非门***（或***反相器***）、***与门***和***或门***。非门接收单个二进制***输入***
    *x*，其值为0或1，并产生一个二进制***输出*** *z*，其值与输入值相反。其他两个门分别接收两个二进制输入 *x* 和 *y*，并产生单个二进制输出
    *z*。
- en: The operation of each gate, or of any boolean combinational element, is defined
    by a ***truth table***, shown under each gate in [Figure 34.7](chapter034.xhtml#Fig_34-7).
    A truth table gives the outputs of the combinational element for each possible
    setting of the inputs. For example, the truth table for the OR gate says that
    when the inputs are *x* = 0 and *y* = 1, the output value is *z* = 1\. The symbol
    ¬ denotes the NOT function, ∧ denotes the AND function, and ∨ denotes the OR function.
    Thus, for example, 0 ∨ 1 = 1.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 每个门的操作，或任何布尔组合元素的操作，由一个***真值表***定义，在[图 34.7](chapter034.xhtml#Fig_34-7)中的每个门下方显示。真值表给出了组合元素在每种可能的输入设置下的输出。例如，或门的真值表表示当输入为
    *x* = 0 和 *y* = 1 时，输出值为 *z* = 1。符号 ¬ 表示非函数，∧ 表示与函数，∨ 表示或函数。因此，例如，0 ∨ 1 = 1。
- en: AND and OR gates are not limited to just two inputs. An AND gate’s output is
    1 if all of its inputs are 1, and its output is 0 otherwise. An OR gate’s output
    is 1 if any of its inputs are 1, and its output is 0 otherwise.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 与门和或门不仅限于两个输入。与门的输出在所有输入为1时为1，否则为0。或门的输出在任何输入为1时为1，否则为0。
- en: A ***boolean combinational circuit*** consists of one or more boolean combinational
    elements interconnected by ***wires***. A wire can connect the output of one element
    to the input of another, so that the output value of the first element becomes
    an input value of the second. [Figure 34.8](chapter034.xhtml#Fig_34-8) shows two
    similar boolean combinational circuits, differing in only one gate. Part (a) of
    the figure also shows the values on the individual wires, given the input 〈*x*[1]
    = 1, *x*[2] = 1, *x*[3] = 0〉. Although a single wire may have no more than one
    combinational-element output connected to it, it can feed several element inputs.
    The number of element inputs fed by a wire is called the ***fan-out*** of the
    wire. If no element output is connected to a wire, the wire is a ***circuit input***,
    accepting input values from an external source. If no element input is connected
    to a wire, the wire is a ***circuit output***, providing the results of the circuit’s
    computation to the outside world. (An internal wire can also fan out to a circuit
    output.) For the purpose of defining the circuit-satisfiability problem, we limit
    the number of circuit outputs to 1, though in actual hardware design, a boolean
    combinational circuit may have multiple outputs.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 一个***布尔组合电路***由一个或多个布尔组合元素通过***导线***相互连接而成。一根导线可以连接一个元素的输出到另一个元素的输入，使得第一个元素的输出值成为第二个元素的输入值。[图
    34.8](chapter034.xhtml#Fig_34-8)展示了两个类似的布尔组合电路，仅在一个门上有所不同。图中的部分（a）还展示了在给定输入 〈*x*[1]
    = 1, *x*[2] = 1, *x*[3] = 0〉 的情况下，各个导线上的值。虽然一根导线可能只连接一个组合元素的输出，但它可以连接多个元素的输入。一根导线连接的元素输入的数量称为导线的***出度***。如果一根导线没有连接任何元素的输出，则该导线是一个***电路输入***，接受来自外部源的输入值。如果一根导线没有连接任何元素的输入，则该导线是一个***电路输出***，将电路计算的结果提供给外部世界。（内部导线也可以连接到电路输出。）为了定义电路可满足性问题，我们将电路输出的数量限制为1，尽管在实际硬件设计中，布尔组合电路可能有多个输出。
- en: '![art](images/Art_P1442.jpg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1442.jpg)'
- en: '**Figure 34.8** Two instances of the circuit-satisfiability problem. **(a)**
    The assignment 〈*x*[1] = 1, *x*[2] = 1, *x*[3] = 0〉 to the inputs of this circuit
    causes the output of the circuit to be 1\. The circuit is therefore satisfiable.
    **(b)** No assignment to the inputs of this circuit can cause the output of the
    circuit to be 1\. The circuit is therefore unsatisfiable.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 34.8** 电路可满足性问题的两个实例。**(a)** 对该电路的输入进行赋值 〈*x*[1] = 1, *x*[2] = 1, *x*[3]
    = 0〉 会导致电路的输出为1。因此，电路是可满足的。**(b)** 对该电路的输入进行任何赋值都无法使电路的输出为1。因此，电路是不可满足的。'
- en: Boolean combinational circuits contain no cycles. In other words, for a given
    combinational circuit, imagine a directed graph *G* = (*V*, *E*) with one vertex
    for each combinational element and with *k* directed edges for each wire whose
    fan-out is *k*, where the graph contains a directed edge (*u*, *v*) if a wire
    connects the output of element *u* to an input of element *v*. Then *G* must be
    acyclic.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔组合电路不包含循环。换句话说，对于给定的组合电路，想象一个有向图 *G* = (*V*, *E*)，其中每个组合元素对应一个顶点，每个具有 *k*
    个出度的导线对应 *k* 条有向边，如果一条导线连接元素 *u* 的输出到元素 *v* 的输入，则图中包含一条从 *u* 指向 *v* 的有向边。那么 *G*
    必须是无环的。
- en: 'A ***truth assignment*** for a boolean combinational circuit is a set of boolean
    input values. We say that a 1-output boolean combinational circuit is ***satisfiable***
    if it has a ***satisfying assignment***: a truth assignment that causes the output
    of the circuit to be 1\. For example, the circuit in [Figure 34.8(a)](chapter034.xhtml#Fig_34-8)
    has the satisfying assignment 〈*x*[1] = 1, *x*[2] = 1, *x*[3] = 0〉, and so it
    is satisfiable. As Exercise 34.3-1 asks you to show, no assignment of values to
    *x*[1], *x*[2], and *x*[3] causes the circuit in [Figure 34.8(b)](chapter034.xhtml#Fig_34-8)
    to produce a 1 output. Since it always produces 0, it is unsatisfiable.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 对于布尔组合电路的***真值赋值***是一组布尔输入值。我们说一个1输出的布尔组合电路是***可满足的***，如果它有一个***满足赋值***：一个使电路输出为1的真值赋值。例如，[图34.8(a)](chapter034.xhtml#Fig_34-8)中的电路有满足赋值〈*x*[1]
    = 1, *x*[2] = 1, *x*[3] = 0〉，因此它是可满足的。正如练习34.3-1要求你展示的那样，对*x*[1]、*x*[2]和*x*[3]的值进行任何赋值都不会使[图34.8(b)](chapter034.xhtml#Fig_34-8)中的电路产生1输出。因为它总是产生0，所以它是不可满足的。
- en: The ***circuit-satisfiability problem*** is, “Given a boolean combinational
    circuit composed of AND, OR, and NOT gates, is it satisfiable?” In order to pose
    this question formally, however, we must agree on a standard encoding for circuits.
    The ***size*** of a boolean combinational circuit is the number of boolean combinational
    elements plus the number of wires in the circuit. We could devise a graph-like
    encoding that maps any given circuit *C* into a binary string 〈*C*〉 whose length
    is polynomial in the size of the circuit itself. As a formal language, we can
    therefore define
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '***电路可满足性问题***是，“给定由AND、OR和NOT门组成的布尔组合电路，它是否可满足？”然而，为了正式提出这个问题，我们必须就电路的标准编码达成一致。布尔组合电路的***大小***是电路中布尔组合元素的数量加上电路中的线的数量。我们可以设计一种类似图形的编码，将任何给定的电路*C*映射到一个二进制字符串〈*C*〉，其长度与电路本身的大小多项式成正比。因此，作为一个形式语言，我们可以定义'
- en: 'CIRCUIT-SAT = {〈*C*〉 : *C* is a satisfiable boolean combinational circuit}.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 'CIRCUIT-SAT = {〈*C*〉 : *C*是一个可满足的布尔组合电路}。'
- en: 'The circuit-satisfiability problem arises in the area of computer-aided hardware
    optimization. If a subcircuit always produces 0, that subcircuit is unnecessary:
    the designer can replace it by a simpler subcircuit that omits all logic gates
    and provides the constant 0 value as its output. You can see the value in having
    a polynomial-time algorithm for this problem.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 电路可满足性问题出现在计算机辅助硬件优化领域。如果一个子电路总是产生0，那么这个子电路是不必要的：设计者可以用一个更简单的子电路替换它，省略所有逻辑门，并提供常数0值作为输出。你可以看到拥有一个多项式时间算法解决这个问题的价值。
- en: Given a circuit *C*, you can determine whether it is satisfiable by simply checking
    all possible assignments to the inputs. Unfortunately, if the circuit has *k*
    inputs, then you would have to check up to 2^(*k*) possible assignments. When
    the size of *C* is polynomial in *k*, checking all possible assignments to the
    inputs takes Ω(2^(*k*)) time, which is superpolynomial in the size of the circuit.^([10](#footnote_10))
    In fact, as we have claimed, there is strong evidence that no polynomial-time
    algorithm exists that solves the circuit-satisfiability problem because circuit
    satisfiability is NP-complete. We break the proof of this fact into two parts,
    based on the two parts of the definition of NP-completeness.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个电路*C*，你可以通过简单地检查所有可能的输入赋值来确定它是否可满足。不幸的是，如果电路有*k*个输入，那么你将不得不检查多达2^(*k*)个可能的赋值。当*C*的大小与*k*的多项式成正比时，检查所有可能的输入赋值需要Ω(2^(*k*))时间，这在电路大小方面是超多项式的。事实上，正如我们所声称的，强有力的证据表明不存在解决电路可满足性问题的多项式时间算法，因为电路可满足性是NP完全的。我们将这个事实的证明分为两部分，基于NP完全性定义的两部分。
- en: '***Lemma 34.5***'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理34.5***'
- en: The circuit-satisfiability problem belongs to the class NP.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 电路可满足性问题属于NP类。
- en: '***Proof***   We provide a two-input, polynomial-time algorithm *A* that can
    verify CIRCUIT-SAT. One of the inputs to *A* is (a standard encoding of) a boolean
    combinational circuit *C*. The other input is a certificate corresponding to an
    assignment of a boolean value to each of the wires in *C*. (See Exercise 34.3-4
    for a smaller certificate.)'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   我们提供一个两输入的多项式时间算法*A*，可以验证CIRCUIT-SAT。*A*的一个输入是（一个标准编码的）布尔组合电路*C*。另一个输入是对*C*中每个线赋予布尔值的证书。
    (参见练习34.3-4以获得一个更小的证书。)'
- en: The algorithm *A* works as follows. For each logic gate in the circuit, it checks
    that the value provided by the certificate on the output wire is correctly computed
    as a function of the values on the input wires. Then, if the output of the entire
    circuit is 1, algorithm *A* outputs 1, since the values assigned to the inputs
    of *C* provide a satisfying assignment. Otherwise, *A* outputs 0.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 算法*A*的工作方式如下。对于电路中的每个逻辑门，它检查证书在输出线上提供的值是否正确地作为输入线上值的函数计算。然后，如果整个电路的输出为1，算法*A*输出1，因为分配给*C*输入的值提供了一个满足赋值。否则，*A*输出0。
- en: Whenever a satisfiable circuit *C* is input to algorithm *A*, there exists a
    certificate whose length is polynomial in the size of *C* and that causes *A*
    to output a 1\. Whenever an unsatisfiable circuit is input, no certificate can
    fool *A* into believing that the circuit is satisfiable. Algorithm *A* runs in
    polynomial time, and with a good implementation, linear time suffices. Thus, CIRCUIT-SAT
    is verifiable in polynomial time, and CIRCUIT-SAT ∈ NP.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 每当一个可满足电路*C*输入算法*A*时，存在一个长度与*C*的大小多项式成正比的证书，使得*A*输出1。当输入一个不可满足电路时，没有证书能够欺骗*A*认为电路是可满足的。算法*A*在多项式时间内运行，通过良好的实现，线性时间就足够了。因此，CIRCUIT-SAT在多项式时间内是可验证的，且CIRCUIT-SAT
    ∈ NP。
- en: ▪
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: 'The second part of proving that CIRCUIT-SAT is NP-complete is to show that
    the language is NP-hard: that *every* language in NP is polynomial-time reducible
    to CIRCUIT-SAT. The actual proof of this fact is full of technical intricacies,
    and so instead we’ll sketch the proof based on some understanding of the workings
    of computer hardware.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 证明CIRCUIT-SAT是NP完全的第二部分是展示该语言是NP难的：即*每个*NP中的语言都可以多项式时间归约到CIRCUIT-SAT。这个事实的实际证明充满了技术细节，因此我们将根据对计算机硬件工作原理的一些理解概述证明。
- en: A computer program is stored in the computer’s memory as a sequence of instructions.
    A typical instruction encodes an operation to be performed, addresses of operands
    in memory, and an address where the result is to be stored. A special memory location,
    called the ***program counter***, keeps track of which instruction is to be executed
    next. The program counter automatically increments when each instruction is fetched,
    thereby causing the computer to execute instructions sequentially. Certain instructions
    can cause a value to be written to the program counter, however, which alters
    the normal sequential execution and allows the computer to loop and perform conditional
    branches.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机程序存储在计算机内存中作为一系列指令。典型指令编码了要执行的操作，内存中操作数的地址，以及结果存储的地址。一个特殊的内存位置，称为***程序计数器***，跟踪下一个要执行的指令。当每条指令被获取时，程序计数器会自动递增，从而导致计算机按顺序执行指令。然而，某些指令可以导致值被写入程序计数器，从而改变正常的顺序执行，使计算机循环执行和执行条件分支。
- en: At any point while a program executes, the computer’s memory holds the entire
    state of the computation. (Consider the memory to include the program itself,
    the program counter, working storage, and any of the various bits of state that
    a computer maintains for bookkeeping.) We call any particular state of computer
    memory a ***configuration***. When an instruction executes, it transforms the
    configuration. Think of an instruction as mapping one configuration to another.
    The computer hardware that accomplishes this mapping can be implemented as a boolean
    combinational circuit, which we denote by *M* in the proof of the following lemma.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 在程序执行时的任何时刻，计算机内存保存了计算的整个状态。（考虑内存包括程序本身、程序计数器、工作存储以及计算机为簿记而维护的各种状态位。）我们将计算机内存的任何特定状态称为***配置***。当一条指令执行时，它会转换配置。将一条指令视为将一个配置映射到另一个配置。实现此映射的计算机硬件可以作为布尔组合电路实现，我们在以下引理的证明中用*M*表示。
- en: '***Lemma 34.6***'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 34.6***'
- en: The circuit-satisfiability problem is NP-hard.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 电路可满足性问题是NP难的。
- en: '***Proof***   Let *L* be any language in NP. We’ll describe a polynomial-time
    algorithm *F* computing a reduction function *f* that maps every binary string
    *x* to a circuit *C* = *f* (*x*) such that *x* ∈ *L* if and only if *C* ∈ CIRCUIT-SAT.'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   设*L*是NP中的任意语言。我们将描述一个多项式时间算法*F*，计算一个将每个二进制字符串*x*映射到电路*C* = *f*(*x*)的归约函数*f*，使得*x*
    ∈ *L*当且仅当*C* ∈ CIRCUIT-SAT。'
- en: Since *L* ∈ NP, there must exist an algorithm *A* that verifies *L* in polynomial
    time. The algorithm *F* that we construct uses the two-input algorithm *A* to
    compute the reduction function *f*.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 由于*L* ∈ NP，必须存在一个在多项式时间内验证*L*的算法*A*。我们构建的算法*F*使用两输入算法*A*来计算归约函数*f*。
- en: Let *T* (*n*) denote the worst-case running time of algorithm *A* on length-*n*
    input strings, and let *k* ≥ 1 be a constant such that *T* (*n*) = *O*(*n^k*)
    and the length of the certificate is *O*(*n^k*). (The running time of *A* is actually
    a polynomial in the total input size, which includes both an input string and
    a certificate, but since the length of the certificate is polynomial in the length
    *n* of the input string, the running time is polynomial in *n*.)
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 让*T*(*n*)表示算法*A*在长度为*n*的输入字符串上的最坏情况运行时间，让*k* ≥ 1是一个常数，使得*T*(*n*) = *O*(*n^k*)且证书的长度为*O*(*n^k*)。（*A*的运行时间实际上是总输入大小的多项式，包括输入字符串和证书，但由于证书的长度是输入字符串长度*n*的多项式，因此运行时间是*n*的多项式。）
- en: '![art](images/Art_P1443.jpg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1443.jpg)'
- en: '**Figure 34.9** The sequence of configurations produced by an algorithm *A*
    running on an input *x* and certificate *y*. Each configuration represents the
    state of the computer for one step of the computation and, besides *A*, *x*, and
    *y*, includes the program counter (PC), auxiliary machine state, and working storage.
    Except for the certificate *y*, the initial configuration *c*[0] is constant.
    A boolean combinational circuit *M* maps each configuration to the next configuration.
    The output is a distinguished bit in the working storage.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 34.9** 算法*A*在输入*x*和证书*y*上运行产生的配置序列。每个配置表示计算机在计算的一步中的状态，并且除了*A*、*x*和*y*之外，还包括程序计数器（PC）、辅助机器状态和工作存储。除了证书*y*外，初始配置*c*[0]是恒定的。一个布尔组合电路*M*将每个配置映射到下一个配置。输出是工作存储中的一个特定位。'
- en: 'The basic idea of the proof is to represent the computation of *A* as a sequence
    of configurations. As [Figure 34.9](chapter034.xhtml#Fig_34-9) illustrates, consider
    each configuration as comprising a few parts: the program for *A*, the program
    counter and auxiliary machine state, the input *x*, the certificate *y*, and working
    storage. The combinational circuit *M*, which implements the computer hardware,
    maps each configuration *c[i]* to the next configuration *c*[*i*+1], starting
    from the initial configuration *c*[0]. Algorithm *A* writes its output—0 or 1—to
    some designated location by the time it finishes executing. After *A* halts, the
    output value never changes. Thus, if the algorithm runs for at most *T* (*n*)
    steps, the output appears as one of the bits in *c[T]*(*n*).'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 证明的基本思想是将计算*A*的过程表示为一系列配置。如[图34.9](chapter034.xhtml#Fig_34-9)所示，将每个配置视为包含几个部分：*A*的程序、程序计数器和辅助机器状态、输入*x*、证书*y*和工作存储。实现计算机硬件的组合电路*M*将每个配置*c[i]*映射到下一个配置*c*[*i*+1]，从初始配置*c*[0]开始。算法*A*在执行完毕时将其输出（0或1）写入到指定位置。*A*停止后，输出值不会再改变。因此，如果算法运行最多*T*(*n*)步，则输出将出现在*c[T]*(*n*)的某一位上。
- en: The reduction algorithm *F* constructs a single combinational circuit that computes
    all configurations produced by a given initial configuration. The idea is to paste
    together *T* (*n*) copies of the circuit *M*. The output of the *i*th circuit,
    which produces configuration *c[i]*, feeds directly into the input of the (*i*
    +1)st circuit. Thus, the configurations, rather than being stored in the computer’s
    memory, simply reside as values on the wires connecting copies of *M*.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 缩减算法*F*构建一个单一的组合电路，计算给定初始配置产生的所有配置。其思想是将*T*(*n*)个电路*M*的副本粘贴在一起。第*i*个电路的输出，产生配置*c[i]*，直接输入到第（*i*+1）个电路中。因此，配置不是存储在计算机内存中，而是作为连接*M*副本的电线上的值存在。
- en: Recall what the polynomial-time reduction algorithm *F* must do. Given an input
    *x*, it must compute a circuit *C* = *f* (*x*) that is satisfiable if and only
    if there exists a certificate *y* such that *A*(*x*, *y*) = 1\. When *F* obtains
    an input *x*, it first computes *n* = |*x*| and constructs a combinational circuit
    *C*′ consisting of *T* (*n*) copies of *M*. The input to *C*′ is an initial configuration
    corresponding to a computation on *A*(*x*, *y*), and the output is the configuration
    *c[T]*(*n*).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾多项式时间缩减算法*F*必须做的事情。给定一个输入*x*，它必须计算一个电路*C* = *f*(*x*)，当且仅当存在一个证书*y*使得*A*(*x*,
    *y*) = 1时，该电路是可满足的。当*F*获得一个输入*x*时，首先计算*n* = |*x*|，并构建由*T*(*n*)个*M*副本组成的组合电路*C*′。*C*′的输入是与*A*(*x*,
    *y*)上的计算对应的初始配置，输出是配置*c[T]*(*n*)。
- en: Algorithm *F* modifies circuit *C*′ slightly to construct the circuit *C* =
    *f* (*x*). First, it wires the inputs to *C*′ corresponding to the program for
    *A*, the initial program counter, the input *x*, and the initial state of memory
    directly to these known values. Thus, the only remaining inputs to the circuit
    correspond to the certificate *y*. Second, it ignores all outputs from *C*′, except
    for the one bit of *c[T]*(*n*) corresponding to the output of *A*. This circuit
    *C*, so constructed, computes *C*(*y*) = *A*(*x*, *y*) for any input *y* of length
    *O*(*n^k*). The reduction algorithm *F*, when provided an input string *x*, computes
    such a circuit *C* and outputs it.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 算法*F*稍微修改电路*C*′以构建电路*C* = *f*(*x*)。首先，将输入连接到*C*′对应于*A*的程序、初始程序计数器、输入*x*和内存的初始状态的已知值。因此，电路的唯一剩余输入对应于证书*y*。其次，忽略*C*′的所有输出，除了与*A*的输出对应的*c[T]*(*n*)的一位。这样构建的电路*C*，计算任何长度为*O*(*n^k*)的输入*y*的*C*(*y*)
    = *A*(*x*, *y*)。当提供输入字符串*x*时，缩减算法*F*计算这样一个电路*C*并输出它。
- en: We need to prove two properties. First, we must show that *F* correctly computes
    a reduction function *f*. That is, we must show that *C* is satisfiable if and
    only if there exists a certificate *y* such that *A*(*x*, *y*) = 1\. Second, we
    must show that *F* runs in polynomial time.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要证明两个性质。首先，我们必须证明*F*正确计算一个缩减函数*f*。也就是说，我们必须证明当且仅当存在一个证书*y*使得*A*(*x*, *y*)
    = 1时，*C*是可满足的。其次，我们必须证明*F*在多项式时间内运行。
- en: To show that *F* correctly computes a reduction function, suppose that there
    exists a certificate *y* of length *O*(*n^k*) such that *A*(*x*, *y*) = 1\. Then,
    upon applying the bits of *y* to the inputs of *C*, the output of *C* is *C*(*y*)
    = *A*(*x*, *y*) = 1\. Thus, if a certificate exists, then *C* is satisfiable.
    For the other direction, suppose that *C* is satisfiable. Hence, there exists
    an input *y* to *C* such that *C*(*y*) = 1, from which we conclude that *A*(*x*,
    *y*) = 1\. Thus, *F* correctly computes a reduction function.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 要证明*F*正确计算一个缩减函数，假设存在一个长度为*O*(*n^k*)的证书*y*，使得*A*(*x*, *y*) = 1。那么，在将*y*的位应用于*C*的输入后，*C*的输出为*C*(*y*)
    = *A*(*x*, *y*) = 1。因此，如果存在一个证书，则*C*是可满足的。对于另一个方向，假设*C*是可满足的。因此，存在一个输入*y*到*C*，使得*C*(*y*)
    = 1，由此我们得出*A*(*x*, *y*) = 1。因此，*F*正确计算一个缩减函数。
- en: To complete the proof sketch, we need to show that *F* runs in time polynomial
    in *n* = |*x*|. First, the number of bits required to represent a configuration
    is polynomial in *n*. Why? The program for *A* itself has constant size, independent
    of the length of its input *x*. The length of the input *x* is *n*, and the length
    of the certificate *y* is *O*(*n^k*). Since the algorithm runs for at most *O*(*n^k*)
    steps, the amount of working storage required by *A* is polynomial in *n* as well.
    (We implicitly assume that this memory is contiguous. Exercise 34.3-5 asks you
    to extend the argument to the situation in which the locations accessed by *A*
    are scattered across a much larger region of memory and the particular pattern
    of scattering can differ for each input *x*.)
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成证明概述，我们需要展示*F*在长度为*n* = |*x*|的多项式时间内运行。首先，表示一个配置所需的比特数是*n*的多项式。为什么？算法*A*本身的程序大小是常数，与其输入*x*的长度无关。输入*x*的长度为*n*，证书*y*的长度为*O*(*n^k*)。由于算法运行的步数最多为*O*(*n^k*)步，因此*A*所需的工作存储量也是*n*的多项式。（我们隐含地假设这个内存是连续的。练习34.3-5要求您将这个论点扩展到*A*访问的位置分散在一个更大的内存区域中，而且每个输入*x*的访问模式可能不同的情况。）
- en: The combinational circuit *M* implementing the computer hardware has size polynomial
    in the length of a configuration, which is *O*(*n^k*), and hence, the size of
    *M* is polynomial in *n*. (Most of this circuitry implements the logic of the
    memory system.) The circuit *C* consists of *O*(*n^k*) copies of *M*, and hence
    it has size polynomial in *n*. The reduction algorithm *F* can construct *C* from
    *x* in polynomial time, since each step of the construction takes polynomial time.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 实现计算机硬件的组合电路*M*的大小与配置长度的多项式成正比，即*O*(*n^k*)，因此，*M*的大小与*n*成多项式关系。（这个电路的大部分部分实现了存储系统的逻辑。）电路*C*由*O*(*n^k*)个*M*的副本组成，因此它的大小与*n*成多项式关系。归约算法*F*可以在多项式时间内从*x*构造出*C*，因为构造的每一步都需要多项式时间。
- en: ▪
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: The language CIRCUIT-SAT is therefore at least as hard as any language in NP,
    and since it belongs to NP, it is NP-complete.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，CIRCUIT-SAT语言至少与NP中的任何语言一样困难，而且由于它属于NP，它是NP完全的。
- en: '***Theorem 34.7***'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理34.7***'
- en: The circuit-satisfiability problem is NP-complete.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 电路可满足性问题是NP完全的。
- en: '***Proof***   Immediate from Lemmas 34.5 and 34.6 and from the definition of
    NP-completeness.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   直接根据引理34.5和34.6以及NP完全性的定��得出。'
- en: ▪
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Exercises**'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***34.3-1***'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.3-1***'
- en: Verify that the circuit in [Figure 34.8(b)](chapter034.xhtml#Fig_34-8) is unsatisfiable.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 验证[图34.8(b)](chapter034.xhtml#Fig_34-8)中的电路是否不可满足。
- en: '***34.3-2***'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.3-2***'
- en: Show that the ≤[P] relation is a transitive relation on languages. That is,
    show that if *L*[1] ≤[P] *L*[2] and *L*[2] ≤[P] *L*[3], then *L*[1] ≤[P] *L*[3].
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 证明≤[P]关系是语言上的一个传递关系。也就是说，证明如果*L*[1] ≤[P] *L*[2]和*L*[2] ≤[P] *L*[3]，那么*L*[1]
    ≤[P] *L*[3]。
- en: '***34.3-3***'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.3-3***'
- en: Prove that *L* ≤[P] *L* if and only if *L* ≤[P] *L*.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 证明*L* ≤[P] *L*当且仅当*L* ≤[P] *L*。
- en: '***34.3-4***'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.3-4***'
- en: Show that an alternative proof of Lemma 34.5 can use a satisfying assignment
    as a certificate. Which certificate makes for an easier proof?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 证明引理34.5的另一种方法可以使用一个满足的赋值作为证书。哪种证书更容易进行证明？
- en: '***34.3-5***'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.3-5***'
- en: The proof of Lemma 34.6 assumes that the working storage for algorithm *A* occupies
    a contiguous region of polynomial size. Where does the proof exploit this assumption?
    Argue that this assumption does not involve any loss of generality.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 引理34.6的证明假设算法*A*的工作存储占据一个多项式大小的连续区域。证明中的哪里利用了这个假设？论证这个假设不涉及任何广义性的损失。
- en: '***34.3-6***'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.3-6***'
- en: A language *L* is ***complete*** for a language class *C* with respect to polynomial-time
    reductions if *L* ∈ *C* and *L*′ ≤[P] *L* for all *L*′ ∈ *C*. Show that Ø and
    {0, 1}* are the only languages in P that are not complete for P with respect to
    polynomial-time reductions.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个语言*L*，如果*L* ∈ *C*且对于所有*L*′ ∈ *C*，*L*′ ≤[P] *L*，则*L*相对于多项式时间归约是***完全***的。证明Ø和{0,
    1}*是P中唯一不相对于多项式时间归约是完全的语言。
- en: '***34.3-7***'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.3-7***'
- en: Show that, with respect to polynomial-time reductions (see Exercise 34.3-6),
    *L* is complete for NP if and only if *L* is complete for co-NP.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 证明，关于多项式时间归约（见练习34.3-6），如果*L*对于NP是完全的，当且仅当*L*对于co-NP是完全的。
- en: '***34.3-8***'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.3-8***'
- en: The reduction algorithm *F* in the proof of Lemma 34.6 constructs the circuit
    *C* = *f* (*x*) based on knowledge of *x*, *A*, and *k*. Professor Sartre observes
    that the string *x* is input to *F*, but only the existence of *A*, *k*, and the
    constant factor implicit in the *O*(*n^k*) running time is known to *F* (since
    the language *L* belongs to NP), not their actual values. Thus, the professor
    concludes that *F* cannot possibly construct the circuit *C* and that the language
    CIRCUIT-SAT is not necessarily NP-hard. Explain the flaw in the professor’s reasoning.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 引理34.6证明中的归约算法*F*基于*x*、*A*和*k*的知识构造电路*C* = *f* (*x*)。Sartre教授观察到字符串*x*是*F*的输入，但*F*只知道*A*、*k*和*O*(*n^k*)运行时间中的常数因子的存在（因为语言*L*属于NP），而不知道它们的实际值。因此，教授得出结论说*F*不可能构造电路*C*，并且CIRCUIT-SAT语言不一定是NP困难的。解释教授推理中的错误。
- en: '[**34.4    NP-completeness proofs**](toc.xhtml#Rh1-202)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[**34.4    NP完全性证明**](toc.xhtml#Rh1-202)'
- en: The proof that the circuit-satisfiability problem is NP-complete showed directly
    that *L* ≤[P] CIRCUIT-SAT for every language *L* ∈ NP. This section shows how
    to prove that languages are NP-complete without directly reducing *every* language
    in NP to the given language. We’ll explore examples of this methodology by proving
    that various formula-satisfiability problems are NP-complete. [Section 34.5](chapter034.xhtml#Sec_34.5)
    provides many more examples.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 证明电路可满足性问题是NP完全直接表明*L* ≤[P] CIRCUIT-SAT对于每个*L* ∈ NP。本节展示了如何证明语言是NP完全而不直接将每个NP中的语言归约到给定语言。我们将通过证明各种公式可满足性问题是NP完全来探讨这种方法。[第34.5节](chapter034.xhtml#Sec_34.5)提供了更多的例子。
- en: The following lemma provides a foundation for showing that a given language
    is NP-complete.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的引理为证明给定语言是NP完全提供了基础。
- en: '***Lemma 34.8***'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理34.8***'
- en: If *L* is a language such that *L*′ ≤[P] *L* for some *L*′ ∈ NPC, then *L* is
    NP-hard. If, in addition, we have *L* ∈ NP, then *L* ∈ NPC.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 如果*L*是一种语言，使得存在*L*′ ∈ NPC，满足*L*′ ≤[P] *L*，那么*L*是 NP 难的。此外，如果*L* ∈ NP，那么*L* ∈
    NPC。
- en: '***Proof***   Since *L*′ is NP-complete, for all *L*″ ∈ NP, we have *L*″ ≤[P] *L*′.
    By supposition, we have *L*′ ≤[P] *L*, and thus by transitivity (Exercise 34.3-2),
    we have *L*″ ≤[P] *L*, which shows that *L* is NP-hard. If *L* ∈ NP, we also have
    *L* ∈ NPC.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 由于*L*′是 NP 完全的，对于所有*L*″ ∈ NP，我们有*L*″ ≤[P] *L*′。根据假设，我们有*L*′ ≤[P] *L*，因此根据传递性（练习
    34.3-2），我们有*L*″ ≤[P] *L*，这表明*L*是 NP 难的。如果*L* ∈ NP，我们也有*L* ∈ NPC。'
- en: ▪
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: 'In other words, by reducing a known NP-complete language *L*′ to *L*, we implicitly
    reduce every language in NP to *L*. Thus, Lemma 34.8 provides a method for proving
    that a language *L* is NP-complete:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，通过将已知的 NP 完全语言*L*′简化为*L*，我们隐式地将 NP 中的每种语言简化为*L*。因此，引理 34.8 提供了证明语言*L*是
    NP 完全的方法：
- en: Prove *L* ∈ NP.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明*L* ∈ NP。
- en: 'Prove that *L* is NP-hard:'
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 证明*L*是 NP 难的：
- en: a. Select a known NP-complete language *L*′.
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: a. 选择一个已知的 NP 完全语言*L*′。
- en: b. Describe an algorithm that computes a function *f* mapping every instance
    *x* ∈ {0, 1}* of *L*′ to an instance *f* (*x*) of *L*.
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: b. 描述一个计算函数*f*的算法，将*L*′中的每个实例*x* ∈ {0, 1}*映射到*L*的实例*f*(*x*)。
- en: c. Prove that the function *f* satisfies *x* ∈ *L*′ if and only if *f* (*x*)
    ∈ *L* for all *x* ∈ {0, 1}*.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: c. 证明函数*f*满足*x* ∈ *L*′当且仅当对于所有*x* ∈ {0, 1}*，*f*(*x*) ∈ *L*。
- en: d. Prove that the algorithm computing *f* runs in polynomial time.
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: d. 证明计算*f*的算法在多项式时间内运行。
- en: This methodology of reducing from a single known NP-complete language is far
    simpler than the more complicated process of showing directly how to reduce from
    every language in NP. Proving CIRCUIT-SAT ∈ NPC furnishes a starting point. Knowing
    that the circuit-satisfiability problem is NP-complete makes it much easier to
    prove that other problems are NP-complete. Moreover, as the catalog of known NP-complete
    problems grows, so will the choices for languages from which to reduce.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 从一个已知的 NP 完全语言简化的方法比直接展示如何从 NP 中的每个语言简化要简单得多。证明 CIRCUIT-SAT ∈ NPC 提供了一个起点。知道电路可满足性问题是
    NP 完全的，使得证明其他问题是 NP 完全的变得更容易。此外，随着已知的 NP 完全问题目录的增长，可以减少简化的语言选择。
- en: '**Formula satisfiability**'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**公式可满足性**'
- en: To illustrate the reduction methodology, let’s see an NP-completeness proof
    for the problem of determining whether a boolean *formula*, not a *circuit*, is
    satisfiable. This problem has the historical honor of being the first problem
    ever shown to be NP-complete.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明简化方法，让我们看一个确定布尔*公式*是否可满足的 NP 完全性证明，而不是一个*电路*。这个问题有历史荣誉，是第一个被证明为 NP 完全的问题。
- en: We formulate the ***(formula) satisfiability*** problem in terms of the language
    SAT as follows. An instance of SAT is a boolean formula *ϕ* composed of
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将***(公式)可满足性***问题表述为语言 SAT 如下。SAT 的一个实例是一个由
- en: '*n* boolean variables: *x*[1], *x*[2], … , *x[n]*;'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*n* 个布尔变量：*x*[1]，*x*[2]，…，*x[n]*；'
- en: '*m* boolean connectives: any boolean function with one or two inputs and one
    output, such as ∧ (AND), ∨ (OR), ¬ (NOT), → (implication), ↔ (if and only if);
    and'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*m* 个布尔连接符：任何具有一个或两个输入和一个输出的布尔函数，例如 ∧（与）、∨（或）、¬（非）、→（蕴含）、↔（当且仅当）；和'
- en: parentheses. (Without loss of generality, assume that there are no redundant
    parentheses, i.e., a formula contains at most one pair of parentheses per boolean
    connective.)
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 括号。（不失一般性，假设没有多余的括号，即一个公式中每个布尔连接符最多包含一对括号。）
- en: We can encode a boolean formula *ϕ* in a length that is polynomial in *n* +
    *m*. As in boolean combinational circuits, a ***truth assignment*** for a boolean
    formula *ϕ* is a set of values for the variables of *ϕ*, and a ***satisfying assignment***
    is a truth assignment that causes it to evaluate to 1\. A formula with a satisfying
    assignment is a ***satisfiable*** formula. The satisfiability problem asks whether
    a given boolean formula is satisfiable, which we can express in formal-language
    terms as
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用多项式长度对布尔公式*ϕ*进行编码，长度为*n* + *m*。与布尔组合电路一样，布尔公式*ϕ*的***真值赋值***是*ϕ*变量的一组值，***满足赋值***是使其评估为
    1 的真值赋值。具有满足赋值的公式是***可满足***的公式。可满足性问题询问给定的布尔公式是否可满足，我们可以用形式语言表达为
- en: 'SAT = {〈*ϕ*〉 : *ϕ* is a satisfiable boolean formula}.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: SAT = {〈*ϕ*〉：*ϕ*是一个可满足的布尔公式}。
- en: As an example, the formula
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，公式
- en: '*ϕ* = ((*x*[1] → *x*[2]) ∨ ¬((¬*x*[1] ↔ *x*[3]) ∨ *x*[4])) ∧ ¬*x*[2]'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '*ϕ* = ((*x*[1] → *x*[2]) ∨ ¬((¬*x*[1] ↔ *x*[3]) ∨ *x*[4])) ∧ ¬*x*[2]'
- en: has the satisfying assignment 〈*x*[1] = 0, *x*[2] = 0, *x*[3] = 1, *x*[4] =
    1〉, since
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 具有满足赋值〈*x*[1] = 0，*x*[2] = 0，*x*[3] = 1，*x*[4] = 1〉的公式，因为
- en: '![art](images/Art_P1444.jpg)'
  id: totrans-278
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1444.jpg)'
- en: and thus this formula *ϕ* belongs to SAT.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这个公式*ϕ*属于 SAT。
- en: The naive algorithm to determine whether an arbitrary boolean formula is satisfiable
    does not run in polynomial time. A formula with *n* variables has 2^(*n*) possible
    assignments. If the length of 〈*ϕ*〉 is polynomial in *n*, then checking every
    assignment requires Ω(2^(*n*)) time, which is superpolynomial in the length of
    〈*ϕ*〉. As the following theorem shows, a polynomial-time algorithm is unlikely
    to exist.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 确定任意布尔公式是否可满足的朴素算法不在多项式时间内运行。具有*n*个变量的公式有 2^(*n*) 种可能的赋值。如果〈*ϕ*〉的长度是*n*的多项式，那么检查每个赋值需要Ω(2^(*n*))时间，这在〈*ϕ*〉的长度中是超多项式的。如下定理所示，不太可能存在多项式时间算法。
- en: '***Theorem 34.9***'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 34.9***'
- en: Satisfiability of boolean formulas is NP-complete.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔公式的可满足性是 NP 完全的。
- en: '***Proof***   We start by arguing that SAT ∈ NP. Then we prove that SAT is
    NP-hard by showing that CIRCUIT-SAT ≤[P] SAT, which by Lemma 34.8 will prove the
    theorem.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 我们首先论证 SAT ∈ NP。然后通过展示 CIRCUIT-SAT ≤[P] SAT 来证明 SAT 是 NP 难的，这将证明定理。'
- en: To show that SAT belongs to NP, we show that a certificate consisting of a satisfying
    assignment for an input formula *ϕ* can be verified in polynomial time. The verifying
    algorithm simply replaces each variable in the formula with its corresponding
    value and then evaluates the expression, much as we did in equation (34.2) above.
    This task can be done in polynomial time. If the expression evaluates to 1, then
    the algorithm has verified that the formula is satisfiable. Thus, SAT belongs
    to NP.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明SAT属于NP，我们展示了一个由公式*ϕ*的可满足赋值组成的证书可以在多项式时间内验证。验证算法简单地用其对应值替换公式中的每个变量，然后评估表达式，就像我们在上面的方程(34.2)中所做的那样。这个任务可以在多项式时间内完成。如果表达式评估为1，则算法已验证公式是可满足的。因此，SAT属于NP。
- en: To prove that SAT is NP-hard, we show that CIRCUIT-SAT ≤[P] SAT. In other words,
    we need to show how to reduce any instance of circuit satisfiability to an instance
    of formula satisfiability in polynomial time. We can use induction to express
    any boolean combinational circuit as a boolean formula. We simply look at the
    gate that produces the circuit output and inductively express each of the gate’s
    inputs as formulas. We then obtain the formula for the circuit by writing an expression
    that applies the gate’s function to its inputs’ formulas.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 要证明SAT是NP难题，我们展示了CIRCUIT-SAT ≤[P] SAT。换句话说，我们需要展示如何在多项式时间内将任何电路可满足性实例减少为公式可满足性实例。我们可以使用归纳法将任何布尔组合电路表示为布尔公式。我们只需查看产生电路输出的门，并归纳地将每个门的输入表示为公式。然后，通过编写一个将门的功能应用于其输入公式的表达式来获得电路的公式。
- en: '![art](images/Art_P1445.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1445.jpg)'
- en: '**Figure 34.10** Reducing circuit satisfiability to formula satisfiability.
    The formula produced by the reduction algorithm has a variable for each wire in
    the circuit and a clause for each logic gate.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 34.10** 将电路可满足性减少为公式可满足性。减少算法生成的公式中，每根电路导线都有一个变量，每个逻辑门的操作都有一个子句。'
- en: Unfortunately, this straightforward method does not amount to a polynomial-time
    reduction. As Exercise 34.4-1 asks you to show, shared subformulas—which arise
    from gates whose output wires have fan-out of 2 or more—can cause the size of
    the generated formula to grow exponentially. Thus, the reduction algorithm must
    be somewhat more clever.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种直接的方法并不构成多项式时间的减少。正如34.4-1练习要求您展示的那样，共享子公式——这些子公式来自于输出导线具有2个或更多扇出的门——可能导致生成的公式的大小呈指数增长。因此，减少算法必须更加聪明一些。
- en: '[Figure 34.10](chapter034.xhtml#Fig_34-10) illustrates how to overcome this
    problem, using as an example the circuit from [Figure 34.8(a)](chapter034.xhtml#Fig_34-8).
    For each wire *x[i]* in the circuit *C*, the formula *ϕ* has a variable *x[i]*.
    To express how each gate operates, construct a small formula involving the variables
    of its incident wires. The formula has the form of an “if and only if” (↔), with
    the variable for the gate’s output on the left and on the right a logical expression
    encapsulating the gate’s function on its inputs. For example, the operation of
    the output AND gate (the rightmost gate in the figure) is *x*[10] ↔ (*x*[7] ∧
    *x*[8] ∧ *x*[9]). We call each of these small formulas a ***clause***.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 34.10](chapter034.xhtml#Fig_34-10)展示了如何克服这个问题，以[图 34.8(a)](chapter034.xhtml#Fig_34-8)中的电路为例。对于电路*C*中的每根导线*x[i]*，公式*ϕ*都有一个变量*x[i]*。为了表达每个门的操作方式，构建一个涉及其输入导线变量的小型公式。这个公式的形式是“当且仅当”(↔)，门的输出变量在左边，右边是封装了门在输入上的功能的逻辑表达式。例如，输出AND门的操作（图中最右边的门）是*x*[10]
    ↔ (*x*[7] ∧ *x*[8] ∧ *x*[9])。我们称这些小型公式为***子句***。'
- en: The formula *ϕ* produced by the reduction algorithm is the AND of the circuit-output
    variable with the conjunction of clauses describing the operation of each gate.
    For the circuit in the figure, the formula is
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 由减少算法生成的公式*ϕ*是电路输出变量与描述每个门操作的子句的合取。对于图中的电路，公式为
- en: '| *ϕ = *x*[10]* | ∧ | (*x*[4] ↔ ¬*x*[3]) |'
  id: totrans-291
  prefs: []
  type: TYPE_TB
  zh: '| *ϕ = *x*[10]* | ∧ | (*x*[4] ↔ ¬*x*[3]) |'
- en: '|  | ∧ | (*x*[5] ↔ (*x*[1] ∨ *x*[2])) |'
  id: totrans-292
  prefs: []
  type: TYPE_TB
  zh: '|  | ∧ | (*x*[5] ↔ (*x*[1] ∨ *x*[2])) |'
- en: '|  | ∧ | (*x*[6] ↔ ¬*x*[4]) |'
  id: totrans-293
  prefs: []
  type: TYPE_TB
  zh: '|  | ∧ | (*x*[6] ↔ ¬*x*[4]) |'
- en: '|  | ∧ | (*x*[7] ↔ (*x*[1] ∧ *x*[2] ∧ *x*[4])) |'
  id: totrans-294
  prefs: []
  type: TYPE_TB
  zh: '|  | ∧ | (*x*[7] ↔ (*x*[1] ∧ *x*[2] ∧ *x*[4])) |'
- en: '|  | ∧ | (*x*[8] ↔ (*x*[5] ∨ *x*[6])) |'
  id: totrans-295
  prefs: []
  type: TYPE_TB
  zh: '|  | ∧ | (*x*[8] ↔ (*x*[5] ∨ *x*[6])) |'
- en: '|  | ∧ | (*x*[9] ↔ (*x*[6] ∨ *x*[7])) |'
  id: totrans-296
  prefs: []
  type: TYPE_TB
  zh: '|  | ∧ | (*x*[9] ↔ (*x*[6] ∨ *x*[7])) |'
- en: '|  | ∧ | (*x*[10] ↔ (*x*[7] ∧ *x*[8] ∧ *x*[9])). |'
  id: totrans-297
  prefs: []
  type: TYPE_TB
  zh: '|  | ∧ | (*x*[10] ↔ (*x*[7] ∧ *x*[8] ∧ *x*[9])). |'
- en: Given a circuit *C*, it is straightforward to produce such a formula *ϕ* in
    polynomial time.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个电路*C*，很容易在多项式时间内生成这样的公式*ϕ*。
- en: Why is the circuit *C* satisfiable exactly when the formula *ϕ* is satisfiable?
    If *C* has a satisfying assignment, then each wire of the circuit has a well-defined
    value, and the output of the circuit is 1\. Therefore, when wire values are assigned
    to variables in *ϕ*, each clause of *ϕ* evaluates to 1, and thus the conjunction
    of all evaluates to 1\. Conversely, if some assignment causes *ϕ* to evaluate
    to 1, the circuit *C* is satisfiable by an analogous argument. Thus, we have shown
    that CIRCUIT-SAT ≤[P] SAT, which completes the proof.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么电路*C*仅当公式*ϕ*可满足时才可满足？如果*C*有一个可满足的赋值，那么电路的每根导线都有一个明确定义的值，电路的输出为1。因此，当将导线值分配给*ϕ*中的变量时，*ϕ*的每个子句都评估为1，因此所有子句的合取也评估为1。反之，如果某个赋值导致*ϕ*评估为1，则电路*C*可通过类似的论证可满足。因此，我们已经证明了CIRCUIT-SAT
    ≤[P] SAT，这完成了证明。
- en: ▪
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**3-CNF satisfiability**'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**3-CNF可满足性**'
- en: Reducing from formula satisfiability gives us an avenue to prove many problems
    NP-complete. The reduction algorithm must handle any input formula, though, and
    this requirement can lead to a huge number of cases to consider. Instead, it is
    usually simpler to reduce from a restricted language of boolean formulas. Of course,
    the restricted language must not be polynomial-time solvable. One convenient language
    is 3-CNF satisfiability, or 3-CNF-SAT.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 从公式可满足性减少给了我们证明许多问题NP完全的途径。然而，减少算法必须处理任何输入公式，这一要求可能导致需要考虑大量情况。相反，通常更简单的是从布尔公式的受限语言减少。当然，受限语言不能在多项式时间内可解。一个方便的语言是3-CNF可满足性，或3-CNF-SAT。
- en: In order to define 3-CNF satisfiability, we first need to define a few terms.
    A ***literal*** in a boolean formula is an occurrence of a variable (such as *x*[1])
    or its negation (¬*x*[1]). A ***clause*** is the OR of one or more literals, such
    as *x*[1] ∨ ¬*x*[2] ∨ ¬*x*[3]. A boolean formula is in ***conjunctive normal form***,
    or ***CNF***, if it is expressed as an AND of clauses, and it’s in ***3-conjunctive
    normal form***, or ***3-CNF***, if each clause contains exactly three distinct
    literals.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了定义3-CNF可满足性，我们首先需要定义一些术语。布尔公式中的***文字***是变量（如*x*[1]）或其否定（¬*x*[1]）的出现。***子句***是一个或多个文字的OR，如*x*[1]
    ∨ ¬*x*[2] ∨ ¬*x*[3]。如果布尔公式表示为子句的AND，则它是***合取范式***，或***CNF***，如果每个子句包含三个不同的文字，则它是***3-合取范式***，或***3-CNF***。
- en: For example, the boolean formula
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，布尔公式
- en: (*x*[1] ∨ ¬*x*[1] ∨ ¬*x*[2]) ∧ (*x*[3] ∨ *x*[2] ∨ *x*[4]) ∧ (¬*x*[1] ∨ ¬*x*[3]
    ∨ ¬*x*[4])
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: (*x*[1] ∨ ¬*x*[1] ∨ ¬*x*[2]) ∧ (*x*[3] ∨ *x*[2] ∨ *x*[4]) ∧ (¬*x*[1] ∨ ¬*x*[3]
    ∨ ¬*x*[4])
- en: is in 3-CNF. The first of its three clauses is (*x*[1] ∨ ¬*x*[1] ∨ ¬*x*[2]),
    which contains the three literals *x*[1], ¬*x*[1], and ¬*x*[2].
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 是3-CNF的。其三个子句中的第一个是(*x*[1] ∨ ¬*x*[1] ∨ ¬*x*[2])，其中包含*x*[1]、¬*x*[1]和¬*x*[2]三个文字。
- en: The language 3-CNF-SAT consists of encodings of boolean formulas in 3-CNF that
    are satisfiable. The following theorem shows that a polynomial-time algorithm
    that can determine the satisfiability of boolean formulas is unlikely to exist,
    even when they are expressed in this simple normal form.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 语言3-CNF-SAT包含了可满足的3-CNF布尔公式的编码。以下定理表明，即使在这种简单的正常形式中表达，也不太可能存在一个能够确定布尔公式可满足性的多项式时间算法。
- en: '***Theorem 34.10***'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理34.10***'
- en: Satisfiability of boolean formulas in 3-conjunctive normal form is NP-complete.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 3-合取范式中布尔公式的可满足性是NP完全的。
- en: '***Proof***   The argument from the proof of Theorem 34.9 to show that SAT
    ∈ NP applies equally well here to show that 3-CNF-SAT ∈ NP. By Lemma 34.8, therefore,
    we need only show that SAT ≤[P] 3-CNF-SAT.'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   证明定理34.9中的SAT ∈ NP的论证同样适用于证明3-CNF-SAT ∈ NP。因此，根据引理34.8，我们只需要证明SAT
    ≤[P] 3-CNF-SAT。'
- en: '![art](images/Art_P1446.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1446.jpg)'
- en: '**Figure 34.11** The tree corresponding to the formula *ϕ* = ((*x*[1] →*x*[2])∨¬((¬*x*[1]
    ↔ *x*[3])∨*x*[4]))∧¬*x*[2].'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '**图34.11** 对应于公式*ϕ* = ((*x*[1] →*x*[2])∨¬((¬*x*[1] ↔ *x*[3])∨*x*[4]))∧¬*x*[2]的树。'
- en: We break the reduction algorithm into three basic steps. Each step progressively
    transforms the input formula *ϕ* closer to the desired 3-conjunctive normal form.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将缩减算法分为三个基本步骤。每个步骤逐渐将输入公式*ϕ*转换为所需的3-合取范式。
- en: The first step is similar to the one used to prove CIRCUIT-SAT ≤[P] SAT in Theorem
    34.9\. First, construct a binary “parse” tree for the input formula *ϕ*, with
    literals as leaves and connectives as internal nodes. [Figure 34.11](chapter034.xhtml#Fig_34-11)
    shows such a parse tree for the formula
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步类似于用于证明定理34.9中的CIRCUIT-SAT ≤[P] SAT的步骤。首先，为输入公式*ϕ*构造一个二进制“解析”树，其中文字为叶子，连接词为内部节点。[图34.11](chapter034.xhtml#Fig_34-11)展示了公式的这样一个解析树
- en: '![art](images/Art_P1447.jpg)'
  id: totrans-315
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1447.jpg)'
- en: If the input formula contains a clause such as the OR of several literals, use
    associativity to parenthesize the expression fully so that every internal node
    in the resulting tree has just one or two children. The binary parse tree is like
    a circuit for computing the function.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入公式包含诸如多个文字的OR子句，则使用结合律完全括号化表达式，以便结果树中的每个内部节点只有一个或两个子节点。二进制解析树类似于计算函数的电路。
- en: Mimicking the reduction in the proof of Theorem 34.9, introduce a variable *y[i]*
    for the output of each internal node. Then rewrite the original formula *ϕ* as
    the AND of the variable at the root of the parse tree and a conjunction of clauses
    describing the operation of each node. For the formula (34.3), the resulting expression
    is
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 模仿定理34.9证明中的缩减，为每个内部节点的输出引入一个变量*y[i]*。然后将原始公式*ϕ*重写为解析树根处的变量与描述每个节点操作的子句的合取的AND。对于公式(34.3)，得到的表达式是
- en: '| *ϕ*′ = *y*[1] | ∧ | (*y*[1] ↔ (*y*[2] ∧ ¬*x*[2])) |'
  id: totrans-318
  prefs: []
  type: TYPE_TB
  zh: '| *ϕ*′ = *y*[1] | ∧ | (*y*[1] ↔ (*y*[2] ∧ ¬*x*[2])) |'
- en: '|  | ∧ | (*y*[2] ↔ (*y*[3] ∨ *y*[4])) |'
  id: totrans-319
  prefs: []
  type: TYPE_TB
  zh: '|  | ∧ | (*y*[2] ↔ (*y*[3] ∨ *y*[4])) |'
- en: '|  | ∧ | (*y*[3] ↔ (*x*[1] → *x*[2])) |'
  id: totrans-320
  prefs: []
  type: TYPE_TB
  zh: '|  | ∧ | (*y*[3] ↔ (*x*[1] → *x*[2])) |'
- en: '|  | ∧ | (*y*[4] ↔ ¬*y*[5]) |'
  id: totrans-321
  prefs: []
  type: TYPE_TB
  zh: '|  | ∧ | (*y*[4] ↔ ¬*y*[5]) |'
- en: '|  | ∧ | (*y*[5] ↔ (*y*[6] ∨ *x*[4])) |'
  id: totrans-322
  prefs: []
  type: TYPE_TB
  zh: '|  | ∧ | (*y*[5] ↔ (*y*[6] ∨ *x*[4])) |'
- en: '|  | ∧ | (*y*[6] ↔ (¬*x*[1] ↔ *x*[3])). |'
  id: totrans-323
  prefs: []
  type: TYPE_TB
  zh: '|  | ∧ | (*y*[6] ↔ (¬*x*[1] ↔ *x*[3])). |'
- en: '![art](images/Art_P1448.jpg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1448.jpg)'
- en: '**Figure 34.12** The truth table for the clause (*y*[1] ↔ (*y*[2] ∧ ¬*x*[2])).'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '**图34.12** 子句(*y*[1] ↔ (*y*[2] ∧ ¬*x*[2]))的真值表。'
- en: The formula *ϕ*′ thus obtained is a conjunction of clauses ![art](images/Art_P1448a.jpg),
    each of which has at most three literals. These clauses are not yet ORs of three
    literals.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 因此得到的*ϕ*′公式是一个由![art](images/Art_P1448a.jpg)构成的子句的合取，每个子句最多有三个文字。这些子句还不是三文字的OR。
- en: The second step of the reduction converts each clause ![art](images/Art_P1448a.jpg)
    into conjunctive normal form. Construct a truth table for ![art](images/Art_P1448a.jpg)
    by evaluating all possible assignments to its variables. Each row of the truth
    table consists of a possible assignment of the variables of the clause, together
    with the value of the clause under that assignment. Using the truth-table entries
    that evaluate to 0, build a formula in ***disjunctive normal form*** (or ***DNF***)—an
    OR of ANDs—that is equivalent to ¬ ![art](images/Art_P1448a.jpg). Then negate
    this formula and convert it into a CNF formula ![art](images/Art_P1448b.jpg) by
    using ***DeMorgan’s laws*** for propositional logic,
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 缩减的第二步将每个子句![art](images/Art_P1448a.jpg)转换为合取范式。通过评估其变量的所有可能赋值来为![art](images/Art_P1448a.jpg)构造真值表。真值表的每一行由子句变量的一个可能赋值以及该赋值下子句的值组成。利用评估为0的真值表条目，构建一个等价于¬![art](images/Art_P1448a.jpg)的***析取范式***（或***DNF***）—一个AND的OR，然后否定这个公式，并使用命题逻辑的***德摩根定律***将其转换为CNF公式![art](images/Art_P1448b.jpg)，
- en: '| ¬(*a* ∧ *b*) | = | ¬*a* ∨ ¬*b,* |'
  id: totrans-328
  prefs: []
  type: TYPE_TB
  zh: '| ¬(*a* ∧ *b*) | = | ¬*a* ∨ ¬*b,* |'
- en: '| ¬(*a* ∨ *b*) | = | ¬*a* ∧ ¬*b,* |'
  id: totrans-329
  prefs: []
  type: TYPE_TB
  zh: '| ¬(*a* ∨ *b*) | = | ¬*a* ∧ ¬*b,* |'
- en: to complement all literals, change ORs into ANDs, and change ANDs into ORs.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有文字取补，将OR变为AND，将AND变为OR。
- en: In our example, the clause ![art](images/Art_P1448c.jpg) converts into CNF as
    follows. The truth table for ![art](images/Art_P1448d.jpg) appears in [Figure
    34.12](chapter034.xhtml#Fig_34-12). The DNF formula equivalent to ¬ ![art](images/Art_P1448d.jpg)
    is
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，子句![art](images/Art_P1448c.jpg)转换为CNF如下。![art](images/Art_P1448d.jpg)的真值表出现在[图34.12](chapter034.xhtml#Fig_34-12)中。等价于¬![art](images/Art_P1448d.jpg)的DNF公式是
- en: (*y*[1] ∧ *y*[2] ∧ *x*[2]) ∨ (*y*[1] ∧ ¬*y*[2] ∧ *x*[2]) ∨ (*y*[1] ∧ ¬*y*[2]
    ∧ ¬*x*[2]) ∨ (¬*y*[1] ∧ *y*[2] ∧ ¬*x*[2]).
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: (*y*[1] ∧ *y*[2] ∧ *x*[2]) ∨ (*y*[1] ∧ ¬*y*[2] ∧ *x*[2]) ∨ (*y*[1] ∧ ¬*y*[2]
    ∧ ¬*x*[2]) ∨ (¬*y*[1] ∧ *y*[2] ∧ ¬*x*[2])。
- en: Negating and applying DeMorgan’s laws yields the CNF formula
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 取反并应用德摩根定律得到CNF公式
- en: '![art](images/Art_P1448e.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1448e.jpg)'
- en: which is equivalent to the original clause ![art](images/Art_P1448d.jpg).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 等价于原始子句![art](images/Art_P1448d.jpg)。
- en: At this point, each clause ![art](images/Art_P1448a.jpg) of the formula *ϕ*′
    has been converted into a CNF formula ![art](images/Art_P1448b.jpg), and thus
    *ϕ*′ is equivalent to the CNF formula *ϕ*″ consisting of the conjunction of the
    ![art](images/Art_P1448b.jpg). Moreover, each clause of *ϕ*″ has at most three
    literals.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，公式*ϕ*′的每个子句![art](images/Art_P1448a.jpg)已转换为CNF公式![art](images/Art_P1448b.jpg)，因此*ϕ*′等价于由![art](images/Art_P1448b.jpg)构成的CNF公式*ϕ*″的合取。此外，*ϕ*″的每个子句最多有三个文字。
- en: 'The third and final step of the reduction further transforms the formula so
    that each clause has *exactly* three distinct literals. From the clauses of the
    CNF formula *ϕ*″, construct the final 3-CNF formula *ϕ*‴. This formula also uses
    two auxiliary variables, *p* and *q*. For each clause *C[i]* of *ϕ*″, include
    the following clauses in *ϕ*‴:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 归约的第三步也进一步转换了公式，使得每个子句都有*正好*三个不同的文字。从CNF公式*ϕ*″的子句构造最终的3-CNF公式*ϕ*‴。这个公式还使用了两个辅助变量*p*和*q*。对于*ϕ*″的每个子句*C[i]*，在*ϕ*‴中包含以下子句：
- en: If *C[i]* contains three distinct literals, then simply include *C[i]* as a
    clause of *ϕ*‴.
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*C[i]*包含三个不同的文字，则将*C[i]*简单地包含为*ϕ*‴的一个子句。
- en: If *C[i]* contains exactly two distinct literals, that is, if *C[i]* = (*l*[1]
    ∨ *l*[2]), where *l*[1] and *l*[2] are literals, then include (*l*[1] ∨ *l*[2]
    ∨ *p*) ∧ (*l*[1] ∨ *l*[2] ∨ ¬*p*) as clauses of *ϕ*‴. The literals *p* and ¬*p*
    merely fulfill the syntactic requirement that each clause of *ϕ*‴ contain exactly
    three distinct literals. Whether *p* = 0 or *p* = 1, one of the clauses is equivalent
    to *l*[1] ∨ *l*[2], and the other evaluates to 1, which is the identity for AND.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*C[i]*包含正好两个不同的文字，即如果*C[i]* = (*l*[1] ∨ *l*[2])，其中*l*[1]和*l*[2]*是文字，则将(*l*[1]
    ∨ *l*[2] ∨ *p*) ∧ (*l*[1] ∨ *l*[2] ∨ ¬*p*)包含为*ϕ*‴的子句。文字*p*和¬*p*仅满足*ϕ*‴的每个子句包含正好三个不同文字的语法要求。无论*p*
    = 0还是*p* = 1，其中一个子句等价于*l*[1] ∨ *l*[2]，另一个求值为1，这是AND的恒等式。
- en: If *C[i]* contains just one distinct literal *l*, then include (*l* ∨*p* ∨*q*)∧(*l*
    ∨ *p* ∨ ¬*q*) ∧ (*l* ∨ ¬*p* ∨ *q*) ∧ (*l* ∨ ¬*p* ∨ ¬*q*) as clauses of *ϕ*‴. Regardless
    of the values of *p* and *q*, one of the four clauses is equivalent to *l*, and
    the other three evaluate to 1.
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果*C[i]*只包含一个不同的文字*l*，则将(*l* ∨*p* ∨*q*)∧(*l* ∨ *p* ∨ ¬*q*) ∧ (*l* ∨ ¬*p* ∨ *q*)
    ∧ (*l* ∨ ¬*p* ∨ ¬*q*)包含为*ϕ*‴的子句。无论*p*和*q*的值如何，其中四个子句中的一个等价于*l*，另外三个求值为1。
- en: We can see that the 3-CNF formula *ϕ*‴ is satisfiable if and only if *ϕ* is
    satisfiable by inspecting each of the three steps. Like the reduction from CIRCUIT-SAT
    to SAT, the construction of *ϕ*′ from *ϕ* in the first step preserves satisfiability.
    The second step produces a CNF formula *ϕ*″ that is algebraically equivalent to
    *ϕ*′. Then the third step produces a 3-CNF formula *ϕ*‴ that is effectively equivalent
    to *ϕ*″, since any assignment to the variables *p* and *q* produces a formula
    that is algebraically equivalent to *ϕ*″.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查每个步骤，我们可以看到3-CNF公式*ϕ*‴仅当*ϕ*可满足时才可满足。与从CIRCUIT-SAT到SAT的归约类似，第一步中从*ϕ*到*ϕ*′的构造保持了可满足性。第二步产生了一个与*ϕ*′代数上等价的CNF公式*ϕ*″。然后第三步产生了一个与*ϕ*″有效等价的3-CNF公式*ϕ*‴，因为对变量*p*和*q*的任何赋值都会产生一个与*ϕ*″代数上等价的公式。
- en: We must also show that the reduction can be computed in polynomial time. Constructing
    *ϕ*′ from *ϕ* introduces at most one variable and one clause per connective in
    *ϕ*. Constructing *ϕ*″ from *ϕ*′ can introduce at most eight clauses into *ϕ*″
    for each clause from *ϕ*′, since each clause of *ϕ*′ contains at most three variables,
    and the truth table for each clause has at most 2³ = 8 rows. The construction
    of *ϕ*‴ from *ϕ*″ introduces at most four clauses into *ϕ*‴ for each clause of
    *ϕ*″. Thus the size of the resulting formula *ϕ*‴ is polynomial in the length
    of the original formula. Each of the constructions can be accomplished in polynomial
    time.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须展示归约可以在多项式时间内计算。从*ϕ*构造*ϕ*′最多引入一个变量和一个子句，每个*ϕ*中的连接词。从*ϕ*′构造*ϕ*″最多为*ϕ*′的每个子句引入八个子句，因为*ϕ*′的每个子句最多包含三个变量，并且每个子句的真值表最多有2³
    = 8行。从*ϕ*″构造*ϕ*‴最多为*ϕ*″的每个子句引入四个子句。因此，结果公式*ϕ*‴的大小与原始公式的长度成多项式关系。每个构造都可以在多项式时间内完成。
- en: ▪
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Exercises**'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***34.4-1***'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.4-1***'
- en: Consider the straightforward (nonpolynomial-time) reduction in the proof of
    Theorem 34.9\. Describe a circuit of size *n* that, when converted to a formula
    by this method, yields a formula whose size is exponential in *n*.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑定理34.9证明中的直接（非多项式时间）归约。描述一个大小为*n*的电路，通过这种方法转换为公式后，得到一个大小与*n*指数成正比的公式。
- en: '***34.4-2***'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.4-2***'
- en: Show the 3-CNF formula that results upon using the method of Theorem 34.10 on
    the formula (34.3).
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 展示在使用定理34.10的方法在公式(34.3)上得到的3-CNF公式。
- en: '***34.4-3***'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.4-3***'
- en: Professor Jagger proposes to show that SAT ≤[P] 3-CNF-SAT by using only the
    truth-table technique in the proof of Theorem 34.10, and not the other steps.
    That is, the professor proposes to take the boolean formula *ϕ*, form a truth
    table for its variables, derive from the truth table a formula in 3-DNF that is
    equivalent to ¬*ϕ*, and then negate and apply DeMorgan’s laws to produce a 3-CNF
    formula equivalent to *ϕ*. Show that this strategy does not yield a polynomial-time
    reduction.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: Jagger教授提出通过在定理34.10的证明中仅使用真值表技术，而不使用其他步骤，来展示SAT ≤[P] 3-CNF-SAT。也就是说，教授提议取布尔公式*ϕ*，为其变量制作真值表，从真值表中导出一个等价于¬*ϕ*的3-DNF公式，然后对其取反并应用德摩根定律，以生成一个等价于*ϕ*的3-CNF公式。展示这种策略不能产生多项式时间的减少。
- en: '***34.4-4***'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.4-4***'
- en: Show that the problem of determining whether a boolean formula is a tautology
    is complete for co-NP. (*Hint:* See Exercise 34.3-7.)
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 展示确定布尔公式是否永真的问题对于co-NP是完全的。（*提示：参见练习34.3-7。*）
- en: '***34.4-5***'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.4-5***'
- en: Show that the problem of determining the satisfiability of boolean formulas
    in disjunctive normal form is polynomial-time solvable.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 展示确定合取范式中布尔公式的可满足性问题是多项式时间可解的。
- en: '***34.4-6***'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.4-6***'
- en: Someone gives you a polynomial-time algorithm to decide formula satisfiability.
    Describe how to use this algorithm to find satisfying assignments in polynomial
    time.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 有人给了你一个决定公式可满足性的多项式时间算法。描述如何利用这个算法在多项式时间内找到满足的赋值。
- en: '***34.4-7***'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.4-7***'
- en: Let 2-CNF-SAT be the set of satisfiable boolean formulas in CNF with exactly
    two literals per clause. Show that 2-CNF-SAT ∈ P. Make your algorithm as efficient
    as possible. (*Hint:* Observe that *x* ∨ *y* is equivalent to ¬*x* → *y*. Reduce
    2-CNF-SAT to an efficiently solvable problem on a directed graph.)
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 令2-CNF-SAT为CNF中每个子句恰好有两个文字的可满足布尔公式的集合。展示2-CNF-SAT ∈ P。使你的算法尽可能高效。（*提示：观察到*x*
    ∨ *y*等价于¬*x* → *y*。将2-CNF-SAT减少到有向图上的一个可有效解决的问题。）
- en: '[**34.5    NP-complete problems**](toc.xhtml#Rh1-203)'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '[**34.5    NP完全问题**](toc.xhtml#Rh1-203)'
- en: 'NP-complete problems arise in diverse domains: boolean logic, graphs, arithmetic,
    network design, sets and partitions, storage and retrieval, sequencing and scheduling,
    mathematical programming, algebra and number theory, games and puzzles, automata
    and language theory, program optimization, biology, chemistry, physics, and more.
    This section uses the reduction methodology to provide NP-completeness proofs
    for a variety of problems drawn from graph theory and set partitioning.'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: NP完全问题出现在各种领域：布尔逻辑、图形、算术、网络设计、集合和分区、存储和检索、排序和调度、数学规划、代数和数论、游戏和谜题、自动机和语言理论、程序优化、生物学、化学、物理等等。本节使用减少方法为从图论和集合分割中提取的各种问题提供NP完全性证明。
- en: '![art](images/Art_P1449.jpg)'
  id: totrans-361
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1449.jpg)'
- en: '**Figure 34.13** The structure of NP-completeness proofs in [Sections 34.4](chapter034.xhtml#Sec_34.4)
    and [34.5](chapter034.xhtml#Sec_34.5). All proofs ultimately follow by reduction
    from the NP-completeness of CIRCUIT-SAT.'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**图34.13** 本节和[第34.4节](chapter034.xhtml#Sec_34.4)中NP完全性证明的结构。所有证明最终都通过从CIRCUIT-SAT的NP完全性进行减少而得出。'
- en: '[Figure 34.13](chapter034.xhtml#Fig_34-13) outlines the structure of the NP-completeness
    proofs in this section and [Section 34.4](chapter034.xhtml#Sec_34.4). We prove
    each language in the figure to be NP-complete by reduction from the language that
    points to it. At the root is CIRCUIT-SAT, which we proved NP-complete in Theorem
    34.7\. This section concludes with a recap of reduction strategies.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: '[图34.13](chapter034.xhtml#Fig_34-13)概述了本节和[第34.4节](chapter034.xhtml#Sec_34.4)中NP完全性证明的结构。我们通过从指向它的语言进行减少来证明图中的每种语言都是NP完全的。根源是CIRCUIT-SAT，我们在定理34.7中证明了它是NP完全的。本节以减少策略的回顾结束。'
- en: '**34.5.1    The clique problem**'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: '**34.5.1    团问题**'
- en: A ***clique*** in an undirected graph *G* = (*V*, *E*) is a subset *V*′ ⊆ *V*
    of vertices, each pair of which is connected by an edge in *E*. In other words,
    a clique is a complete subgraph of *G*. The ***size*** of a clique is the number
    of vertices it contains. The ***clique problem*** is the optimization problem
    of finding a clique of maximum size in a graph. The corresponding decision problem
    asks simply whether a clique of a given size *k* exists in the graph. The formal
    definition is
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 无向图*G* = (*V*, *E*)中的***团***是顶点的子集*V*′ ⊆ *V*，其中每对顶点在*E*中由边连接。换句话说，团是*G*的完全子图。***大小***是团包含的顶点数。***团问题***是在图中找到最大大小的团的优化问题。相应的决策问题只是询问图中是否存在给定大小*k*的团。正式定义如下
- en: 'CLIQUE = {〈*G, k*〉 : *G* is a graph containing a clique of size *k*}.'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 'CLIQUE = {〈*G, k*〉 : *G*是包含大小为*k*的团的图}。'
- en: A naive algorithm for determining whether a graph *G* = (*V*, *E*) with |*V*|
    vertices contains a clique of size *k* lists all *k*-subsets of *V* and checks
    each one to see whether it forms a clique. The running time of this algorithm
    is ![art](images/Art_P1450.jpg), which is polynomial if *k* is a constant. In
    general, however, *k* could be near |*V*|/2, in which case the algorithm runs
    in superpolynomial time. Indeed, an efficient algorithm for the clique problem
    is unlikely to exist.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 一个用���确定具有|*V*|个顶点的图*G* = (*V*, *E*)是否包含大小为*k*的团的天真算法列出了*V*的所有*k*子集，并检查每个子集是否形成团。该算法的运行时间是![art](images/Art_P1450.jpg)，如果*k*是一个常数，则是多项式的。然而，一般情况下，*k*可能接近|*V*|/2，此时算法运行时间为超多项式。事实上，一个高效的团问题算法不太可能存在。
- en: '***Theorem 34.11***'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理34.11***'
- en: The clique problem is NP-complete.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 团问题是NP完全的。
- en: '***Proof***   First, we show that CLIQUE ∈ NP. For a given graph *G* = (*V*,
    *E*), use the set *V*′ ⊆ *V* of vertices in the clique as a certificate for *G*.
    To check whether *V*′ is a clique in polynomial time, check whether, for each
    pair *u, v* ∈ *V*′, the edge (*u*, *v*) belongs to *E*.'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   首先，我们展示CLIQUE ∈ NP。对于给定的图*G* = (*V*, *E*)，将团中的顶点集*V*′ ⊆ *V*用作*G*的证书。为了在多项式时间内检查*V*′是否是团，检查对于每对*u,
    v* ∈ *V*′，边(*u*, *v*)是否属于*E*。'
- en: We next prove that 3-CNF-SAT ≤[P] CLIQUE, which shows that the clique problem
    is NP-hard. You might be surprised that the proof reduces an instance of 3-CNF-SAT
    to an instance of CLIQUE, since on the surface logical formulas seem to have little
    to do with graphs.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们证明3-CNF-SAT ≤[P] CLIQUE，这表明团问题是NP难的。你可能会惊讶于证明将一个3-CNF-SAT实例简化为一个团实例，因为表面上逻辑公式似乎与图没有太多关系。
- en: 'The reduction algorithm begins with an instance of 3-CNF-SAT. Let *ϕ* = *C*[1]
    ∧ *C*[2] ∧ ⋯ ∧ *C[k]* be a boolean formula in 3-CNF with *k* clauses. For *r*
    = 1, 2, … , *k*, each clause *C[r]* contains exactly three distinct literals:
    ![art](images/Art_P1451.jpg), and ![art](images/Art_P1452.jpg). We will construct
    a graph *G* such that *ϕ* is satisfiable if and only if *G* contains a clique
    of size *k*.'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 缩减算法从一个3-CNF-SAT实例开始。设*ϕ* = *C*[1] ∧ *C*[2] ∧ ⋯ ∧ *C[k]*是一个包含*k*个子句的3-CNF布尔公式。对于*r*
    = 1, 2, … , *k*，每个子句*C[r]*包含三个不同的文字：![art](images/Art_P1451.jpg)，和![art](images/Art_P1452.jpg)。我们将构造一个图*G*，使得*ϕ*可满足当且仅当*G*包含大小为*k*的团。
- en: 'We construct the undirected graph *G* = (*V*, *E*) as follows. For each clause
    ![art](images/Art_P1453.jpg) in *ϕ*, place a triple of vertices ![art](images/Art_P1454.jpg),
    and ![art](images/Art_P1455.jpg) into *V*. Add edge ![art](images/Art_P1456.jpg)
    into *E* if both of the following hold:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们按照以下方式构造无向图*G* = (*V*, *E*)。对于*ϕ*中的每个子句![art](images/Art_P1453.jpg)，将一个三元组的顶点![art](images/Art_P1454.jpg)和![art](images/Art_P1455.jpg)放入*V*中。如果以下两个条件都成立，则将边![art](images/Art_P1456.jpg)加入*E*：
- en: '![art](images/Art_P1457.jpg) and ![art](images/Art_P1458.jpg) are in different
    triples, that is, *r* ≠ *s*, and'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '![art](images/Art_P1457.jpg)和![art](images/Art_P1458.jpg)在不同的三元组中，即*r* ≠ *s*，且'
- en: their corresponding literals are ***consistent***, that is, ![art](images/Art_P1459.jpg)
    is not the negation of ![art](images/Art_P1460.jpg).
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们对应的文字是***一致***的，即，![art](images/Art_P1459.jpg)不是![art](images/Art_P1460.jpg)的否定。
- en: We can build this graph from *ϕ* in polynomial time. As an example of this construction,
    if
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在多项式时间内从*ϕ*构建这个图。作为这个构造的一个例子，如果
- en: '*ϕ* = (*x*[1] ∨ ¬*x*[2] ∨ ¬*x*[3]) ∧ (¬*x*[1] ∨ *x*[2] ∨ *x*[3]) ∧ (*x*[1]
    ∨ *x*[2] ∨ *x*[3]),'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: '*ϕ* = (*x*[1] ∨ ¬*x*[2] ∨ ¬*x*[3])*∧*(¬*x*[1] ∨ *x*[2] ∨ *x*[3])*∧*(*x*[1]
    ∨ *x*[2] ∨ *x*[3])*，'
- en: then *G* is the graph shown in [Figure 34.14](chapter034.xhtml#Fig_34-14).
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 则*G*是在[图 34.14](chapter034.xhtml#Fig_34-14)中显示的图。
- en: We must show that this transformation of *ϕ* into *G* is a reduction. First,
    suppose that *ϕ* has a satisfying assignment. Then each clause *C[r]* contains
    at least one literal ![art](images/Art_P1459.jpg) that is assigned 1, and each
    such literal corresponds to a vertex ![art](images/Art_P1457.jpg). Picking one
    such “true” literal from each clause yields a set *V*′ of *k* vertices. We claim
    that *V*′ is a clique. For any two vertices ![art](images/Art_P1463.jpg), where
    *r* ≠ *s*, both corresponding literals ![art](images/Art_P1459.jpg) and ![art](images/Art_P1460.jpg)
    map to 1 by the given satisfying assignment, and thus the literals cannot be complements.
    Thus, by the construction of *G*, the edge ![art](images/Art_P1456.jpg) belongs
    to *E*.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须证明*ϕ*到*G*的这种转换是一个简化。首先，假设*ϕ*有一个满足赋值。那么每个子句*C[r]*至少包含一个被赋值为1的文字![art](images/Art_P1459.jpg)，并且每个这样的文字对应一个顶点![art](images/Art_P1457.jpg)。从每个子句中选择一个这样的“真”文字得到一个*k*个顶点的集合*V*′。我们声称*V*′是一个团。对于任意两个顶点![art](images/Art_P1463.jpg)，其中*r*
    ≠ *s*，通过给定的满足赋值，对应的文字![art](images/Art_P1459.jpg)和![art](images/Art_P1460.jpg)都映射到1，因此这些文字不可能是补充。因此，根据*G*的构造，边![art](images/Art_P1456.jpg)属于*E*。
- en: Conversely, suppose that *G* contains a clique *V*′ of size *k*. No edges in
    *G* connect vertices in the same triple, and so *V*′ contains exactly one vertex
    per triple. If ![art](images/Art_P1467.jpg), then assign 1 to the corresponding
    literal ![art](images/Art_P1459.jpg). Since *G* contains no edges between inconsistent
    literals, no literal and its complement are both assigned 1\. Each clause is satisfied,
    and so *ϕ* is satisfied. (Any variables that do not correspond to a vertex in
    the clique may be set arbitrarily.)
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 反之，假设*G*包含大小为*k*的团*V*′。*G*中没有边连接同一三元组中的顶点，因此*V*′中恰好包含每个三元组中的一个顶点。如果![art](images/Art_P1467.jpg)，则将1赋给对应的文字![art](images/Art_P1459.jpg)。由于*G*中没有连接不一致文字的边，没有文字及其补充都被赋值为1。每个子句都被满足，因此*ϕ*被满足。（任何不对应团中顶点的变��可以任意设置。）
- en: ▪
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '![art](images/Art_P1469.jpg)'
  id: totrans-382
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1469.jpg)'
- en: '**Figure 34.14** The graph *G* derived from the 3-CNF formula *ϕ* = *C*[1]
    ∧ *C*[2] ∧ *C*[3], where *C*[1] = (*x*[1] ∨ ¬*x*[2] ∨ ¬*x*[3]), *C*[2] = (¬*x*[1]
    ∨ *x*[2] ∨ *x*[3]), and *C*[3] = (*x*[1] ∨ *x*[2] ∨ *x*[3]), in reducing 3-CNF-SAT
    to CLIQUE. A satisfying assignment of the formula has *x*[2] = 0, *x*[3] = 1,
    and *x*[1] set to either 0 or 1\. This assignment satisfies *C*[1] with ¬*x*[2],
    and it satisfies *C*[2] and *C*[3] with *x*[3], corresponding to the clique with
    blue vertices.'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 34.14** 图*G*源自3-CNF公式*ϕ* = *C*[1] ∧ *C*[2] ∧ *C*[3]，其中*C*[1] = (*x*[1]
    ∨ ¬*x*[2] ∨ ¬*x*[3])*，*C*[2] = (¬*x*[1] ∨ *x*[2] ∨ *x*[3])*，*C*[3] = (*x*[1] ∨
    *x*[2] ∨ *x*[3])*，在将3-CNF-SAT简化为团问题时。公式的一个满足赋值为*x*[2] = 0，*x*[3] = 1，*x*[1]设置为0或1。这个赋值通过使用¬*x*[2]满足*C*[1]，并且通过*x*[3]满足*C*[2]和*C*[3]，对应于具有蓝色顶点的团。'
- en: In the example of [Figure 34.14](chapter034.xhtml#Fig_34-14), a satisfying assignment
    of *ϕ* has *x*[2] = 0 and *x*[3] = 1\. A corresponding clique of size *k* = 3
    consists of the vertices corresponding to ¬*x*[2] from the first clause, *x*[3]
    from the second clause, and *x*[3] from the third clause. Because the clique contains
    no vertices corresponding to either *x*[1] or ¬*x*[1], this satisfying assignment
    can set *x*[1] to either 0 or 1.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在[图 34.14](chapter034.xhtml#Fig_34-14)的例子中，*ϕ*的一个满足赋值为*x*[2] = 0和*x*[3] = 1。大小为*k*
    = 3的一个对应团包含了来自第一个子句的¬*x*[2]，来自第二个子句的*x*[3]，和来自第三个子句的*x*[3]的顶点。因为该团不包含任何对应*x*[1]或¬*x*[1]的顶点，这个满足赋值可以将*x*[1]设置为0或1。
- en: The proof of Theorem 34.11 reduced an arbitrary instance of 3-CNF-SAT to an
    instance of CLIQUE with a particular structure. You might think that we have shown
    only that CLIQUE is NP-hard in graphs in which the vertices are restricted to
    occur in triples and in which there are no edges between vertices in the same
    triple. Indeed, we have shown that CLIQUE is NP-hard only in this restricted case,
    but this proof suffices to show that CLIQUE is NP-hard in general graphs. Why?
    If there were a polynomial-time algorithm that solves CLIQUE on general graphs,
    it would also solve CLIQUE on restricted graphs.
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 定理34.11的证明将3-CNF-SAT的任意实例缩减为具有特定结构的团问题实例。你可能会认为我们只证明了在顶点被限制为出现在三元组中且同一三元组中的顶点之间没有边的图中，团问题是NP难的。事实上，我们只证明了在这种受限情况下团问题是NP难的，但这个证明足以表明团问题在一般图中也是NP难的。为什么？如果存在一个能在一般图上解决团问题的多项式时间算法，那么它也会在受限图上解决团问题。
- en: The opposite approach—reducing instances of 3-CNF-SAT with a special structure
    to general instances of CLIQUE—does not suffice, however. Why not? Perhaps the
    instances of 3-CNF-SAT that we choose to reduce from are “easy,” and so we would
    not have reduced an NP-hard problem to CLIQUE.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 相反的方法——将具有特殊结构的3-CNF-SAT实例缩减为一般的团实例——却不够。为什么？也许我们选择要缩减的3-CNF-SAT实例是“简单”的，因此我们并没有将一个NP难问题缩减为团问题。
- en: Moreover, the reduction uses the instance of 3-CNF-SAT, but not the solution.
    We would have erred if the polynomial-time reduction had relied on knowing whether
    the formula *ϕ* is satisfiable, since we do not know how to decide whether *ϕ*
    is satisfiable in polynomial time.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，缩减使用了3-CNF-SAT的实例，但没有使用解决方案。如果多项式时间缩减依赖于知道公式 *ϕ* 是否可满足，那么我们就会犯错，因为我们不知道如何在多项式时间内判断
    *ϕ* 是否可满足。
- en: '![art](images/Art_P1470.jpg)'
  id: totrans-388
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1470.jpg)'
- en: '**Figure 34.15** Reducing CLIQUE to VERTEX-COVER. **(a)** An undirected graph
    *G* = (*V*, *E*) with clique *V*′ = {*u, v, x, y*}, shown in blue. **(b)** The
    graph *G* produced by the reduction algorithm that has vertex cover *V* − *V′*
    = {*w, z*}, in blue.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '**图34.15** 将团问题缩减为顶点覆盖问题。**(a)** 一个无向图 *G* = (*V*, *E*)，其中团 *V*′ = {*u, v,
    x, y*}，用蓝色表示。**(b)** 缩减算法生成的图 *G*，其顶点覆盖为 *V* − *V′* = {*w, z*}，用蓝色表示。'
- en: '**34.5.2    The vertex-cover problem**'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '**34.5.2    顶点覆盖问题**'
- en: A ***vertex cover*** of an undirected graph *G* = (*V*, *E*) is a subset *V*′
    ⊆ *V* such that if (*u*, *v*) ∈ *E*, then *u* ∈ *V*′ or *v* ∈ *V*′ (or both).
    That is, each vertex “covers” its incident edges, and a vertex cover for *G* is
    a set of vertices that covers all the edges in *E*. The ***size*** of a vertex
    cover is the number of vertices in it. For example, the graph in [Figure 34.15(b)](chapter034.xhtml#Fig_34-15)
    has a vertex cover {*w, z*} of size 2.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 一个无向图 *G* = (*V*, *E*) 的***顶点覆盖***是一个子集 *V*′ ⊆ *V*，使得如果 (*u*, *v*) ∈ *E*，则 *u*
    ∈ *V*′ 或 *v* ∈ *V*′（或两者都是）。也就是说，每个顶点“覆盖”其关联的边，而图 *G* 的顶点覆盖是一个覆盖所有边的顶点集。顶点覆盖的***大小***是其中顶点的数量。例如，[图34.15(b)](chapter034.xhtml#Fig_34-15)中的图有大小为2的顶点覆盖
    {*w, z*}。
- en: The ***vertex-cover problem*** is to find a vertex cover of minimum size in
    a given graph. For this optimization problem, the corresponding decision problem
    asks whether a graph has a vertex cover of a given size *k*. As a language, we
    define
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: '***顶点覆盖问题*** 是在给定图中找到最小大小的顶点覆盖。对于这个优化问题，相应的决策问题询问一个图是否有给定大小 *k* 的顶点覆盖。作为一种语言，我们定义'
- en: 'VERTEX-COVER = {〈*G, k*〉 : graph *G* has a vertex cover of size *k*}.'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: '顶点覆盖 = {〈*G, k*〉 : 图 *G* 有大小为 *k* 的顶点覆盖}。'
- en: The following theorem shows that this problem is NP-complete.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的定理表明这个问题是NP完全的。
- en: '***Theorem 34.12***'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理34.12***'
- en: The vertex-cover problem is NP-complete.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点覆盖问题是NP完全的。
- en: '***Proof***   We first show that VERTEX-COVER ∈ NP. Given a graph *G* = (*V*,
    *E*) and an integer *k*, the certificate is the vertex cover *V*′ ⊆ *V* itself.
    The verification algorithm affirms that |*V*′| = *k*, and then it checks, for
    each edge (*u*, *v*) ∈ *E*, that *u* ∈ *V*′ or *v* ∈ *V*′. It is easy to verify
    the certificate in polynomial time.'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 我们首先展示顶点覆盖 ∈ NP。给定一个图 *G* = (*V*, *E*) 和一个整数 *k*，证书是顶点覆盖 *V*′ ⊆ *V*
    本身。验证算法确认 |*V*′| = *k*，然后检查每条边 (*u*, *v*) ∈ *E*，确保 *u* ∈ *V*′ 或 *v* ∈ *V*′。在多项式时间内验证证书是很容易的。'
- en: 'To prove that the vertex-cover problem is NP-hard, we reduce from the clique
    problem, showing that CLIQUE ≤[P] VERTEX-COVER. This reduction relies on the notion
    of the complement of a graph. Given an undirected graph *G* = (*V*, *E*), we define
    the ***complement*** of *G* as a graph *G* = (*V*, *E*), where *E* = {(*u*, *v*)
    : *u, v* ∈ *V, u* ≠ *v*, and (*u*, *v*) ∉ *E*}. In other words, *G* is the graph
    containing exactly those edges that are not in *G*. [Figure 34.15](chapter034.xhtml#Fig_34-15)
    shows a graph and its complement and illustrates the reduction from CLIQUE to
    VERTEX-COVER.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '为了证明顶点覆盖问题是NP难的，我们从团问题进行缩减，展示团 ≤[P] 顶点覆盖。这个缩减依赖于图的补图概念。给定一个无向图 *G* = (*V*,
    *E*)，我们将 *G* 的***补图***定义为一个图 *G* = (*V*, *E*)，其中 *E* = {(*u*, *v*) : *u, v* ∈
    *V, u* ≠ *v*, 且 (*u*, *v*) ∉ *E*}。换句话说，*G* 是包含所有不在 *G* 中的边的图。[图34.15](chapter034.xhtml#Fig_34-15)展示了一个图及其补图，并说明了从团到顶点覆盖的缩减。'
- en: 'The reduction algorithm takes as input an instance 〈*G, k*〉 of the clique problem
    and computes the complement *G* in polynomial time. The output of the reduction
    algorithm is the instance 〈*G*, |*V*| − *k*〉 of the vertex-cover problem. To complete
    the proof, we show that this transformation is indeed a reduction: the graph *G*
    contains a clique of size *k* if and only if the graph *G* has a vertex cover
    of size |*V*| − *k*.'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 缩减算法以团问题实例 〈*G, k*〉 作为输入，并在多项式时间内计算出补图 *G*。缩减算法的输出是顶点覆盖问题实例 〈*G*, |*V*| − *k*〉。为了完成证明，我们展示这个转换确实是一个缩减：图
    *G* 包含大小为 *k* 的团当且仅当图 *G* 有大小为 |*V*| − *k* 的顶点覆盖。
- en: Suppose that *G* contains a clique *V*′ ⊆ *V* with |*V*′| = *k*. We claim that
    *V* − *V*′ is a vertex cover in *G*. Let (*u*, *v*) be any edge in *E*. Then,
    (*u*, *v*) ∉ *E*, which implies that at least one of *u* or *v* does not belong
    to *V*′, since every pair of vertices in *V*′ is connected by an edge of *E*.
    Equivalently, at least one of *u* or *v* belongs to *V* − *V*′, which means that
    edge (*u*, *v*) is covered by *V* − *V*′. Since (*u*, *v*) was chosen arbitrarily
    from *E*, every edge of *E* is covered by a vertex in *V* −*V*′. Hence the set
    *V* − *V*′, which has size |*V*| − *k*, forms a vertex cover for *G*.
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 假设*G*包含一个团*V*′ ⊆ *V*，其中|*V*′| = *k*。我们声称*V* − *V*′是*G*中的一个顶点覆盖。设(*u*, *v*)是*E*中的任意一条边。那么，(*u*,
    *v*) ∉ *E*，这意味着*u*或*v*至少有一个不属于*V*′，因为*V*′中的每对顶点都由*E*中的一条边连接。换句话说，*u*或*v*至少有一个属于*V*
    − *V*′，这意味着边(*u*, *v*)被*V* − *V*′覆盖。由于(*u*, *v*)是从*E*中任意选择的，所以*E*中的每条边都被*V* −
    *V*′中的一个顶点覆盖。因此，大小为|*V*| − *k*的集合*V* − *V*′形成了*G*的一个顶点覆盖。
- en: Conversely, suppose that *G* has a vertex cover *V*′ ⊆ *V*, where |*V*′| = |*V*|
    − *k*. Then for all *u, v* ∈ *V*, if (*u*, *v*) ∈ *E*, then *u* ∈ *V*′ or *v*
    ∈ *V*′ or both. The contrapositive of this implication is that for all *u, v*
    ∈ *V*, if *u* ∉ *V*′ and *v* ∉ *V*′, then (*u*, *v*) ∈ *E*. In other words, *V*
    − *V*′ is a clique, and it has size |*V*|−|*V*′| = *k*.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，假设*G*有一个顶点覆盖*V*′ ⊆ *V*，其中|*V*′| = |*V*| − *k*。对于所有*u, v* ∈ *V*，如果(*u*, *v*)
    ∈ *E*，那么*u* ∈ *V*′或*v* ∈ *V*′或两者都是。这个蕴含的逆否命题是，对于所有*u, v* ∈ *V*，如果*u* ∉ *V*′且*v*
    ∉ *V*′，那么(*u*, *v*) ∈ *E*。换句话说，*V* − *V*′是一个团，它的大小为|*V*|−|*V*′| = *k*。
- en: ▪
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Since VERTEX-COVER is NP-complete, we don’t expect to find a polynomial-time
    algorithm for finding a minimum-size vertex cover. [Section 35.1](chapter035.xhtml#Sec_35.1)
    presents a polynomial-time “approximation algorithm,” however, which produces
    “approximate” solutions for the vertex-cover problem. The size of a vertex cover
    produced by the algorithm is at most twice the minimum size of a vertex cover.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 由于VERTEX-COVER是NP完全的，我们不指望找到一个找到最小大小顶点覆盖的多项式时间算法。然而，[第35.1节](chapter035.xhtml#Sec_35.1)提供了一个多项式时间的“近似算法”，它为顶点覆盖问题产生“近似”解。算法产生的顶点覆盖的大小至多是最小顶点覆盖大小的两倍。
- en: Thus, you shouldn’t give up hope just because a problem is NP-complete. You
    might be able to design a polynomial-time approximation algorithm that obtains
    near-optimal solutions, even though finding an optimal solution is NP-complete.
    [Chapter 35](chapter035.xhtml) gives several approximation algorithms for NP-complete
    problems.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你不应该因为一个问题是NP完全的就放弃希望。你可能能够设计一个多项式时间的近似算法，获得接近最优解，尽管找到一个最优解是NP完全的。[第35章](chapter035.xhtml)提供了几种NP完全问题的近似算法。
- en: '**34.5.3    The hamiltonian-cycle problem**'
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**34.5.3** 哈密顿回路问题'
- en: We now return to the hamiltonian-cycle problem defined in [Section 34.2](chapter034.xhtml#Sec_34.2).
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们回到[第34.2节](chapter034.xhtml#Sec_34.2)中定义的哈密顿回路问题。
- en: '***Theorem 34.13***'
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理34.13***'
- en: The hamiltonian cycle problem is NP-complete.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 哈密顿回路问题是NP完全的。
- en: '![art](images/Art_P1471.jpg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1471.jpg)'
- en: '**Figure 34.16** The gadget used in reducing the vertex-cover problem to the
    hamiltonian-cycle problem. An edge (*u*, *v*) of graph *G* corresponds to gadget
    Γ[*uv*] in the graph *G*′ created in the reduction. **(a)** The gadget, with individual
    vertices labeled. **(b)–(d)** The paths highlighted in blue are the only possible
    ones through the gadget that include all vertices, assuming that the only connections
    from the gadget to the remainder of *G*′ are through vertices [*u, v*, 1], [*u,
    v*, 6], [*v, u*, 1], and [*v, u*, 6].'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: '**图34.16** 用于将顶点覆盖问题简化为哈密顿回路问题的小工具。图*G*中的边(*u*, *v*)对应于简化中创建的图*G*′中的工具Γ[*uv*]。**(a)**
    工具，带有标记的单个顶点。**(b)–(d)** 用蓝色突出显示的路径是通过工具的唯一可能路径，假设从工具到*G*′的其余部分的唯一连接是通过顶点[*u,
    v*, 1]，[*u, v*, 6]，[*v, u*, 1]和[*v, u*, 6]。'
- en: '***Proof***   We first show that HAM-CYCLE ∈ NP. Given an undirected graph
    *G* = (*V*, *E*), the certificate is the sequence of |*V*| vertices that makes
    up the hamiltonian cycle. The verification algorithm checks that this sequence
    contains each vertex in *V* exactly once and that with the first vertex repeated
    at the end, it forms a cycle in *G*. That is, it checks that there is an edge
    between each pair of consecutive vertices and between the first and last vertices.
    This certificate can be verified in polynomial time.'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 我们首先证明HAM-CYCLE ∈ NP。给定一个无向图*G* = (*V*, *E*)，证书是构成哈密顿回路的|*V*|个顶点的序列。验证算法检查这个序列是否包含每个顶点恰好一次，并且第一个顶点在末尾重复，形成*G*中的一个循环。也就是说，它检查每对连续顶点之间是否有���条边，以及第一个和最后一个顶点之间是否有一条边。这个证书可以在多项式时间内验证。'
- en: We now prove that VERTEX-COVER ≤[P] HAM-CYCLE, which shows that HAM-CYCLE is
    NP-complete. Given an undirected graph *G* = (*V*, *E*) and an integer *k*, we
    construct an undirected graph *G*′ = (*V*′, *E*′) that has a hamiltonian cycle
    if and only if *G* has a vertex cover of size *k*. We assume without loss of generality
    that *G* contains no isolated vertices (that is, every vertex in *V* has at least
    one incident edge) and that *k* ≤ |*V*|. (If an isolated vertex belongs to a vertex
    cover of size *k*, then there also exists a vertex cover of size *k* − 1, and
    for any graph, the entire set *V* is always a vertex cover.)
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们证明VERTEX-COVER ≤[P] HAM-CYCLE，这表明HAM-CYCLE是NP完全的。给定一个无向图*G* = (*V*, *E*)和一个整数*k*，我们构造一个无向图*G*′
    = (*V*′, *E*′)，当且仅当*G*有大小为*k*的顶点覆盖时，*G*′有一个哈密顿回路。我们假设无损失地*G*不包含孤立顶点（即*V*中的每个顶点至少有一条关联边）且*k*
    ≤ |*V*|。（如果一个孤立顶点属于大小为*k*的顶点覆盖，那么也存在一个大小为*k*−1的顶点覆盖，对于任何图，整个集合*V*总是一个顶点覆盖。）
- en: Our construction uses a ***gadget***, which is a piece of a graph that enforces
    certain properties. [Figure 34.16(a)](chapter034.xhtml#Fig_34-16) shows the gadget
    we use. For each edge (*u*, *v*) ∈ *E*, the constructed graph *G*′ contains one
    copy of this gadget, which we denote by Γ*[uv]*. We denote each vertex in Γ*[uv]*
    by [*u, v, i*] or [*v, u, i*], where 1 ≤ *i* ≤ 6, so that each gadget Γ*[uv]*
    contains 12 vertices. Gadget Γ*[uv]* also contains the 14 edges shown in [Figure
    34.16(a)](chapter034.xhtml#Fig_34-16).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的构造使用了一个***小工具***，它是一个强制执行某些属性的图形部分。[图 34.16(a)](chapter034.xhtml#Fig_34-16)展示了我们使用的小工具。对于每条边(*u*,
    *v*) ∈ *E*，构造的图*G*′包含一个此小工具的副本，我们用Γ*[uv]*表示。我们用[*u, v, i*]或[*v, u, i*]来表示Γ*[uv]*中的每个顶点，其中1
    ≤ *i* ≤ 6，因此每个小工具Γ*[uv]*包含12个顶点。小工具Γ*[uv]*还包含[图 34.16(a)](chapter034.xhtml#Fig_34-16)中显示的14条边。
- en: Along with the internal structure of the gadget, we enforce the properties we
    want by limiting the connections between the gadget and the remainder of the graph
    *G*′ that we construct. In particular, only vertices [*u, v,* 1], [*u, v,* 6],
    [*v, u,* 1], and [*v, u,* 6] will have edges incident from outside Γ*[uv]*. Any
    hamiltonian cycle of *G*′ must traverse the edges of Γ*[uv]* in one of the three
    ways shown in [Figures 34.16(b)](chapter034.xhtml#Fig_34-16)–[(d)](chapter034.xhtml#Fig_34-16).
    If the cycle enters through vertex [*u, v,* 1], it must exit through vertex [*u,
    v,* 6], and it either visits all 12 of the gadget’s vertices ([Figure 34.16(b)](chapter034.xhtml#Fig_34-16))
    or the six vertices [*u, v,* 1] through [*u, v,* 6] ([Figure 34.16(c)](chapter034.xhtml#Fig_34-16)).
    In the latter case, the cycle will have to reenter the gadget to visit vertices
    [*v, u,* 1] through [*v, u,* 6]. Similarly, if the cycle enters through vertex
    [*v, u,* 1], it must exit through vertex [*v, u,* 6], and either it visits all
    12 of the gadget’s vertices ([Figure 34.16(d)](chapter034.xhtml#Fig_34-16)) or
    it visits the six vertices [*v, u,* 1] through [*v, u,* 6] and reenters to visit
    [*u, v,* 1] through [*u, v,* 6] ([Figure 34.16(c)](chapter034.xhtml#Fig_34-16)).
    No other paths through the gadget that visit all 12 vertices are possible. In
    particular, it is impossible to construct two vertex-disjoint paths, one of which
    connects [*u, v,* 1] to [*v, u,* 6] and the other of which connects [*v, u,* 1]
    to [*u, v,* 6], such that the union of the two paths contains all of the gadget’s
    vertices.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 除了小工具的内部结构，我们通过限制小工具与我们构造的图*G*′的其余部分之间的连接来强制执行我们想要的属性。特别地，只有顶点[*u, v,* 1]、[*u,
    v,* 6]、[*v, u,* 1]和[*v, u,* 6]会有从Γ*[uv]*外部接入的边。*G*′的任何哈密顿回路必须以[图 34.16(b)](chapter034.xhtml#Fig_34-16)至[(d)](chapter034.xhtml#Fig_34-16)中所示的三种方式之一穿越Γ*[uv]*的边。如果回路通过顶点[*u,
    v,* 1]进入，它必须通过顶点[*u, v,* 6]退出，并且它要么访问小工具的所有12个顶点([图 34.16(b)](chapter034.xhtml#Fig_34-16))，要么访问顶点[*u,
    v,* 1]至[*u, v,* 6]的六个顶点([图 34.16(c)](chapter034.xhtml#Fig_34-16))。在后一种情况下，回路将不得不重新进入小工具以访问顶点[*v,
    u,* 1]至[*v, u,* 6]。类似地，如果回路通过顶点[*v, u,* 1]进入，它必须通过顶点[*v, u,* 6]退出，并且要么访问小工具的所有12个顶点([图
    34.16(d)](chapter034.xhtml#Fig_34-16))，要么访问顶点[*v, u,* 1]至[*v, u,* 6]的六个顶点，并重新进入以访问[*u,
    v,* 1]至[*u, v,* 6]的顶点([图 34.16(c)](chapter034.xhtml#Fig_34-16))。不可能通过访问所有12个顶点的小工具构造两条互不相交的路径，其中一条连接[*u,
    v,* 1]至[*v, u,* 6]，另一条连接[*v, u,* 1]至[*u, v,* 6]，使得这两条路径的并集包含小工具的所有顶点。
- en: The only other vertices in *V*′ other than those of gadgets are ***selector
    vertices*** *s*[1], *s*[2], … , *s[k]*. We’ll use edges incident on selector vertices
    in *G*′ to select the *k* vertices of the cover in *G*.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: '*V*′中除了小工具的顶点之外，还有***选择器顶点*** *s*[1], *s*[2], … , *s[k]*。我们将使用*G*′中与选择器顶点相邻的边来选择*G*中覆盖的*k*个顶点。'
- en: 'In addition to the edges in gadgets, *E*′ contains two other types of edges,
    which [Figure 34.17](chapter034.xhtml#Fig_34-17) shows. First, for each vertex
    *u* ∈ *V*, edges join pairs of gadgets in order to form a path containing all
    gadgets corresponding to edges incident on *u* in *G*. We arbitrarily order the
    vertices adjacent to each vertex *u* ∈ *V* as *u*^((1)), *u*^((2)), … , *u*^((degree(*u*))),
    where degree(*u*) is the number of vertices adjacent to *u*. To create a path
    in *G*′ through all the gadgets corresponding to edges incident on *u*, *E*′ contains
    the edges {([*u*, *u*^((*i*)), 6], [*u*, *u*^((*i*+1)), 1]) : 1 ≤ *i* ≤ degree(*u*)
    − 1}. In [Figure 34.17](chapter034.xhtml#Fig_34-17), for example, we order the
    vertices adjacent to *w* as 〈*x, y, z*〉, and so graph *G*′ in part (b) of the
    figure includes the edges ([*w*, *x*, 6], [*w, y*, 1]) and ([*w*, *y*, 6], [*w*,
    *z*, 1]). The vertices adjacent to *x* are ordered as 〈*w, y*〉, so that *G*′ includes
    the edge ([*x*, *w*, 6], [*x*, *y*, 1]). For each vertex *u* ∈ *V*, these edges
    in *G*′ fill in a path containing all gadgets corresponding to edges incident
    on *u* in *G*.'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '除了小工具中的边之外，*E*′还包含另外两种类型的边，[图 34.17](chapter034.xhtml#Fig_34-17)展示了这些边。首先，对于每个顶点*u*
    ∈ *V*，边连接一对小工具，以形成包含*G*中与*u*相邻的边对应的所有小工具的路径。我们将每个与顶点*u* ∈ *V*相邻的顶点任意排序为*u*^((1)),
    *u*^((2)), … , *u*^((degree(*u*)))，其中degree(*u*)是与*u*相邻的顶点数。为了在*G*′中创建一条通过所有与*u*相邻的边对应的小工具的路径，*E*′包含边{([*u*,
    *u*^((*i*)), 6], [*u*, *u*^((*i*+1)), 1]) : 1 ≤ *i* ≤ degree(*u*) − 1}。例如，在[图
    34.17](chapter034.xhtml#Fig_34-17)中，我们将与*w*相邻的顶点排序为〈*x, y, z*〉，因此图中(b)部分的*G*′包括边([*w*,
    *x*, 6], [*w, y*, 1])和([*w*, *y*, 6], [*w*, *z*, 1])。与*x*相邻的顶点排序为〈*w, y*〉，因此*G*′包括边([*x*,
    *w*, 6], [*x*, *y*, 1])。对于每个顶点*u* ∈ *V*，*G*′中的这些边填充了包含*G*中与*u*相邻的边对应的所有小工具的路径。'
- en: The intuition behind these edges is that if vertex *u* ∈ *V* belongs to the
    vertex cover of *G*, then *G*′ contains a path from [*u, u*^((1)), 1] to [*u,
    u*^((degree(*u*))), 6] that “covers” all gadgets corresponding to edges incident
    on *u*. That is, for each of these gadgets, say ![art](images/Art_P1472.jpg),
    the path either includes all 12 vertices (if *u* belongs to the vertex cover but
    *u*^((*i*)) does not) or just the six vertices [*u, u*^((*i*)), 1] through [*u,
    u*^((*i*)), 6] (if both *u* and *u*^((*i*)) belong to the vertex cover).
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 这些边背后的直觉是，如果顶点*u* ∈ *V*属于*G*的顶点覆盖，那么*G*′包含了从[*u, u*^((1)), 1]到[*u, u*^((degree(*u*))),
    6]的路径，这条路径“覆盖”了所有与*u*关联的小工具。也就是说，对于这些小工具中的每一个，比如![art](images/Art_P1472.jpg)，路径要么包含所有12个顶点（如果*u*属于顶点覆盖但*u*^((*i*))不属于），要么只包含六个顶点[*u,
    u*^((*i*)), 1]到[*u, u*^((*i*)), 6]（如果*u*和*u*^((*i*))都属于顶点覆盖）。
- en: The final type of edge in *E*′ joins the first vertex [*u, u*^((1)), 1] and
    the last vertex [*u, u*^((degree(*u*))), 6] of each of these paths to each of
    the selector vertices. That is, *E*′ includes the edges
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: '*E*′中的最终类型的边连接了每个路径的第一个顶点[*u, u*^((1)), 1]和最后一个顶点[*u, u*^((degree(*u*))), 6]到每个选择器顶点。也就是说，*E*′包括了边'
- en: '| {(*s*[*j*], [*u, u*^((1)), 1]) : *u* ∈ *V* and 1 ≤ *j* ≤ *k*} |'
  id: totrans-419
  prefs: []
  type: TYPE_TB
  zh: '| {(*s*[*j*], [*u, u*^((1)), 1]) : *u* ∈ *V* and 1 ≤ *j* ≤ *k*} |'
- en: '| ∪ {(*s*[*j*], [*u, u*^((degree(*u*))), 6]) : *u* ∈ *V* and 1 ≤ *j* ≤ *k*}.
    |'
  id: totrans-420
  prefs: []
  type: TYPE_TB
  zh: '| ∪ {(*s*[*j*], [*u, u*^((degree(*u*))), 6]) : *u* ∈ *V* and 1 ≤ *j* ≤ *k*}.
    |'
- en: '![art](images/Art_P1473.jpg)'
  id: totrans-421
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1473.jpg)'
- en: '**Figure 34.17** Reducing an instance of the vertex-cover problem to an instance
    of the hamiltonian-cycle problem. **(a)** An undirected graph *G* with a vertex
    cover of size 2, consisting of the blue vertices *w* and *y*. **(b)** The undirected
    graph *G*′ produced by the reduction, with the hamiltonian cycle corresponding
    to the vertex cover highlighted in blue. The vertex cover {*w, y*} corresponds
    to edges (*s*[1], [*w, x*, 1]) and (*s*[2], [*y, x*, 1]) appearing in the hamiltonian
    cycle.'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: '**图34.17** 将顶点覆盖问题的实例规约为哈密顿回路问题的实例。**(a)** 一个具有大小为2的顶点覆盖，由蓝色顶点*w*和*y*组成的无向图*G*。**(b)**
    通过规约产生的无向图*G*′，其中哈密顿回路对应于蓝色突出显示的顶点覆盖。顶点覆盖{*w, y*}对应于出现在哈密顿回路中的边(*s*[1], [*w, x*,
    1])和(*s*[2], [*y, x*, 1])。'
- en: Next we show that the size of *G*′ is polynomial in the size of *G*, and hence
    it takes time polynomial in the size of *G* to construct *G*′. The vertices of
    *G*′ are those in the gadgets, plus the selector vertices. With 12 vertices per
    gadget, plus *k* ≤ |*V* | selector vertices, *G*′ contains a total of
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来我们展示*G*′的大小是*G*的大小的多项式，并且构建*G*′需要的时间是*G*的大小的多项式。*G*′的顶点是小工具中的顶点，加上选择器顶点。每个小工具有12个顶点，再加上*k*
    ≤ |*V*| 个选择器顶点，*G*′总共包含
- en: '| &#124;*V′*&#124; | = | 12 &#124;*E*&#124; + *k* |'
  id: totrans-424
  prefs: []
  type: TYPE_TB
  zh: '| &#124;*V′*&#124; | = | 12 &#124;*E*&#124; + *k* |'
- en: '|  | ≤ | 12 &#124;*E*&#124; + &#124;*V*&#124; |'
  id: totrans-425
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | 12 &#124;*E*&#124; + &#124;*V*&#124; |'
- en: vertices. The edges of *G*′ are those in the gadgets, those that go between
    gadgets, and those connecting selector vertices to gadgets. Each gadget contains
    14 edges, totaling 14 |*E*| in all gadgets. For each vertex *u* ∈ *V*, graph *G*′
    has degree(*u*) − 1 edges going between gadgets, so that summed over all vertices
    in *V*,
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 顶点。*G*′的边包括了小工具中的边，连接小工具之间的边，以及连接选择器顶点到小工具的边。每个小工具包含14条边，总共有14 |*E*| 条边。对于每个顶点*u*
    ∈ *V*，图*G*′有度数(*u*) − 1的边连接小工具之间，所以对所有顶点*u* ∈ *V*求和，
- en: '![art](images/Art_P1474.jpg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1474.jpg)'
- en: edges go between gadgets. Finally, *G*′ has two edges for each pair consisting
    of a selector vertex and a vertex of *V*, totaling 2*k* |*V*| such edges. The
    total number of edges of *G*′ is therefore
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 边连接小工具之间。最后，*G*′对于每对选择器顶点和*V*中的顶点都有两条边，总共有2*k* |*V*| 这样的边。因此，*G*′的总边数为
- en: '| &#124;*E′*&#124; | = | (14 &#124;*E*&#124;) + (2 &#124;*E*&#124; − &#124;*V*&#124;)
    + (2*k* &#124;*V*&#124;) |'
  id: totrans-429
  prefs: []
  type: TYPE_TB
  zh: '| &#124;*E′*&#124; | = | (14 &#124;*E*&#124;) + (2 &#124;*E*&#124; − &#124;*V*&#124;)
    + (2*k* &#124;*V*&#124;) |'
- en: '|  | = | 16 &#124;*E*&#124; + (2*k* − 1) &#124;*V*&#124; |'
  id: totrans-430
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 16 &#124;*E*&#124; + (2*k* − 1) &#124;*V*&#124; |'
- en: '|  | ≤ | 16 &#124;*E*&#124; + (2 &#124;*V*&#124; − 1) &#124;*V*&#124;. |'
  id: totrans-431
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | 16 &#124;*E*&#124; + (2 &#124;*V*&#124; − 1) &#124;*V*&#124;。|'
- en: Now we show that the transformation from graph *G* to *G*′ is a reduction. That
    is, we must show that *G* has a vertex cover of size *k* if and only if *G*′ has
    a hamiltonian cycle.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们展示从图*G*到*G*′的转换是一个规约。也就是说，我们必须展示如果*G*有大小为*k*的顶点覆盖，那么*G*′有哈密顿回路，反之亦然。
- en: Suppose that *G* = (*V*, *E*) has a vertex cover *V** ⊆ *V*, where |*V**| =
    *k*. Let *V** = {*u*[1], *u*[2], … , *u[k]*}. As [Figure 34.17](chapter034.xhtml#Fig_34-17)
    shows, we can construct a hamiltonian cycle in *G*′ by including the following
    edges^([11](#footnote_11)) for each vertex *u[j]* ∈ *V**. Start by including edges
    ![art](images/Art_P1475.jpg), which connect all gadgets corresponding to edges
    incident on *u[j]*. Also include the edges within these gadgets as [Figures 34.16(b)](chapter034.xhtml#Fig_34-16)–[(d)](chapter034.xhtml#Fig_34-16)
    show, depending on whether the edge is covered by one or two vertices in *V**.
    The hamiltonian cycle also includes the edges
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 假设*G* = (*V*, *E*)有一个大小为*k*的顶点覆盖*V** ⊆ *V*，其中|*V**| = *k*。让*V** = {*u*[1], *u*[2],
    … , *u[k]*}。如[图34.17](chapter034.xhtml#Fig_34-17)所示，我们可以通过为每个顶点*u[j]* ∈ *V**包含以下边^([11](#footnote_11))来构建*G*′中的哈密顿回路。首先包括连接所有与*u[j]*相关的小工具的边![art](images/Art_P1475.jpg)。还包括这些小工具内部的边，如图34.16(b)–(d)所示，具���取决于边是由一个还是两个顶点在*V**中覆盖。哈密顿回路还包括以下边
- en: '![art](images/Art_P1476.jpg)'
  id: totrans-434
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1476.jpg)'
- en: By inspecting [Figure 34.17](chapter034.xhtml#Fig_34-17), you can verify that
    these edges form a cycle, where *u*[1] = *w* and *u*[2] = *y*. The cycle starts
    at *s*[1], visits all gadgets corresponding to edges incident on *u*[1], then
    visits *s*[2], visits all gadgets corresponding to edges incident on *u*[2], and
    so on, until it returns to *s*[1]. The cycle visits each gadget either once or
    twice, depending on whether one or two vertices of *V** cover its corresponding
    edge. Because *V** is a vertex cover for *G*, each edge in *E* is incident on
    some vertex in *V**, and so the cycle visits each vertex in each gadget of *G*′.
    Because the cycle also visits every selector vertex, it is hamiltonian.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 通过检查[图34.17](chapter034.xhtml#Fig_34-17)，您可以验证这些边形成一个循环，其中*u*[1] = *w*，*u*[2]
    = *y*。该循环从*s*[1]开始，访问所有与*u*[1]关联的小工具，然后访问*s*[2]，访问所有与*u*[2]关联的小工具，依此类推，直到返回*s*[1]。该循环访问每个小工具一次或两次，取决于*V*中一个还是两个顶点覆盖其对应的边。因为*V*是*G*的一个顶点覆盖，所以*E*中的每条边都与*V*中的某个顶点关联，因此该循环访问*G*′的每个小工具中的每个顶点。因为该循环还访问每个选择器顶点，所以它是汉密尔顿的。
- en: Conversely, suppose that *G*′ = (*V*′, *E*′) contains a hamiltonian cycle *C*
    ⊆ *E*′. We claim that the set
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，假设*G*′ = (*V*′, *E*′)包含汉密尔顿循环*C* ⊆ *E*′。我们声称集合
- en: '![art](images/Art_P1477.jpg)'
  id: totrans-437
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P1477.jpg)'
- en: is a vertex cover for *G*.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 是*G*的一个顶点覆盖。
- en: We first argue that the set *V** is well defined, that is, for each selector
    vertex *s[j]*, exactly one of the incident edges in the hamiltonian cycle *C*
    is of the form (*s*[*j*], [*u*, *u*^((1)), 1]) for some vertex *u* ∈ *V*. To see
    why, partition the hamiltonian cycle *C* into maximal paths that start at some
    selector vertex *s[i]*, visit one or more gadgets, and end at some selector vertex
    *s[j]* without passing through any other selector vertex. Let’s call each of these
    maximal paths a “cover path.” Let *P* be one such cover path, and orient it going
    from *s[i]* to *s[j]*. If *P* contains the edge (*s[i]*, [*u*, *u*^((1)), 1])
    for some vertex *u* ∈ *V*, then we have shown that one edge incident on *s[i]*
    has the required form. Assume, then, that *P* contains the edge (*s*[*i*], [*v,
    v*^((degree(*v*))), 6]) for some vertex *v* ∈ *V*. This path enters a gadget from
    the bottom, as drawn in [Figures 34.16](chapter034.xhtml#Fig_34-16) and [34.17](chapter034.xhtml#Fig_34-17),
    and it leaves from the top. It might go through several gadgets, but it always
    enters from the bottom of a gadget and leaves from the top. The only edges incident
    on vertices at the top of a gadget either go to the bottoms of other gadgets or
    to selector vertices. Therefore, after the last gadget in the series of gadgets
    visited by *P*, the edge taken must go to a selector vertex *s[j]*, so that *P*
    contains an edge of the form (*s*[*j*], [*u*, *u*^((1)), 1]), where [*u, u*^((1)),
    1] is a vertex at the top of some gadget. To see that not both edges incident
    on *s[j]* have this form, simply reverse the direction of traversing *P* in the
    above argument.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要证明集合*V*是明确定义的，也就是说，对于每个选择器顶点*s[j]*，汉密尔顿循环*C*中恰好有一个形式为(*s*[*j*], [*u*, *u*^((1)),
    1])的关联边，其中*u* ∈ *V*。为什么呢？将汉密尔顿循环*C*分成从某个选择器顶点*s[i]*开始，访问一个或多个小工具，然后在不经过其他选择器顶点的情况下结束于某个选择器顶点*s[j]*的最大路径。让我们称这些最大路径为“覆盖路径”。让*P*是这样的一个覆盖路径，并将其从*s[i]*定向到*s[j]*。如果*P*包含形式为(*s[i]*,
    [*u*, *u*^((1)), 1])的边，其中*u* ∈ *V*，那么我们已经证明了一个与*s[i]*关联的边具有所需的形式。然后假设*P*包含形式为(*s*[*i*],
    [*v, v*^((degree(*v*))), 6])的边，其中*v* ∈ *V*。这条路径从底部进入一个小工具，如[图34.16](chapter034.xhtml#Fig_34-16)和[34.17](chapter034.xhtml#Fig_34-17)所示，然后从顶部离开。它可能经过几个小工具，但它总是从一个小工具的底部进入并从顶部离开。顶部小工具上的唯一边要么通向其他小工具的底部，要么通向选择器顶点。因此，在*P*访问的最后一个小工具之后，所取的边必须通向选择器顶点*s[j]*，这样*P*就包含形式为(*s*[*j*],
    [*u*, *u*^((1)), 1])的边，其中[*u, u*^((1)), 1]是某个小工具顶部的顶点。要看到并非*s[j]*上的两条边都具有这种形式，只需将上述论证中*P*的遍历方向反转即可。
- en: Having established that the set *V** is well defined, let’s see why it is a
    vertex cover for *G*. We have already established that each cover path starts
    at some *s[i]*, takes the edge (*s*[*i*], [*u, u*^((1)), 1]) for some vertex *u*
    ∈ *V*, passes through all the gadgets corresponding to edges in *E* incident on
    *u*, and then ends at some selector vertex *s[j]*. (This orientation is the reverse
    of the orientation in the paragraph above.) Let’s call this cover path *P[u]*,
    and by equation (34.4), the vertex cover *V** includes *u*. Each gadget visited
    by *P[u]* must be Γ*[uv]* or Γ*[vu]* for some *v* ∈ *V*. For each gadget visited
    by *P[u]*, its vertices are visited by either one or two cover paths. If they
    are visited by one cover path, then edge (*u*, *v*) ∈ *E* is covered in *G* by
    vertex *u*. If two cover paths visit the gadget, then the other cover path must
    be *P[v]*, which implies that *v* ∈ *V**, and edge (*u*, *v*) ∈ *E* is covered
    by both *u* and *v*. Because each vertex in each gadget is visited by some cover
    path, we see that each edge in *E* is covered by some vertex in *V**.
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 确定了集合*V*明确定义后，让我们看看为什么它是*G*的一个顶点覆盖。我们已经确定每个覆盖路径从某个*s[i]*开始，取形式为(*s*[*i*], [*u,
    u*^((1)), 1])的边，其中*u* ∈ *V*，经过所有与*u*关联的边对应的所有小工具，然后结束于某个选择器顶点*s[j]*。（这个方向与上面段落中的方向相反。）让这条覆盖路径为*P[u]*，根据方程(34.4)，顶点覆盖*V*包括*u*。*P[u]*访问的每个小工具必须是Γ*[uv]*或Γ*[vu]*，其中*v*
    ∈ *V*。对于*P[u]*访问的每个小工具，其顶点被一个或两个覆盖路径访问。如果它们被一个覆盖路径访问，则边(*u*, *v*) ∈ *E*在*G*中由顶点*u*覆盖。如果两个覆盖路径访问该小工具，则另一个覆盖路径必须是*P[v]*，这意味着*v*
    ∈ *V*，且边(*u*, *v*) ∈ *E*由*u*和*v*都覆盖。因为每个小工具中的每个顶点都被某个覆盖路径访问，我们看到*E*中的每条边都被*V*中的某个顶点覆盖。
- en: ▪
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**34.5.4    The traveling-salesperson problem**'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '**34.5.4    旅行推销员问题**'
- en: In the ***traveling-salesperson problem***, which is closely related to the
    hamiltonian-cycle problem, a salesperson must visit *n* cities. Let’s model the
    problem as a complete graph with *n* vertices, so that the salesperson wishes
    to make a ***tour***, or hamiltonian cycle, visiting each city exactly once and
    finishing at the starting city. The salesperson incurs a nonnegative integer cost
    *c*(*i, j*) to travel from city *i* to city *j*. In the optimization version of
    the problem, the salesperson wishes to make the tour whose total cost is minimum,
    where the total cost is the sum of the individual costs along the edges of the
    tour. For example, in [Figure 34.18](chapter034.xhtml#Fig_34-18), a minimum-cost
    tour is 〈*u, w, v, x, u*〉, with cost 7\. The formal language for the corresponding
    decision problem is
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 在与哈密顿回路问题密切相关的***旅行推销员问题***中，一个推销员必须访问*n*个城市。让我们将问题建模为一个具有*n*个顶点的完全图，以便推销员希望进行一次***旅行***或哈密顿循环，每次访问每个城市一次，并在起始城市结束。推销员需要花费非负整数成本*c*(*i,
    j*)从城市*i*到城市*j*旅行。在问题的优化版本中，推销员希望进行总成本最小的旅行，其中总成本是沿着旅行的边的个别成本之和。例如，在[图34.18](chapter034.xhtml#Fig_34-18)中，最小成本旅行是〈*u,
    w, v, x, u*〉，成本为7。相应决策问题的形式语言是
- en: '![art](images/Art_P1478.jpg)'
  id: totrans-444
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1478.jpg)'
- en: '**Figure 34.18** An instance of the traveling-salesperson problem. Edges highlighted
    in blue represent a minimum-cost tour, with cost 7.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: '**图34.18** 旅行推销员问题的一个实例。蓝色突出显示的边代表成本为7的最小成本旅行。'
- en: '| TSP = {〈*G, c, k*〉: | *G* = (*V*, *E*) is a complete graph, |'
  id: totrans-446
  prefs: []
  type: TYPE_TB
  zh: '| TSP = {〈*G, c, k*〉: | *G* = (*V*, *E*)是一个完全图， |'
- en: '|  | *c* is a function from *V* × *V* → ℕ, |'
  id: totrans-447
  prefs: []
  type: TYPE_TB
  zh: '|  | *c*是从*V* × *V* → ℕ的函数， |'
- en: '|  | *k* ∈ ℕ, and |'
  id: totrans-448
  prefs: []
  type: TYPE_TB
  zh: '|  | *k* ∈ ℕ，并且 |'
- en: '|  | *G* has a traveling-salesperson tour with cost at most *k*}. |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '|  | *G*具有成本最多为*k*的旅行推销员旅行}。 |'
- en: The following theorem shows that a fast algorithm for the traveling-salesperson
    problem is unlikely to exist.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 以下定理表明，旅行推销员问题的快速算法不太可能存在。
- en: '***Theorem 34.14***'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理34.14***'
- en: The traveling-salesperson problem is NP-complete.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 旅行推销员问题是NP完全的。
- en: '***Proof***   We first show that TSP ∈ NP. Given an instance of the problem,
    the certificate is the sequence of *n* vertices in the tour. The verification
    algorithm checks that this sequence contains each vertex exactly once, sums up
    the edge costs, and checks that the sum is at most *k*. This process can certainly
    be done in polynomial time.'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 我们首先展示TSP ∈ NP。给定问题的一个实例，证书是旅行中*n*个顶点的序列。验证算法检查该序列是否包含每个顶点恰好一次，计算边的成本总和，并检查总和是否最多为*k*。这个过程肯定可以在多项式时间内完成。'
- en: 'To prove that TSP is NP-hard, we show that HAM-CYCLE ≤[P] TSP. Given an instance
    *G* = (*V*, *E*) of HAM-CYCLE, construct an instance of TSP by forming the complete
    graph *G*′ = (*V*, *E*′), where *E*′ = {(*i*, *j*) : *i, j* ∈ *V* and *i* ≠ *j*
    }, with the cost function *c* defined as'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明TSP是NP难的，我们展示HAM-CYCLE ≤[P] TSP。给定HAM-CYCLE的实例*G* = (*V*, *E*)，通过构建完全图*G*′
    = (*V*, *E*′)的TSP实例，其中*E*′ = {(*i*, *j*)：*i, j* ∈ *V*且*i* ≠ *j*}，成本函数*c*定义为
- en: '![art](images/Art_P1479.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1479.jpg)'
- en: (Because *G* is undirected, it contains no self-loops, and so *c*(*v, v*) =
    1 for all vertices *v* ∈ *V*.) The instance of TSP is then 〈*G*′, *c*, 0〉, which
    can be created in polynomial time.
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: （因为*G*是无向的，它不包含自环，因此对于所有顶点*v* ∈ *V*，*c*(*v, v*) = 1。）TSP的实例是〈*G*′，*c*，0〉，可以在多项式时间内创建。
- en: We now show that graph *G* has a hamiltonian cycle if and only if graph *G*′
    has a tour of cost at most 0\. Suppose that graph *G* has a hamiltonian cycle
    *H*. Each edge in *H* belongs to *E* and thus has cost 0 in *G*′. Thus, *H* is
    a tour in *G*′ with cost 0\. Conversely, suppose that graph *G*′ has a tour *H*′
    of cost at most 0\. Since the costs of the edges in *E*′ are 0 and 1, the cost
    of tour *H*′ is exactly 0 and each edge on the tour must have cost 0\. Therefore,
    *H*′ contains only edges in *E*. We conclude that *H*′ is a hamiltonian cycle
    in graph *G*.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在展示图*G*具有哈密顿回路当且仅当图*G*′具有成本最多为0的旅行。假设图*G*有一个哈密顿回路*H*。*H*中的每条边属于*E*，因此在*G*′中的成本为0。因此，*H*是*G*′中成本为0的旅行。反之，假设图*G*′有一个成本最多为0的旅行*H*′。由于*E*′中边的成本为0和1，*H*′的成本恰好为0，旅行中的每条边必须成本为0。因此，*H*′仅包含*E*中的边。我们得出结论，*H*′是图*G*中的一个哈密顿回路。
- en: ▪
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**34.5.5    The subset-sum problem**'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: '**34.5.5** 子集和问题'
- en: We next consider an arithmetic NP-complete problem. The ***subset-sum problem***
    takes as inputs a finite set *S* of positive integers and an integer ***target*** *t*
    > 0\. It asks whether there exists a subset *S*′ ⊆ *S* whose elements sum to exactly
    *t*. For example, if *S* = {1, 2, 7, 14, 49, 98, 343, 686, 2409, 2793, 16808,
    17206, 117705, 117993} and *t* = 138457, then the subset *S*′ = {1, 2, 7, 98,
    343, 686, 2409, 17206, 117705} is a solution.
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接下来考虑一个算术NP完全问题。***子集和问题***的输入是一组正整数*S*和一个整数***目标*** *t* > 0。它询问是否存在一个子集*S*′
    ⊆ *S*，其元素的和恰好为*t*。例如，如果*S* = {1, 2, 7, 14, 49, 98, 343, 686, 2409, 2793, 16808,
    17206, 117705, 117993}，*t* = 138457，那么子集*S*′ = {1, 2, 7, 98, 343, 686, 2409, 17206,
    117705}是一个解。
- en: 'As usual, we express the problem as a language:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，我们将问题表达为一个语言：
- en: 'SUBSET-SUM = {〈*S*, *t*〉 : there exists a subset *S*′ ⊆ *S* such that *t* =
    Σ[*s*∈*S*′] *S*}.'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 'SUBSET-SUM = {〈*S*, *t*〉 : 存在一个子集*S*′ ⊆ *S*，使得*t* = Σ[*s*∈*S*′] *S*}。'
- en: As with any arithmetic problem, it is important to recall that our standard
    encoding assumes that the input integers are coded in binary. With this assumption
    in mind, we can show that the subset-sum problem is unlikely to have a fast algorithm.
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何算术问题一样，重要的是要记住我们的标准编码假设输入整数是用二进制编码的。有了这个假设，我们可以证明子集和问题不太可能有一个快速算法。
- en: '***Theorem 34.15***'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理34.15***'
- en: The subset-sum problem is NP-complete.
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 子集和问题是NP完全的。
- en: '***Proof***   To show that SUBSET-SUM ∈ NP, for an instance 〈*S, t*〉 of the
    problem, let the subset *S*′ be the certificate. A verification algorithm can
    check whether *t* = Σ[*s*∈*S*′] *S* in polynomial time.'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 为了证明SUBSET-SUM ∈ NP，对于问题的实例〈*S, t*〉，让子集*S*′成为证书。验证算法可以在多项式时间内检查*t*
    = Σ[*s*∈*S*′] *S*。'
- en: We now show that 3-CNF-SAT ≤[P] SUBSET-SUM. Given a 3-CNF formula *ϕ* over variables
    *x*[1], *x*[2], … , *x[n]* with clauses *C*[1], *C*[2], … , *C[k]*, each containing
    exactly three distinct literals, the reduction algorithm constructs an instance
    〈*S, t*〉 of the subset-sum problem such that *ϕ* is satisfiable if and only if
    there exists a subset of *S* whose sum is exactly *t*. Without loss of generality,
    we make two simplifying assumptions about the formula *ϕ*. First, no clause contains
    both a variable and its negation, for such a clause is automatically satisfied
    by any assignment of values to the variables. Second, each variable appears in
    at least one clause, because it does not matter what value is assigned to a variable
    that appears in no clauses.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在证明3-CNF-SAT ≤[P] SUBSET-SUM。 给定一个关于变量*x*[1]、*x*[2]、…、*x[n]*和包含恰好三个不同文字的子句*C*[1]、*C*[2]、…、*C[k]*的3-CNF公式*ϕ*，减少算法构造了一个子集和问题的实例〈*S,
    t*〉，使得*ϕ*可满足当且仅当存在一个子集*S*的和恰好为*t*。 不失一般性，我们对公式*ϕ*做两个简化假设。 首先，没有子句同时包含一个变量及其否定，因为这样的子句会被任何对变量的值的赋值自动满足。
    其次，每个变量至少出现在一个子句中，因为对于不出现在任何子句中的变量赋什么值并不重要。
- en: The reduction creates two numbers in set *S* for each variable *x[i]* and two
    numbers in *S* for each clause *C[j]*. The numbers will be represented in base
    10, with each number containing *n* + *k* digits and each digit corresponding
    to either one variable or one clause. Base 10 (and other bases, as we shall see)
    has the property we need of preventing carries from lower digits to higher digits.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个变量*x[i]*，减少为集合*S*中的两个数字，并且对于每个子句*C[j]*，也是两个数字。 这些数字将以十进制表示，每个数字包含*n* + *k*位，每位对应于一个变量或一个子句。
    十进制（以及我们将看到的其他进制）具有我们需要的防止低位到高位的进位的属性。
- en: '![art](images/Art_P1480.jpg)'
  id: totrans-469
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1480.jpg)'
- en: '**Figure 34.19** The reduction of 3-CNF-SAT to SUBSET-SUM. The formula in 3-CNF
    is *ϕ* = *C*[1]∧*C*[2]∧*C*[3]∧*C*[4], where *C*[1] = (*x*[1]∨¬*x*[2]∨¬*x*[3]),
    *C*[2] = (¬*x*[1]∨¬*x*[2]∨¬*x*[3]), *C*[3] = (¬*x*[1]∨¬*x*[2]∨*x*[3]), and *C*[4]
    = (*x*[1] ∨ *x*[2] ∨ *x*[3]). A satisfying assignment of *ϕ* is 〈*x*[1] = 0, *x*[2]
    = 0, *x*[3] = 1〉. The set *S* produced by the reduction consists of the base-10
    numbers shown: reading from top to bottom, *S* = {1001001, 1000110, 100001, 101110,
    10011, 11100, 1000, 2000, 100, 200, 10, 20, 1, 2}. The target *t* is 1114444\.
    The subset *S*′ ⊆ *S* is shaded blue, and it contains ![art](images/Art_P1480a.jpg),
    and *v*[3], corresponding to the satisfying assignment. Subset *S*′ also contains
    slack variables *s*[1], ![art](images/Art_P1480b.jpg), *s*[3], *s*[4], and ![art](images/Art_P1480c.jpg)
    to achieve the target value of 4 in the digits labeled by *C*[1] through *C*[4].'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: '**图34.19** 3-CNF-SAT到SUBSET-SUM的减少。 3-CNF中的公式为*ϕ* = *C*[1]∧*C*[2]∧*C*[3]∧*C*[4]，其中*C*[1]
    = (*x*[1]∨¬*x*[2]∨¬*x*[3])*，*C*[2] = (¬*x*[1]∨¬*x*[2]∨¬*x*[3])*，*C*[3] = (¬*x*[1]∨¬*x*[2]∨*x*[3])*，*C*[4]
    = (*x*[1] ∨ *x*[2] ∨ *x*[3])*。 *ϕ*的一个满足的赋值是〈*x*[1] = 0, *x*[2] = 0, *x*[3] = 1〉。
    减少产生的集合*S*如下所示：从上到下阅读，*S* = {1001001, 1000110, 100001, 101110, 10011, 11100, 1000,
    2000, 100, 200, 10, 20, 1, 2}。 目标*t*为1114444。 子集*S*′ ⊆ *S*被标记为蓝色，并且包含![艺术](images/Art_P1480a.jpg)和*v*[3]，对应于满足的赋值。
    子集*S*′还包含松弛变量*s*[1]、![艺术](images/Art_P1480b.jpg)、*s*[3]、*s*[4]和![艺术](images/Art_P1480c.jpg)，以实现由*C*[1]到*C*[4]标记的数字中的目标值4。'
- en: As [Figure 34.19](chapter034.xhtml#Fig_34-19) shows, we construct set *S* and
    target *t* as follows. Label each digit position by either a variable or a clause.
    The least significant *k* digits are labeled by the clauses, and the most significant
    *n* digits are labeled by variables.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 如[图34.19](chapter034.xhtml#Fig_34-19)所示，我们构建集合*S*和目标*t*如下。 将每个数字位置标记为变量或子句。
    最不重要的*k*位由子句���记，最重要的*n*位由变量标记。
- en: The target *t* has a 1 in each digit labeled by a variable and a 4 in each digit
    labeled by a clause.
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标*t*在由变量标记的每个数字中为1，在由子句标记的每个数字中为4。
- en: For each variable *x[i]*, set *S* contains two integers *v[i]* and ![art](images/Art_P1480d.jpg).
    Each of *v[i]* and ![art](images/Art_P1480d.jpg) has a 1 in the digit labeled
    by *x[i]* and 0s in the other variable digits. If literal *x[i]* appears in clause
    *C[j]*, then the digit labeled by *C[j]* in *v[i]* contains a 1\. If literal ¬*x[i]*
    appears in clause *C[j]*, then the digit labeled by *C[j]* in ![art](images/Art_P1480d.jpg)
    contains a 1\. All other digits labeled by clauses in *v[i]* and ![art](images/Art_P1480d.jpg)
    are 0.
  id: totrans-473
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个变量*x[i]*，集合*S*包含两个整数*v[i]*和![艺术](images/Art_P1480d.jpg)。 *v[i]*和![艺术](images/Art_P1480d.jpg)中由*x[i]*标记的数字为1，其他变量数字为0。
    如果文字*x[i]*出现在子句*C[j]*中，则*v[i]*中由*C[j]*标记的数字包含1。 如果文字¬*x[i]*出现在子句*C[j]*中，则![艺术](images/Art_P1480d.jpg)中由*C[j]*标记的数字包含1。
    在*v[i]*和![艺术](images/Art_P1480d.jpg)中由其他子句标记的数字都为0。
- en: All *v[i]* and ![art](images/Art_P1480d.jpg) values in set *S* are unique. Why?
    For *ℓ* ≠ *i*, no *v*[*ℓ*] or ![art](images/Art_P1480e.jpg) values can equal *v[i]*
    and ![art](images/Art_P1480d.jpg) in the most significant *n* digits. Furthermore,
    by our simplifying assumptions above, no *v[i]* and ![art](images/Art_P1480d.jpg)
    can be equal in all *k* least significant digits. If *v[i]* and ![art](images/Art_P1480d.jpg)
    were equal, then *x[i]* and ¬*x[i]* would have to appear in exactly the same set
    of clauses. But we assume that no clause contains both *x[i]* and ¬*x[i]* and
    that either *x[i]* or ¬*x[i]* appears in some clause, and so there must be some
    clause *C[j]* for which *v[i]* and ![art](images/Art_P1480d.jpg) differ.
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 集合*S*中的所有*v[i]*和![艺术](images/Art_P1480d.jpg)值都是唯一的。 为什么？ 对于*ℓ* ≠ *i*，没有*v*[*ℓ*]或![艺术](images/Art_P1480e.jpg)值可以等于*v[i]*和![艺术](images/Art_P1480d.jpg)中最重要的*n*位。
    此外，根据我们上面的简化假设，没有*v[i]*和![艺术](images/Art_P1480d.jpg)可以在所有*k*最不重要的位上相等。 如果*v[i]*和![艺术](images/Art_P1480d.jpg)相等，那么*x[i]*和¬*x[i]*必须出现在完全相同的一组子句中。
    但我们假设没有子句同时包含*x[i]*和¬*x[i]*，并且任何一个*x[i]*或¬*x[i]*都出现在某个子句中，因此必须存在一些子句*C[j]*，其中*v[i]*和![艺术](images/Art_P1480d.jpg)不同。
- en: For each clause *C[j]*, set *S* contains two integers *s[j]* and ![art](images/Art_P1480f.jpg).
    Each of *s[j]* and ![art](images/Art_P1480f.jpg) has 0s in all digits other than
    the one labeled by *C[j]*. For *s[j]*, there is a 1 in the *C[j]* digit, and ![art](images/Art_P1480f.jpg)
    has a 2 in this digit. These integers are “slack variables,” which we use to get
    each clause-labeled digit position to add to the target value of 4.
  id: totrans-475
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于每个子句*C[j]*，集合*S*包含两个整数*s[j]*和![art](images/Art_P1480f.jpg)。每个*s[j]*和![art](images/Art_P1480f.jpg)在除了由*C[j]*标记的位之外的所有位上都是0。对于*s[j]*，在*C[j]*位有一个1，而![art](images/Art_P1480f.jpg)在这个位上有一个2。这些整数是“松弛变量”，我们使用它们使得每个由子句标记的位加到目标值4。
- en: Simple inspection of [Figure 34.19](chapter034.xhtml#Fig_34-19) demonstrates
    that all *s[j]* and ![art](images/Art_P1480f.jpg) values in *S* are unique in
    set *S*.
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对[图34.19](chapter034.xhtml#Fig_34-19)的简单检查表明，*S*中的所有*s[j]*和![art](images/Art_P1480f.jpg)值在集合*S*中是唯一的。
- en: The greatest sum of digits in any one digit position is 6, which occurs in the
    digits labeled by clauses (three 1s from the *v[i]* and ![art](images/Art_P1480d.jpg)
    values, plus 1 and 2 from the *s[j]* and ![art](images/Art_P1480f.jpg) values).
    Interpreting these numbers in base 10, therefore, no carries can occur from lower
    digits to higher digits.^([12](#footnote_12))
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 任何一个数字位置上的数字之和的最大值为6，在由子句标记的数字中发生（来自*v[i]*和![art](images/Art_P1480d.jpg)值的三个1，加上来自*s[j]*和![art](images/Art_P1480f.jpg)值的1和2）。因此，将这些数字解释为十进制，因此从低位到高位不会发生进位。^([12](#footnote_12))
- en: The reduction can be performed in polynomial time. The set *S* consists of 2*n*
    + 2*k* values, each of which has *n* + *k* digits, and the time to produce each
    digit is polynomial in *n* + *k*. The target *t* has *n* + *k* digits, and the
    reduction produces each in constant time.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这个规约可以在多项式时间内完成。集合*S*由2*n* + 2*k*个值组成，每个值有*n* + *k*位，生成每个位的时间与*n* + *k*的多项式成正比。目标*t*有*n*
    + *k*位，规约产生每个位的时间是常数。
- en: Let’s now show that the 3-CNF formula *ϕ* is satisfiable if and only if there
    exists a subset *S*′ ⊆ *S* whose sum is *t*. First, suppose that *ϕ* has a satisfying
    assignment. For *i* = 1, 2, … , *n*, if *x[i]* = 1 in this assignment, then include
    *v[i]* in *S*′. Otherwise, include ![art](images/Art_P1480d.jpg). In other words,
    *S*′ includes exactly the *v[i]* and ![art](images/Art_P1480d.jpg) values that
    correspond to literals with the value 1 in the satisfying assignment. Having included
    either *v[i]* or ![art](images/Art_P1480d.jpg), but not both, for all *i*, and
    having put 0 in the digits labeled by variables in all *s[j]* and ![art](images/Art_P1480f.jpg),
    we see that for each variable-labeled digit, the sum of the values of *S*′ must
    be 1, which matches those digits of the target *t*. Because each clause is satisfied,
    the clause contains some literal with the value 1\. Therefore, each digit labeled
    by a clause has at least one 1 contributed to its sum by a *v[i]* or ![art](images/Art_P1480d.jpg)
    value in *S*′. In fact, one, two, or three literals may be 1 in each clause, and
    so each clause-labeled digit has a sum of 1, 2, or 3 from the *v[i]* and ![art](images/Art_P1480d.jpg)
    values in *S*′. In [Figure 34.19](chapter034.xhtml#Fig_34-19) for example, literals
    ¬*x*[1], ¬*x*[2], and *x*[3] have the value 1 in a satisfying assignment. Each
    of clauses *C*[1] and *C*[4] contains exactly one of these literals, and so together
    ![art](images/Art_P1480i.jpg), and *v*[3] contribute 1 to the sum in the digits
    for *C*[1] and *C*[4]. Clause *C*[2] contains two of these literals, and ![art](images/Art_P1480i.jpg),
    and *v*[3] contribute 2 to the sum in the digit for *C*[2]. Clause *C*[3] contains
    all three of these literals, and ![art](images/Art_P1480i.jpg), and *v*[3] contribute
    3 to the sum in the digit for *C*[3]. To achieve the target of 4 in each digit
    labeled by clause *C[j]*, include in *S*′ the appropriate nonempty subset of slack
    variables {*s*[*j*], ![art](images/Art_P1480f.jpg) }. In [Figure 34.19](chapter034.xhtml#Fig_34-19),
    *S*′ includes *s*[1], ![art](images/Art_P1480b.jpg), *s*[3], *s*[4], and ![art](images/Art_P1480c.jpg).
    Since *S*′ matches the target in all digits of the sum, and no carries can occur,
    the values of *S*′ sum to *t*.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们证明3-CNF公式*ϕ*是可满足的，当且仅当存在一个子集*S*′ ⊆ *S*，其和为*t*。首先，假设*ϕ*有一个满足的赋值。对于*i* =
    1, 2, … , *n*，如果在这个赋值中*x[i]* = 1，那么将*v[i]*包含在*S*′中。否则，包含![art](images/Art_P1480d.jpg)。换句话说，*S*′包含与满足赋值中值为1的文字对应的*v[i]*和![art](images/Art_P1480d.jpg)值。对于所有*i*，包含*v[i]*或![art](images/Art_P1480d.jpg)，但不是两者，同时在所有*s[j]*和![art](images/Art_P1480f.jpg)标记的数字中放入0，我们可以看到对于每个标记为变量的数字，*S*′的值之和必须为1，与目标*t*的数字匹配。因为每个子句都被满足，子句包含一些值为1的文字。因此，每个子句标记的数字至少有一个由*S*′中的*v[i]*或![art](images/Art_P1480d.jpg)值贡献给其和的1。实际上，每个子句可能有一个、两个或三个文字为1，因此每个子句标记的数字的和为1、2或3，来自*S*′中的*v[i]*和![art](images/Art_P1480d.jpg)值。例如，在[图34.19](chapter034.xhtml#Fig_34-19)中，文字¬*x*[1]、¬*x*[2]和*x*[3]在一个满足的赋值中的值为1。子句*C*[1]和*C*[4]分别包含这些文字中的一个，因此一起![art](images/Art_P1480i.jpg)和*v*[3]为*C*[1]和*C*[4]的数字的和贡献1。子句*C*[2]包含这些文字中的两个，因此![art](images/Art_P1480i.jpg)和*v*[3]为*C*[2]的数字的和贡献2。子句*C*[3]包含这些文字中的全部三个，因此![art](images/Art_P1480i.jpg)和*v*[3]为*C*[3]的数字的和贡献3。为了实现每个由子句*C[j]*标记的数字的目标为4，在*S*′中包含适当的非空子集的松弛变量{*s*[*j*]，![art](images/Art_P1480f.jpg)}。在[图34.19](chapter034.xhtml#Fig_34-19)中，*S*′包含*s*[1]、![art](images/Art_P1480b.jpg)、*s*[3]、*s*[4]和![art](images/Art_P1480c.jpg)。由于*S*′在和的所有数字中匹配目标，并且不会发生进位，*S*′的值之和为*t*。
- en: Now suppose that some subset *S*′ ⊆ *S* sums to *t*. The subset *S*′ must include
    exactly one of *v[i]* and ![art](images/Art_P1480d.jpg) for each *i* = 1, 2, …
    , *n*, for otherwise the digits labeled by variables would not sum to 1\. If *v[i]*
    ∈ *S*′, then set *x[i]* = 1\. Otherwise, ![art](images/Art_P1480j.jpg), and set
    *x[i]* = 0\. We claim that every clause *C[j]*, for *j* = 1, 2, … , *k*, is satisfied
    by this assignment. To prove this claim, note that to achieve a sum of 4 in the
    digit labeled by *C[j]*, the subset *S*′ must include at least one *v[i]* or ![art](images/Art_P1480d.jpg)
    value that has a 1 in the digit labeled by *C[j]*, since the contributions of
    the slack variables *s[j]* and ![art](images/Art_P1480f.jpg) together sum to at
    most 3\. If *S*′ includes a ![art](images/Art_P1480d.jpg) that has a 1 in *C[j]*’s
    position, then the literal *x[i]* appears in clause *C[j]*. Since *x[i]* = 1 when
    *v[i]* ∈ *S*′, clause *C[j]* is satisfied. If *S*′ includes a ![art](images/Art_P1480d.jpg)
    that has a 1 in that position, then the literal ¬*x[i]* appears in *C[j]*. Since
    *x[i]* = 0 when ![art](images/Art_P1480d.jpg) ∈ *S*′, clause *C[j]* is again satisfied.
    Thus, all clauses of *ϕ* are satisfied, which completes the proof.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 现在假设某个子集*S*′ ⊆ *S*求和为*t*。子集*S*′必须包括每个*i* = 1, 2, … , *n*的*v[i]*和![art](images/Art_P1480d.jpg)中的一个，否则由变量标记的数字将不会求和为1。如果*v[i]*
    ∈ *S*′，则设置*x[i]* = 1。否则，![art](images/Art_P1480j.jpg)，并设置*x[i]* = 0。我们声称这种赋值满足每个子句*C[j]*，对于*j*
    = 1, 2, … , *k*。为了证明这一点，请注意，为了在由*C[j]*标记的数字中实现和为4，子集*S*′必须至少包括一个在*C[j]*标记的数字中具有1的*v[i]*或![art](images/Art_P1480d.jpg)值，因为松弛变量*s[j]*和![art](images/Art_P1480f.jpg)的贡献总和最多为3。如果*S*′包括一个在*C[j]*位置有1的![art](images/Art_P1480d.jpg)，那么文字*x[i]*出现在子句*C[j]*中。由于当*v[i]*
    ∈ *S*′时*x[i]* = 1，子句*C[j]*被满足。如果*S*′包括一个在该位置有1的![art](images/Art_P1480d.jpg)，那么文字¬*x[i]*出现在*C[j]*中。由于当![art](images/Art_P1480d.jpg)
    ∈ *S*′时*x[i]* = 0，子句*C[j]*再次被满足。因此，*ϕ*的所有子句都被满足，这完成了证明。
- en: ▪
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**34.5.6    Reduction strategies**'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: '**34.5.6    简化策略**'
- en: From the reductions in this section, you can see that no single strategy applies
    to all NP-complete problems. Some reductions are straightforward, such as reducing
    the hamiltonian-cycle problem to the traveling-salesperson problem. Others are
    considerably more complicated. Here are a few things to keep in mind and some
    strategies that you can often bring to bear.
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 从本节的简化中，您可以看到没有一种策略适用于所有NP完全问题。有些简化是直接的，例如将哈密顿回路问题简化为旅行推销员问题。其他则更加复杂。以下是一些需要牢记的事项以及您经常可以采用的一些策略。
- en: '**Pitfalls**'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '**陷阱**'
- en: Make sure that you don’t get the reduction backward. That is, in trying to show
    that problem *Y* is NP-complete, you might take a known NP-complete problem *X*
    and give a polynomial-time reduction from *Y* to *X*. That is the wrong direction.
    The reduction should be from *X* to *Y*, so that a solution to *Y* gives a solution
    to *X*.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您不要将简化反过来。也就是说，在试图证明问题*Y*是NP完全时，您可能会取一个已知的NP完全问题*X*，并从*Y*到*X*给出一个多项式时间的简化。这是错误的方向。简化应该是从*X*到*Y*，这样*Y*的解决方案就给出了*X*的解决方案。
- en: Remember also that reducing a known NP-complete problem *X* to a problem *Y*
    does not in itself prove that *Y* is NP-complete. It proves that *Y* is NP-hard.
    In order to show that *Y* is NP-complete, you additionally need to prove that
    it’s in NP by showing how to verify a certificate for *Y* in polynomial time.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 还要记住，将已知的NP完全问题*X*简化为问题*Y*本身并不能证明*Y*是NP完全的。这证明了*Y*是NP难的。为了证明*Y*是NP完全的，您还需要证明它在NP中，方法是展示如何在多项式时间内验证*Y*的证书。
- en: '**Go from general to specific**'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: '**从一般到具体**'
- en: 'When reducing problem *X* to problem *Y*, you always have to start with an
    arbitrary input to problem *X*. But you are allowed to restrict the input to problem
    *Y* as much as you like. For example, when reducing 3-CNF satisfiability to the
    subset-sum problem, the reduction had to be able to handle *any* 3-CNF formula
    as its input, but the input to the subset-sum problem that it produced had a particular
    structure: 2*n* + 2*k* integers in the set, and each integer was formed in a particular
    way. The reduction did not need to produce *every* possible input to the subset-sum
    problem. The point is that one way to solve the 3-CNF satisfiability problem transforms
    the input into an input to the subset-sum problem and then uses the answer to
    the subset-sum problem as the answer to the 3-CNF satisfiability problem.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 在将问题*X*简化为问题*Y*时，您始终必须从问题*X*的任意输入开始。但您可以尽可能限制问题*Y*的输入。例如，将3-CNF可满足性简化为子集和问题时，简化必须能够处理*任何*3-CNF公式作为其输入，但它生成的子集和问题的输入具有特定结构：集合中的2*n*
    + 2*k*个整数，并且每个整数以特定方式形成。简化不需要生成子集和问题的*每个*可能输入。关键是解决3-CNF可满足性问题的一种方法将输入转换为子集和问题的输入，然后将子集和问题的答案用作3-CNF可满足性问题的答案。
- en: '**Take advantage of structure in the problem you are reducing from**'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '**利用要简化的问题中的结构**'
- en: When you are choosing a problem to reduce from, you might consider two problems
    in the same domain, but one problem has more structure than the other. For example,
    it’s almost always much easier to reduce from 3-CNF satisfiability than to reduce
    from formula satisfiability. Boolean formulas can be arbitrarily complicated,
    but you can exploit the structure of 3-CNF formulas when reducing.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择要简化的问题时，可以考虑同一领域中的两个问题，但一个问题比另一个问题更有结构。例如，从3-CNF可满足性简化通常比从公式可满足性简化要容易得多。布尔公式可以任意复杂，但在简化时可以利用3-CNF公式的结构。
- en: Likewise, it is usually more straightforward to reduce from the hamiltonian-cycle
    problem than from the traveling-salesperson problem, even though they are so similar.
    That’s because you can view the hamiltonian-cycle problem as taking a complete
    graph but with edge weights of just 0 or 1, as they would appear in the adjacency
    matrix. In that sense, the hamiltonian-cycle problem has more structure than the
    traveling-salesperson problem, in which edge weights are unrestricted.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，通常从哈密顿回路问题减少比从旅行推销员问题减少更为直接，尽管它们非常相似。这是因为你可以将哈密顿回路问题视为取一个完全图，但边的权重只有0或1，就像它们在邻接矩阵中出现的那样。从这个意义上讲，哈密顿回路问题比旅行推销员问题更有结构，后者的边权是不受限制的。
- en: '**Look for special cases**'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: '**寻找特殊情况**'
- en: 'Several NP-complete problems are just special cases of other NP-complete problems.
    For example, consider the decision version of the 0-1 knapsack problem: given
    a set of *n* items, each with a weight and a value, does there exist a subset
    of items whose total weight is at most a given weight *W* and whose total value
    is at least a given value *V*? You can view the set-partition problem in Exercise
    34.5-5 as a special case of the 0-1 knapsack problem: let the value of each item
    equal its weight, and set both *W* and *V* to half the total weight. If problem
    *X* is NP-hard and it is a special case of problem *Y*, then problem *Y* must
    be NP-hard as well. That is because a polynomial-time solution for problem *Y*
    automatically gives a polynomial-time solution for problem *X*. More intuitively,
    problem *Y*, being more general than problem *X*, is at least as hard.'
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 几个NP完全问题只是其他NP完全问题的特殊情况。例如，考虑0-1背包问题的决策版本：给定一组*n*个带有重量和价值的物品，是否存在一个物品子集，其总重量最多为给定重量*W*，总价值至少为给定价值*V*？你可以将练习34.5-5中的集合划分问题视为0-1背包问题的特殊情况：让每个物品的价值等于其重量，并将*W*和*V*都设��为总重量的一半。如果问题*X*是NP难的，并且它是问题*Y*的一个特殊情况，那么问题*Y*也必须是NP难的。这是因为问题*Y*的多项式时间解决方案自动给出了问题*X*的多项式时间解决方案。更直观地说，问题*Y*比问题*X*更一般，至少同样困难。
- en: '**Select an appropriate problem to reduce from**'
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: '**选择一个适当的问题进行减少**'
- en: It’s often a good strategy to reduce from a problem in a domain that is the
    same as, or at least related to, the domain of the problem that you’re trying
    to prove NP-complete. For example, we saw that the vertex-cover problem—a graph
    problem—was NP-hard by reducing from the clique problem—also a graph problem.
    From the vertex-cover problem, we reduced to the hamiltonian-cycle problem, and
    from the hamiltonian-cycle problem, we reduced to the traveling-salesperson problem.
    All of these problems take undirected graphs as inputs.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，从与你试图证明NP完全的问题的领域相同或至少相关的领域中减少问题是一个很好的策略。例如，我们看到顶点覆盖问题——一个图问题——通过从团问题——也是一个图问题——减少而是NP难的。从顶点覆盖问题，我们减少到哈密顿回路问题，从哈密顿回路问题，我们减少到旅行推销员问题。所有这些问题都以无向图作为输入。
- en: Sometimes, however, you will find that is it better to cross over from one domain
    to another, such as when we reduced from 3-CNF satisfiability to the clique problem
    or to the subset-sum problem. 3-CNF satisfiability often turns out to be a good
    choice as a problem to reduce from when crossing domains.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，然而，你会发现最好从一个领域跨越到另一个领域，比如当我们将3-CNF可满足性问题减少到团问题或子集和问题时。当跨越领域时，3-CNF可满足性问题通常是一个很好的选择。
- en: Within graph problems, if you need to select a portion of the graph, without
    regard to ordering, then the vertex-cover problem is often a good place to start.
    If ordering matters, then consider starting from the hamiltonian-cycle or hamiltonian-path
    problem (see Exercise 34.5-6).
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 在图问题中，如果你需要选择图的一部分，而不考虑顺序，那么顶点覆盖问题通常是一个很好的起点。如果顺序很重要，那么考虑从哈密顿回路或哈密顿路径问题开始（参见练习34.5-6）。
- en: '**Make big rewards and big penalties**'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: '**设定大奖励和大惩罚**'
- en: 'The strategy for reducing the hamiltonian-cycle problem with a graph *G* to
    the traveling-salesperson problem encouraged using edges present in *G* when choosing
    edges for the traveling-salesperson tour. The reduction did so by giving these
    edges a low weight: 0\. In other words, we gave a big reward for using these edges.'
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 将哈密顿回路问题与图*G*减少到旅行推销员问题的策略鼓励在选择旅行推销员路径的边时使用*G*中存在的边。通过给这些边一个低权重：0来实现这种减少。换句话说，我们为使用这些边给予了很大的奖励。
- en: Alternatively, the reduction could have given the edges in *G* a finite weight
    and given edges not in *G* infinite weight, thereby exacting a hefty penalty for
    using edges not in *G*. With this approach, if each edge in *G* has weight *W*,
    then the target weight of the traveling-salesperson tour becomes *W* · |*V*|.
    You can sometimes think of the penalties as a way to enforce requirements. For
    example, if the traveling-salesperson tour includes an edge with infinite weight,
    then it violates the requirement that the tour should include only edges belonging
    to *G*.
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，减少可以给予*G*中的边一个有限的权重，并给予不在*G*中的边无限的权重，从而对使用不在*G*中的边施加沉重的惩罚。通过这种方法，如果*G*中的每条边的权重为*W*，那么旅行推销员路径的目标权重变为*W*
    · |*V*|。有时你可以将惩罚看作是强制要求的一种方式。例如，如果旅行推销员路径包括一条权重为无穷大的边，那么它违反了路径应该只包括属于*G*的边的要求。
- en: '**Design gadgets**'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: '**设计小工具**'
- en: 'The reduction from the vertex-cover problem to the hamiltonian-cycle problem
    uses the gadget shown in [Figure 34.16](chapter034.xhtml#Fig_34-16). This gadget
    is a subgraph that is connected to other parts of the constructed graph in order
    to restrict the ways that a cycle can visit each vertex in the gadget once. More
    generally, a gadget is a component that enforces certain properties. Gadgets can
    be complicated, as in the reduction to the hamiltonian-cycle problem. Or they
    can be simple: in the reduction of 3-CNF satisfiability to the subset-sum problem,
    you can view the slack variables *s[j]* and ![art](images/Art_P1480f.jpg) as gadgets
    enabling each clause-labeled digit position to achieve the target value of 4.'
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 从顶点覆盖问题到哈密顿回路问题的归约使用了[图34.16](chapter034.xhtml#Fig_34-16)中显示的装置。这个装置是一个子图，连接到构造图的其他部分，以限制循环访问每个顶点的方式。更一般地说，装置是强制执行某些属性的组件。装置可以很复杂，就像归约到哈密顿回路问题一样。或者它们可以很简单：在将3-CNF可满足性归约到子集和问题时，你可以将松弛变量*s[j]*和![art](images/Art_P1480f.jpg)视为装置，使得每个标有子句的数字位置可以达到目标值4。
- en: '**Exercises**'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***34.5-1***'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.5-1***'
- en: The ***subgraph-isomorphism problem*** takes two undirected graphs *G*[1] and
    *G*[2], and asks whether *G*[1] is isomorphic to a subgraph of *G*[2]. Show that
    the subgraph-isomorphism problem is NP-complete.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '***子图同构问题***接受两个无向图*G*[1]和*G*[2]，询问*G*[1]是否同构于*G*[2]的一个子图。展示子图同构问题是NP完全的。'
- en: '***34.5-2***'
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.5-2***'
- en: Given an integer *m* × *n* matrix *A* and an integer *m*-vector *b*, the ***0-1
    integer-programming problem*** asks whether there exists an integer *n*-vector
    *x* with elements in the set {0, 1} such that *Ax* ≤ *b*. Prove that 0-1 integer
    programming is NP-complete. (*Hint:* Reduce from 3-CNF-SAT.)
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个整数*m* × *n*矩阵*A*和一个整数*m*-向量*b*，***0-1整数规划问题***询问是否存在一个元素在{0, 1}集合中的整数*n*-向量*x*，使得*Ax*
    ≤ *b*。证明0-1整数规划是NP完全的。（*提示：*从3-CNF-SAT归约。）
- en: '***34.5-3***'
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.5-3***'
- en: The ***integer linear-programming problem*** is like the 0-1 integer-programming
    problem given in Exercise 34.5-2, except that the values of the vector *x* may
    be any integers rather than just 0 or 1\. Assuming that the 0-1 integer-programming
    problem is NP-hard, show that the integer linear-programming problem is NP-complete.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: '***整数线性规划问题***类似于练习34.5-2中给出的0-1整数规划问题，不同之处在于向量*x*的值可以是任意整数而不仅仅是0或1。假设0-1整数规划问题是NP难的，证明整数线性规划问题是NP完全的。'
- en: '***34.5-4***'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.5-4***'
- en: Show how to solve the subset-sum problem in polynomial time if the target value
    *t* is expressed in unary.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何在目标值*t*以一元表示时在多项式时间内解决子集和问题。
- en: '***34.5-5***'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.5-5***'
- en: The ***set-partition problem*** takes as input a set *S* of numbers. The question
    is whether the numbers can be partitioned into two sets *A* and *A* = *S* − *A*
    such that Σ[*x*∈*A*] *x* = Σ[*x*∈*A*] *x*. Show that the set-partition problem
    is NP-complete.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
  zh: '***集合划分问题***接受一个数字集合*S*作为输入。问题是这些数字是否可以被划分为两个集合*A*和*A* = *S* − *A*，使得Σ[*x*∈*A*] *x*
    = Σ[*x*∈*A*] *x*。展示集合划分问题是NP完全的。'
- en: '***34.5-6***'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.5-6***'
- en: Show that the hamiltonian-path problem is NP-complete.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 展示哈密顿路径问题是NP完全的。
- en: '***34.5-7***'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.5-7***'
- en: The ***longest-simple-cycle problem*** is the problem of determining a simple
    cycle (no repeated vertices) of maximum length in a graph. Formulate a related
    decision problem, and show that the decision problem is NP-complete.
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '***最长简单循环问题***是确定图中最大长度的简单循环（无重复顶点）的问题。制定一个相关的决策问题，并展示该决策问题是NP完全的。'
- en: '***34.5-8***'
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.5-8***'
- en: In the ***half 3-CNF satisfiability*** problem, the input is a 3-CNF formula
    *ϕ* with *n* variables and *m* clauses, where *m* is even. The question is whether
    there exists a truth assignment to the variables of *ϕ* such that exactly half
    the clauses evaluate to 0 and exactly half the clauses evaluate to 1\. Prove that
    the half 3-CNF satisfiability problem is NP-complete.
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 在***一半的3-CNF可满足性***问题中，输入是一个具有*n*个变量和*m*个子句的3-CNF公式*ϕ*，其中*m*是偶数。问题是是否存在对*ϕ*的变量的真值赋值，使得一半的子句评估为0，另一半的子句评估为1。证明一半的3-CNF可满足性问题是NP完全的。
- en: '***34.5-9***'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '***34.5-9***'
- en: The proof that VERTEX-COVER ≤[P] HAM-CYCLE assumes that the graph *G* given
    as input to the vertex-cover problem has no isolated vertices. Show how the reduction
    in the proof can break down if *G* has an isolated vertex.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 假设给定作为顶点覆盖问题输入的图*G*没有孤立顶点，那么证明顶点覆盖≤[P]哈密顿回路的证明是成立的。展示如果*G*有一个孤立顶点，那么证明中的归约会如何失败。
- en: '**Problems**'
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '***34-1     Independent set***'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: '***34-1     独立集***'
- en: An ***independent set*** of a graph *G* = (*V*, *E*) is a subset *V*′ ⊆ *V*
    of vertices such that each edge in *E* is incident on at most one vertex in *V*′.
    The ***independent-set problem*** is to find a maximum-size independent set in
    *G*.
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 图*G* = (*V*, *E*)的一个***独立集***是顶点的子集*V*′ ⊆ *V*，使得*E*中的每条边最多与*V*′中的一个顶点关联。***独立集问题***是在*G*中找到一个最大大小的独立集。
- en: '***a.*** Formulate a related decision problem for the independent-set problem,
    and prove that it is NP-complete. (*Hint:* Reduce from the clique problem.)'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 为独立集问题制定一个相关的决策问题，并证明它是NP完全的。（*提示：*从团问题归约。）'
- en: '***b.*** You are given a “black-box” subroutine to solve the decision problem
    you defined in part (a). Give an algorithm to find an independent set of maximum
    size. The running time of your algorithm should be polynomial in |*V* | and |*E*|,
    counting queries to the black box as a single step.'
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 给定一个“黑盒”子例程来解决你在(a)部分定义的决策问题。给出一个算法来找到最大大小的独立集。你的算法的运行时间应该是多项式的|*V*|和|*E*|，将对黑盒的查询计为一步。'
- en: Although the independent-set decision problem is NP-complete, certain special
    cases are polynomial-time solvable.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管独立集决策问题是NP完全的，但是某些特殊情况是多项式时间可解的。
- en: '***c.*** Give an efficient algorithm to solve the independent-set problem when
    each vertex in *G* has degree 2\. Analyze the running time, and prove that your
    algorithm works correctly.'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 给出一个有效的算法来解决当*G*中每个顶点的度为2时的独立集问题。分析运行时间，并证明你的算法正确性。'
- en: '***d.*** Give an efficient algorithm to solve the independent-set problem when
    *G* is bipartite. Analyze the running time, and prove that your algorithm works
    correctly. (*Hint:* First prove that in a bipartite graph, the size of the maximimum
    independent set plus the size of the maximum matching is equal to |*V*|. Then
    use a maximum-matching algorithm (see [Section 25.1](chapter025.xhtml#Sec_25.1))
    as a first step in an algorithm to find an independent set.)'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 给��一个有效的算法来解决当 *G* 是二分图时的独立集问题。分析运行时间，并证明您的算法正确运行。(*提示:* 首先证明在二分图中，最大独立集的大小加上最大匹配的大小等于|*V*|。然后使用最大匹配算法（参见[第25.1节](chapter025.xhtml#Sec_25.1)）作为找到独立集的算法的第一步。)'
- en: '***34-2     Bonnie and Clyde***'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: '***34-2     邦妮和克莱德***'
- en: Bonnie and Clyde have just robbed a bank. They have a bag of money and want
    to divide it up. For each of the following scenarios, either give a polynomial-time
    algorithm to divide the money or prove that the problem of dividing the money
    in the manner described is NP-complete. The input in each case is a list of the
    *n* items in the bag, along with the value of each.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 邦妮和克莱德刚刚抢劫了一家银行。他们有一袋钱，想要分配它。对于以下每种情况，要么给出一个多项式时间算法来分配钱，要么证明以所描述的方式分配钱的问题是NP完全的。每种情况的输入是袋子中的
    *n* 个物品的列表，以及每个物品的价值。
- en: '***a.*** The bag contains *n* coins, but only two different denominations:
    some coins are worth *x* dollars, and some are worth *y* dollars. Bonnie and Clyde
    wish to divide the money exactly evenly.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 袋子里有 *n* 枚硬币，但只有两种不同的币值：一些硬币价值为 *x* 美元，一些硬币价值为 *y* 美元。邦妮和克莱德希望将钱均匀分配。'
- en: '***b.*** The bag contains *n* coins, with an arbitrary number of different
    denominations, but each denomination is a nonnegative exact power of 2, so that
    the possible denominations are 1 dollar, 2 dollars, 4 dollars, etc. Bonnie and
    Clyde wish to divide the money exactly evenly.'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 袋子里有 *n* 枚硬币，币值各不相同，但每个币值都是非负的2的幂，因此可能的币值是1美元，2美元，4美元等。邦妮和克莱德希望将钱均匀分配。'
- en: '***c.*** The bag contains *n* checks, which are, in an amazing coincidence,
    made out to “Bonnie or Clyde.” They wish to divide the checks so that they each
    get the exact same amount of money.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 袋子里有 *n* 张支票，令人惊讶的是，这些支票都写给“邦妮或克莱德”。他们希望分配支票，以便他们每个人都获得完全相同的金额。'
- en: '***d.*** The bag contains *n* checks as in part (c), but this time Bonnie and
    Clyde are willing to accept a split in which the difference is no larger than
    100 dollars.'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 袋子里有 *n* 张支票，就像第 (c) 部分一样，但这次邦妮和克莱德愿意接受一个分割，其中差额不超过100美元。'
- en: '***34-3     Graph coloring***'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: '***34-3     图着色***'
- en: 'Mapmakers try to use as few colors as possible when coloring countries on a
    map, subject to the restriction that if two countries share a border, they must
    have different colors. You can model this problem with an undirected graph *G*
    = (*V*, *E*) in which each vertex represents a country and vertices whose respective
    countries share a border are adjacent. Then, a ***k-coloring*** is a function
    *c* : *V* → {1, 2, … , *k*} such that *c*(*u*) ≠ *c*(*v*) for every edge (*u*,
    *v*) ∈ *E*. In other words, the numbers 1, 2, … , *k* represent the *k* colors,
    and adjacent vertices must have different colors. The ***graph-coloring problem***
    is to determine the minimum number of colors needed to color a given graph.'
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: '制图师在地图上给国家着色时尽量使用尽可能少的颜色，但有一个限制条件，即如果两个国家共享边界，则它们必须有不同的颜色。您可以用一个无向图 *G* = (*V*,
    *E*) 来建模这个问题，其中每个顶点代表一个国家，而邻接的顶点代表各自的国家共享边界。然后，一个***k-着色***是一个函数 *c* : *V* → {1,
    2, … , *k*}，使得对于每条边 (*u*, *v*) ∈ *E*，*c*(*u*) ≠ *c*(*v*)。换句话说，数字1, 2, … , *k*代表*k*种颜色，相邻的顶点必须有不同的颜色。***图着色问题***是确定给定图着色所需的最少颜色数。'
- en: '***a.*** Give an efficient algorithm to determine a 2-coloring of a graph,
    if one exists.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 给出一个有效的算法来确定图的2-着色，如果存在的话。'
- en: '***b.*** Cast the graph-coloring problem as a decision problem. Show that your
    decision problem is solvable in polynomial time if and only if the graph-coloring
    problem is solvable in polynomial time.'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 将图着色问题转化为一个决策问题。证明当且仅当图着色问题可以在多项式时间内解决时，你的决策问题才可以在多项式时间内解决。'
- en: '***c.*** Let the language 3-COLOR be the set of graphs that can be 3-colored.
    Show that if 3-COLOR is NP-complete, then your decision problem from part (b)
    is NP-complete.'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 让语言3-着色表示可以进行3-着色的图的集合。证明如果3-着色是NP完全的，那么你在部分 (b) 中的决策问题也是NP完全的。'
- en: '![art](images/Art_P1481.jpg)'
  id: totrans-541
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1481.jpg)'
- en: '**Figure 34.20** The subgraph of *G* in Problem 34-3 formed by the literal
    edges. The special vertices TRUE, FALSE, and RED form a triangle, and for each
    variable *x[i]*, the vertices *x[i]*, ¬*x[i]*, and RED form a triangle.'
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: '**图34.20** 问题34-3中形成的图 *G* 的子图，由文字边构成。特殊顶点TRUE，FALSE和RED形成一个三角形，对于每个变量 *x[i]*，顶点
    *x[i]*，¬*x[i]*和RED形成一个三角形。'
- en: '![art](images/Art_P1482.jpg)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P1482.jpg)'
- en: '**Figure 34.21** The gadget corresponding to a clause (*x* ∨ *y* ∨ *z*), used
    in Problem 34-3.'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: '**图34.21** 对应于一个子句 (*x* ∨ *y* ∨ *z*) 的小工具，用于问题34-3。'
- en: 'To prove that 3-COLOR is NP-complete, you can reduce from 3-CNF-SAT. Given
    a formula *ϕ* of *m* clauses on *n* variables *x*[1], *x*[2], … , *x[n]*, construct
    a graph *G* = (*V*, *E*) as follows. The set *V* consists of a vertex for each
    variable, a vertex for the negation of each variable, five vertices for each clause,
    and three special vertices: TRUE, FALSE, and RED. The edges of the graph are of
    two types: “literal” edges that are independent of the clauses and “clause” edges
    that depend on the clauses. As [Figure 34.20](chapter034.xhtml#Fig_34-20) shows,
    the literal edges form a triangle on the three special vertices TRUE, FALSE, and
    RED, and they also form a triangle on *x[i]*, ¬*x[i]*, and RED for *i* = 1, 2,
    … , *n*.'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 要证明3-COLOR是NP完全的，你可以从3-CNF-SAT进行归约。给定一个包含*n*个变量*x*[1]，*x*[2]，…，*x[n]*的*m*个子句的公式*ϕ*，构造一个图*G*
    = (*V*, *E*)如下。集合*V*包括每个变量的一个顶点，每个变量的否定的一个顶点，每个子句的五个顶点，以及三个特殊顶点：TRUE，FALSE和RED。图的边有两种类型：“文字”边与子句无关，“子句”边依赖于子句。如[图34.20](chapter034.xhtml#Fig_34-20)所示，文字边在三个特殊顶点TRUE，FALSE和RED上形成一个三角形，它们也在*x[i]*，¬*x[i]*和RED上形成一个三角形，其中*i*
    = 1, 2, …，*n*。
- en: '***d.*** Consider a graph containing the literal edges. Argue that in any 3-coloring
    *c* of such a graph, exactly one of a variable and its negation is colored *c*(TRUE)
    and the other is colored *c*(FALSE). Then argue that for any truth assignment
    for *ϕ*, there exists a 3-coloring of the graph containing just the literal edges.'
  id: totrans-546
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 考虑一个包含文字边的图。证明在这样一个图的任何3着色*c*中，一个变量及其否定中的恰好一个被着色为*c*(TRUE)，另一个被着色为*c*(FALSE)。然后证明对于*ϕ*的任何真值赋值，存在一个包含文字边的图的3着色。'
- en: The gadget shown in [Figure 34.21](chapter034.xhtml#Fig_34-21) helps to enforce
    the condition corresponding to a clause (*x* ∨ *y* ∨ *z*), where *x*, *y*, and
    *z* are literals. Each clause requires a unique copy of the five blue vertices
    in the figure. They connect as shown to the literals of the clause and the special
    vertex TRUE.
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '[图34.21](chapter034.xhtml#Fig_34-21)中显示的小装置有助于强制执行与子句对应的条件（*x* ∨ *y* ∨ *z*），其中*x*，*y*和*z*是文字。每个子句需要图中五个蓝色顶点的一个唯一副本。它们按照图中所示连接到子句的文字和特殊顶点TRUE。'
- en: '***e.*** Argue that if each of *x*, *y*, and *z* is colored *c*(TRUE) or *c*(FALSE),
    then the gadget is 3-colorable if and only if at least one of *x*, *y*, or *z*
    is colored *c*(TRUE).'
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** 论证如果*x*，*y*和*z*中的每一个都被着色为*c*(TRUE)或*c*(FALSE)，那么只有当*x*，*y*或*z*中至少有一个被着色为*c*(TRUE)时，这个小装置才是3可着色的。'
- en: '***f.*** Complete the proof that 3-COLOR is NP-complete.'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: '***f.*** 完成证明3-COLOR是NP完全的。'
- en: '***34-4     Scheduling with profits and deadlines***'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: '***34-4     带利润和截止日期的调度***'
- en: You have one computer and a set of *n* tasks {*a*[1], *a*[2], … , *a[n]*} requiring
    time on the computer. Each task *a[j]* requires *t[j]* time units on the computer
    (its processing time), yields a profit of *p[j]*, and has a deadline *d[j]*. The
    computer can process only one task at a time, and task *a[j]* must run without
    interruption for *t[j]* consecutive time units. If task *a[j]* completes by its
    deadline *d[j]*, you receive a profit *p[j]*. If instead task *a[j]* completes
    after its deadline, you receive no profit. As an optimization problem, given the
    processing times, profits, and deadlines for a set of *n* tasks, you wish to find
    a schedule that completes all the tasks and returns the greatest amount of profit.
    The processing times, profits, and deadlines are all nonnegative numbers.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 你有一台计算机和一组*n*个任务{*a*[1]，*a*[2]，…，*a[n]*}需要在计算机上花费时间。每个任务*a[j]*在计算机上需要*t[j]*个时间单位（其处理时间），产生*P[j]*的利润，并且有一个截止日期*d[j]*。计算机一次只能处理一个任务，任务*a[j]*必须在*t[j]*个连续时间单位内不间断运行。如果任务*a[j]*在其截止日期*d[j]*之前完成，你将获得利润*P[j]*。如果任务*a[j]*在截止日期之后完成，你将不获得利润。作为一个优化问题，给定一组*n*个任务的处理时间、利润和截止日期，你希望找到一个完成所有任务并返回最大利润的调度。处理时间、利润和截止日期都是非负数。
- en: '***a.*** State this problem as a decision problem.'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 将这个问题陈述为一个决策问题。'
- en: '***b.*** Show that the decision problem is NP-complete.'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 证明这个决策问题是NP完全的。'
- en: '***c.*** Give a polynomial-time algorithm for the decision problem, assuming
    that all processing times are integers from 1 to *n*. (*Hint:* Use dynamic programming.)'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 给出一个多项式时间算法来解决这个决策问题，假设所有处理时间都是从1到*n*的整数。（*提示：* 使用动态规划。）'
- en: '***d.*** Give a polynomial-time algorithm for the optimization problem, assuming
    that all processing times are integers from 1 to *n*.'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 给出一个多项式时间算法来解决这个优化问题，假设所有处理时间都是从1到*n*的整数。'
- en: '**Chapter notes**'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节注释**'
- en: The book by Garey and Johnson [[176](bibliography001.xhtml#endnote_176)] provides
    a wonderful guide to NP-completeness, discussing the theory at length and providing
    a catalogue of many problems that were known to be NP-complete in 1979\. The proof
    of Theorem 34.13 is adapted from their book, and the list of NP-complete problem
    domains at the beginning of [Section 34.5](chapter034.xhtml#Sec_34.5) is drawn
    from their table of contents. Johnson wrote a series of 23 columns in the *Journal
    of Algorithms* between 1981 and 1992 reporting new developments in NP-completeness.
    Fortnow’s book [[152](bibliography001.xhtml#endnote_152)] gives a history of NP-completeness,
    along with societal implications. Hopcroft, Motwani, and Ullman [[225](bibliography001.xhtml#endnote_225)],
    Lewis and Papadimitriou [[299](bibliography001.xhtml#endnote_299)], Papadimitriou
    [[352](bibliography001.xhtml#endnote_352)], and Sipser [[413](bibliography001.xhtml#endnote_413)]
    have good treatments of NP-completeness in the context of complexity theory. NP-completeness
    and several reductions also appear in books by Aho, Hopcroft, and Ullman [[5](bibliography001.xhtml#endnote_5)],
    Dasgupta, Papadimitriou, and Vazirani [[107](bibliography001.xhtml#endnote_107)],
    Johnsonbaugh and Schaefer [[239](bibliography001.xhtml#endnote_239)], and Kleinberg
    and Tardos [[257](bibliography001.xhtml#endnote_257)]. The book by Hromkovič [[229](bibliography001.xhtml#endnote_229)]
    studies various methods for solving hard problems.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: Garey和Johnson的书[[176](bibliography001.xhtml#endnote_176)]提供了NP完全性的精彩指南，详细讨论了这一理论，并提供了一个在1979年已知的许多NP完全问题的目录。定理34.13的证明改编自他们的书，而在[第34.5节](chapter034.xhtml#Sec_34.5)开头的NP完全问题领域列表则来自他们的目录。Johnson在1981年至1992年间在《算法杂志》上撰写了一系列有关NP完全性新发展的23篇专栏文章。Fortnow的书[[152](bibliography001.xhtml#endnote_152)]介绍了NP完全性的历史，以及社会影响。Hopcroft、Motwani和Ullman[[225](bibliography001.xhtml#endnote_225)]，Lewis和Papadimitriou[[299](bibliography001.xhtml#endnote_299)]，Papadimitriou[[352](bibliography001.xhtml#endnote_352)]和Sipser[[413](bibliography001.xhtml#endnote_413)]在复杂性理论背景下对NP完全性有很好的处理。Aho、Hopcroft和Ullman[[5](bibliography001.xhtml#endnote_5)]，Dasgupta、Papadimitriou和Vazirani[[107](bibliography001.xhtml#endnote_107)]，Johnsonbaugh和Schaefer[[239](bibliography001.xhtml#endnote_239)]，以及Kleinberg和Tardos[[257](bibliography001.xhtml#endnote_257)]的书中也出现了NP完全性和几种简化。Hromkovič的书[[229](bibliography001.xhtml#endnote_229)]研究了解决困难问题的各种方法。
- en: The class P was introduced in 1964 by Cobham [[96](bibliography001.xhtml#endnote_96)]
    and, independently, in 1965 by Edmonds [[130](bibliography001.xhtml#endnote_130)],
    who also introduced the class NP and conjectured that P ≠ NP. The notion of NP-completeness
    was proposed in 1971 by Cook [[100](bibliography001.xhtml#endnote_100)], who gave
    the first NP-completeness proofs for formula satisfiability and 3-CNF satisfiability.
    Levin [[297](bibliography001.xhtml#endnote_297)] independently discovered the
    notion, giving an NP-completeness proof for a tiling problem. Karp [[248](bibliography001.xhtml#endnote_248)]
    introduced the methodology of reductions in 1972 and demonstrated the rich variety
    of NP-complete problems. Karp’s paper included the original NP-completeness proofs
    of the clique, vertex-cover, and hamiltonian-cycle problems. Since then, thousands
    of problems have been proven to be NP-complete by many researchers.
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
  zh: P类是由Cobham[[96](bibliography001.xhtml#endnote_96)]于1964年引入的，同时也是由Edmonds[[130](bibliography001.xhtml#endnote_130)]于1965年引入的，他还引入了NP类，并猜想P
    ≠ NP。NP完全性的概念是由Cook[[100](bibliography001.xhtml#endnote_100)]于1971年提出的，他为公式可满足性和3-CNF可满足性给出了第一个NP完全性证明。Levin[[297](bibliography001.xhtml#endnote_297)]独立发现了这个概念，为一个平铺问题给出了一个NP完全性证明。Karp[[248](bibliography001.xhtml#endnote_248)]于1972年引入了简化的方法，并展示了丰富多样的NP完全问题。Karp的论文包括了团、顶点覆盖和哈密顿回路问题的最初NP完全性证明。从那时起，许多研究人员已经证明了成千上万的问题是NP完全的。
- en: Work in complexity theory has shed light on the complexity of computing approximate
    solutions. This work gives a new definition of NP using “probabilistically checkable
    proofs.” This new definition implies that for problems such as clique, vertex
    cover, the traveling-salesperson problem with the triangle inequality, and many
    others, computing good approximate solutions (see [Chapter 35](chapter035.xhtml))
    is NP-hard and hence no easier than computing optimal solutions. An introduction
    to this area can be found in Arora’s thesis [[21](bibliography001.xhtml#endnote_21)],
    a chapter by Arora and Lund in Hochbaum [[221](bibliography001.xhtml#endnote_221)],
    a survey article by Arora [[22](bibliography001.xhtml#endnote_22)], a book edited
    by Mayr, Prömel, and Steger [[319](bibliography001.xhtml#endnote_319)], a survey
    article by Johnson [[237](bibliography001.xhtml#endnote_237)], and a chapter in
    the textbook by Arora and Barak [[24](bibliography001.xhtml#endnote_24)].
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂性理论的研究揭示了计算近似解的复杂性。这项工作使用“概率可检验证明”对NP进行了新的定义。这个新定义意味着对于诸如团、顶点覆盖、满足三角不等式的旅行推销员问题等问题，计算良好的近似解（见[第35章](chapter035.xhtml)）是NP难的，因此不比计算最优解更容易。关于这一领域的介绍可以在Arora的论文[[21](bibliography001.xhtml#endnote_21)]中找到，Hochbaum中Arora和Lund的一章[[221](bibliography001.xhtml#endnote_221)]，Arora的一篇调查文章[[22](bibliography001.xhtml#endnote_22)]，Mayr、Prömel和Steger编辑的一本书[[319](bibliography001.xhtml#endnote_319)]，Johnson的一篇调查文章[[237](bibliography001.xhtml#endnote_237)]，以及Arora和Barak的教科书中的一章[[24](bibliography001.xhtml#endnote_24)]中找到。
- en: '[¹](#footnote_ref_1) For the Halting Problem and other unsolvable problems,
    there are proofs that no algorithm can exist that, for every input, eventually
    produces the correct answer. A procedure attempting to solve an unsolvable problem
    might always produce an answer but is sometimes incorrect, or all the answers
    it produces might be correct but for some inputs it never produces an answer.'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: '[¹](#footnote_ref_1) 对于停机问题和其他不可解问题，有证明表明不存在算法，对于每个输入，最终产生正确答案。试图解决不可解问题的过程可能总是产生一个答案，但有时是错误的，或者它产生的所有答案可能都是正确的，但对于某些输入它永远不会产生答案。'
- en: '[²](#footnote_ref_2) See the books by Hopcroft and Ullman [[228](bibliography001.xhtml#endnote_228)],
    Lewis and Papadimitriou [[299](bibliography001.xhtml#endnote_299)], or Sipser
    [[413](bibliography001.xhtml#endnote_413)] for a thorough treatment of the Turing-machine
    model.'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: '[²](#footnote_ref_2) 有关图灵机模型的详细讨论，请参阅 Hopcroft 和 Ullman [[228](bibliography001.xhtml#endnote_228)]，Lewis
    和 Papadimitriou [[299](bibliography001.xhtml#endnote_299)]，或 Sipser [[413](bibliography001.xhtml#endnote_413)]
    的书籍。'
- en: '[³](#footnote_ref_3) The codomain of *e* need not be *binary* strings: any
    set of strings over a finite alphabet having at least two symbols will do.'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: '[³](#footnote_ref_3) *e* 的值域不一定是 *二进制* 字符串：任何由至少两个符号组成的有限字母表的字符串集合都可以。'
- en: '[⁴](#footnote_ref_4) We assume that the algorithm’s output is separate from
    its input. Because it takes at least one time step to produce each bit of the
    output and the algorithm takes *O*(*T* (*n*)) time steps, the size of the output
    is *O*(*T* (*n*)).'
  id: totrans-563
  prefs: []
  type: TYPE_NORMAL
  zh: '[⁴](#footnote_ref_4) 我们假设算法的输出与其输入是分开的。因为每产生一个输出位需要至少一个时间步，并且算法需要 *O*(*T* (*n*))
    个时间步，所以输出的大小是 *O*(*T* (*n*)）。'
- en: '[⁵](#footnote_ref_5) The notation {0, 1}* denotes the set of all strings composed
    of symbols from the set {0, 1}.'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: '[⁵](#footnote_ref_5) 符号 {0, 1}* 表示由集合 {0, 1} 中的符号组成的所有字符串的集合。'
- en: '[⁶](#footnote_ref_6) Technically, we also require the functions *f*[12] and
    *f*[21] to “map noninstances to noninstances.” A ***noninstance*** of an encoding
    *e* is a string *x* ∈ {0, 1}* such that there is no instance *i* for which *e*(*i*)
    = *x*. We require that *f*[12](*x*) = *y* for every noninstance *x* of encoding
    *e*[1], where *y* is some noninstance of *e*[2], and that *f*[21](*x*′) = *y*′
    for every noninstance *x*′ of *e*[2], where *y*′ is some noninstance of *e*[1].'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: '[⁶](#footnote_ref_6) 从技术上讲，我们还需要函数 *f*[12] 和 *f*[21] “将非实例映射到非实例”。对于编码 *e*
    的非实例 *x* ∈ {0, 1}*，即不存在实例 *i* 使得 *e*(*i*) = *x*。我们要求对于编码 *e*[1] 的每个非实例 *x*，*f*[12](*x*)
    = *y*，其中 *y* 是 *e*[2] 的某个非实例，并且对于 *e*[2] 的每个非实例 *x*′，*f*[21](*x*′) = *y*′，其中 *y*′
    是 *e*[1] 的某个非实例。'
- en: '[⁷](#footnote_ref_7) For more on complexity classes, see the seminal paper
    by Hartmanis and Stearns [[210](bibliography001.xhtml#endnote_210)].'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '[⁷](#footnote_ref_7) 有关复杂性类的更多信息，请参阅 Hartmanis 和 Stearns 的开创性论文[[210](bibliography001.xhtml#endnote_210)]。'
- en: '[⁸](#footnote_ref_8) In a letter dated 17 October 1856 to his friend John T.
    Graves, Hamilton [[206](bibliography001.xhtml#endnote_206), p. 624] wrote, “I
    have found that some young persons have been much amused by trying a new mathematical
    game which the Icosion furnishes, one person sticking five pins in any five consecutive
    points … and the other player then aiming to insert, which by the theory in this
    letter can always be done, fifteen other pins, in cyclical succession, so as to
    cover all the other points, and to end in immediate proximity to the pin wherewith
    his antagonist had begun.”'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: '[⁸](#footnote_ref_8) 在 1856 年 10 月 17 日写给他的朋友约翰·T·格雷夫斯的一封信中，汉密尔顿[[206](bibliography001.xhtml#endnote_206),
    p. 624]写道：“我发现一些年轻人非常喜欢尝试一种新的数学游戏，这是 Icosion 提供的，一个人在任意五个连续点上插入五根针 … 另一位玩家则试图插入，根据这封信中的理论，总是可以做到，另外的十五根针，按循环顺序，以覆盖所有其他点，并最终紧邻他的对手开始的针。”'
- en: '[⁹](#footnote_ref_9) The name “NP” stands for “nondeterministic polynomial
    time.” The class NP was originally studied in the context of nondeterminism, but
    this book uses the somewhat simpler yet equivalent notion of verification. Hopcroft
    and Ullman [[228](bibliography001.xhtml#endnote_228)] give a good presentation
    of NP-completeness in terms of nondeterministic models of computation.'
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: '[⁹](#footnote_ref_9) “NP” 的名称代表“nondeterministic polynomial time”。NP 类最初是在非确定性的背景下研究的，但本书使用了稍微简单但等效的验证概念。Hopcroft
    和 Ullman [[228](bibliography001.xhtml#endnote_228)] 在非确定性计算模型方面对 NP 完全性进行了很好的介绍。'
- en: '[^(10)](#footnote_ref_10) On the other hand, if the size of the circuit *C*
    is Θ(2^(*k*)), then an algorithm whose running time is *O*(2^(*k*)) has a running
    time that is polynomial in the circuit size. Even if P ≠ NP, this situation would
    not contradict the NP-completeness of the problem. The existence of a polynomial-time
    algorithm for a special case does not imply that there is a polynomial-time algorithm
    for all cases.'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: '[^(10)](#footnote_ref_10) 另一方面，如果电路 *C* 的大小为 Θ(2^(*k*))，那么运行时间为 *O*(2^(*k*))
    的算法的运行时间与电路大小的多项式成正比。即使 P ≠ NP，这种情况也不会违反问题的 NP 完全性。对于特殊情况存在多项式时间算法并不意味着对所有情况都存在多项式时间算法。'
- en: '[^(11)](#footnote_ref_11) Technically, a cycle is defined as a sequence of
    vertices rather than edges (see [Section B.4](appendix002.xhtml#Sec_B.4)). In
    the interest of clarity, we abuse notation here and define the hamiltonian cycle
    by its edges.'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
  zh: '[^(11)](#footnote_ref_11) 从技术上讲，循环被定义为顶点序列而不是边（参见 [Section B.4](appendix002.xhtml#Sec_B.4)）。为了清晰起见，在这里我们滥用符号，并通过其边来定义哈密顿循环。'
- en: '[^(12)](#footnote_ref_12) In fact, any base *b* ≥ 7 works. The instance at
    the beginning of this subsection is the set *S* and target *t* in [Figure 34.19](chapter034.xhtml#Fig_34-19)
    interpreted in base 7, with *S* listed in sorted order.'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: '[^(12)](#footnote_ref_12) 实际上，任何基数 *b* ≥ 7 都可以。本小节开头的实例是在基数为 7 的情况下解释的 [Figure
    34.19](chapter034.xhtml#Fig_34-19) 中的集合 *S* 和目标 *t*，其中 *S* 按排序顺序列出。'
