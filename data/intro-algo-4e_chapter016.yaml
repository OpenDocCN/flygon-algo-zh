- en: '[**16        Amortized Analysis**](toc.xhtml#chap-16)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[**16        摊销分析**](toc.xhtml#chap-16)'
- en: Imagine that you join Buff’s Gym. Buff charges a membership fee of $60 per month,
    plus $3 for every time you use the gym. Because you are disciplined, you visit
    Buff’s Gym every day during the month of November. On top of the $60 monthly charge
    for November, you pay another 3 × $30 = $90 that month. Although you can think
    of your fees as a flat fee of $60 and another $90 in daily fees, you can think
    about it in another way. All together, you pay $150 over 30 days, or an average
    of $5 per day. When you look at your fees in this way, you are ***amortizing***
    the monthly fee over the 30 days of the month, spreading it out at $2 per day.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下您加入了巴夫健身房。巴夫每月收取60美元的会员费，每次使用健身房收取3美元。因为您很有纪律，您在11月份的每一天都去了巴夫健身房。除了11月份的60美元月费外，您当月还支付了另外3
    × 30 = 90美元。尽管您可以将费用看作是60美元的固定费用和每天90美元的额外费用，但您也可以另一种方式来考虑。总共，您在30天内支付了150美元，平均每天5美元。当您以这种方式查看费用时，您正在***摊销***每月费用至该月的30天内，以每天2美元的速度分摊。
- en: You can do the same thing when you analyze running times. In an ***amortized
    analysis***, you average the time required to perform a sequence of data-structure
    operations over all the operations performed. With amortized analysis, you show
    that if you average over a sequence of operations, then the average cost of an
    operation is small, even though a single operation within the sequence might be
    expensive. Amortized analysis differs from average-case analysis in that probability
    is not involved. An amortized analysis guarantees the *average performance of
    each operation in the worst case*.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当您分析运行时间时，您可以做同样的事情。在***摊销分析***中，您将执行数据结构操作序列所需的时间平均化。通过摊销分析，您可以表明，如果对一系列操作进行平均化，那么每次操作的平均成本是很小的，即使序列中的单个操作可能很昂贵。摊销分析与平均情况分析不同之处在于不涉及概率。摊销分析保证了*最坏情况下每次操作的平均性能*。
- en: The first three sections of this chapter cover the three most common techniques
    used in amortized analysis. [Section 16.1](chapter016.xhtml#Sec_16.1) starts with
    aggregate analysis, in which you determine an upper bound *T* (*n*) on the total
    cost of a sequence of *n* operations. The average cost per operation is then *T*
    (*n*)/*n*. You take the average cost as the amortized cost of each operation,
    so that all operations have the same amortized cost.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前三节涵盖了摊销分析中最常用的三种技术。[第16.1节](chapter016.xhtml#Sec_16.1)从聚合分析开始，其中您确定了一系列*n*个操作的总成本上限*T*(*n*)。然后每次操作的平均成本为*T*(*n*)/*n*。您将平均成本视为每次操作的摊销成本，以便所有操作具有相同的摊销成本。
- en: '[Section 16.2](chapter016.xhtml#Sec_16.2) covers the accounting method, in
    which you determine an amortized cost of each operation. When there is more than
    one type of operation, each type of operation may have a different amortized cost.
    The accounting method overcharges some operations early in the sequence, storing
    the overcharge as “prepaid credit” on specific objects in the data structure.
    Later in the sequence, the credit pays for operations that are charged less than
    they actually cost.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '[第16.2节](chapter016.xhtml#Sec_16.2)涵盖了会计方法，其中您确定每次操作的摊销成本。当存在多种类型的操作时，每种操作可能具有不同的摊销成本。会计方法在序列中的早期对某些操作进行过度收费，将过度收费存储为数据结构中特定对象上的“预付信用”。序列后期，信用用于支付实际成本低于收费的操作。'
- en: '[Section 16.3](chapter016.xhtml#Sec_16.3) discusses the potential method, which
    is like the accounting method in that you determine the amortized cost of each
    operation and may overcharge operations early on to compensate for undercharges
    later. The potential method maintains the credit as the “potential energy” of
    the data structure as a whole instead of associating the credit with individual
    objects within the data structure.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '[第16.3节](chapter016.xhtml#Sec_16.3)讨论了潜在方法，类似于会计方法，您确定每次操作的摊销成本，并可能在早期对某些操作进行过度收费以补偿后期的低收费。潜在方法将信用保持为数据结构作为整体的“势能”，而不是将信用与数据结构中的个别对象相关联。'
- en: We’ll use use two examples in this chapter to examine each of these three methods.
    One is a stack with the additional operation MULTIPOP, which pops several objects
    at once. The other is a binary counter that counts up from 0 by means of the single
    operation INCREMENT.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使用两个示例来检验这三种方法。一个是具有额外操作MULTIPOP的堆栈，该操作一次弹出多个对象。另一个是通过单个操作INCREMENT从0开始计数的二进制计数器。
- en: While reading this chapter, bear in mind that the charges assigned during an
    amortized analysis are for analysis purposes only. They need not—and should not—appear
    in the code. If, for example, you assign a credit to an object *x* when using
    the accounting method, you have no need to assign an appropriate amount to some
    attribute, such as *x*.*credit*, in the code.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本章时，请记住，摊销分析中分配的费用仅用于分析目的。它们不需要——也不应该——出现在代码中。例如，如果您在使用会计方法时为对象*x*分配信用，那么您无需在代码中为*x*.*credit*等属性分配适当的金额。
- en: When you perform an amortized analysis, you often gain insight into a particular
    data structure, and this insight can help you optimize the design. For example,
    [Section 16.4](chapter016.xhtml#Sec_16.4) will use the potential method to analyze
    a dynamically expanding and contracting table.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 当您进行摊销分析时，通常可以深入了解特定数据结构，这种了解可以帮助您优化设计。例如，[第16.4节](chapter016.xhtml#Sec_16.4)将使用潜在方法来分析一个动态扩展和收缩的表。
- en: '[**16.1    Aggregate analysis**](toc.xhtml#Rh1-94)'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: '[**16.1    聚合分析**](toc.xhtml#Rh1-94)'
- en: In ***aggregate analysis***, you show that for all *n*, a sequence of *n* operations
    takes *T* (*n*) *worst-case* time in total. In the worst case, the average cost,
    or ***amortized cost***, per operation is therefore *T* (*n*)/*n*. This amortized
    cost applies to each operation, even when there are several types of operations
    in the sequence. The other two methods we shall study in this chapter, the accounting
    method and the potential method, may assign different amortized costs to different
    types of operations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在***聚合分析***中，你展示了对于所有*n*，一个包含*n*个操作的序列在总体上花费了*T*(*n*)的*最坏情况*时间。在最坏情况下，每次操作的平均成本，或者***摊销成本***，因此是*T*(*n*)/*n*。这个摊销成本适用于每个操作，即使序列中有多种类型的操作。我们将在本章中研究的另外两种方法，会计方法和潜在方法，可能会为不同类型的操作分配不同的摊销成本。
- en: '**Stack operations**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈操作**'
- en: 'As the first example of aggregate analysis, let’s analyze stacks that have
    been augmented with a new operation. [Section 10.1.3](chapter010.xhtml#Sec_10.1.3)
    presented the two fundamental stack operations, each of which takes *O*(1) time:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 作为聚合分析的第一个例子，让我们分析已经增加了一个新操作的栈。[第10.1.3节](chapter010.xhtml#Sec_10.1.3)介绍了两个基本的栈操作，每个操作都需要*O*(1)的时间：
- en: PUSH(*S*, *x*) pushes object *x* onto stack *S*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: PUSH(*S*, *x*)将对象*x*推入栈*S*。
- en: POP(*S*) pops the top of stack *S* and returns the popped object. Calling POP
    on an empty stack generates an error.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: POP(*S*)弹出栈*S*的顶部并返回弹出的对象。在空栈上调用POP会生成错误。
- en: '![art](images/Art_P506.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P506.jpg)'
- en: '**Figure 16.1** The action of MULTIPOP on a stack *S*, shown initially in **(a)**.
    The top 4 objects are popped by MULTIPOP(*S*, 4), whose result is shown in **(b)**.
    The next operation is MULTIPOP(*S*, 7), which empties the stack—shown in **(c)**—since
    fewer than 7 objects remained.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**图16.1** MULTIPOP在栈*S*上的操作，最初显示在**(a)**中。前4个对象被MULTIPOP(*S*, 4)弹出，其结果显示在**(b)**中。下一个操作是MULTIPOP(*S*,
    7)，它清空了栈—显示在**(c)**中—因为剩余的对象少于7个。'
- en: Since each of these operations runs in *O*(1) time, let us consider the cost
    of each to be 1\. The total cost of a sequence of *n* PUSH and POP operations
    is therefore *n*, and the actual running time for *n* operations is therefore
    Θ(*n*).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这些操作每个都在*O*(1)时间内运行，让我们考虑每个操作的成本为1。因此，*n*个PUSH和POP操作的总成本为*n*，因此*n*个操作的实际运行时间为Θ(*n*)。
- en: Now let’s add the stack operation MULTIPOP(*S*, *k*), which removes the *k*
    top objects of stack *S*, popping the entire stack if the stack contains fewer
    than *k* objects. Of course, the procedure assumes that *k* is positive, and otherwise,
    the MULTIPOP operation leaves the stack unchanged. In the pseudocode for MULTIPOP,
    the operation STACK-EMPTY returns TRUE if there are no objects currently on the
    stack, and FALSE otherwise. [Figure 16.1](chapter016.xhtml#Fig_16-1) shows an
    example of MULTIPOP.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们添加栈操作MULTIPOP(*S*, *k*)，它移除栈*S*的前*k*个对象，如果栈包含的对象少于*k*个，则弹出整个栈。当然，该过程假设*k*是正数，否则MULTIPOP操作不会改变栈。在MULTIPOP的伪代码中��操作STACK-EMPTY如果栈当前没有对象则返回TRUE，否则返回FALSE。[图16.1](chapter016.xhtml#Fig_16-1)展示了MULTIPOP的一个示例。
- en: MULTIPOP(*S*, *k*)
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: MULTIPOP(*S*, *k*)
- en: '| 1 | **while** not STACK-EMPTY(*S*) and *k* > 0 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **当** 栈非空(*S*) 且 *k* > 0 **时** |'
- en: '| 2 | POP(*S*) |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 2 | POP(*S*) |'
- en: '| 3 | *k* = *k* − 1 |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *k* = *k* − 1 |'
- en: What is the running time of MULTIPOP(*S*, *k*) on a stack of *s* objects? The
    actual running time is linear in the number of POP operations actually executed,
    and thus we can analyze MULTIPOP in terms of the abstract costs of 1 each for
    PUSH and POP. The number of iterations of the **while** loop is the number min
    {*s*, *k*} of objects popped off the stack. Each iteration of the loop makes one
    call to POP in line 2\. Thus, the total cost of MULTIPOP is min {*s*, *k*}, and
    the actual running time is a linear function of this cost.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在包含*s*个对象的栈上，MULTIPOP(*S*, *k*)的运行时间是多少？实际运行时间与实际执行的POP操作数量成正比，因此我们可以根据每个PUSH和POP的抽象成本为1来分析MULTIPOP。**while**循环的迭代次数是弹出栈的对象数min{*s*,
    *k*}。循环的每次迭代在第2行调用一次POP。因此，MULTIPOP的总成本是min{*s*, *k*}，实际运行时间是这个成本的线性函数。
- en: Now let’s analyze a sequence of *n* PUSH, POP, and MULTIPOP operations on an
    initially empty stack. The worst-case cost of a MULTIPOP operation in the sequence
    is *O*(*n*), since the stack size is at most *n*. The worst-case time of any stack
    operation is therefore *O*(*n*), and hence a sequence of *n* operations costs
    *O*(*n*²), since the sequence contains at most *n* MULTIPOP operations costing
    *O*(*n*) each. Although this analysis is correct, the *O*(*n*²) result, which
    came from considering the worst-case cost of each operation individually, is not
    tight.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们分析一个最初为空栈上的*n*个PUSH、POP和MULTIPOP操作序列。序列中MULTIPOP操作的最坏情况成本是*O*(*n*)，因为栈的大小最多为*n*。因此，任何栈操作的最坏情况时间是*O*(*n*)，因此*n*个操作的序列成本为*O*(*n*²)，因为序列中最多包含*n*个成本为*O*(*n*)的MULTIPOP操作。尽管这个分析是正确的，但是来自于考虑每个操作的最坏情况成本的*O*(*n*²)结果并不紧密。
- en: Yes, a single MULTIPOP might be expensive, but an aggregate analysis shows that
    any sequence of *n* PUSH, POP, and MULTIPOP operations on an initially empty stack
    has an upper bound on its cost of *O*(*n*). Why? An object cannot be popped from
    the stack unless it was first pushed. Therefore, the number of times that POP
    can be called on a nonempty stack, including calls within MULTIPOP, is at most
    the number of PUSH operations, which is at most *n*. For any value of *n*, any
    sequence of *n* PUSH, POP, and MULTIPOP operations takes a total of *O*(*n*) time.
    Averaging over the *n* operations gives an average cost per operation of *O*(*n*)/*n*
    = *O*(1). Aggregate analysis assigns the amortized cost of each operation to be
    the average cost. In this example, therefore, all three stack operations have
    an amortized cost of *O*(1).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，单个MULTIPOP可能很昂贵，但聚合分析表明，对初始为空栈的*n*个PUSH、POP和MULTIPOP操作序列的成本有一个*O*(*n*)的上界。为什么？除非首先推送对象，否则无法从堆栈中弹出对象。因此，在非空栈上调用POP的次数，包括MULTIPOP内的调用，最多为PUSH操作的次数，最多为*n*。对于任何值的*n*，*n*个PUSH、POP和MULTIPOP操作序列的总时间为*O*(*n*)。对*n*次操作进行平均，得到每次操作的平均成本为*O*(*n*)/*n*
    = *O*(1)。聚合分析将每个操作的摊销成本分配为平均成本。因此，在这个例子中，所有三个堆栈操作的摊销成本均为*O*(1)。
- en: 'To recap: although the average cost, and hence the running time, of a stack
    operation is *O*(1), the analysis did not rely on probabilistic reasoning. Instead,
    the analysis yielded a *worst-case* bound of *O*(*n*) on a sequence of *n* operations.
    Dividing this total cost by *n* yielded that the average cost per operation—that
    is, the amortized cost—is *O*(1).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下：尽管堆栈操作的平均成本和运行时间为*O*(1)，但分析并不依赖于概率推理。相反，分析得出了对*n*次操作序列的*最坏情况*界限为*O*(*n*)。将总成本除以*n*得到每次操作的平均成本，即摊销成本为*O*(1)。
- en: '**Incrementing a binary counter**'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**递增二进制计数器**'
- en: 'As another example of aggregate analysis, consider the problem of implementing
    a *k*-bit binary counter that counts upward from 0\. An array *A*[0 : *k* − 1]
    of bits represents the counter. A binary number *x* that is stored in the counter
    has its lowest-order bit in *A*[0] and its highest-order bit in *A*[*k* − 1],
    so that ![art](images/Art_P507.jpg). Initially, *x* = 0, and thus *A*[*i*] = 0
    for *i* = 0, 1, … , *k* − 1\. To add 1 (modulo 2*^k*) to the value in the counter,
    call the INCREMENT procedure.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '作为聚合分析的另一个例子，考虑实现一个从0开始向上计数的*k*位二进制计数器的问题。数组*A*[0 : *k* − 1]表示计数器。存储在计数器中的二进制数*x*的最低位在*A*[0]中，最高位在*A*[*k*
    − 1]中，因此![艺术](images/Art_P507.jpg)。最初，*x* = 0，因此对于*i* = 0, 1, … , *k* − 1，*A*[*i*]
    = 0。要将计数器中的值加1（模2*^k*），请调用INCREMENT过程。'
- en: INCREMENT(*A*, *k*)
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: INCREMENT(*A*, *k*)
- en: '| 1 | *i* = 0 |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *i* = 0 |'
- en: '| 2 | **while** *i < k* and *A*[*i*] == 1 |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **当** *i < k* **且** *A*[*i*] == 1 **时** |'
- en: '| 3 | *A*[*i*] = 0 |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *A*[*i*] = 0 |'
- en: '| 4 | *i* = *i* + 1 |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *i* = *i* + 1 |'
- en: '| 5 | **if** *i < k* |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **如果** *i < k* |'
- en: '| 6 | *A*[*i*] = 1 |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 6 | *A*[*i*] = 1 |'
- en: '[Figure 16.2](chapter016.xhtml#Fig_16-2) shows what happens to a binary counter
    when INCREMENT is called 16 times, starting with the initial value 0 and ending
    with the value 16\. Each iteration of the **while** loop in lines 2–4 adds a 1
    into position *i*. If *A*[*i*] = 1, then adding 1 flips the bit to 0 in position
    *i* and yields a carry of 1, to be added into position *i* + 1 during the next
    iteration of the loop. Otherwise, the loop ends, and then, if *i* < *k*, *A*[*i*]
    must be 0, so that line 6 adds a 1 into position *i*, flipping the 0 to a 1\.
    If the loop ends with *i* = *k*, then the call of INCREMENT flipped all *k* bits
    from 1 to 0\. The cost of each INCREMENT operation is linear in the number of
    bits flipped.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16.2](chapter016.xhtml#Fig_16-2)展示了当INCREMENT被调用16次时，二进制计数器会发生什么变化，从初始值0到值16结束。在第2-4行的**while**循环的每次迭代中，将1添加到位置*i*。如果*A*[*i*]
    = 1，则添加1会将位置*i*的位翻转为0，并产生一个进位1，在下一次循环迭代中添加到位置*i* + 1。否则，循环结束，然后，如果*i* < *k*，则*A*[*i*]必须为0，因此第6行将1添加到位置*i*，将0翻转为1。如果循环以*i*
    = *k*结束，则INCREMENT的调用将所有*k*位从1翻转为0。每次INCREMENT操作的成本与翻转位的数量成正比。'
- en: '![art](images/Art_P508.jpg)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P508.jpg)'
- en: '**Figure 16.2** An 8-bit binary counter as its value goes from 0 to 16 by a
    sequence of 16 INCREMENT operations. Bits that flip to achieve the next value
    are shaded in blue. The running cost for flipping bits is shown at the right.
    The total cost is always less than twice the total number of INCREMENT operations.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**图16.2** 一个8位二进制计数器，通过16次INCREMENT操作从0到16的值。为实现下一个值而翻转的位以蓝色阴影显示。翻转位的运行成本显示在右侧。总成本始终小于INCREMENT操作总数的两倍。'
- en: As with the stack example, a cursory analysis yields a bound that is correct
    but not tight. A single execution of INCREMENT takes Θ(*k*) time in the worst
    case, in which all the bits in array *A* are 1\. Thus, a sequence of *n* INCREMENT
    operations on an initially zero counter takes *O*(*nk*) time in the worst case.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 与堆栈示例一样，粗略分析得出的界限是正确的，但不够紧凑。在最坏情况下，单次执行INCREMENT操作需要Θ(*k*)时间，其中数组*A*中的所有位都为1。因此，在最坏情况下，对初始为零的计数器进行*n*次INCREMENT操作需要*O*(*nk*)时间。
- en: 'Although a single call of INCREMENT might flip all *k* bits, not all bits flip
    upon each call. (Note the similarity to MULTIPOP, where a single call might pop
    many objects, but not every call pops many objects.) As [Figure 16.2](chapter016.xhtml#Fig_16-2)
    shows, *A*[0] does flip each time INCREMENT is called. The next bit up, *A*[1],
    flips only every other time: a sequence of *n* INCREMENT operations on an initially
    zero counter causes *A*[1] to flip ⌊*n*/2⌋ times. Similarly, bit *A*[2] flips
    only every fourth time, or ⌊*n*/4⌋ times in a sequence of *n* INCREMENT operations.
    In general, for *i* = 0, 1, … , *k* − 1, bit *A*[*i*] flips ⌊*n*/2^(*i*)⌋ times
    in a sequence of *n* INCREMENT operations on an initially zero counter. For *i*
    ≥ *k*, bit *A*[*i*] does not exist, and so it cannot flip. The total number of
    flips in the sequence is thus'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管单次调用INCREMENT可能会翻转所有*k*位，但并非每次调用都会翻转所有位。 （请注意与MULTIPOP的相似之处，其中单次调用可能弹出许多对象，但并非每次调用都会弹出许多对象。）正如[图16.2](chapter016.xhtml#Fig_16-2)所示，*A*[0]在每次调用INCREMENT时都会翻转。上一个位，*A*[1]只有每隔一次才会翻转：在初始为零的计数器上进行一系列*n*个INCREMENT操作会导致*A*[1]翻转⌊*n*/2⌋次。类似地，位*A*[2]只有每四次才会翻转，或者在一系列*n*个INCREMENT操作中翻转⌊*n*/4⌋次。一般来说，对于*i*
    = 0, 1, … , *k* − 1，位*A*[*i*]在初始为零的计数器上进行一系列*n*个INCREMENT操作时会翻转⌊*n*/2^(*i*)⌋次。对于*i*
    ≥ *k*，位*A*[*i*]不存在，因此不能翻转。因此，序列中的总翻转次数为
- en: '![art](images/Art_P509.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P509.jpg)'
- en: by equation (A.7) on page 1142\. Thus, a sequence of *n* INCREMENT operations
    on an initially zero counter takes *O*(*n*) time in the worst case. The average
    cost of each operation, and therefore the amortized cost per operation, is *O*(*n*)/*n*
    = *O*(1).
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 根据第1142页上的方程（A.7），因此，对于初始为零的计数器上的一系列*n*个INCREMENT操作，在最坏情况下需要*O*(*n*)的时间。每个操作的平均成本，因此每个操作的摊销成本是*O*(*n*)/*n*
    = *O*(1)。
- en: '**Exercises**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***16.1-1***'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.1-1***'
- en: If the set of stack operations includes a MULTIPUSH operation, which pushes
    *k* items onto the stack, does the *O*(1) bound on the amortized cost of stack
    operations continue to hold?
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如果栈操作集包括MULTIPUSH操作，该操作将*k*个项目推入栈中，那么栈操作的摊销成本的*O*(1)上界是否仍然成立？
- en: '***16.1-2***'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.1-2***'
- en: Show that if a DECREMENT operation is included in the *k*-bit counter example,
    *n* operations can cost as much as Θ(*nk*) time.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 证明如果在*k*位计数器示例中包含DECREMENT操作，则*n*个操作的成本最多可能为Θ(*nk*)时间。
- en: '***16.1-3***'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.1-3***'
- en: Use aggregate analysis to determine the amortized cost per operation for a sequence
    of *n* operations on a data structure in which the *i*th operation costs *i* if
    *i* is an exact power of 2, and 1 otherwise.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 使用聚合分析来确定在数据结构上执行一系列*n*个操作的摊销成本。其中，如果*i*是2的确切幂，则第*i*个操作的成本为*i*，否则为1。
- en: '[**16.2    The accounting method**](toc.xhtml#Rh1-95)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '[**16.2    会计法**](toc.xhtml#Rh1-95)'
- en: In the ***accounting method*** of amortized analysis, you assign differing charges
    to different operations, with some operations charged more or less than they actually
    cost. The amount that you charge an operation is its ***amortized cost***. When
    an operation’s amortized cost exceeds its actual cost, you assign the difference
    to specific objects in the data structure as ***credit***. Credit can help pay
    for later operations whose amortized cost is less than their actual cost. Thus,
    you can view the amortized cost of an operation as being split between its actual
    cost and credit that is either deposited or used up. Different operations may
    have different amortized costs. This method differs from aggregate analysis, in
    which all operations have the same amortized cost.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在摊销分析的***会计法***中，你为不同的操作分配不同的费用，有些操作的费用高于或低于它们实际的成本。你为一个操作分配的费用称为其***摊销成本***。当一个操作的摊销成本超过其实际成本时，你将差额分配给数据结构中的特定对象作为***信用***。信用可以帮助支付后续操作，后续操作的摊销成本低于其实际成本。因此，你可以将一个操作的摊销成本视为其实际成本和存款或使用的信用之间的分割。不同的操作可能具有不同的摊销成本。这种方法与聚合分析不同，聚合分析中所有操作具有相同的摊销成本。
- en: You must choose the amortized costs of operations carefully. If you want to
    use amortized costs to show that in the worst case the average cost per operation
    is small, you must ensure that the total amortized cost of a sequence of operations
    provides an upper bound on the total actual cost of the sequence. Moreover, as
    in aggregate analysis, the upper bound must apply to all sequences of operations.
    Let’s denote the actual cost of the *i*th operation by *c[i]* and the amortized
    cost of the *i*th operation by *ĉ[i]*. Then you need to have
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须仔细选择操作的摊销成本。如果你想使用摊销成本来表明在最坏情况下每个操作的平均成本很小，你必须确保一系列操作的总摊销成本对该序列的总实际成本提供了上界。此外，正如在聚合分析中一样，上界必须适用于所有操作序列。让我们用*c[i]*表示第*i*个操作的实际成本，*ĉ[i]*表示第*i*个操作的摊销成本。那么你需要满足
- en: '![art](images/Art_P510.jpg)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P510.jpg)'
- en: for all sequences of *n* operations. The total credit stored in the data structure
    is the difference between the total amortized cost and the total actual cost,
    or ![art](images/Art_P511.jpg). By inequality (16.1), the total credit associated
    with the data structure must be nonnegative at all times. If you ever allowed
    the total credit to become negative (the result of undercharging early operations
    with the promise of repaying the account later on), then the total amortized costs
    incurred at that time would be below the total actual costs incurred. In that
    case, for the sequence of operations up to that time, the total amortized cost
    would not be an upper bound on the total actual cost. Thus, you must take care
    that the total credit in the data structure never becomes negative.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有的*n*个操作序列。数据结构中存储的总信用是总摊销成本和总实际成本之间的差异，即![art](images/Art_P511.jpg)。根据不等式（16.1），与数据结构相关联的总信用必须始终为非负。如果你允许总信用变为负数（这是因为在早期操作中收费不足，承诺稍后偿还），那么此时产生的总摊销成本将低于实际产生的总成本。在这种情况下，对于到那个时候的操作序列，总摊销成本将不是总实际成本的上界。因此，你必须小心确保数据结构中的总信用永远不会变为负数。
- en: '**Stack operations**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈操作**'
- en: To illustrate the accounting method of amortized analysis, we return to the
    stack example. Recall that the actual costs of the operations were
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明摊销分析的会计方法，我们回到栈的例子。回想一下操作的实际成本是多少
- en: '| PUSH | 1, |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| PUSH | 1, |'
- en: '| POP | 1, |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| POP | 1, |'
- en: '| MULTIPOP | min {*s*, *k*}, |'
  id: totrans-59
  prefs: []
  type: TYPE_TB
  zh: '| MULTIPOP | min {*s*, *k*}, |'
- en: 'where *k* is the argument supplied to MULTIPOP and *s* is the stack size when
    it is called. Let us assign the following amortized costs:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*k*是提供给MULTIPOP的参数，*s*是调用时的栈大小。让我们分配以下摊销成本：
- en: '| PUSH | 2, |'
  id: totrans-61
  prefs: []
  type: TYPE_TB
  zh: '| PUSH | 2, |'
- en: '| POP | 0, |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| POP | 0, |'
- en: '| MULTIPOP | 0. |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| MULTIPOP | 0. |'
- en: The amortized cost of MULTIPOP is a constant (0), whereas the actual cost is
    variable, and thus all three amortized costs are constant. In general, the amortized
    costs of the operations under consideration may differ from each other, and they
    may even differ asymptotically.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: MULTIPOP的摊销成本是一个常数（0），而实际成本是可变的，因此所有三个摊销成本都是常数。一般来说，所考虑的操作的摊销成本可能彼此不同，甚至在渐近上也可能不同。
- en: Now let’s see how to pay for any sequence of stack operations by charging the
    amortized costs. Let $1 represent each unit of cost. At first, the stack is empty.
    Recall the analogy of [Section 10.1.3](chapter010.xhtml#Sec_10.1.3) between the
    stack data structure and a stack of plates in a cafeteria. Upon pushing a plate
    onto the stack, use $1 to pay the actual cost of the push, leaving a credit of
    $1 (out of the $2 charged). Place that $1 of credit on top of the plate. At any
    point in time, every plate on the stack has $1 of credit on it.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看如何通过收取摊销成本来支付任何一系列栈操作。让$1代表每个成本单位。一开始，栈是空的。回想一下[第10.1.3节](chapter010.xhtml#Sec_10.1.3)中栈数据结构与自助餐厅中的盘子堆叠之间的类比。将一个盘子推入栈时，使用$1支付推入的实际成本，留下$1的信用（从收取的$2中）。将该$1的信用放在盘子顶部。在任何时候，栈上的每个盘子都有$1的信用。
- en: 'The $1 stored on the plate serves to prepay the cost of popping the plate from
    the stack. A POP operation incurs no charge: pay the actual cost of popping a
    plate by taking the $1 of credit off the plate. Thus, by charging the PUSH operation
    a little bit more, we can view the POP operation as free.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: ���储在盘子上的$1用于预付从栈中弹出盘子的成本。POP操作不产生费用：通过从盘子上取下$1的信用来支付弹出盘子的实际成本。因此，通过稍微增加PUSH操作的费用，我们可以将POP操作视为免费。
- en: Moreover, the MULTIPOP operation also incurs no charge, since it’s just repeated
    POP operations, each of which is free. If a MULTIPOP operation pops *k* plates,
    then the actual cost is paid by the *k* dollars stored on the *k* plates. Because
    each plate on the stack has $1 of credit on it, and the stack always has a nonnegative
    number of plates, the amount of credit is always nonnegative. Thus, for *any*
    sequence of *n* PUSH, POP, and MULTIPOP operations, the total amortized cost is
    an upper bound on the total actual cost. Since the total amortized cost is *O*(*n*),
    so is the total actual cost.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，MULTIPOP操作也不产生费用，因为它只是重复的POP操作，每个操作都是免费的。如果MULTIPOP操作弹出*k*个盘子，则实际成本由存储在*k*个盘子上的*k*美元支付。因为栈上的每个盘子都有$1的信用，而且栈上始终有非负数的盘子，所以信用金额始终为非负数。因此，对于*任何*一系列*
    n *个PUSH、POP和MULTIPOP操作，总摊销成本是总实际成本的上限。由于总摊销成本为*O*(*n*)，因此总实际成本也是*O*(*n*)。
- en: '**Incrementing a binary counter**'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '**增加二进制计数器**'
- en: As another illustration of the accounting method, let’s analyze the INCREMENT
    operation on a binary counter that starts at 0\. Recall that the running time
    of this operation is proportional to the number of bits flipped, which serves
    as the cost for this example. Again, we’ll use $1 to represent each unit of cost
    (the flipping of a bit in this example).
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 作为会计方法的另一个例子，让我们分析从0开始的二进制计数器上的INCREMENT操作。回想一下，此操作的运行时间与翻转的位数成正比，这作为此示例的成本。同样，我们将使用$1来表示每个成本单位（在此示例中翻转位的成本）。
- en: For the amortized analysis, the amortized cost to set a 0-bit to 1 is $2\. When
    a bit is set to 1, $1 of the $2 pays to actually set the bit. The second $1 resides
    on the bit as credit to be used later if and when the bit is reset to 0\. At any
    point in time, every 1-bit in the counter has $1 of credit on it, and thus resetting
    a bit to 0 can be viewed as costing nothing, and the $1 on the bit prepays for
    the reset.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 对于摊销分析，将0位设置为1的摊销成本为$2。当一个位被设置为1时，$2中的$1用于实际设置该位。第二个$1作为信用留在位上，以便在将来如果该位被重置为0时使用。在任何时候，计数器中的每个1位都有$1的信用，因此将位重置为0可以视为不花费任何成本，而位上的$1预付了重置的成本。
- en: Here is how to determine the amortized cost of INCREMENT. The cost of resetting
    the bits to 0 within the **while** loop is paid for by the dollars on the bits
    that are reset. The INCREMENT procedure sets at most one bit to 1, in line 6,
    and therefore the amortized cost of an INCREMENT operation is at most $2\. The
    number of 1-bits in the counter never becomes negative, and thus the amount of
    credit stays nonnegative at all times. Thus, for *n* INCREMENT operations, the
    total amortized cost is *O*(*n*), which bounds the total actual cost.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何确定INCREMENT的摊销成本。在**while**循环中重置位为0的成本由重置位上的美元支付。INCREMENT过程在第6行最多将一个位设置为1，因此INCREMENT操作的摊销成本最多为$2。计数器中的1位数永远不会变为负数，因此信用金额始终为非负数。因此，对于*n*个INCREMENT操作，总摊销成本为*O*(*n*)，这限制了总实际成本。
- en: '**Exercises**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***16.2-1***'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.2-1***'
- en: You perform a sequence of PUSH and POP operations on a stack whose size never
    exceeds *k*. After every *k* operations, a copy of the entire stack is made automatically,
    for backup purposes. Show that the cost of *n* stack operations, including copying
    the stack, is *O*(*n*) by assigning suitable amortized costs to the various stack
    operations.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个栈上执行一系列PUSH和POP操作，其大小永远不超过*k*。每经过*k*次操作，整个栈都会自动复制一次，以备份目的。通过为各种栈操作分配合适的摊销成本，证明*n*个栈操作的成本，包括复制栈，是*O*(*n*)。
- en: '***16.2-2***'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.2-2***'
- en: Redo Exercise 16.1-3 using an accounting method of analysis.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 使用会计方法重新执行练习16.1-3。
- en: '***16.2-3***'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.2-3***'
- en: 'You wish not only to increment a counter but also to reset it to 0 (i.e., make
    all bits in it 0). Counting the time to examine or modify a bit as Θ(1), show
    how to implement a counter as an array of bits so that any sequence of *n* INCREMENT
    and RESET operations takes *O*(*n*) time on an initially zero counter. (*Hint*:
    Keep a pointer to the high-order 1.)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你不仅希望增加一个计数器，还希望将其重置为0（即，使其所有位都为0）。将检查或修改一个位的时间计为Θ(1)，展示如何将计数器实现为一个位数组，以便在初始为零的计数器上进行任意序列的*n*次增量和重置操作的时间为*O*(*n*)。(*提示*：保持指向高阶1的指针。)
- en: '[**16.3    The potential method**](toc.xhtml#Rh1-96)'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '[**16.3    潜力法**](toc.xhtml#Rh1-96)'
- en: Instead of representing prepaid work as credit stored with specific objects
    in the data structure, the ***potential method*** of amortized analysis represents
    the prepaid work as “potential energy,” or just “potential,” which can be released
    to pay for future operations. The potential applies to the data structure as a
    whole rather than to specific objects within the data structure.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 摊销分析的***潜力法***不是将预付的工作表示为存储在数据结构中特定对象的信用，而是将预付的工作表示为“潜在能量”或简称“潜力”，可以用来支付未来的操作。潜力适用于整个数据结构，而不是数据结构中的特定对象。
- en: The potential method works as follows. Starting with an initial data structure
    *D*[0], a sequence of *n* operations occurs. For each *i* = 1, 2, … , *n*, let
    *c[i]* be the actual cost of the *i*th operation and *D[i]* be the data structure
    that results after applying the *i*th operation to data structure *D*[*i*−1].
    A ***potential function*** Φ maps each data structure *D[i]* to a real number
    Φ(*D[i]*), which is the ***potential*** associated with *D[i]*. The ***amortized
    cost*** *ĉ[i]* of the *i*th operation with respect to potential function Φ is
    defined by
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 潜力法的工作方式如下。从初始数据结构*D*[0]开始，发生一系列*n*次操作。对于每个*i* = 1, 2, … , *n*，让*c[i]*表示第*i*次操作的实际成本，*D[i]*表示将第*i*次操作应用于数据结构*D*[*i*−1]后得到的数据结构。一个***潜力函数***Φ将每个数据结构*D[i]*映射到一个实数Φ(*D[i]*)，这是与*D[i]*相关联的***潜力***。第*i*次操作相对于潜力函数Φ的***摊销成本***
    *ĉ[i]*由以下定义
- en: '![art](images/Art_P512.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P512.jpg)'
- en: The amortized cost of each operation is therefore its actual cost plus the change
    in potential due to the operation. By equation (16.2), the total amortized cost
    of the *n* operations is
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每个操作的摊销成本是其实际成本加上由于操作而产生的潜力变化。根据方程(16.2)，*n*次操作的总摊销成本为
- en: '![art](images/Art_P513.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P513.jpg)'
- en: The second equation follows from equation (A.12) on page 1143 because the Φ(*D[i]*)
    terms telescope.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个方程来自第1143页的方程(A.12)，因为Φ(*D[i]*)项是级数。
- en: If you can define a potential function Φ so that Φ(*D[n]*) ≥ Φ(*D*[0]), then
    the total amortized cost ![art](images/Art_P514.jpg) gives an upper bound on the
    total actual cost ![art](images/Art_P515.jpg). In practice, you don’t always know
    how many operations might be performed. Therefore, if you require that Φ(*D[i]*)
    ≥ Φ(*D*[0]) for all *i*, then you guarantee, as in the accounting method, that
    you’ve paid in advance. It’s usually simplest to just define Φ(*D*[0]) to be 0
    and then show that Φ(*D[i]*) ≥ 0 for all *i*. (See Exercise 16.3-1 for an easy
    way to handle cases in which Φ(*D*[0]) ≠ 0.)
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以定义一个潜力函数Φ，使得Φ(*D[n]*) ≥ Φ(*D*[0])，那么总摊销成本![art](images/Art_P514.jpg)给出了总实际成本![art](images/Art_P515.jpg)的上界。在实践中，您并不总是知道可能执行多少次操作。因此，如果��求对所有*i*，Φ(*D[i]*)
    ≥ Φ(*D*[0])，那么您就像在会计方法中一样，提前支付了费用。通常，最简单的方法是将Φ(*D*[0])定义为0，然后证明对所有*i*，Φ(*D[i]*)
    ≥ 0。 (参见练习16.3-1，了解处理Φ(*D*[0]) ≠ 0情况的简单方法。)
- en: Intuitively, if the potential difference Φ(*D[i]*) − Φ(*D*[*i*−1]) of the *i*th
    operation is positive, then the amortized cost *ĉ[i]* represents an overcharge
    to the *i*th operation, and the potential of the data structure increases. If
    the potential difference is negative, then the amortized cost represents an undercharge
    to the *i*th operation, and the decrease in the potential pays for the actual
    cost of the operation.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 直观地说，如果第*i*次操作的潜力差Φ(*D[i]*) − Φ(*D*[*i*−1])为正，则摊销成本*ĉ[i]*表示对第*i*次操作的过度收费，数据结构的潜力增加。如果潜力差为负，则摊销成本表示对第*i*次操作的不足收费，潜力的减少用于支付操作的实际成本。
- en: The amortized costs defined by equations (16.2) and (16.3) depend on the choice
    of the potential function Φ. Different potential functions may yield different
    amortized costs, yet still be upper bounds on the actual costs. You will often
    find trade-offs that you can make in choosing a potential function. The best potential
    function to use depends on the desired time bounds.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 方程(16.2)和(16.3)定义的摊销成本取决于潜力函数Φ的选择。不同的潜力函数可能产生不同的摊销成本，但仍然是实际成本的上界。在选择潜力函数时，您通常会发现可以进行权衡。选择使用的最佳潜力函数取决于所需的时间界限。
- en: '**Stack operations**'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '**栈操作**'
- en: To illustrate the potential method, we return once again to the example of the
    stack operations PUSH, POP, and MULTIPOP. We define the potential function Φ on
    a stack to be the number of objects in the stack. The potential of the empty initial
    stack *D*[0] is Φ(*D*[0]) = 0\. Since the number of objects in the stack is never
    negative, the stack *D[i]* that results after the *i*th operation has nonnegative
    potential, and thus
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明潜力法，我们再次回到栈操作PUSH、POP和MULTIPOP的示例。我们定义栈上的潜力函数Φ为栈中对象的数量。空初始栈*D*[0]的潜力为Φ(*D*[0])
    = 0。由于栈中对象的数量永远不会为负，因此第*i*次操作后得到的栈*D[i]*具有非负潜力，因此
- en: '| Φ(*D[i]*) | ≥ | 0 |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| Φ(*D[i]*) | ≥ | 0 |'
- en: '|  | = | Φ(*D*[0]). |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '|  | = | Φ(*D*[0])。 |'
- en: The total amortized cost of *n* operations with respect to Φ therefore represents
    an upper bound on the actual cost.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，关于Φ的*n*次操作的总摊销成本代表了实际成本的上界。
- en: Now let’s compute the amortized costs of the various stack operations. If the
    *i*th operation on a stack containing *s* objects is a PUSH operation, then the
    potential difference is
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们计算各种栈操作的摊销成本。如果对包含*s*个对象的栈进行的第*i*次操作是一个PUSH操作，则潜力差为
- en: '| Φ(*D[i]*) − Φ(*D*[*i*−1]) | = | (*s* + 1) − *s* |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| Φ(*D[i]*) − Φ(*D*[*i*−1]) | = | (*s* + 1) − *s* |'
- en: '|  | = | 1. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 1. |'
- en: By equation (16.2), the amortized cost of this PUSH operation is
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 根据方程（16.2），这个 PUSH 操作的摊销成本为
- en: '| *ĉ[i]* | = | *c[i]* + Φ(*D[i]*) − Φ(*D*[*i*−1]) |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| *ĉ[i]* | = | *c[i]* + Φ(*D[i]*) − Φ(*D[i−1]*) |'
- en: '|  | = | 1 + 1 |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 1 + 1 |'
- en: '|  | = | 2. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 2. |'
- en: Suppose that the *i*th operation on the stack of *s* objects is MULTIPOP(*S*,
    *k*), which causes *k*′ = min {*s*, *k*} objects to be popped off the stack. The
    actual cost of the operation is *k*′, and the potential difference is
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设栈中第 *s* 个对象的第 *i* 次操作是 MULTIPOP(*S*, *k*)，导致弹出 *k*′ = min {*s*, *k*} 个对象。操作的实际成本为
    *k*′，潜在差异为
- en: Φ(*D[i]*) − Φ(*D*[*i*−1]) = −*k*′.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: Φ(*D[i]*) − Φ(*D*[*i*−1]) = −*k*′.
- en: Thus, the amortized cost of the MULTIPOP operation is
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，MULTIPOP 操作的摊销成本为
- en: '| *ĉ[i]* | = | *c[i]* + Φ(*D[i]*) − Φ(*D*[*i*−1]) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| *ĉ[i]* | = | *c[i]* + Φ(*D[i]*) − Φ(*D[i−1]*) |'
- en: '|  | = | *k*′ − *k*′ |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *k*′ − *k*′ |'
- en: '|  | = | 0. |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 0. |'
- en: Similarly, the amortized cost of an ordinary POP operation is 0.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，普通 POP 操作的摊销成本为 0。
- en: The amortized cost of each of the three operations is *O*(1), and thus the total
    amortized cost of a sequence of *n* operations is *O*(*n*). Since Φ(*D[i]*) ≥
    Φ(*D*[0]), the total amortized cost of *n* operations is an upper bound on the
    total actual cost. The worst-case cost of *n* operations is therefore *O*(*n*).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 三种操作的摊销成本均为 *O*(1)，因此 *n* 次操作的总摊销成本为 *O*(*n*)。由于 Φ(*D[i]*) ≥ Φ(*D[0]*)，*n* 次操作的总摊销成本是总实际成本的上界。因此，*n*
    次操作的最坏情况成本为 *O*(*n*)。
- en: '**Incrementing a binary counter**'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '**增加二进制计数器**'
- en: As another example of the potential method, we revisit incrementing a *k*-bit
    binary counter. This time, the potential of the counter after the *i*th INCREMENT
    operation is defined to be the number of 1-bits in the counter after the *i*th
    operation, which we’ll denote by *b[i]*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 作为潜在方法的另一个例子，我们重新审视增加 *k* 位二进制计数器。这次，第 *i* 次 INCREMENT 操作后计数器的潜力定义为操作后计数器中的
    1 位数，我们将其表示为 *b[i]*。
- en: Here is how to compute the amortized cost of an INCREMENT operation. Suppose
    that the *i*th INCREMENT operation resets *t[i]* bits to 0\. The actual cost *c[i]*
    of the operation is therefore at most *t[i]* + 1, since in addition to resetting
    *t[i]* bits, it sets at most one bit to 1\. If *b[i]* = 0, then the *i*th operation
    had reset all *k* bits to 0, and so *b*[*i*−1] = *t[i]* = *k*. If *b[i] >* 0,
    then *b[i]* = *b*[*i*−1] −*t[i]* +1\. In either case, *b[i]* ≤ *b*[*i*−1] − *t[i]*
    + 1, and the potential difference is
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何计算 INCREMENT 操作的摊销成本。假设第 *i* 次 INCREMENT 操作将 *t[i]* 位重置为 0。因此，操作的实际成本 *c[i]*
    最多为 *t[i]* + 1，因为除了重置 *t[i]* 位外，它还将最多一个位设置为 1。如果 *b[i]* = 0，则第 *i* 次操作将所有 *k*
    位重置为 0，因此 *b[i−1]* = *t[i]* = *k*。如果 *b[i] >* 0，则 *b[i]* = *b[i−1]* −*t[i]* +1。无论哪种情况，*b[i]*
    ≤ *b[i−1]* − *t[i]* + 1，潜在差异为
- en: '| Φ(*D[i]*) − Φ(*D*[*i*−1]) | ≤ | (*b*[*i*−1] − *t[i]* + 1) − *b*[*i*−1] |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| Φ(*D[i]*) − Φ(*D*[*i*−1]) | ≤ | (*b*[*i*−1] − *t[i]* + 1) − *b*[*i*−1] |'
- en: '|  | = | 1 − *t[i]*. |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 1 − *t[i]*. |'
- en: The amortized cost is therefore
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，摊销成本为
- en: '| *ĉ[i]* | = | *c[i]* + Φ(*D[i]*) − Φ(*D*[*i*−1]) |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| *ĉ[i]* | = | *c[i]* + Φ(*D[i]*) − Φ(*D[i−1]*) |'
- en: '|  | ≤ | (*t[i]* + 1) + (1 − *t[i]*) |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | (*t[i]* + 1) + (1 − *t[i]*) |'
- en: '|  | = | 2. |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 2. |'
- en: If the counter starts at 0, then Φ(*D*[0]) = 0\. Since Φ(*D[i]*) ≥ 0 for all
    *i*, the total amortized cost of a sequence of *n* INCREMENT operations is an
    upper bound on the total actual cost, and so the worst-case cost of *n* INCREMENT
    operations is *O*(*n*).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果计数器从 0 开始，则 Φ(*D[0]*) = 0。由于对于所有 *i*，Φ(*D[i]*) ≥ 0，*n* 次 INCREMENT 操作的总摊销成本是总实际成本的上界，因此
    *n* 次 INCREMENT 操作的最坏情况成本为 *O*(*n*)。
- en: The potential method provides a simple and clever way to analyze the counter
    even when it does not start at 0\. The counter starts with *b*[0] 1-bits, and
    after *n* INCREMENT operations it has *b[n]* 1-bits, where 0 ≤ *b*[0], *b[n]*
    ≤ *k*. Rewrite equation (16.3) as
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 即使计数器不从 0 开始，潜在方法也提供了一种简单而巧妙的分析计数器的方法。计数器从 *b[0]* 1 位开始，经过 *n* 次 INCREMENT 操作后，它有
    *b[n]* 1 位，其中 0 ≤ *b[0]*，*b[n]* ≤ *k*。将方程（16.3）重写为
- en: '![art](images/Art_P516.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P516.jpg)'
- en: Since Φ(*D*[0]) = *b*[0], Φ(*D[n]*) = *b[n]*, and *ĉ[i]* ≤ 2 for all 1 ≤ *i*
    ≤ *n*, the total actual cost of *n* INCREMENT operations is
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Φ(*D[0]*) = *b[0]*，Φ(*D[n]*) = *b[n]*，且对于所有 1 ≤ *i* ≤ *n*，*ĉ[i]* ≤ 2，因此 *n*
    次 INCREMENT 操作的总实际成本为
- en: '![art](images/Art_P517.jpg)'
  id: totrans-122
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P517.jpg)'
- en: In particular, *b*[0] ≤ *k* means that as long as *k* = *O*(*n*), the total
    actual cost is *O*(*n*). In other words, if at least *n* = Ω(*k*) INCREMENT operations
    occur, the total actual cost is *O*(*n*), no matter what initial value the counter
    contains.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 特别地，*b[0] ≤ k* 意味着只要 *k* = *O*(*n*)，总实际成本为 *O*(*n*)。换句话说，只要至少发生 *n* = Ω(*k*)
    次 INCREMENT 操作，总实际成本为 *O*(*n*)，无论计数器包含什么初始值。
- en: '**Exercises**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***16.3-1***'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.3-1***'
- en: Suppose you have a potential function Φ such that Φ(*D[i]*) ≥ Φ(*D*[0]) for
    all *i*, but Φ(*D*[0]) ≠ 0\. Show that there exists a potential function Φ′ such
    that Φ′(*D*[0]) = 0, Φ′(*D[i]*) ≥ 0 for all *i* ≥ 1, and the amortized costs using
    Φ′ are the same as the amortized costs using Φ.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个潜在函数 Φ，使得对于所有 *i*，Φ(*D[i]*) ≥ Φ(*D[0]*)，但 Φ(*D[0]*) ≠ 0。证明存在一个潜在函数 Φ′，使得
    Φ′(*D[0]*) = 0，对于所有 *i* ≥ 1，Φ′(*D[i]*) ≥ 0，并且使用 Φ′ 的摊销成本与使用 Φ 的摊销成本相同。
- en: '***16.3-2***'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.3-2***'
- en: Redo Exercise 16.1-3 using a potential method of analysis.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 使用潜在方法重新做练习 16.1-3。
- en: '***16.3-3***'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.3-3***'
- en: Consider an ordinary binary min-heap data structure supporting the instructions
    INSERT and EXTRACT-MIN that, when there are *n* items in the heap, implements
    each operation in *O*(lg *n*) worst-case time. Give a potential function Φ such
    that the amortized cost of INSERT is *O*(lg *n*) and the amortized cost of EXTRACT-MIN
    is *O*(1), and show that your potential function yields these amortized time bounds.
    Note that in the analysis, *n* is the number of items currently in the heap, and
    you do not know a bound on the maximum number of items that can ever be stored
    in the heap.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个支持指令 INSERT 和 EXTRACT-MIN 的普通二进制最小堆数据结构，当堆中有 *n* 个项目时，每个操作的最坏情况时间复杂度为 *O*(lg
    *n*)。给出一个潜在函数 Φ，使得 INSERT 的摊销成本为 *O*(lg *n*)，EXTRACT-MIN 的摊销成本为 *O*(1)，并展���你的潜在函数如何产生这些摊销时间界。请注意，在分析中，*n*
    是堆中当前项目的数量，你不知道堆中可以存储的最大项目数量的界限。
- en: '***16.3-4***'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.3-4***'
- en: What is the total cost of executing *n* of the stack operations PUSH, POP, and
    MULTIPOP, assuming that the stack begins with *s*[0] objects and finishes with
    *s[n]* objects?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 执行*n*个栈操作PUSH、POP和MULTIPOP的总成本是多少，假设栈以*s*[0]个对象开始，以*s[n]*个对象结束？
- en: '***16.3-5***'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.3-5***'
- en: Show how to implement a queue with two ordinary stacks (Exercise 10.1-7) so
    that the amortized cost of each ENQUEUE and each DEQUEUE operation is *O*(1).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 展示如何使用两个普通栈实现一个队列（练习10.1-7），使得每个ENQUEUE和DEQUEUE操作的摊销成本为*O*(1)。
- en: '***16.3-6***'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.3-6***'
- en: 'Design a data structure to support the following two operations for a dynamic
    multiset *S* of integers, which allows duplicate values:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 设计一个数据结构，支持动态多重集合*S*中整数的以下两个操作，允许重复值：
- en: INSERT(*S*, *x*) inserts *x* into *S*.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: INSERT(*S*, *x*)将*x*插入*S*中。
- en: DELETE-LARGER-HALF(*S*) deletes the largest ⌈|*S*|/2⌉ elements from *S*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: DELETE-LARGER-HALF(*S*)从*S*中删除最大的⌈|*S*|/2⌉个元素。
- en: Explain how to implement this data structure so that any sequence of *m* INSERT
    and DELETE-LARGER-HALF operations runs in *O*(*m*) time. Your implementation should
    also include a way to output the elements of *S* in *O*(|*S*|) time.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 解释如何实现这种数据结构，使得任何*m*个INSERT和DELETE-LARGER-HALF操作序列在*O*(*m*)时间内运行。你的实现还应包括一种在*O*(|*S*|)时间内输出*S*元素的方法。
- en: '[**16.4    Dynamic tables**](toc.xhtml#Rh1-97)'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '[**16.4    动态表**](toc.xhtml#Rh1-97)'
- en: When you design an application that uses a table, you do not always know in
    advance how many items the table will hold. You might allocate space for the table,
    only to find out later that it is not enough. The program must then reallocate
    the table with a larger size and copy all items stored in the original table over
    into the new, larger table. Similarly, if many items have been deleted from the
    table, it might be worthwhile to reallocate the table with a smaller size. This
    section studies this problem of dynamically expanding and contracting a table.
    Amortized analyses will show that the amortized cost of insertion and deletion
    is only *O*(1), even though the actual cost of an operation is large when it triggers
    an expansion or a contraction. Moreover, you’ll see how to guarantee that the
    unused space in a dynamic table never exceeds a constant fraction of the total
    space.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计使用表的应用程序时，你并不总是提前知道表将容纳多少项目。你可能为表分配空间，只能在后来发现不够用时。程序必须重新分配一个更大尺寸的表，并将存储在原始表中的所有项目复制到新的、更大的表中。同样，如果从表中删除了许多项目，可能值得重新分配一个尺寸较小的表。本节研究了动态扩展和收缩表的问题。摊销分析将表明，插���和删除的摊销成本仅为*O*(1)，即使实际操作的成本很大，当触发扩展或收缩时。此外，你将看到如何保证动态表中未使用的空间永远不会超过总空间的一个常数分数。
- en: 'Let’s assume that the dynamic table supports the operations TABLE-INSERT and
    TABLE-DELETE. TABLE-INSERT inserts into the table an item that occupies a single
    ***slot***, that is, a space for one item. Likewise, TABLE-DELETE removes an item
    from the table, thereby freeing a slot. The details of the data-structuring method
    used to organize the table are unimportant: it could be a stack ([Section 10.1.3](chapter010.xhtml#Sec_10.1.3)),
    a heap ([Chapter 6](chapter006.xhtml)), a hash table ([Chapter 11](chapter011.xhtml)),
    or something else.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 假设动态表支持TABLE-INSERT和TABLE-DELETE操作。TABLE-INSERT将一个占用单个***槽位***的项目插入表中，即一个项目的空间。同样，TABLE-DELETE从表中移除一个项目，从而释放一个槽位。表组织方法的细节并不重要：它可以是一个栈（[第10.1.3节](chapter010.xhtml#Sec_10.1.3)）、一个堆（[第6章](chapter006.xhtml)）、一个哈希表（[第11章](chapter011.xhtml)）或其他什么。
- en: It is convenient to use a concept introduced in [Section 11.2](chapter011.xhtml#Sec_11.2),
    where we analyzed hashing. The ***load factor*** *α*(*T*) of a nonempty table
    *T* is defined as the number of items stored in the table divided by the size
    (number of slots) of the table. An empty table (one with no slots) has size 0,
    and its load factor is defined to be 1\. If the load factor of a dynamic table
    is bounded below by a constant, the unused space in the table is never more than
    a constant fraction of the total amount of space.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第11.2节](chapter011.xhtml#Sec_11.2)中介绍的概念很方便，我们在那里分析了哈希。非空表*T*的***负载因子*** *α*(*T*)定义为存储在表中的项目数除以表的大小（槽位数）。一个空表（没有槽位的表）的大小为0，其负载因子定义为1。如果动态表的负载因子被下界常数限制，表中未使用的空间永远不会超过总空间的一个常数分数。
- en: We start by analyzing a dynamic table that allows only insertion and then move
    on to the more general case that supports both insertion and deletion.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先分析一个只允许插入的动态表，然后转向支持插入和删除的更一般情况。
- en: '**16.4.1    Table expansion**'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.4.1    表扩展**'
- en: Let’s assume that storage for a table is allocated as an array of slots. A table
    fills up when all slots have been used or, equivalently, when its load factor
    is 1.^([1](#footnote_1)) In some software environments, upon an attempt to insert
    an item into a full table, the only alternative is to abort with an error. The
    scenario in this section assumes, however, that the software environment, like
    many modern ones, provides a memory-management system that can allocate and free
    blocks of storage on request. Thus, upon inserting an item into a full table,
    the system can ***expand*** the table by allocating a new table with more slots
    than the old table had. Because the table must always reside in contiguous memory,
    the system must allocate a new array for the larger table and then copy items
    from the old table into the new table.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 假设表的存储是作为槽位数组分配的。当所有槽位都被使用时，表填满了，或者等效地说，当其负载因子为1时。在某些软件环境中，尝试将项目插入满表时，唯一的选择是中止并显示错误。然而，本节的情景假设软件环境，像许多现代软件环境一样，提供了一个可以根据请求分配和释放存储块的内存管理系统。因此，在将项目插入满表时，系统可以通过分配一个比旧表槽位更多的新表来***扩展***表。因为表必须始终驻留在连续内存中，系统必须为更大的表分配一个新数组，然后将项目从旧表复制到新表。
- en: A common heuristic allocates a new table with twice as many slots as the old
    one. If the only table operations are insertions, then the load factor of the
    table is always at least 1/2, and thus the amount of wasted space never exceeds
    half the total space in the table.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的启发式方法是将新表的槽数设置为旧表的两倍。如果唯一的表操作是插入，则表的负载因子始终至少为1/2，因此浪费空间的量永远不会超过表中总空间的一半。
- en: 'The TABLE-INSERT procedure on the following page assumes that *T* is an object
    representing the table. The attribute *T*.*table* contains a pointer to the block
    of storage representing the table, *T*.*num* contains the number of items in the
    table, and *T*.*size* gives the total number of slots in the table. Initially,
    the table is empty: *T*.*num* = *T*.*size* = 0.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 下一页的TABLE-INSERT过程假定*T*是代表表的对象。属性*T*.*table*包含指向表示表的存储块的指针，*T*.*num*包含表中项目的数量，*T*.*size*给出表中总槽的数量。最初，表是空的：*T*.*num*
    = *T*.*size* = 0。
- en: 'There are two types of insertion here: the TABLE-INSERT procedure itself and
    the ***elementary insertion*** into a table in lines 6 and 10\. We can analyze
    the running time of TABLE-INSERT in terms of the number of elementary insertions
    by assigning a cost of 1 to each elementary insertion. In most computing environments,
    the overhead for allocating an initial table in line 2 is constant and the overhead
    for allocating and freeing storage in lines 5 and 7 is dominated by the cost of
    transfer-ring items in line 6\. Thus, the actual running time of TABLE-INSERT
    is linear in the number of elementary insertions. An ***expansion*** occurs when
    lines 5–9 execute.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有两种插入类型：TABLE-INSERT过程本身和行6和10中表中的***基本插入***。我们可以通过为每个基本插入分配成本1来分析TABLE-INSERT的运行时间。在大多数计算环境中，行2中分配初始表的开销是恒定的，行5和7中分配和释放存储的开销被行6中传输项目的成本所主导。因此，TABLE-INSERT的实际运行时间与基本插入的数量成正比。当执行行5–9时会发生***扩展***。
- en: TABLE-INSERT(*T*, *x*)
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: TABLE-INSERT(*T*, *x*)
- en: '|   1 | **if** *T*.*size* == 0 |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|   1 | **如果** *T*.*size* == 0 |'
- en: '|   2 | allocate *T*.*table* with 1 slot |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|   2 | 用1个槽分配*T*.*table* |'
- en: '|   3 | *T*.*size* = 1 |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|   3 | *T*.*size* = 1 |'
- en: '|   4 | **if** *T*.*num* == *T*.*size* |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|   4 | **如果** *T*.*num* == *T*.*size* |'
- en: '|   5 | allocate *new*-*table* with 2 *· T*.*size* slots |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|   5 | 用2 *· T*.*size*槽分配*new*-*table* |'
- en: '|   6 | insert all items in *T*.*table* into *new*-*table* |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|   6 | 将*T*.*table*中的所有项目插入*new*-*table* |'
- en: '|   7 | free *T*.*table* |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|   7 | 空闲*T*.*table* |'
- en: '|   8 | *T*.*table* = *new*-*table* |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|   8 | *T*.*table* = *new*-*table* |'
- en: '|   9 | *T*.*size* = 2 · *T*.*size* |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|   9 | *T*.*size* = 2 · *T*.*size* |'
- en: '| 10 | insert *x* into *T*.*table* |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '| 10 | 将*x*插入*T*.*table* |'
- en: '| 11 | *T*.*num* = *T*.*num* + 1 |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 11 | *T*.*num* = *T*.*num* + 1 |'
- en: 'Now, we’ll use all three amortized analysis techniques to analyze a sequence
    of *n* TABLE-INSERT operations on an initially empty table. First, we need to
    determine the actual cost *c[i]* of the *i*th operation. If the current table
    has room for the new item (or if this is the first operation), then *c[i]* = 1,
    since the only elementary insertion performed is the one in line 10\. If the current
    table is full, however, and an expansion occurs, then *c[i]* = *i*: the cost is
    1 for the elementary insertion in line 10 plus *i* − 1 for the items copied from
    the old table to the new table in line 6\. For *n* operations, the worst-case
    cost of an operation is *O*(*n*), which leads to an upper bound of *O*(*n*²) on
    the total running time for *n* operations.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将使用所有三种摊销分析技术来分析最初为空表上的*n* TABLE-INSERT操作序列。首先，我们需要确定第*i*个操作的实际成本*c[i]*。如果当前表有空间容纳新项目（或者这是第一个操作），那么*c[i]*
    = 1，因为唯一执行的基本插入是第10行中的插入。然而，如果当前表已满并发生扩展，则*c[i]* = *i*：成本为第10行中的基本插入加上从旧表复制到新表的项目的*i*
    − 1。对于*n*个操作，操作的最坏情况成本是*O*(*n*)，这导致*n*个操作的总运行时间的上限为*O*(*n*²)。
- en: This bound is not tight, because the table rarely expands in the course of *n*
    TABLE-INSERT operations. Specifically, the *i*th operation causes an expansion
    only when *i* − 1 is an exact power of 2\. The amortized cost of an operation
    is in fact *O*(1), as an aggregate analysis shows. The cost of the *i*th operation
    is
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 这个界限并不严格，因为表在*n* TABLE-INSERT操作过程中很少扩展。具体来说，第*i*个操作仅在*i* − 1是2的精确幂时才会导致扩展。事实上，操作的摊销成本是*O*(1)，如聚合分析所示。第*i*个操作的成本是
- en: '![art](images/Art_P518.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P518.jpg)'
- en: The total cost of *n* TABLE-INSERT operations is therefore
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，*n*个TABLE-INSERT操作的总成本是
- en: '![art](images/Art_P519.jpg)'
  id: totrans-166
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P519.jpg)'
- en: because at most *n* operations cost 1 each and the costs of the remaining operations
    form a geometric series. Since the total cost of *n* TABLE-INSERT operations is
    bounded by 3*n*, the amortized cost of a single operation is at most 3.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因为最多*n*个操作每个成本为1，而其余操作的成本形成一个等比数列。由于*n*个TABLE-INSERT操作的总成本受到3*n*的限制，单个操作的摊销成本最多为3。
- en: '![art](images/Art_P520.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P520.jpg)'
- en: '**Figure 16.3** Analysis of table expansion by the accounting method. Each
    call of TABLE-INSERT charges $3 as follows: $1 to pay for the elementary insertion,
    $1 on the item inserted as prepayment for it to be reinserted later, and $1 on
    an item that was already in the table, also as prepayment for reinsertion. **(a)**
    The table immediately after an expansion, with 8 slots, 4 items (tan slots), and
    no stored credit. **(b)–(e)** After each of 4 calls to TABLE-INSERT, the table
    has one more item, with $1 stored on the new item and $1 stored on one of the
    4 items that were present immediately after the expansion. Slots with these new
    items are blue. **(f)** Upon the next call to TABLE-INSERT, the table is full,
    and so it expands again. Each item had $1 to pay for it to be reinserted. Now
    the table looks as it did in part (a), with no stored credit but 16 slots and
    8 items.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '**图16.3** 通过会计方法分析表扩展。每次调用TABLE-INSERT都会收取$3，具体如下：$1用于支付基本插入，$1用于插入的项目作为以后重新插入的预付款，$1用于已经在表中的项目，也作为重新插入的预付款。
    **(a)** 扩展后的表，有8个插槽，4个项目（棕色插槽），没有存储的信用。 **(b)–(e)** 每次调用TABLE-INSERT后，表中有一个额外的项目，新项目上存有$1，之前扩展后表中的4个项目之一上也存有$1。带有这些新项目的插槽是蓝色的。
    **(f)** 下一次调用TABLE-INSERT时，表已满，因此再次扩展。每个项目都有$1用于重新插入。现在表看起来像(a)部分一样，没有存储的信用，但有16个插槽和8个项目。'
- en: 'The accounting method can provide some intuition for why the amortized cost
    of a TABLE-INSERT operation should be 3\. You can think of each item paying for
    three elementary insertions: inserting itself into the current table, moving itself
    the next time that the table expands, and moving some other item that was already
    in the table the next time that the table expands. For example, suppose that the
    size of the table is *m* immediately after an expansion, as shown in [Figure 16.3](chapter016.xhtml#Fig_16-3)
    for *m* = 8\. Then the table holds *m*/2 items, and it contains no credit. Each
    call of TABLE-INSERT charges $3\. The elementary insertion that occurs immediately
    costs $1\. Another $1 resides on the item inserted as credit. The third $1 resides
    as credit on one of the *m*/2 items already in the table. The table will not fill
    again until another *m*/2 − 1 items have been inserted, and thus, by the time
    the table contains *m* items and is full, each item has $1 on it to pay for it
    to be reinserted it during the expansion.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 会计方法可以为为什么TABLE-INSERT操作的摊销成本应为3提供一些直觉。您可以将每个项目视为支付三次基本插入：将自身插入当前表中，下次表扩展时移动自身，下次表扩展时移动已经在表中的某个其他项目。例如，假设表在扩展后的大小为*m*，如*m*
    = 8所示。然后表中有*m*/2个项目，且不包含信用。每次TABLE-INSERT调用收取$3。立即发生的基本插入成本为$1。另外$1存储在作为信用插入的项目上。第三个$1存储在表中已有的*m*/2个项目之一上。直到再插入*m*/2
    − 1个项目后，表才会再次填满，因此，当表包含*m*个项目且已满时，每个项目都有$1用于在扩展期间重新插入。
- en: Now, let’s see how to use the potential method. We’ll use it again in [Section
    16.4.2](chapter016.xhtml#Sec_16.4.2) to design a TABLE-DELETE operation that has
    an *O*(1) amortized cost as well. Just as the accounting method had no stored
    credit immediately after an expansion—that is, when *T*.*num* = *T*.*size*/2—let’s
    define the potential to be 0 when *T*.*num* = *T*.*size*/2\. As elementary insertions
    occur, the potential needs to increase enough to pay for all the reinsertions
    that will happen when the table next expands. The table fills after another *T*.*size*/2
    calls of TABLE-INSERT, when *T*.*num* = *T*.*size*. The next call of TABLE-INSERT
    after these *T*.*size*/2 calls triggers an expansion with a cost of *T*.*size*
    to reinsert all the items. Therefore, over the course of *T*.*size*/2 calls of
    TABLE-INSERT, the potential must increase from 0 to *T*.*size*. To achieve this
    increase, let’s design the potential so that each call of TABLE-INSERT increases
    it by
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何使用潜力方法。我们将在[第16.4.2节](chapter016.xhtml#Sec_16.4.2)中再次使用它，设计一个具有*O*(1)摊销成本的TABLE-DELETE操作。就像会计方法在扩展后没有存储信用一样，即*T*.*num*
    = *T*.*size*/2时，让我们定义潜力为0当*T*.*num* = *T*.*size*/2。随着基本插入的发生，潜力需要增加足够的量来支付下次表扩展时将发生的所有重新插入。在另外*T*.*size*/2次调用TABLE-INSERT后，表填满，当*T*.*num*
    = *T*.*size*时。这*T*.*size*/2次调用TABLE-INSERT后的下一次调用触发了一个成本为*T*.*size*的扩展，以重新插入所有项目。因此，在*T*.*size*/2次调用TABLE-INSERT的过程中，潜力必须从0增加到*T*.*size*。为了实现这种增加，让我们设计潜力，使得每次TABLE-INSERT调用都增加
- en: '![art](images/Art_P521.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P521.jpg)'
- en: until the table expands. You can see that the potential function
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 直到表扩展。您可以看到潜力函数
- en: '![art](images/Art_P522.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P522.jpg)'
- en: equals 0 immediately after the table expands, when *T*.*num* = *T*.*size*/2,
    and it increases by 2 upon each insertion until the table fills. Once the table
    fills, that is, when *T*.*num* = *T*.*size*, the potential Φ(*T*) equals *T*.*size*.
    The initial value of the potential is 0, and since the table is always at least
    half full, *T*.*num* ≥ *T*.*size*/2, which implies that Φ(*T*) is always nonnegative.
    Thus, the sum of the amortized costs of *n* TABLE-INSERT operations gives an upper
    bound on the sum of the actual costs.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在表扩展后立即为0，当*T*.*num* = *T*.*size*/2时，每次插入后增加2，直到表填满。一旦表填满，即*T*.*num* = *T*.*size*时，潜力Φ(*T*)等于*T*.*size*。潜力的初始值为0，由于表始终至少半满，*T*.*num*
    ≥ *T*.*size*/2，这意味着Φ(*T*)始终为非负。因此，*n*次TABLE-INSERT操作的摊销成本之和给出了实际成本之和的上界。
- en: To analyze the amortized costs of table operations, it is convenient to think
    in terms of the change in potential due to each operation. Letting Φ*[i]* denote
    the potential after the *i*th operation, we can rewrite equation (16.2) as
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 要分析表操作的摊销成本，方便的方法是考虑每个操作引起的潜力变化。让Φ*[i]*表示第*i*次操作后的潜力，我们可以将方程(16.2)重写为
- en: '| *ĉ[i]* | = | *c[i]* + Φ*[i]* − Φ[*i*−1] |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| *ĉ[i]* | = | *c[i]* + Φ*[i]* − Φ[*i*−1] |'
- en: '|  | = | *c[i]* + ΔΦ*[i]*, |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *c[i]* + ΔΦ*[i]*, |'
- en: where ΔΦ*[i]* is the change in potential due to the *i*th operation. First,
    consider the case when the *i*th insertion does not cause the table to expand.
    In this case, ΔΦ*[i]* is 2\. Since the actual cost *c[i]* is 1, the amortized
    cost is
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 其中ΔΦ*[i]*是第*i*次操作导致的电位变化。首先，考虑第*i*次插入不会导致表扩展的情况。在这种情况下，ΔΦ*[i]*为2\. 由于实际成本*c[i]*为1，摊销成本为
- en: '| *ĉ[i]* | = | *c[i]* + ΔΦ*[i]* |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
  zh: '| *ĉ[i]* | = | *c[i]* + ΔΦ*[i]* |'
- en: '|  | = | 1 + 2 |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 1 + 2 |'
- en: '|  | = | 3. |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 3. |'
- en: Now, consider the change in potential when the table does expand during the
    *i*th insertion because it was full immediately before the insertion. Let *num[i]*
    denote the number of items stored in the table after the *i*th operation and *size[i]*
    denote the total size of the table after the *i*th operation, so that *size*[*i*−1]
    = *num*[*i*−1] = *i* − 1 and therefore Φ[*i*−1] = 2(*size*[*i*−1] − *size*[*i*−1]/2)
    = *size*[*i*−1] = *i* − 1\. Immediately after the expansion, the potential goes
    down to 0, and then the new item is inserted, causing the potential to increase
    to Φ*[i]* = 2\. Thus, when the *i*th insertion triggers an expansion, ΔΦ*[i]*
    = 2 − (*i* − 1) = 3 − *i*. When the table expands in the *i*th TABLE-INSERT operation,
    the actual cost *c[i]* equals *i* (to reinsert *i* − 1 items and insert the *i*th
    item), giving an amortized cost of
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑当表在第*i*次插入时扩展时的电位变化，因为在插入之前它是满的。让*num[i]*表示第*i*次操作后表中存储的项目数，*size[i]*表示第*i*次操作后表的总大小，以便*size*[*i*−1]
    = *num*[*i*−1] = *i* − 1，因此Φ[*i*−1] = 2(*size*[*i*−1] − *size*[*i*−1]/2) = *size*[*i*−1]
    = *i* − 1\. 扩展后，电位下降到0，然后插入新项目，导致电位增加到Φ*[i]* = 2\. 因此，当第*i*次插入触发扩展时，ΔΦ*[i]* =
    2 − (*i* − 1) = 3 − *i*。当表在第*i*次TABLE-INSERT操作中扩展时，实际成本*c[i]*等于*i*（重新插入*i* − 1个项目并插入第*i*个项目），给出摊销成本为
- en: '| *ĉ[i]* | = | *c[i]* + ΔΦ*[i]* |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
  zh: '| *ĉ[i]* | = | *c[i]* + ΔΦ*[i]* |'
- en: '|  | = | *i* + (3 − *i*) |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *i* + (3 − *i*) |'
- en: '|  | = | 3. |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 3. |'
- en: '[Figure 16.4](chapter016.xhtml#Fig_16-4) plots the values of *num[i]*, *size[i]*,
    and Φ*[i]* against *i*. Notice how the potential builds to pay for expanding the
    table.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '[图16.4](chapter016.xhtml#Fig_16-4)绘制了*num[i]*、*size[i]*和Φ*[i]*随*i*的值的变化。注意电位如何积累以支付扩展表的成本。'
- en: '![art](images/Art_P523.jpg)'
  id: totrans-188
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P523.jpg)'
- en: '**Figure 16.4** The effect of a sequence of *n* TABLE-INSERT operations on
    the number *num[i]* of items in the table (the brown line), the number *size[i]*
    of slots in the table (the blue line), and the potential Φ*[i]* = 2(*num[i]* −
    *size[i]*/2) (the red line), each being measured after the *i*th operation. Immediately
    before an expansion, the potential has built up to the number of items in the
    table, and therefore it can pay for moving all the items to the new table. Afterward,
    the potential drops to 0, but it immediately increases by 2 upon insertion of
    the item that caused the expansion.'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '**图16.4** 一系列*n*个TABLE-INSERT操作对表中项目数*num[i]*（棕色线）、表中插槽数*size[i]*（蓝色线）和电位Φ*[i]*
    = 2(*num[i]* − *size[i]*/2)（红色线）的影响，每次操作后进行测量。在扩展之前，电位已经积累到表中的项目数，因此可以支付将所有项目移动到新表的成本。之后，电位降至0，但在导致扩展的项目插入后立即增加2。'
- en: '**16.4.2    Table expansion and contraction**'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: '**16.4.2    表扩展和收缩**'
- en: 'To implement a TABLE-DELETE operation, it is simple enough to remove the specified
    item from the table. In order to limit the amount of wasted space, however, you
    might want to ***contract*** the table when the load factor becomes too small.
    Table contraction is analogous to table expansion: when the number of items in
    the table drops too low, allocate a new, smaller table and then copy the items
    from the old table into the new one. You can then free the storage for the old
    table by returning it to the memory-management system. In order to not waste space,
    yet keep the amortized costs low, the insertion and deletion procedures should
    preserve two properties:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现TABLE-DELETE操作，只需从表中删除指定项目即可。然而，为了限制浪费空间的量，当负载因子变得太小时，您可能希望在缩小表时***收缩***表。表的收缩类似于表的扩展：当表中的项目数量下降得太低时，分配一个新的、更小的表，然后将项目从旧表复制到新表中。然后可以通过将旧表的存储返回给内存管理系统来释放旧表的存储空间。为了不浪费空间，同时保持摊销成本低，插入和删除过程应该保持两个属性：
- en: the load factor of the dynamic table is bounded below by a positive constant,
    as well as above by 1, and
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动态表的负载因子下界为正常数，上界为1，以及
- en: the amortized cost of a table operation is bounded above by a constant.
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表操作的摊销成本被一个常数上界限制。
- en: The actual cost of each operation equals the number of elementary insertions
    or deletions.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 每个操作的实际成本等于基本插入或删除的数量。
- en: 'You might think that if you double the table size upon inserting an item into
    a full table, then you should halve the size when deleting an item that would
    cause the table to become less than half full. This strategy does indeed guarantee
    that the load factor of the table never drops below 1/2\. Unfortunately, it can
    also cause the amortized cost of an operation to be quite large. Consider the
    following scenario. Perform *n* operations on a table *T* of size *n*/2, where
    *n* is an exact power of 2\. The first *n*/2 operations are insertions, which
    by our previous analysis cost a total of Θ(*n*). At the end of this sequence of
    insertions, *T*.*num* = *T*.*size* = *n*/2\. For the second *n*/2 operations,
    perform the following sequence:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为，如果在向满表插入项目时将表大小加倍，那么当删除导致表变得不到一半满时，应该将大小减半。这种策略确实保证了表的负载因子永远不会低于1/2\.
    不幸的是，这也可能导致操作的摊销成本非常高。考虑以下情况。在大小为*n*/2的表*T*上执行*n*次操作，其中*n*是2的幂。前*n*/2次操作是插入，根据我们之前的分析，总成本为Θ(*n*)。在这些插入操作序列结束时，*T*.*num*
    = *T*.*size* = *n*/2\. 对于后续的*n*/2次操作，执行以下序列：
- en: insert, delete, delete, insert, insert, delete, delete, insert, insert, ….
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 插入，删除，删除，插入，插入，删除，删除，插入，插入，…。
- en: The first insertion causes the table to expand to size *n*. The two deletions
    that follow cause the table to contract back to size *n*/2\. Two further insertions
    cause another expansion, and so forth. The cost of each expansion and contraction
    is Θ(*n*), and there are Θ(*n*) of them. Thus, the total cost of the *n* operations
    is Θ(*n*²), making the amortized cost of an operation Θ(*n*).
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次插入导致表扩展到大小*n*。随后的两次删除导致表收缩回大小*n*/2。再进行两次插入会导致另一次扩展，依此类推。每次扩展和收缩的成本为Θ(*n*)，共有Θ(*n*)次。因此，*n*次操作的总成本为Θ(*n*²)，使得操作的摊销成本为Θ(*n*)。
- en: The problem with this strategy is that after the table expands, not enough deletions
    occur to pay for a contraction. Likewise, after the table contracts, not enough
    insertions take place to pay for an expansion.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这种策略的问题在于，表扩展后，没有足够的删除操作来支付收缩。同样，在表收缩后，没有足够的插入操作来支付扩展。
- en: How can we solve this problem? Allow the load factor of the table to drop below
    1/2\. Specifically, continue to double the table size upon inserting an item into
    a full table, but halve the table size when deleting an item causes the table
    to become less than 1/4 full, rather than 1/2 full as before. The load factor
    of the table is therefore bounded below by the constant 1/4, and the load factor
    is 1/2 immediately after a contraction.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何解决这个问题？允许表的负载因子降至1/2以下。具体来说，继续在将项目插入满表时将表大小加倍，但是当删除项目导致表变得不到1/4满时，将表大小减半，而不是之前的1/2满。因此，表的负载因子在常数1/4以下，且在收缩后立即为1/2。
- en: An expansion or contraction should exhaust all the built-up potential, so that
    immediately after expansion or contraction, when the load factor is 1/2, the table’s
    potential is 0\. [Figure 16.5](chapter016.xhtml#Fig_16-5) shows the idea. As the
    load factor deviates from 1/2, the potential increases so that by the time an
    expansion or contraction occurs, the table has garnered sufficient potential to
    pay for copying all the items into the newly allocated table. Thus, the potential
    function should grow to *T*.*num* by the time that the load factor has either
    increased to 1 or decreased to 1/4\. Immediately after either expanding or contracting
    the table, the load factor goes back to 1/2 and the table’s potential reduces
    back to 0.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展或收缩应该耗尽所有已积累的潜在函数，因此在扩展或收缩后立即，当负载因子为1/2时，表的潜在函数为0。[图16.5](chapter016.xhtml#Fig_16-5)展示了这个想法。当负载因子偏离1/2时，潜在函数增加，以便在扩展或收缩发生时，表已经积累了足够的潜在函数来支付将所有项目复制到新分配的表中的成本。因此，潜在函数应该在负载因子增加到1或降至1/4时增长到*T*.*num*。在扩展或收缩表后，负载因子立即恢复为1/2，表的潜在函数也立即减少为0。
- en: '![art](images/Art_P524.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P524.jpg)'
- en: '**Figure 16.5** How to think about the potential function Φ for table insertion
    and deletion. When the load factor *α* is 1/2, the potential is 0\. In order to
    accumulate sufficient potential to pay for reinserting all *T*.*size* items when
    the table fills, the potential needs to increase by 2 upon each insertion when
    *α* ≥ 1/2\. Correspondingly, the potential decreases by 2 upon each deletion that
    leaves *α* ≥ 1/2\. In order to accrue enough potential to cover the cost of reinserting
    all *T*.*size*/4 items when the table contracts, the potential needs to increase
    by 1 upon each deletion when *α* < 1/2, and correspondingly the potential decreases
    by 1 upon each insertion that leaves *α* < 1/2\. The red area represents load
    factors less than 1/4, which are not allowed.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**图16.5** 如何思考关于表插入和删除的潜在函数Φ。当负载因子*α*为1/2时，潜在函数为0。为了在表填满时积累足够的潜在函数来支付重新插入所有*T*.*size*项的成本，当*α*
    ≥ 1/2时，每次插入时潜在函数需要增加2。相应地，当*α* ≥ 1/2时，每次删除使潜在函数减少2。为了积累足够的潜在函数来支付表收缩时重新插入所有*T*.*size*/4项的成本，当*α*
    < 1/2时，每次删除时潜在函数需要增加1，相应地，当*α* < 1/2时，每次插入使潜在函数减少1。红色区域代表负载因子小于1/4，这是不允许的。'
- en: We omit the code for TABLE-DELETE, since it is analogous to TABLE-INSERT. We
    assume that if a contraction occurs during TABLE-DELETE, it occurs after the item
    is deleted from the table. The analysis assumes that whenever the number of items
    in the table drops to 0, the table occupies no storage. That is, if *T*.*num*
    = 0, then *T*.*size* = 0.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 我们省略了TABLE-DELETE的代码，因为它类似于TABLE-INSERT。我们假设如果在TABLE-DELETE期间发生收缩，那么它发生在从表中删除项目之后。分析假设，每当表中的项目数量降至0时，表不占用存储空间。也就是说，如果*T*.*num*
    = 0，则*T*.*size* = 0。
- en: How do we design a potential function that gives constant amortized time for
    both insertion and deletion? When the load factor is at least 1/2, the same potential
    function, Φ(*T*) = 2(*T*.*num* − *T*.*size*/2), that we used for insertion still
    works. When the table is at least half full, each insertion increases the potential
    by 2 if the table does not expand, and each deletion reduces the potential by
    2 if it does not cause the load factor to drop below 1/2.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何设计一个潜在函数，使得插入和删除的摊销时间都是常数？当负载因子至少为1/2时，与插入时使用的相同潜在函数Φ(*T*) = 2(*T*.*num*
    − *T*.*size*/2)仍然有效。当表至少半满时，如果表不扩展，每次插入都会使潜在函数增加2，如果不导致负载因子降至1/2以下，每次删除都会使潜在函数减少2。
- en: What about when the load factor is less than 1/2, that is, when 1/4 ≤ *α*(*T*)
    < 1/2? As before, when *α*(*T*) = 1/2, so that *T*.*num* = *T*.*size*/2, the potential
    Φ(*T*) should be 0\. To get the load factor from 1/2 down to 1/4, *T*.*size*/4
    deletions need to occur, at which time *T*.*num* = *T*.*size*/4\. To pay for all
    the reinsertions, the potential must increase from 0 to *T*.*size*/4 over these
    *T*.*size*/4 deletions. Therefore, for each call of TABLE-DELETE until the table
    contracts, the potential should increase by
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '当负载因子小于1/2时，即当1/4 ≤ *α*(*T*) < 1/2时，情况如何？与之前一样，当*α*(*T*) = 1/2时，即*T*.*num*
    = *T*.*size*/2，潜在函数Φ(*T*)应为0。要将负载因子从1/2降至1/4，需要进行*T*.*size*/4次删除，此时*T*.*num* =
    *T*.*size*/4。为了支付所有重新插入的成本，潜在函数必须在这*T*.*size*/4次删除中从0增加到*T*.*size*/4。因此，对于每次TABLE-DELETE的调用，直到表收缩，潜在函数应该增加。 '
- en: '![art](images/Art_P525.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P525.jpg)'
- en: Likewise, when *α* < 1/2, each call of TABLE-INSERT should decrease the potential
    by 1\. When 1/4 ≤ *α*(*T*) < 1/2, the potential function
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，当*α* < 1/2时，每次TABLE-INSERT调用应该将电位减少1。当1/4 ≤ *α*(*T*) < 1/2时，电位函数
- en: Φ(*T*) = *T*.*size*/2 − *T*.*num*
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: Φ(*T*) = *T*.*size*/2 − *T*.*num*
- en: produces this desired behavior.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 产生了这种期望的行为。
- en: Putting the two cases together, we get the potential function
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 将这两种情况结合起来，我们得到电位函数
- en: '![art](images/Art_P526.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P526.jpg)'
- en: The potential of an empty table is 0 and the potential is never negative. Thus,
    the total amortized cost of a sequence of operations with respect to Φ provides
    an upper bound on the actual cost of the sequence. [Figure 16.6](chapter016.xhtml#Fig_16-6)
    illustrates how the potential function behaves over a sequence of insertions and
    deletions.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一个空表的电位为0，且电位永远不会为负。因此，关于Φ的一系列操作的总摊销成本提供了该序列的实际成本的上限。[图16.6](chapter016.xhtml#Fig_16-6)展示了电位函数在一系列插入和删除操作中的行为。
- en: Now, let’s determine the amortized costs of each operation. As before, let *num[i]*
    denote the number of items stored in the table after the *i*th operation, *size[i]*
    denote the total size of the table after the *i*th operation, *α[i]* = *num[i]*/*size[i]*
    denote the load factor after the *i*th operation, Φ*[i]* denote the potential
    after the *i*th operation, and ΔΦ*[i]* denote the change in potential due to the
    *i*th operation. Initially, *num*[0] = 0, *size*[0] = 0, and Φ[0] = 0.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们确定每个操作的摊销成本。与之前一样，让*num[i]*表示第*i*个操作后表中存储的项目数，*size[i]*表示第*i*个操作后表的总大小，*α[i]*
    = *num[i]*/*size[i]*表示第*i*个操作后的负载因子，Φ*[i]*表示第*i*个操作后的电位，ΔΦ*[i]*表示第*i*个操作引起的电位变化。最初，*num*[0]
    = 0，*size*[0] = 0，Φ[0] = 0。
- en: The cases in which the table does not expand or contract and the load factor
    does not cross *α* = 1/2 are straightforward. As we have seen, if *α*[*i*−1] ≥
    1/2 and the *i*th operation is an insertion that does not cause the table to expand,
    then ΔΦ*[i]* = 2\. Likewise, if the *i*th operation is a deletion and *α[i]* ≥
    1/2, then ΔΦ*[i]* = −2\. Furthermore, if *α*[*i*−1] < 1/2 and the *i*th operation
    is a deletion that does not trigger a contraction, then ΔΦ*[i]* = 1, and if the
    *i*th operation is an insertion and *α[i]* < 1/2, then ΔΦ*[i]* = −1\. In other
    words, if no expansion or contraction occurs and the load factor does not cross
    *α* = 1/2, then
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 表不扩展或收缩且负载因子不越过*α* = 1/2的情况很简单。正如我们所见，如果*α*[*i*−1] ≥ 1/2且第*i*个操作是不导致表扩展的插入，则ΔΦ*[i]*
    = 2。同样，如果第*i*个操作是删除且*α[i]* ≥ 1/2，则ΔΦ*[i]* = −2。此外，如果*α*[*i*−1] < 1/2且第*i*个操作是不触发收缩的删除，则ΔΦ*[i]*
    = 1，如果第*i*个操作是插入且*α[i]* < 1/2，则ΔΦ*[i]* = −1。换句话说，如果没有扩展或收缩发生且负载因子不越过*α* = 1/2，则
- en: if the load factor stays at or above 1/2, then the potential increases by 2
    for an insertion and decreases by 2 for a deletion, and
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果负载因子保持在或高于1/2，那么插入时电位增加2，删除时减少2，且
- en: if the load factor stays below 1/2, then the potential increases by 1 for a
    deletion and decreases by 1 for an insertion.
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果负载因子低于1/2，则删除时电位增加1，插入时减少1。
- en: In each of these cases, the actual cost *c[i]* of the *i*th operation is just
    1, and so
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，第*i*个操作的实际成本*c[i]*只是1，因此
- en: '![art](images/Art_P527.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P527.jpg)'
- en: '**Figure 16.6** The effect of a sequence of *n* TABLE-INSERT and TABLE-DELETE
    operations on the number *num[i]* of items in the table (the brown line), the
    number *size[i]* of slots in the table (the blue line), and the potential (the
    red line)'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**图16.6** 一系列*n*个TABLE-INSERT和TABLE-DELETE操作对表中项目数*num[i]*（棕色线）、表中槽位数*size[i]*（蓝色线）和电位（红色线）的影响'
- en: '![art](images/Art_P528.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P528.jpg)'
- en: where *α[i]* = *num[i]*/*size[i]*, each measured after the *i*th operation.
    Immediately before an expansion or contraction, the potential has built up to
    the number of items in the table, and therefore it can pay for moving all the
    items to the new table.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*α[i]* = *num[i]*/*size[i]*，每次在第*i*个操作后测量。在扩展或收缩之前，电位已经积累到表中的项目数，因此可以支付将所有项目移动到新表的费用。
- en: if the *i*th operation is an insertion, its amortized cost *ĉ[i]* is *c[i]*
    + ΔΦ*[i]*, which is 1 + 2 = 3 if the load factor stays at or above 1/2, and 1
    + (−1) = 0 if the load factor stays below 1/2, and
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第*i*个操作是插入，其摊销成本*ĉ[i]*为*c[i]* + ΔΦ*[i]*，如果负载因子保持在或高于1/2，则为1 + 2 = 3，如果负载因子低于1/2，则为1
    + (−1) = 0，且
- en: if the *i*th operation is a deletion, its amortized cost *ĉ[i]* is *c[i]* +
    ΔΦ*[i]*, which is 1 + (−2) = −1 if the load factor stays at or above 1/2, and
    1 + 1 = 2 if the load factor stays below 1/2.
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果第*i*个操作是删除，其摊销成本*ĉ[i]*为*c[i]* + ΔΦ*[i]*，如果负载因子保持在或高于1/2，则为1 + (−2) = −1，如果负载因子低于1/2，则为1
    + 1 = 2。
- en: 'Four cases remain: an insertion that takes the load factor from below 1/2 to
    1/2, a deletion that takes the load factor from 1/2 to below 1/2, a deletion that
    causes the table to contract, and an insertion that causes the table to expand.
    We analyzed that last case at the end of [Section 16.4.1](chapter016.xhtml#Sec_16.4.1)
    to show that its amortized cost is 3.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 还剩下四种情况：将负载因子从低于1/2提升到1/2的插入，将负载因子从1/2降低到低于1/2的删除，导致表收缩的删除，导致表扩展的插入。我们在[第16.4.1节](chapter016.xhtml#Sec_16.4.1)末尾分析了最后一种情况，以展示其摊销成本为3。
- en: When the *i*th operation is a deletion that causes the table to contract, we
    have *num*[*i*−1] = *size*[*i*−1]/4 before the contraction, then the item is deleted,
    and finally *num[i]* = *size[i]*/2 − 1 after the contraction. Thus, by equation
    (16.5) we have
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当第*i*个操作是导致表收缩的删除时，我们有在收缩之前*num*[*i*−1] = *size*[*i*−1]/4，然后删除项目，最后*num[i]*
    = *size[i]*/2 − 1。因此，根据方程(16.5)，我们有
- en: '| Φ[*i*−1] | = | *size*[*i*−1]/2 − *num*[*i*−1] |'
  id: totrans-226
  prefs: []
  type: TYPE_TB
  zh: '| Φ[*i*−1] | = | *size*[*i*−1]/2 − *num*[*i*−1] |'
- en: '|  | = | *size*[*i*−1]/2 − *size*[*i*−1]/4 |'
  id: totrans-227
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *size*[*i*−1]/2 − *size*[*i*−1]/4 |'
- en: '|  | = | *size*[*i*−1]/4, |'
  id: totrans-228
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *size*[*i*−1]/4, |'
- en: which also equals the actual cost *c[i]* of deleting one item and copying *size*[*i*−1]/4
    − 1 items into the new, smaller table. Since *num[i]* = *size[i]*/2 − 1 after
    the operation has completed, *α[i]* < 1/2, and so
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这也等于删除一个项目和将*size*[*i*−1]/4 − 1个项目复制到新的、更小的表的实际成本*c[i]*。由于操作完成后*num[i]* = *size[i]*/2
    − 1，*α[i]* < 1/2，所以
- en: '| Φ*[i]* | = | *size[i]*/2 − *num[i]* |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
  zh: '| Φ*[i]* | = | *size[i]*/2 − *num[i]* |'
- en: '|  | = | 1, |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 1, |'
- en: giving ΔΦ*[i]* = 1 − *size*[*i*−1]/4\. Therefore, when the *i*th operation is
    a deletion that triggers a contraction, its amortized cost is
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 得到ΔΦ*[i]* = 1 − *size*[*i*−1]/4。因此，当第*i*个操作是触发收缩的删除操作时，其摊销成本为
- en: '| *ĉ[i]* | = | *c[i]* + ΔΦ[*i*] |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| *ĉ[i]* | = | *c[i]* + ΔΦ[*i*] |'
- en: '|  | = | *size*[*i*−1]/4 + (1 − *size*[*i*−1]/4) |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *size*[*i*−1]/4 + (1 − *size*[*i*−1]/4) |'
- en: '|  | = | 1. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '|  | = | 1. |'
- en: Finally, we handle the cases where the load factor fits one case of equation
    (16.5) before the operation and the other case afterward. We start with deletion,
    where we have *num*[*i*−1] = *size*[*i*−1]/2, so that *α*[*i*−1] = 1/2, beforehand,
    and *num[i]* = *size[i]*/2−1, so that *α[i]* < 1/2 afterward. Because *α*[*i*−1]
    = 1/2, we have Φ[*i*−1] = 0, and because *α[i]* < 1/2, we have Φ*[i]* = *size[i]*/2
    − *num[i]* = 1\. Thus we get that ΔΦ*[i]* = 1 − 0 = 1\. Since the *i*th operation
    is a deletion that does not cause a contraction, the actual cost *c[i]* equals
    1, and the amortized cost *ĉ[i]* is *c[i]* + ΔΦ*[i]* = 1 + 1 = 2.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们处理负载因子在操作前符合方程(16.5)的一个情况，操作后符合另一个情况的情况。我们从删除开始，其中我们有*num*[*i*−1] = *size*[*i*−1]/2，因此*α*[*i*−1]
    = 1/2，在操作之前，以及*num[i]* = *size[i]*/2−1，在操作之后，因此*α[i]* < 1/2。因为*α*[*i*−1] = 1/2，我们有Φ[*i*−1]
    = 0，因为*α[i]* < 1/2，我们有Φ*[i]* = *size[i]*/2 − *num[i]* = 1。因此，我们得到ΔΦ*[i]* = 1 −
    0 = 1。由于第*i*个操作是一个不会导致收缩的删除操作，实际成本*c[i]*等于1，摊销成本*ĉ[i]*为*c[i]* + ΔΦ*[i]* = 1 +
    1 = 2。
- en: Conversely, if the *i*th operation is an insertion that takes the load factor
    from below 1/2 to equaling 1/2, the change in potential ΔΦ*[i]* equals −1\. Again,
    the actual cost *c[i]* is 1, and now the amortized cost *ĉ[i]* is *c[i]* + ΔΦ*[i]*
    = 1 + (−1) = 0.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，如果第*i*个操作是一个插入操作，将负载因子从低于1/2提高到等于1/2，潜能的变化ΔΦ*[i]*等于−1。同样，实际成本*c[i]*为1，现在摊销成本*ĉ[i]*为*c[i]*
    + ΔΦ*[i]* = 1 + (−1) = 0。
- en: In summary, since the amortized cost of each operation is bounded above by a
    constant, the actual time for any sequence of *n* operations on a dynamic table
    is *O*(*n*).
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，由于每个操作的摊销成本都被一个常数上界限制，对于动态表上的任何*n*个操作序列，实际时间为*O*(*n*)。
- en: '**Exercises**'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***16.4-1***'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.4-1***'
- en: Using the potential method, analyze the amortized cost of the first table insertion.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 使用潜能方法，分析第一个表插入的摊销成本。
- en: '***16.4-2***'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.4-2***'
- en: You wish to implement a dynamic, open-address hash table. Why might you consider
    the table to be full when its load factor reaches some value *α* that is strictly
    less than 1? Describe briefly how to make insertion into a dynamic, open-address
    hash table run in such a way that the expected value of the amortized cost per
    insertion is *O*(1). Why is the expected value of the actual cost per insertion
    not necessarily *O*(1) for all insertions?
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 你希望实现一个动态的开地址哈希表。为什么当负载因子达到严格小于1的某个值*α*时，你会认为表已满？简要描述如何使得动态的开地址哈希表的插入以*O*(1)的摊销成本运行。为什么实际插入的摊销成本并不一定对于所有插入都是*O*(1)？
- en: '***16.4-3***'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.4-3***'
- en: Discuss how to use the accounting method to analyze both the insertion and deletion
    operations, assuming that the table doubles in size when its load factor exceeds
    1 and the table halves in size when its load factor goes below 1/4.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论如何使用会计方法分析插入和删除操作，假设当负载因子超过1时表的大小加倍，当负载因子低于1/4时表的大小减半。
- en: '***16.4-4***'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '***16.4-4***'
- en: Suppose that instead of contracting a table by halving its size when its load
    factor drops below 1/4, you contract the table by multiplying its size by 2/3
    when its load factor drops below 1/3\. Using the potential function
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 假设当负载因子低于1/4时，你不是通过将表的大小减半来收缩表，而是在负载因子低于1/3时通过将表的大小乘以2/3来收缩表。使用潜能函数
- en: Φ(*T*) = |2(*T*.*num* − *T*.*size*/2)|,
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: Φ(*T*) = |2(*T*.*num* − *T*.*size*/2)|,
- en: show that the amortized cost of a TABLE-DELETE that uses this strategy is bounded
    above by a constant.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 表明使用这种策略的TABLE-DELETE的摊销成本被一个常数上界限制。
- en: '**Problems**'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '***16-1     Binary reflected Gray code***'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '***16-1     二进制反射格雷码***'
- en: 'A ***binary Gray code*** represents a sequence of nonnegative integers in binary
    such that to go from one integer to the next, exactly one bit flips every time.
    The ***binary reflected Gray code*** represents a sequence of the integers 0 to
    2*^k* − 1 for some positive integer *k* according to the following recursive method:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 一个***二进制格雷码***表示了一个非负整数序列，其中每次从一个整数到下一个整数，都会有一位二进制位翻转。***二进制反射格雷码***根据以下递归方法表示了一些正整数0到2*^k*
    − 1，其中*k*是某个正整数：
- en: For *k* = 1, the binary reflected Gray code is 〈0, 1〉.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于*k* = 1，二进制反射格雷码是〈0, 1〉。
- en: For *k* ≥ 2, first form the binary reflected Gray code for *k* − 1, giving the
    2^(*k*−1) integers 0 to 2^(*k*−1) − 1\. Then form the reflection of this sequence,
    which is just the sequence in reverse. (That is, the *j* th integer in the sequence
    becomes the (2^(*k*−1) − *j* − 1)st integer in the reflection). Next, add 2^(*k*−1)
    to each of the 2^(*k*−1) integers in the reflected sequence. Finally, concatenate
    the two sequences.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于*k* ≥ 2，首先形成*k* − 1的二进制反射格雷码，给出0到2^(*k*−1) − 1的整数。然后形成这个序列的反射，即反转序列。（也就是说，序列中的第*j*个整数变为反射中的(2^(*k*−1)
    − *j* − 1)个整数）。接下来，将反射序列中的每个2^(*k*−1)个整数加上2^(*k*−1)。最后，连接这两个序列。
- en: For example, for *k* = 2, first form the binary reflected Gray code 〈0, 1〉 for
    *k* = 1\. Its reflection is the sequence 〈1, 0〉. Adding 2^(*k*−1) = 2 to each
    integer in the reflection gives the sequence 〈3, 2〉. Concatenating the two sequences
    gives 〈0, 1, 3, 2〉 or, in binary, 〈00, 01, 11, 10〉, so that each integer differs
    from its predecessor by exactly one bit. For *k* = 3, the reflection of the binary
    reflected Gray code for *k* = 2 is 〈2, 3, 1, 0〉 and adding 2^(*k*−1) = 4 gives
    〈6, 7, 5, 4〉. Concatenating produces the sequence 〈0, 1, 3, 2, 6, 7, 5, 4〉, which
    in binary is 〈000, 001, 011, 010, 110, 111, 101,100〉. In the binary reflected
    Gray code, only one bit flips even when wrapping around from the last integer
    to the first.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，对于*k* = 2，首先形成*k* = 1的二进制反射格雷码〈0, 1〉。它的反射是序列〈1, 0〉。将2^(*k*−1) = 2添加到反射中的每个整数，得到序列〈3,
    2〉。连接这两个序列得到〈0, 1, 3, 2〉或者用二进制表示为〈00, 01, 11, 10〉，因此每个整数与其前一个整数只有一位不同。对于*k* =
    3，*k* = 2的二进制反射格雷码的反射是〈2, 3, 1, 0〉，添加2^(*k*−1) = 4得到〈6, 7, 5, 4〉。连接产生序列〈0, 1,
    3, 2, 6, 7, 5, 4〉，用二进制表示为〈000, 001, 011, 010, 110, 111, 101,100〉。在二进制反射格雷码中，即使从最后一个整数到第一个整数时，只有一位翻转。
- en: '***a.*** Index the integers in a binary reflected Gray code from 0 to 2^(*k*)
    − 1, and consider the *i*th integer in the binary reflected Gray code. To go from
    the (*i* −1)st integer to the *i*th integer in the binary reflected Gray code,
    exactly one bit flips. Show how to determine which bit flips, given the index
    *i*.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 从0到2^(*k*) − 1的二进制反射格雷码中索引整数，并考虑二进制反射格雷码中的第*i*个整数。要从第(*i* −1)个整数转到二进制反射格雷码中的第*i*个整数，恰好有一个位翻转。展示如何确定哪个位翻转，给定索引*i*。'
- en: '***b.*** Assuming that given a bit number *j*, you can flip bit *j* of an integer
    in constant time, show how to compute the entire binary reflected Gray code sequence
    of 2^(*k*) numbers in Θ(2^(*k*)) time.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 假设给定位号*j*，您可以在常数时间内翻转整数的第*j*位，展示如何在Θ(2^(*k*))时间内计算2^(*k*)个数字的整个二进制反射格雷码序列。'
- en: '***16-2     Making binary search dynamic***'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '***16-2     使二分搜索动态化***'
- en: Binary search of a sorted array takes logarithmic search time, but the time
    to insert a new element is linear in the size of the array. You can improve the
    time for insertion by keeping several sorted arrays.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 对排序数组进行二分搜索需要对数搜索时间，但插入新元素的时间与数组大小成线性关系。您可以通过保持多个排序数组来改进插入时间。
- en: Specifically, suppose that you wish to support SEARCH and INSERT on a set of
    *n* elements. Let *k* = ⌈lg(*n* + 1)⌉, and let the binary representation of *n*
    be 〈*n*[*k*−1], *n*[*k*−2], … , *n*[0]〉. Maintain *k* sorted arrays *A*[0], *A*[1],
    … , *A*[*k*−1], where for *i* = 0, 1, … , *k* − 1, the length of array *A[i]*
    is 2^(*i*). Each array is either full or empty, depending on whether *n[i]* =
    1 or *n[i]* = 0, respectively. The total number of elements held in all *k* arrays
    is therefore ![art](images/Art_P529.jpg). Although each individual array is sorted,
    elements in different arrays bear no particular relationship to each other.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，假设您希望在一组*n*个元素上支持SEARCH和INSERT。让*k* = ⌈lg(*n* + 1)⌉，并且让*n*的二进制表示为〈*n*[*k*−1],
    *n*[*k*−2], … , *n*[0]〉。维护*k*个排序数组*A*[0]，*A*[1]，…，*A*[*k*−1]，其中对于*i* = 0, 1, …，*k*
    − 1，数组*A[i]*的长度为2^(*i*)。每个数组都是满的或空的，具体取决于*n[i]* = 1或*n[i]* = 0。所有*k*个数组中保存的元素的总数因此为![art](images/Art_P529.jpg)。尽管每个单独的数组都是排序的，但不同数组中的元素之间没有特定的关系。
- en: '***a.*** Describe how to perform the SEARCH operation for this data structure.
    Analyze its worst-case running time.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 描述如何为这种数据结构执行SEARCH操作。分析其最坏情况运行时间。'
- en: '***b.*** Describe how to perform the INSERT operation. Analyze its worst-case
    and amortized running times, assuming that the only operations are INSERT and
    SEARCH.'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 描述如何执行INSERT操作。分析其最坏情况和摊销运行时间，假设唯一的操作是INSERT和SEARCH。'
- en: '***c.*** Describe how to implement DELETE. Analyze its worst-case and amortized
    running times, assuming that there can be DELETE, INSERT, and SEARCH operations.'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 描述如何实现DELETE。分析其最坏情况和摊销运行时间，假设可以进行DELETE、INSERT和SEARCH操作。'
- en: '***16-3     Amortized weight-balanced trees***'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '***16-3     摊销权重平衡树***'
- en: Consider an ordinary binary search tree augmented by adding to each node *x*
    the attribute *x*.*size*, which gives the number of keys stored in the subtree
    rooted at *x*. Let *α* be a constant in the range 1/2 ≤ *α* < 1\. We say that
    a given node *x* is ***α-balanced*** if *x*.*left*.*size* ≤ *α* · *x*.*size* and
    *x*.*right*.*size* ≤ *α* · *x*.*size*. The tree as a whole is ***α-balanced***
    if every node in the tree is *α*-balanced. The following amortized approach to
    maintaining weight-balanced trees was suggested by G. Varghese.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个普通的二叉搜索树，通过为每个节点*x*添加属性*x*.*size*来增强，该属性给出以*x*为根的子树中存储的键的数量。让*α*是一个常数，范围为1/2
    ≤ *α* < 1。我们说给定节点*x*是***α-平衡***的，如果*x*.*left*.*size* ≤ *α* · *x*.*size*和*x*.*right*.*size*
    ≤ *α* · *x*.*size*。整棵树如果每个节点都是*α*-平衡，则为***α-平衡***。G. Varghese建议的维护权重平衡树的摊销方法如下。
- en: '***a.*** A 1/2-balanced tree is, in a sense, as balanced as it can be. Given
    a node *x* in an arbitrary binary search tree, show how to rebuild the subtree
    rooted at *x* so that it becomes 1/2-balanced. Your algorithm should run in Θ(*x*.*size*)
    time, and it can use *O*(*x*.*size*) auxiliary storage.'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 1/2-平衡树在某种意义上是尽可能平衡的。给定任意二叉搜索树中的节点*x*，展示如何重建以*x*为根的子树，使其变为1/2-平衡。您的算法应在Θ(*x*.*size*)时间内运行，并且可以使用*O*(*x*.*size*)辅助存储。'
- en: '***b.*** Show that performing a search in an *n*-node *α*-balanced binary search
    tree takes *O*(lg *n*) worst-case time.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 显示在一个*n*节点的*α*-平衡二叉搜索树中执行搜索需要*O*(lg *n*)最坏情况时间。'
- en: For the remainder of this problem, assume that the constant *α* is strictly
    greater than 1/2\. Suppose that you implement INSERT and DELETE as usual for an
    *n*-node binary search tree, except that after every such operation, if any node
    in the tree is no longer *α*-balanced, then you “rebuild” the subtree rooted at
    the highest such node in the tree so that it becomes 1/2-balanced.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本问题的其余部分中，假设常数*α*严格大于1/2。假设您按照通常的方式为一个*n*节点的二叉搜索树实现INSERT和DELETE，只是在每次操作之后，如果树中的任何节点不再是*α*-平衡，则“重建”树中以最高节点为根的子树，使其变为1/2-平衡。
- en: We’ll analyze this rebuilding scheme using the potential method. For a node
    *x* in a binary search tree *T*, define
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用潜力方法分析这个重建方案。对于二叉搜索树*T*中的节点*x*，定义
- en: Δ(*x*) = |*x*.*left*.*size* − *x*.*right*.*size*|.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: Δ(*x*) = |*x*.*left*.*size* − *x*.*right*.*size*|.
- en: Define the potential of *T* as
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 将*T*的潜力定义为
- en: '![art](images/Art_P530.jpg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P530.jpg)'
- en: where *c* is a sufficiently large constant that depends on *α*.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 其中*c*是一个足够大的常数，取决于*α*。
- en: '***c.*** Argue that any binary search tree has nonnegative potential and also
    that a 1/2-balanced tree has potential 0.'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 论证任何二叉搜索树都具有非负潜力，并且1/2平衡树的潜力为0。'
- en: '***d.*** Suppose that *m* units of potential can pay for rebuilding an *m*-node
    subtree. How large must *c* be in terms of *α* in order for it to take *O*(1)
    amortized time to rebuild a subtree that is not *α*-balanced?'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 假设*m*单位的潜力可以支付重建一个*m*节点子树。为了使重建一个不是*α*-平衡的子树摊销时间为*O*(1)，*c*必须多大，以*α*为单位？'
- en: '***e.*** Show that inserting a node into or deleting a node from an *n*-node
    *α*-balanced tree costs *O*(lg *n*) amortized time.'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** 证明将节点插入或从*n*个节点的*α*-平衡树中删除节点的摊销时间为*O*(lg *n*)。'
- en: '***16-4     The cost of restructuring red-black trees***'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '***16-4     重构红黑树的成本***'
- en: 'There are four basic operations on red-black trees that perform ***structural
    modifications***: node insertions, node deletions, rotations, and color changes.
    We have seen that RB-INSERT and RB-DELETE use only *O*(1) rotations, node insertions,
    and node deletions to maintain the red-black properties, but they may make many
    more color changes.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 红黑树上有四种基本操作执行***结构修改***：节点插入、节点删除、旋转和颜色变化。我们已经看到RB-INSERT和RB-DELETE仅使用*O*(1)次旋转、节点插入和节点删除来维护红黑属性，但它们可能会进行更多的颜色变化。
- en: '***a.*** Describe a legal red-black tree with *n* nodes such that calling RB-INSERT
    to add the (*n* + 1)st node causes Ω(lg *n*) color changes. Then describe a legal
    red-black tree with *n* nodes for which calling RB-DELETE on a particular node
    causes Ω(lg *n*) color changes.'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 描述一个具有*n*个节点的合法红黑树，调用RB-INSERT添加第(*n* + 1)个节点会导致Ω(lg *n*)次颜色变化。然后描述一个具有*n*个节点的合法红黑树，对特定节点调用RB-DELETE会导致Ω(lg
    *n*)次颜色变化。'
- en: Although the worst-case number of color changes per operation can be logarithmic,
    you will prove that any sequence of *m* RB-INSERT and RB-DELETE operations on
    an initially empty red-black tree causes *O*(*m*) structural modifications in
    the worst case.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管每次操作的最坏情况下颜色变化次数可以是对数级的，但你将证明在最坏情况下，对于一个最初为空的红黑树，任何*m*个RB-INSERT和RB-DELETE操作序列会导致*O*(*m*)次结构修改。
- en: '***b.*** Some of the cases handled by the main loop of the code of both RB-INSERT-FIXUP
    and RB-DELETE-FIXUP are ***terminating***: once encountered, they cause the loop
    to terminate after a constant number of additional operations. For each of the
    cases of RB-INSERT-FIXUP and RB-DELETE-FIXUP, specify which are terminating and
    which are not. (*Hint*: Look at [Figures 13.5](chapter013.xhtml#Fig_13-1), [13.6](chapter013.xhtml#Fig_13-6),
    and [13.7](chapter013.xhtml#Fig_13-7) in [Sections 13.3](chapter013.xhtml#Sec_13.3)
    and [13.4](chapter013.xhtml#Sec_13.4).)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 代码主循环处理的RB-INSERT-FIXUP和RB-DELETE-FIXUP的一些情况是***终止***的：一旦遇到，它们会导致循环在经过常数次额外操作后终止。对于RB-INSERT-FIXUP和RB-DELETE-FIXUP的每种情况，指明哪些是终止的，哪些不是。（*提示*：查看[第13.3节](chapter013.xhtml#Sec_13.3)和[第13.4节](chapter013.xhtml#Sec_13.4)中的[图13.5](chapter013.xhtml#Fig_13-1)、[13.6](chapter013.xhtml#Fig_13-6)和[13.7](chapter013.xhtml#Fig_13-7)。）'
- en: You will first analyze the structural modifications when only insertions are
    performed. Let *T* be a red-black tree, and define Φ(*T*) to be the number of
    red nodes in *T*. Assume that one unit of potential can pay for the structural
    modifications performed by any of the three cases of RB-INSERT-FIXUP.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当只执行插入时，你将分析结构修改。设*T*为红黑树，并定义Φ(*T*)为*T*中红色节点的数量。假设一单位的潜力可以支付RB-INSERT-FIXUP的三种情况中执行的结构修改。
- en: '***c.*** Let *T*′ be the result of applying Case 1 of RB-INSERT-FIXUP to *T*.
    Argue that Φ(*T*′) = Φ(*T*) − 1.'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 让*T*′是将RB-INSERT-FIXUP的Case 1应用于*T*后的结果。论证Φ(*T*′) = Φ(*T*) − 1。'
- en: '***d.*** We can break the operation of the RB-INSERT procedure into three parts.
    List the structural modifications and potential changes resulting from lines 1–16
    of RB-INSERT, from nonterminating cases of RB-INSERT-FIXUP, and from terminating
    cases of RB-INSERT-FIXUP.'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 我们可以将RB-INSERT过程的操作分为三部分。列出RB-INSERT的第1-16行、RB-INSERT-FIXUP的非终止情况和终止情况导致的结构修改和潜力变化。'
- en: '***e.*** Using part (d), argue that the amortized number of structural modifications
    performed by any call of RB-INSERT is *O*(1).'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** 使用(d)部分，论证RB-INSERT的每次调用执行的结构修改的摊销数量是*O*(1)。'
- en: Next you will prove that there are *O*(*m*) structural modifications when both
    insertions and deletions occur. Define, for each node *x*,
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将证明当插入和删除同时发生时，结构修改次数为*O*(*m*)。对于每个节点*x*，
- en: '![art](images/Art_P531.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P531.jpg)'
- en: Now redefine the potential of a red-black tree *T* as
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 现在重新定义红黑树*T*的潜力为
- en: '![art](images/Art_P532.jpg)'
  id: totrans-289
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P532.jpg)'
- en: and let *T*′ be the tree that results from applying any nonterminating case
    of RB-INSERT-FIXUP or RB-DELETE-FIXUP to *T*.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 让*T*′是应用RB-INSERT-FIXUP或RB-DELETE-FIXUP的任何非终止情况后得到的树。
- en: '***f.*** Show that Φ(*T*′) ≤ Φ(*T*) − 1 for all nonterminating cases of RB-INSERT-FIXUP.
    Argue that the amortized number of structural modifications performed by any call
    of RB-INSERT-FIXUP is *O*(1).'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '***f.*** 证明对于RB-INSERT-FIXUP的所有非终止情况，Φ(*T*′) ≤ Φ(*T*) − 1。论证RB-INSERT-FIXUP的每次调用执行的结构修改的摊销数量是*O*(1)。'
- en: '***g.*** Show that Φ(*T*′) ≤ Φ(*T*) − 1 for all nonterminating cases of RB-DELETE-FIXUP.
    Argue that the amortized number of structural modifications performed by any call
    of RB-DELETE-FIXUP is *O*(1).'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '***g.*** 证明对于RB-DELETE-FIXUP的所有非终止情况，Φ(*T*′) ≤ Φ(*T*) − 1。论证RB-DELETE-FIXUP的每次调用执行的结构修改的摊销数量是*O*(1)。'
- en: '***h.*** Complete the proof that in the worst case, any sequence of *m* RB-INSERT
    and RB-DELETE operations performs *O*(*m*) structural modifications.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '***h.*** 完成最坏情况下，任何*m*个RB-INSERT和RB-DELETE操作序列执行*O*(*m*)次结构修改的证明。'
- en: '**Chapter notes**'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节注释**'
- en: Aho, Hopcroft, and Ullman [[5](bibliography001.xhtml#endnote_5)] used aggregate
    analysis to determine the running time of operations on a disjoint-set forest.
    We’ll analyze this data structure using the potential method in [Chapter 19](chapter019.xhtml).
    Tarjan [[430](bibliography001.xhtml#endnote_430)] surveys the accounting and potential
    methods of amortized analysis and presents several applications. He attributes
    the accounting method to several authors, including M. R. Brown, R. E. Tarjan,
    S. Huddleston, and K. Mehlhorn. He attributes the potential method to D. D. Sleator.
    The term “amortized” is due to D. D. Sleator and R. E. Tarjan.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Aho、Hopcroft 和 Ullman [[5](bibliography001.xhtml#endnote_5)] 使用聚合分析来确定不相交集合森林上操作的运行时间。我们将在[第19章](chapter019.xhtml)中使用势能方法来分析这种数据结构。Tarjan
    [[430](bibliography001.xhtml#endnote_430)] 对摊销分析的会计和势能方法进行了调查，并提出了几个应用。他将会计方法归因于几位作者，包括M.
    R. Brown、R. E. Tarjan、S. Huddleston 和 K. Mehlhorn。他将势能方法归因于D. D. Sleator。术语“摊销”归因于D.
    D. Sleator 和 R. E. Tarjan。
- en: 'Potential functions are also useful for proving lower bounds for certain types
    of problems. For each configuration of the problem, define a potential function
    that maps the configuration to a real number. Then determine the potential Φ[init]
    of the initial configuration, the potential Φ[final] of the final configuration,
    and the maximum change in potential ΔΦ[max] due to any step. The number of steps
    must therefore be at least |Φ[final] − Φ[init]| / | ΔΦ[max]|. Examples of potential
    functions to prove lower bounds in I/O complexity appear in works by Cormen, Sundquist,
    and Wisniewski [[105](bibliography001.xhtml#endnote_105)], Floyd [[146](bibliography001.xhtml#endnote_146)],
    and Aggarwal and Vitter [[3](bibliography001.xhtml#endnote_3)]. Krumme, Cybenko,
    and Venkataraman [[271](bibliography001.xhtml#endnote_271)] applied potential
    functions to prove lower bounds on ***gossiping***: communicating a unique item
    from each vertex in a graph to every other vertex.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 势能函数对于证明某些类型问题的下界也很有用。对于问题的每个配置，定义一个将配置映射到实数的势能函数。然后确定初始配置的势能Φ[init]，最终配置的势能Φ[final]，以及由于任何步骤导致的势能变化的最大值ΔΦ[max]。因此，步数至少必须是
    |Φ[final] − Φ[init]| / | ΔΦ[max]|。用于证明I/O复杂度下界的势能函数示例出现在Cormen、Sundquist 和 Wisniewski的作品中[[105](bibliography001.xhtml#endnote_105)]，Floyd[[146](bibliography001.xhtml#endnote_146)]，以及Aggarwal
    和 Vitter[[3](bibliography001.xhtml#endnote_3)]。Krumme、Cybenko 和 Venkataraman[[271](bibliography001.xhtml#endnote_271)]应用势能函数来证明***传话***的下界：从图中每个顶点向每个其他顶点传递一个唯一项。
- en: '[¹](#footnote_ref_1) In some situations, such as an open-address hash table,
    it’s better to consider a table to be full if its load factor equals some constant
    strictly less than 1\. (See Exercise 16.4-2.)'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[¹](#footnote_ref_1) 在某些情况下，比如开放地址哈希表，如果负载因子等于严格小于1的某个常数，就更好地将表视为已满。（参见练习16.4-2。）'
