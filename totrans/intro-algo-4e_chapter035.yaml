- answer: '---

    -   **35        近似算法**

    ---


    '
  en: '**35        近似算法**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **35        近似算法**  输出：'
  type: TYPE_NORMAL
- answer: '-   许多实际意义重大的问题都是 NP 完全的，但它们太重要了，不能仅仅因为没有人知道如何在多项式时间内找到最优解而放弃。即使一个问题是 NP
    完全的，也可能有希望。你至少有三种方法可以避开 NP 完全性。首先，如果实际输入很小，具有指数运行时间的算法可能足够快。其次，您可能能够孤立出可以在多项式时间内解决的重要特殊情况。第三，您可以尝试设计一种方法，在多项式时间内找到一个`接近最优`解（无论是在最坏情况下还是在期望情况下）。在实践中，接近最优通常已经足够好了。我们称返回接近最优解的算法为***近似算法***。本章介绍了几个
    NP 完全问题的多项式时间近似算法。'
  en: 许多实际意义重大的问题都是 NP 完全的，但它们太重要了，不能仅仅因为没有人知道如何在多项式时间内找到最优解而放弃。即使一个问题是 NP 完全的，也可能有希望。你至少有三种方法可以避开
    NP 完全性。首先，如果实际输入很小，具有指数运行时间的算法可能足够快。其次，您可能能够孤立出可以在多项式时间内解决的重要特殊情况。第三，您可以尝试设计一种方法，在多项式时间内找到一个*接近最优*解（无论是在最坏情况下还是在期望情况下）。在实践中，接近最优通常已经足够好了。我们称返回接近最优解的算法为***近似算法***。本章介绍了几个
    NP 完全问题的多项式时间近似算法。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   许多实际意义重大的问题都是
    NP 完全的，但它们太重要了，不能仅仅因为没有人知道如何在多项式时间内找到最优解而放弃。即使一个问题是 NP 完全的，也可能有希望。你至少有三种方法可以避开
    NP 完全性。首先，如果实际输入很小，具有指数运行时间的算法可能足够快。其次，您可能能够孤立出可以在多项式时间内解决的重要特殊情况。第三，您可以尝试设计一种方法，在多项式时间内找到一个*接近最优*解（无论是在最坏情况下还是在期望情况下）。在实践中，接近最优通常已经足够好了。我们称返回接近最优解的算法为***近似算法***。本章介绍了几个
    NP 完全问题的多项式时间近似算法。  输出：'
  type: TYPE_NORMAL
- answer: '-   **`近似算法的性能比率`**  '
  en: '**近似算法的性能比率**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **近似算法的性能比率**  输出：'
  type: TYPE_NORMAL
- answer: '-   假设您正在解决一个优化问题，其中每个潜在解决方案都有正成本，并且您希望找到一个接近最优解。根据问题的不同，您可以将最优解定义为具有最大可能成本或具有最小可能成本的解，也就是说，问题可能是一个最大化问题或一个最小化问题。'
  en: 假设您正在解决一个优化问题，其中每个潜在解决方案都有正成本，并且您希望找到一个接近最优解。根据问题的不同，您可以将最优解定义为具有最大可能成本或具有最小可能成本的解，也就是说，问题可能是一个最大化问题或一个最小化问题。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   假设您正在解决一个优化问题，其中每个潜在解决方案都有正成本，并且您希望找到一个接近最优解。根据问题的不同，您可以将最优解定义为具有最大可能成本或具有最小可能成本的解，也就是说，问题可能是一个最大化问题或一个最小化问题。  输出：'
  type: TYPE_NORMAL
- answer: '-   对于问题的算法具有`ρ(n)`的***近似比率***，如果对于任何大小为`n`的输入，算法产生的解的成本`C`与最优解的成本`C*`之间的比例在`ρ(n)`的因子范围内：  '
  en: 对于问题的算法具有*ρ*(*n*)的***近似比率***，如果对于任何大小为*n*的输入，算法产生的解的成本*C*与最优解的成本*C**之间的比例在*ρ*(*n*)的因子范围内：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于问题的算法具有*ρ*(*n*)的***近似比率***，如果对于任何大小为*n*的输入，算法产生的解的成本*C*与最优解的成本*C**之间的比例在*ρ*(*n*)的因子范围内：  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   `![艺术](img/Art_P1483.jpg)`'
  en: '![艺术](img/Art_P1483.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1483.jpg)  输出：'
  type: TYPE_IMG
- answer: '-   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于
    1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。'
  en: 如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比���永远不会小于
    1，因为*C*/*C** ≤ 1 意味着*C**/*C* ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比���永远不会小于
    1，因为*C*/*C** ≤ 1 意味着*C**/*C* ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  输出：'
  type: TYPE_NORMAL
- answer: '-   对于许多问题，我们知道具有小常数近似比率的多项式时间近似算法，尽管对于其他问题，已知的最佳多项式时间近似算法的近似比率会随着输入大小`n`的增长而增加。一个例子是
    35.3 节中介绍的集合覆盖问题。  '
  en: 对于许多问题，我们知道具有小常数近似比率的多项式时间近似算法，尽管对于其他问题，已知的最佳多项式时间近似算法的近似比率会随着输入大小*n*的增长而增加。一个例子是
    35.3 节中介绍的集合覆盖问题。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于许多问题，我们知道具有小常数近似比率的多项式时间近似算法，尽管对于其他问题，已知的最佳多项式时间近似算法的近似比率会随着输入大小*n*的增长而增加。一个例子是
    35.3 节中介绍的集合覆盖问题。  输出：'
  type: TYPE_NORMAL
- answer: '-   一些多项式时间近似算法可以通过使用越来越多的计算时间来实现越来越好的近似比率。对于这样的问题，您可以通过计算时间来交换近似的质量。一个例子是
    35.5 节中研究的子集和问题。这种情况足够重要，值得有一个专门的名称。'
  en: 一些多项式时间近似算法可以通过使用越来越多的计算时间来实现越来越好的近似比率。对于这样的问题，您可以通过计算时间来交换近似的质量。一个例子是 35.5
    节中研究的子集和问题。这种情况足够重要，值得有一个专门的名称。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   一些多项式时间近似算法可以通过使用越来越多的计算时间来实现越来越好的近似比率。对于这样的问题，您可以通过计算时间来交换近似的质量。一个例子是
    35.5 节中研究的子集和问题。这种情况足够重要，值得有一个专门的名称。  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   优化问题的一个`***近似方案***`是一个近似算法，它不仅接受问题的一个实例作为输入，还接受一个`ϵ > 0` 的值，使得对于任何固定的`ϵ`，该方案都是一个`(1
    + ϵ)`-近似算法。我们称一个近似方案为`***多项式时间近似方案***`，如果对于任何固定的`ϵ > 0`，该方案在其输入实例的大小`n`的多项式时间内运行。'
  en: 优化问题的一个***近似方案***是一个近似算法，它不仅接受问题的一个实例作为输入，还接受一个*ϵ* > 0 的值，使得对于任何固定的*ϵ*，该方案都是一个(1
    + *ϵ*)-近似算法。我们称一个近似方案为***多项式时间近似方案***，如果对于任何固定的*ϵ* > 0，该方案在其输入实例的大小*n*的多项式时间内运行。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   优化问题的一个***近似方案***是一个近似算法，它不仅接受问题的一个实例作为输入，还接受一个*ϵ*
    > 0 的值，使得对于任何固定的*ϵ*，该方案都是一个(1 + *ϵ*)-近似算法。我们称一个近似方案为***多项式时间近似方案***，如果对于任何固定的*ϵ*
    > 0，该方案在其输入实例的大小*n*的多项式时间内运行。  输出：'
  type: TYPE_NORMAL
- answer: '-   当`ϵ`减小时，多项式时间逼近方案的运行时间可能会急剧增加。例如，多项式时间逼近方案的运行时间可能为`O(n^(2/ϵ))`。理想情况下，如果`ϵ`按照一个常数因子减小，为了达到所需的逼近，运行时间不应该增加超过一个常数因子（尽管不一定是`ϵ`减小的同一个常数因子）。'
  en: 当*ϵ*减小时，多项式时间逼近方案的运行时间可能会急剧增加。例如，多项式时间逼近方案的运行时间可能为*O*(*n*^(2/*ϵ*))。理想情况下，如果*ϵ*按照一个常数因子减小，为了达到所需的逼近，运行时间不应该增加超过一个常数因子（尽管不一定是*ϵ*减小的同一个常数因子）。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   当*ϵ*减小时，多项式时间逼近方案的运行时间可能会急剧增加。例如，多项式时间逼近方案的运行时间可能为*O*(*n*^(2/*ϵ*))。理想情况下，如果*ϵ*按照一个常数因子减小，为了达到所需的逼近，运行时间不应该增加超过一个常数因子（尽管不一定是*ϵ*减小的同一个常数因子）。  输出：'
  type: TYPE_NORMAL
- answer: '-   如果一个逼近方案是一个`完全多项式时间逼近方案`，那么它是一个逼近方案，并且其运行时间在 `1/ϵ` 和输入实例大小 `n` 中都是多项式的。例如，该方案的运行时间可能为
    `O((1/ϵ)²*n*³)`。有了这样的方案，`ϵ` 的任何常数因子减少都会伴随着运行时间的相应常数因子增加。'
  en: 如果一个逼近方案是一个***完全多项式时间逼近方案***，那么它是一个逼近方案，并且其运行时间在 1/*ϵ*和输入实例大小*n*中都是多项式的。例如，该方案的运行时间可能为*O*((1/*ϵ*)²*n*³)。有了这样的方案，*ϵ*的任何常数因子减少都会伴随着运行时间的相应常数因子增加。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   如果一个逼近方案是一个***完全多项式时间逼近方案***，那么它是一个逼近方案，并且其运行时间在
    1/*ϵ*和输入实例大小*n*中都是多项式的。例如，该方案的运行时间可能为*O*((1/*ϵ*)²*n*³)。有了这样的方案，*ϵ*的任何常数因子减少都会伴随着运行时间的相应常数因子增加。  输出：'
  type: TYPE_NORMAL
- answer: '---

    **章节大纲**

    ---'
  en: '**章节大纲**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **章节大纲**  输出：'
  type: TYPE_NORMAL
- answer: '-   本章的前四节介绍了一些 NP 完全问题的多项式时间逼近算法的示例，第五节提供了一个完全多项式时间逼近方案。我们从 35.1 节开始研究顶点覆盖问题，这是一个
    NP 完全的最小化问题，具有逼近比为 2 的逼近算法。35.2 节讨论了旅行推销员问题的一个版本，其中成本函数满足三角不等式，并提供了一个逼近比为 2 的逼近算法。该节还表明，如果没有三角不等式，对于任意常数`ρ`
    ≥ 1，除非 P = NP，否则不存在`ρ`逼近算法。35.3 节将贪婪方法应用为集盖问题的有效逼近算法，得到的覆盖成本最多比最优成本大一个对数因子。35.4
    节使用随机化和线性规划开发了另外两个逼近算法。该节首先定义了 3-CNF 可满足性的优化版本，并给出了一个简单的随机算法，产生一个期望逼近比为 8/7 的解。然后
    35.4 节研究了顶点覆盖问题的加权变体，并展示如何使用线性规划开发一个 2 逼近算法。最后，35.5 节提出了子集和问题的完全多项式时间逼近方案。  '
  en: 本章的前四节介绍了一些 NP 完全问题的多项式时间逼近算法的示例，第五节提供了一个完全多项式时间逼近方案。我们从 35.1 节开始研究顶点覆盖问题，这是一个
    NP 完全的最小化问题，具有逼近比为 2 的逼近算法。35.2 节讨论了旅行推销员问题的一个版本，其中成本函数满足三角不等式，并提供了一个逼近比为 2 的逼近算法。该节还表明，如果没有三角不等式，对于任意常数*ρ*
    ≥ 1，除非 P = NP，否则不存在*ρ*逼近算法。35.3 节将贪婪方法应用为集盖问题的有效逼近算法，得到的覆盖成本最多比最优成本大一个对数因子。35.4
    节使用随机化和线性规划开发了另外两个逼近算法。该节首先定义了 3-CNF 可满足性的优化版本，并给出了一个简单的随机算法，产生一个期望逼近比为 8/7 的解。然后
    35.4 节研究了顶点覆盖问题的加权变体，并展示如何使用线性规划开发一个 2 逼近算法。最后，35.5 节提出了子集和问题的完全多项式时间逼近方案。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   本章的前四节介绍了一些
    NP 完全问题的多项式时间逼近算法的示例，第五节提供了一个完全多项式时间逼近方案。我们从 35.1 节开始研究顶点覆盖问题，这是一个 NP 完全的最小化问题，具有逼近比为
    2 的逼近算法。35.2 节讨论了旅行推销员问题的一个版本，其中成本函数满足三角不等式，并提供了一个逼近比为 2 的逼近算法。该节还表明，如果没有三角不等式，对于任意常数*ρ*
    ≥ 1，除非 P = NP，否则不存在*ρ*逼近算法。35.3 节将贪婪方法应用为集盖问题的有效逼近算法，得到的覆盖成本最多比最优成本大一个对数因子。35.4
    节使用随机化和线性规划开发了另外两个逼近算法。该节首先定义了 3-CNF 可满足性的优化版本，并给出了一个简单的随机算法，产生一个期望逼近比为 8/7 的解。然后
    35.4 节研究了顶点覆盖问题的加权变体，并展示如何使用线性规划开发一个 2 逼近算法。最后，35.5 节提出了子集和问题的完全多项式时间逼近方案。  输出：'
  type: TYPE_NORMAL
- answer: '-   `35.1    顶点覆盖问题`'
  en: '**35.1    顶点覆盖问题**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **35.1    顶点覆盖问题**  输出：'
  type: TYPE_NORMAL
- answer: '-   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′
    ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u ∈ V′`或`v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。'
  en: 34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′ ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u*
    ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。  输出：'
  type: TYPE_NORMAL
- answer: '-   `***顶点覆盖问题***`是在给定的无向图中找到最小大��的顶点覆盖。我们称这样的顶点覆盖为`***最优顶点覆盖***`。这个问题是
    NP 完全决策问题的优化版本。'
  en: '***顶点覆盖问题***是在给定的无向图中找到最小大��的顶点覆盖。我们称这样的顶点覆盖为***最优顶点覆盖***。这个问题是 NP 完全决策问题的优化版本。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***顶点覆盖问题***是在给定的无向图中找到最小大��的顶点覆盖。我们称这样的顶点覆盖为***最优顶点覆盖***。这个问题是
    NP 完全决策问题的优化版本。  输出：'
  type: TYPE_NORMAL
- answer: '-   尽管没有人知道如何在多项式时间内找到图`G`中的最优顶点覆盖，但有一种有效的算法可以找到一个接近最优的顶点覆盖。面对页面上的逼近算法
    `APPROX-VERTEX-COVER` 以无向图`G`作为输入，并返回一个顶点覆盖，其大小保证不超过最优顶点覆盖大小的两倍。'
  en: 尽管没有人知道如何在多项式时间内找到图*G*中的最优顶点覆盖，但有一种有效的算法可以找到一个接近最优的顶点覆盖。面对页面上的逼近算法 APPROX-VERTEX-COVER
    以无向图*G*作为输入，并返回一个顶点覆盖，其大小保证不超过最优顶点覆盖大小的两倍。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   尽管没有人知道如何在多项式时间内找到图*G*中的最优顶点覆盖，但有一种有效的算法可以找到一个接近最优的顶点覆盖。面对页面上的逼近算法
    APPROX-VERTEX-COVER 以无向图*G*作为输入，并返回一个顶点覆盖，其大小保证不超过最优顶点覆盖大小的两倍。  输出：'
  type: TYPE_NORMAL
- answer: '-   图 35.1 说明了 APPROX-VERTEX-COVER 在一个示例图上的操作。变量 `C` 包含正在构建的顶点覆盖。第 1 行将
    `C` 初始化为空集。第 2 行将 `E`′ 设置为图的边集 `G.E` 的副本。第 3-6 行的 **while** 循环重复地从 `E`′ 中选择一条边（`u`,
    `v`），将其端点 `u` 和 `v` 加入 `C`，并删除 `E`′ 中 `u` 或 `v` 覆盖的所有边。最后，第 7 行返回顶点覆盖 `C`。该算法的运行时间为
    `O(V + E)`，使用邻接表来表示 `E`′。'
  en: 图 35.1 说明了 APPROX-VERTEX-COVER 在一个示例图上的操作。变量 *C* 包含正在构建的顶点覆盖。第 1 行将 *C* 初始化为空集。第
    2 行将 *E*′ 设置为图的边集 *G.E* 的副本。第 3-6 行的 **while** 循环重复地从 *E*′ 中选择一条边（*u*, *v*），将其端点
    *u* 和 *v* 加入 *C*，并删除 *E*′ 中 *u* 或 *v* 覆盖的所有边。最后，第 7 行返回顶点覆盖 *C*。该算法的运行时间为 *O*(*V*
    + *E*)，使用邻接表来表示 *E*′。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   图 35.1 说明了
    APPROX-VERTEX-COVER 在一个示例图上的操作。变量 *C* 包含正在构建的顶点覆盖。第 1 行将 *C* 初始化为空集。第 2 行将 *E*′
    设置为图的边集 *G.E* 的副本。第 3-6 行的 **while** 循环重复地从 *E*′ 中选择一条边（*u*, *v*），将其端点 *u* 和 *v*
    加入 *C*，并删除 *E*′ 中 *u* 或 *v* 覆盖的所有边。最后，第 7 行返回顶点覆盖 *C*。该算法的运行时间为 *O*(*V* + *E*)，使用邻接表来表示
    *E*′。  输出：'
  type: TYPE_NORMAL
- answer: '```

    -   APPROX-VERTEX-COVER (G)

    ```'
  en: APPROX-VERTEX-COVER (*G*)
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   APPROX-VERTEX-COVER
    (*G*)  输出：'
  type: TYPE_NORMAL
- answer: '-   | 1 | `C` = Ø |'
  en: '| 1 | *C* = Ø |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 1 | *C* =
    Ø |  输出：'
  type: TYPE_TB
- answer: '```

    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆
    V`，使得如果`(u, v)`是`G`的一条边，则`u ∈ V′`或`v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。

    ```'
  en: '| --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | --- | ---
    |  输出：'
  type: TYPE_TB
- answer: '-   | `2` | `E′ = G.E` |  '
  en: '| 2 | *E*′ = *G.E* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 2 | *E*′
    = *G.E* |  输出：'
  type: TYPE_TB
- answer: '-   | `3` | **当** `E′ ≠ Ø` **时** |  '
  en: '| 3 | **当** *E*′ ≠ Ø **时** |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 3 | **当** *E*′
    ≠ Ø **时** |  输出：'
  type: TYPE_TB
- answer: '```

    -   | `4` | 令 (`u`, `v`) 为 `E′` 的任意边 |

    ```'
  en: '| 4 | 令 (*u*, *v*) 为 *E*′ 的任意边 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 4 | 令 (*u*,
    *v*) 为 *E*′ 的任意边 |  输出：'
  type: TYPE_TB
- answer: '-   | 5 | `C = C ∪ {u, v}` |'
  en: '| 5 | *C* = *C* ∪ {*u, v*} |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 5 | *C* =
    *C* ∪ {*u, v*} |  输出：'
  type: TYPE_TB
- answer: '-   | 6 | 从 `E''` 中移除边（`u`, `v`）以及任何与 `u` 或 `v` 相关的边 |'
  en: '| 6 | 从 *E*′ 中移除边（*u*, *v*）以及任何与 *u* 或 *v* 相关的边 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 6 | 从 *E*′
    中移除边（*u*, *v*）以及任何与 *u* 或 *v* 相关的边 |  输出：'
  type: TYPE_TB
- answer: '-   | 7 | **返回** `C` |  '
  en: '| 7 | **返回** *C* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 7 | **返回** *C*
    |  输出：'
  type: TYPE_TB
- answer: '-   ***定理 `35.1`***  '
  en: '***定理 35.1***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***定理 35.1***  输出：'
  type: TYPE_NORMAL
- answer: '-   APPROX-VERTEX-COVER 是一个多项式时间的`2`-近似算法。'
  en: APPROX-VERTEX-COVER 是一个多项式时间的 2-近似算法。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   APPROX-VERTEX-COVER
    是一个多项式时间的 2-近似算法。  输出：'
  type: TYPE_NORMAL
- answer: '-   ***证明***   我们已经证明了`APPROX-VERTEX-COVER`在多项式时间内运行。'
  en: '***证明***   我们已经证明了 APPROX-VERTEX-COVER 在多项式时间内运行。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***证明***   我们已经证明了
    APPROX-VERTEX-COVER 在多项式时间内运行。  输出：'
  type: TYPE_NORMAL
- answer: '-   由 APPROX-VERTEX-COVER 返回的顶点集 `C` 是一个顶点覆盖，因为该算法循环直到图 `G.E` 中的每条边都被 `C`
    中的某个顶点覆盖。  '
  en: 由 APPROX-VERTEX-COVER 返回的顶点集 *C* 是一个顶点覆盖，因为该算法循环直到图 *G.E* 中的每条边都被 *C* 中的某个顶点覆盖。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   由 APPROX-VERTEX-COVER
    返回的顶点集 *C* 是一个顶点覆盖，因为该算法循环直到图 *G.E* 中的每条边都被 *C* 中的某个顶点覆盖。  输出：'
  type: TYPE_NORMAL
- answer: '-   为了看到`APPROX-VERTEX-COVER`返回的顶点覆盖最多是最优覆盖大小的两倍，让 `A` 表示 `APPROX-VERTEX-COVER`
    的第 4 行选择的边集。为了覆盖 `A` 中的边，任何顶点覆盖——特别是最优覆盖 `C`——必须至少包括 `A` 中每条边的一个端点。`A` 中没有两条边共享一个端点，因为一旦在第
    4 行选择了一条边，所有其他与其端点相邻的边都在第 6 行从 `E''` 中删除。因此，`A` 中没有两条边被 `C` 中的同一个顶点覆盖，这意味着对于 `C`
    中的每个顶点，`A` 中最多有一条边，给出了下界'
  en: 为了看到 APPROX-VERTEX-COVER 返回的顶点覆盖最多是最优覆盖大小的两倍，让 *A* 表示 APPROX-VERTEX-COVER 的第
    4 行选择的边集。为了覆盖 *A* 中的边，任何顶点覆盖——特别是最优覆盖 *C*——必须至少包括 *A* 中每条边的一个端点。*A* 中没有两条边共享一个端点，因为一旦在第
    4 行选择了一条边，所有其他与其端点相邻的边都在第 6 行从 *E*′ 中删除。因此，*A* 中没有两条边被 *C* 中的同一个顶点覆盖，这意味着对于 *C*
    中的每个顶点，*A* 中最多有一条边，给出了下界
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   为了看到 APPROX-VERTEX-COVER
    返回的顶点覆盖最多是最优覆盖大小的两倍，让 *A* 表示 APPROX-VERTEX-COVER 的第 4 行选择的边集。为了覆盖 *A* 中的边，任何顶点覆盖——特别是最优覆盖
    *C*——必须至少包括 *A* 中每条边的一个端点。*A* 中没有两条边共享一个端点，因为一旦在第 4 行选择了一条边，所有其他与其端点相邻的边都在第 6
    行从 *E*′ 中删除。因此，*A* 中没有两条边被 *C* 中的同一个顶点覆盖，这意味着对于 *C* 中的每个顶点，*A* 中最多有一条边，给出了下界  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   ![艺术](img/Art_P1484.jpg)'
  en: '![艺术](img/Art_P1484.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1484.jpg)  输出：'
  type: TYPE_IMG
- answer: '-   对于最优顶点覆盖的大小有一个上界。第 4 行的每次执行都选择一条边，该边的端点都不在 `C` 中，从而得到一个上界（实际上是一个精确的上界）来返回顶点覆盖的大小：'
  en: 对于最优顶点覆盖的大小有一个上界。第 4 行的每次执行都选择一条边，该边的端点都不在 *C* 中，从而得到一个上界（实际上是一个精确的上界）来返回顶点覆盖的大小：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于最优顶点覆盖的大小有一个上界。第
    4 行的每次执行都选择一条边，该边的端点都不在 *C* 中，从而得到一个上界（实际上是一个精确的上界）来返回顶点覆盖的大小：  输出：'
  type: TYPE_NORMAL
- answer: '-   ![艺术](img/Art_P1485.jpg)'
  en: '![艺术](img/Art_P1485.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1485.jpg)  输出：'
  type: TYPE_IMG
- answer: '-   结合方程（`35.2`）和（`35.3`）得到'
  en: 结合方程（35.2）和（35.3）得到
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   结合方程（35.2）和（35.3）得到  输出：'
  type: TYPE_NORMAL
- answer: ''
  en: '| &#124;*C*&#124; | = | 2 &#124;*A*&#124; |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | &#124;*C*&#124;
    | = | 2 &#124;*A*&#124; |  输出：'
  type: TYPE_TB
- answer: '```

    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆
    V`，使得如果`(u, v)`是`G`的一条边，则`u ∈ V′`或`v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个***`ρ(n)`-近似算法***。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。

    ```'
  en: '| --- | --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | --- | ---
    | --- |  输出：'
  type: TYPE_TB
- answer: '- `|  | ≤ | 2 *C* |, |`'
  en: '|  | ≤ | 2 &#124;*C**&#124;, |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |  | ≤ | 2
    &#124;*C**&#124;, |  输出：'
  type: TYPE_TB
- answer: '-   从而证明了定理。'
  en: 从而证明了定理。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   从而证明了定理。  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   ▪  输出：

    -   `34.5.2` 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′
    ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u ∈ V′`或`v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个***`ρ(n)`-近似算法***。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。'
  en: ▪
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ▪  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   ![艺术](img/Art_P1486.jpg)'
  en: '![艺术](img/Art_P1486.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1486.jpg)  输出：'
  type: TYPE_IMG
- answer: '-   **图 35.1** `APPROX-VERTEX-COVER` 的操作。**(a)** 输入图 `G`，有 7 个顶点和 8 条边。**(b)**
    被 `APPROX-VERTEX-COVER` 选择的第一条边 (`b`, `c`)。蓝色的顶点 `b` 和 `c` 被添加到包含正在创建的顶点覆盖的集合
    `C` 中。虚线边 (`a`, `b`)，(`c`, `e`) 和 (`c`, `d`) 被移除，因为它们现在被 `C` 中的某个顶点覆盖了。**(c)**
    选择了边 (`e`, `f`)，顶点 `e` 和 `f` 被添加到 `C` 中。**(d)** 选择了边 (`d`, `g`)，顶点 `d` 和 `g` 被添加到
    `C` 中。**(e)** 集合 `C`，由 `APPROX-VERTEX-COVER` 产生的顶点覆盖，包含了六个顶点 `b, c, d, e, f, g`。**(f)**
    此问题的最优顶点覆盖仅包含三个顶点：`b`, `d` 和 `e`。'
  en: '**图 35.1** APPROX-VERTEX-COVER 的操作。**(a)** 输入图 *G*，有 7 个顶点和 8 条边。**(b)** 被
    APPROX-VERTEX-COVER 选择的第一条边 (*b*, *c*)。蓝色的顶点 *b* 和 *c* 被添加到包含正在创建的顶点覆盖的集合 *C*
    中。虚线边 (*a*, *b*)，(*c*, *e*) 和 (*c*, *d*) 被移除，因为它们现在被 *C* 中的某个顶点覆盖了。**(c)** 选择了边
    (*e*, *f*)，顶点 *e* 和 *f* 被添加到 *C* 中。**(d)** 选择了边 (*d*, *g*)，顶点 *d* 和 *g* 被添加到 *C*
    中。**(e)** 集合 *C*，由 APPROX-VERTEX-COVER 产生的顶点覆盖，包含了六个顶点 *b, c, d, e, f, g*。**(f)**
    此问题的最优顶点覆盖仅包含三个顶点：*b*, *d* 和 *e*。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **图 35.1**
    APPROX-VERTEX-COVER 的操作。**(a)** 输入图 *G*，有 7 个顶点和 8 条边。**(b)** 被 APPROX-VERTEX-COVER
    选择的第一条边 (*b*, *c*)。蓝色的顶点 *b* 和 *c* 被添加到包含正在创建的顶点覆盖的集合 *C* 中。虚线边 (*a*, *b*)，(*c*,
    *e*) 和 (*c*, *d*) 被移除，因为它们现在被 *C* 中的某个顶点覆盖了。**(c)** 选择了边 (*e*, *f*)，顶点 *e* 和 *f*
    被添加到 *C* 中。**(d)** 选择了边 (*d*, *g*)，顶点 *d* 和 *g* 被添加到 *C* 中。**(e)** 集合 *C*，由 APPROX-VERTEX-COVER
    产生的顶点覆盖，包含了六个顶点 *b, c, d, e, f, g*。**(f)** 此问题的最优顶点覆盖仅包含三个顶点：*b*, *d* 和 *e*。  输出：'
  type: TYPE_NORMAL
- answer: '- 让我们反思这个证明。起初，你可能会想知道如何可能证明由 APPROX-VERTEX-COVER 返回的顶点覆盖的大小至多是最优顶点覆盖大小的两倍，当你甚至不知道最优顶点覆盖的大小时。与其要求你知道最优顶点覆盖的确切大小，不如找到大小的下界。正如习题
    35.1-2 要求你展示的那样，APPROX-VERTEX-COVER 的第 4 行选择的边集 `A` 实际上是图 `G` 中的最大匹配。 （***最大匹配***是一个不能再添加边而仍然具有匹配的匹配。）最大匹配的大小，正如我们在定理
    35.1 的证明中所讨论的那样，是最优顶点覆盖大小的下界。该算法返回的顶点覆盖大小至多是最大匹配 `A` 大小的两倍。逼近比率来自将返回的解的大小与下界相关联。我们在后面的章节中也将使用这种方法。'
  en: 让我们反思这个证明。起初，你可能会想知道如何可能证明由 APPROX-VERTEX-COVER 返回的顶点覆盖的大小至多是最优顶点覆盖大小的两倍，当你甚至不知道最优顶点覆盖的大小时。与其要求你知道最优顶点覆盖的确切大小，不如找到大小的下界。正如习题
    35.1-2 要求你展示的那样，APPROX-VERTEX-COVER 的第 4 行选择的边集 *A* 实际上是图 *G* 中的最大匹配。 （***最大匹配***是一个不能再添加边而仍然具有匹配的匹配。）最大匹配的大小，正如我们在定理
    35.1 的证明中所讨论的那样，是最优顶点覆盖大小的下界。该算法返回的顶点覆盖大小至多是最大匹配 *A* 大小的两倍。逼近比率来自将返回的解的大小与下界相关联。我们在后面的章节中也将使用这种方法。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   让我们反思这个证明。起初，你可能会想知道如何可能证明由
    APPROX-VERTEX-COVER 返回的顶点覆盖的大小至多是最优顶点覆盖大小的两倍，当你甚至不知道最优顶点覆盖的大小时。与其要求你知道最优顶点覆盖的确切大小，不如找到大小的下界。正如习题
    35.1-2 要求你展示的那样，APPROX-VERTEX-COVER 的第 4 行选择的边集 *A* 实际上是图 *G* 中的最大匹配。 （***最大匹配***是一个不能再添加边而仍然具有匹配的匹配。）最大匹配的大小，正如我们在定理
    35.1 的证明中所讨论的那样，是最优顶点覆盖大小的下界。该算法返回的顶点覆盖大小至多是最大匹配 *A* 大小的两倍。逼近比率来自将返回的解的大小与下界相关联。我们在后面的章节中也将使用这种方法。  输出：'
  type: TYPE_NORMAL
- answer: '---

    **习题**

    ---'
  en: '**习题**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **习题**  输出：'
  type: TYPE_NORMAL
- answer: '---

    `35.1-1`

    -'
  en: '***35.1-1***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***35.1-1***  输出：'
  type: TYPE_NORMAL
- answer: '---

    给出一个图的例子，`APPROX-VERTEX-COVER` 总是产生次优解。

    ---'
  en: 给出一个图的例子，APPROX-VERTEX-COVER 总是产生次优解。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   给出一个图的例子，APPROX-VERTEX-COVER
    总是产生次优解。  输出：'
  type: TYPE_NORMAL
- answer: '-   ***`35.1-2`***  '
  en: '***35.1-2***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***35.1-2***  输出：'
  type: TYPE_NORMAL
- answer: '-   证明在 `APPROX-VERTEX-COVER` 的第 4 行中选择的边集形成图 *G* 中的最大匹配。'
  en: 证明在 APPROX-VERTEX-COVER 的第 4 行中选择的边集形成图 *G* 中的最大匹配。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   证明在 APPROX-VERTEX-COVER
    的第 4 行中选择的边集形成图 *G* 中的最大匹配。  输出：'
  type: TYPE_NORMAL
- answer: '- ★ ***`35.1-3`***'
  en: ★ ***35.1-3***
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ★ ***35.1-3***  输出：'
  type: TYPE_NORMAL
- answer: '-   考虑以下启发式方法来解决顶点覆盖问题。重复选择度数最高的顶点，并删除其所有关联边。给出一个示例，表明这种启发式方法不会提供 2 的逼近比率。(*提示:*
    尝试一个左侧顶点度数均匀，���侧顶点度数不同的二部图。)'
  en: 考虑以下启发式方法来解决顶点覆盖问题。重复选择度数最高的顶点，并删除其所有关联边。给出一个示例，表明这种启发式方法不会提供 2 的逼近比率。(*提示:*
    尝试一个左侧顶点度数均匀，���侧顶点度数不同的二部图。)
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   考虑以下启发式方法来解决顶点覆盖问题。重复选择度数最高的顶点，并删除其所有关联边。给出一个示例，表明这种启发式方法不会提供
    2 的逼近比率。(*提示:* 尝试一个左侧顶点度数均匀，���侧顶点度数不同的二部图。)  输出：'
  type: TYPE_NORMAL
- answer: '-   `35.1-4`'
  en: '***35.1-4***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***35.1-4***  输出：'
  type: TYPE_NORMAL
- answer: '-   给出一个有效的贪心算法，以线性时间找到树的最优顶点覆盖。'
  en: 给出一个有效的贪心算法，以线性时间找到树的最优顶点覆盖。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   给出一个有效的贪心算法，以线性时间找到树的最优顶点覆盖。  输出：'
  type: TYPE_NORMAL
- answer: ''
  en: '***35.1-5***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***35.1-5***  输出：'
  type: TYPE_NORMAL
- answer: '-   定理 34.12 在第 1084 页的证明说明，顶点覆盖问题和 NP 完全的团问题在某种意义上是互补的，即最优顶点覆盖是互补图中最大团的补集。这种关系是否意味着存在一个具有常数逼近比的多项式时间逼近算法来解决团问题？请证明你的答案。'
  en: 定理 34.12 在第 1084 页的证明说明，顶点覆盖问题和 NP 完全的团问题在某种意义上是互补的，即最优顶点覆盖是互补图中最大团的补集。这种关系是否意味着存在一个具有常数逼近比的多项式时间逼近算法来解决团问题？请证明你的答案。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   定理 34.12 在第
    1084 页的证明说明，顶点覆盖问题和 NP 完全的团问题在某种意义上是互补的，即最优顶点覆盖是互补图中最大团的补集。这种关系是否意味着存在一个具有常数逼近比的多项式时间逼近算法来解决团问题？请证明你的答案。  输出：'
  type: TYPE_NORMAL
- answer: '-   **35.2  旅行推销员问题**  '
  en: '**35.2    旅行推销员问题**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **35.2    旅行推销员问题**  输出：'
  type: TYPE_NORMAL
- answer: '- 旅行推销员问题的输入，介绍在 第 34.5.4 节 中，是一个完全无向图`G = (V, E)`，每条边`(u, v)` ∈ `E`都有一个非负整数成本`c(u,
    v)`。目标是找到`G`的最小成本哈密顿回路（一次遍历）。作为我们符号的扩展，让`c(A)`表示子集`A` ⊆ `E`中边的总成本：'
  en: 旅行推销员问题的输入，介绍在 第 34.5.4 节 中，是一个完全无向图 *G* = (*V*, *E*)，每条边 (*u*, *v*) ∈ *E* 都有一个非负整数成本
    *c*(*u, v*)。目标是找到 *G* 的最小成本哈密顿回路（一次遍历）。作为我们符号的扩展，让 *c*(*A*) 表示子集 *A* ⊆ *E* 中边的总成本：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   旅行推销员问题的输入，介绍在
    第 34.5.4 节 中，是一个完全无向图 *G* = (*V*, *E*)，每条边 (*u*, *v*) ∈ *E* 都有一个非负整数成本 *c*(*u,
    v*)。目标是找到 *G* 的最小成本哈密顿回路（一次遍历）。作为我们符号的扩展，让 *c*(*A*) 表示子集 *A* ⊆ *E* 中边的总成本：  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   ![艺术](img/Art_P1487.jpg)'
  en: '![艺术](img/Art_P1487.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1487.jpg)  输出：'
  type: TYPE_IMG
- answer: '-   在许多实际情况下，从一个地点 `u` 到一个地点 `w` 的最经济方式是直接前往，没有中间步骤。换句话说，去掉一个中间停靠点永远不会增加成本。这样的成本函数
    `c` 满足***三角不等式***：对于所有顶点 `u, v, w` ∈ `V`，'
  en: 在许多实际情况下，从一个地点 *u* 到一个地点 *w* 的最经济方式是直接前往，没有中间步骤。换句话说，去掉一个中间停靠点永远不会增加成本。这样的成本函数
    *c* 满足***三角不等式***：对于所有顶点 *u, v, w* ∈ *V*，
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   在许多实际情况下，从一个地点
    *u* 到一个地点 *w* 的最经济方式是直接前往，没有中间步骤。换句话说，去掉一个中间停靠点永远不会增加成本。这样的成本函数 *c* 满足***三角不等式***：对于所有顶点
    *u, v, w* ∈ *V*，  输出：'
  type: TYPE_NORMAL
- answer: '-   `c(u, w) ≤ c(u, v) + c(v, w)`。'
  en: '*c*(*u, w*) ≤ *c*(*u, v*) + *c*(*v, w*)。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *c*(*u, w*)
    ≤ *c*(*u, v*) + *c*(*v, w*)。  输出：'
  type: TYPE_NORMAL
- answer: '-   三角不等式似乎应该自然成立，并且在几个应用中自动满足。例如，如果图的顶点是平面上的点，两个顶点之间的旅行成本是它们之间的普通欧几里德距离，那么三角不等式就满足。此外，许多除欧几里德距离之外的成本函数也满足三角不等式。'
  en: 三角不等式似乎应该自然成立，并且在几个应用中自动满足。例如，如果图的顶点是平面上的点，两个顶点之间的旅行成本是它们之间的普通欧几里德距离，那么三角不等式就满足。此外，许多除欧几里德距离之外的成本函数也满足三角不等式。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   三角不等式似乎应该自然成立，并且在几个应用中自动满足。例如，如果图的顶点是平面上的点，两个顶点之间的旅行成本是它们之间的普通欧几里德距离，那么三角不等式就满足。此外，许多除欧几里德距离之外的成本函数也满足三角不等式。  输出：'
  type: TYPE_NORMAL
- answer: '-   正如习题 35.2-2 所示，即使要求成本函数满足三角不等式，旅行推销员问题也是 NP 完全的。因此，不应期望找到解决此问题的多项式时间算法。你的时间最好花在寻找良好的近似算法上。'
  en: 正如习题 35.2-2 所示，即使要求成本函数满足三角不等式，旅行推销员问题也是 NP 完全的。因此，不应期望找到解决此问题的多项式时间算法。你的时间最好花在寻找良好的近似算法上。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   正如习题 35.2-2
    所示，即使要求成本函数满足三角不等式，旅行推销员问题也是 NP 完全的。因此，不应期望找到解决此问题的多项式时间算法。你的时间最好花在寻找良好的近似算法上。  输出：'
  type: TYPE_NORMAL
- answer: '-   在第 35.2.1 节中，我们研究了具有三角不等式的旅行推销员问题的 `2`-近似算法。在第 35.2.2 节中，我们展示了如果没有三角不等式，则不存在具有恒定近似比的多项式时间近似算法，除非
    P = NP。'
  en: 在第 35.2.1 节中，我们研究了具有三角不等式的旅行推销员问题的 2-近似算法。在第 35.2.2 节中，我们展示了如果没有三角不等式，则不存在具有恒定近似比的多项式时间近似算法，除非
    P = NP。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   在第 35.2.1 节中，我们研究了具有三角不等式的旅行推销员问题的
    2-近似算法。在第 35.2.2 节中，我们展示了如果没有三角不等式，则不存在具有恒定近似比的多项式时间近似算法，除非 P = NP。  输出：'
  type: TYPE_NORMAL
- answer: '- **35.2.1** 具有三角不等式的旅行推销员问题'
  en: '**35.2.1** 具有三角不等式的旅行推销员问题'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **35.2.1**
    具有三角不等式的旅行推销员问题  输出：'
  type: TYPE_NORMAL
- answer: '---

    - 应用前一节的方法论，首先计算一个结构——一个最小生成树，其权重给出最佳旅行推销员路线长度的下界。然后使用最小生成树创建一个路线，其成本不超过最小生成树权重的两倍，只要成本函数满足三角不等式。下一页的
    APPROX-TSP-TOUR 过程实现了这种方法，调用第 596 页的最小生成树算法 MST-PRIM 作为子例程。参数 `G` 是一个完整的无向图，成本函数
    `c` 满足三角不等式。'
  en: 应用前一节的方法论，首先计算一个结构——一个最小生成树，其权重给出最佳旅行推销员路线长度的下界。然后使用最小生成树创建一个路线，其成本不超过最小生成树权重的两倍，只要成本函数满足三角不等式。下一页的
    APPROX-TSP-TOUR 过程实现了这种方法，调用第 596 页的最小生成树算法 MST-PRIM 作为子例程。参数 *G* 是一个完整的无向图，成本函数
    *c* 满足三角不等式。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   应用前一节的方法论，首先计算一个结构——一个最小生成树，其权重给出最佳旅行推销员路线长度的下界。然后使用最小生成树创建一个路线，其成本不超过最小生成树权重的两倍，只要成本函数满足三角不等式。下一页的
    APPROX-TSP-TOUR 过程实现了这种方法，调用第 596 页的最小生成树算法 MST-PRIM 作为子例程。参数 *G* 是一个完整的无向图，成本函数
    *c* 满足三角不等式。  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   回顾第 12.1 节，前序树遍历递归地访问树中的每个顶点，在访问任何子节点之前列出一个顶点。'
  en: 回顾第 12.1 节，前序树遍历递归地访问树中的每个顶点，在访问任何子节点之前列出一个顶点。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   回顾第 12.1 节，前序树遍历递归地访问树中的每个顶点，在访问任何子节点之前列出一个顶点。  输出：'
  type: TYPE_NORMAL
- answer: '-   图 35.2 说明了 APPROX-TSP-TOUR 的操作。图的第一部分展示了一个完整的无向图，第二部分展示了由 MST-PRIM
    从根顶点 `a` 生长出的最小生成树 `T`。第三部分展示了 `T` 的前序遍历如何访问顶点，第四部分展示了相应的路线，即 APPROX-TSP-TOUR
    返回的路线。第五部分展示了一个最佳路线，比最佳路线短约 23%。  '
  en: 图 35.2 说明了 APPROX-TSP-TOUR 的操作。图的第一部分展示了一个完整的无向图，第二部分展示了由 MST-PRIM 从根顶点 *a*
    生长出的最小生成树 *T*。第三部分展示了 *T* 的前序遍历如何访问顶点，第四部分展示了相应的路线，即 APPROX-TSP-TOUR 返回的路线。第五部分展示了一个最佳路线，比最佳路线短约
    23%。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   图 35.2 说明了
    APPROX-TSP-TOUR 的操作。图的第一部分展示了一个完整的无向图，第二部分展示了由 MST-PRIM 从根顶点 *a* 生长出的最小生成树 *T*。第三部分展示了
    *T* 的前序遍历如何访问顶点，第四部分展示了相应的路线，即 APPROX-TSP-TOUR 返回的路线。第五部分展示了一个最佳路线，比最佳路线短约 23%。  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   ![art](img/Art_P1488.jpg)

    ---'
  en: '![art](img/Art_P1488.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P1488.jpg)  输出：'
  type: TYPE_IMG
- en: '**图 35.2** APPROX-TSP-TOUR 的操作。**(a)** 一个完整的无向图。顶点位于整数网格线的交点上。例如，*f* 比 *h*
    右移一单位，上移两单位。两点之间的成本函数是普通的欧几里得距离。**(b)** 完整图的最小生成树 *T*，由 MST-PRIM 计算得出。顶点 *a* 是根顶点。只显示最小生成树中的边。顶点恰好按照字母顺序标记，以便
    MST-PRIM 按照字母顺序将它们添加到主树中。**(c)** *T* 的遍历，从 *a* 开始。树的完整遍历按照顺序访问顶点 *a, b, c, b,
    h, b, a, d, e, f, e, g, e, d, a*。*T* 的前序遍历列出了每个顶点第一次遇到时的顺序，如每个顶点旁边的点所示，得到顺序 *a,
    b, c, h, d, e, f, g*。**(d)** 按照前序遍历给出的顺序访问顶点得到的旅行路线，即 APPROX-TSP-TOUR 返回的路线 *H*。其总成本约为
    19.074。**(e)** 原始完整图的最佳路线 *H*。其总成本约为 14.715。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **图 35.2**
    APPROX-TSP-TOUR 的操作。**(a)** 一个完整的无向图。顶点位于整数网格线的交点上。例如，*f* 比 *h* 右移一单位，上移两单位。两点之间的成本函数是普通的欧几里得距离。**(b)**
    完整图的最小生成树 *T*，由 MST-PRIM 计算得出。顶点 *a* 是根顶点。只显示最小生成树中的边。顶点恰好按照字母顺序标记，以便 MST-PRIM
    按照字母顺序将它们添加到主树中。**(c)** *T* 的遍历，从 *a* 开始。树的完整遍历按照顺序访问顶点 *a, b, c, b, h, b, a,
    d, e, f, e, g, e, d, a*。*T* 的前序遍历列出了每个顶点第一次遇到时的顺序，如每个顶点旁边的点所示，得到顺序 *a, b, c, h,
    d, e, f, g*。**(d)** 按照前序遍历给出的顺序访问顶点得到的旅行路线，即 APPROX-TSP-TOUR 返回的路线 *H*。其总成本约为
    19.074。**(e)** 原始完整图的最佳路线 *H*。其总成本约为 14.715。  输出：'
  type: TYPE_NORMAL
- answer: '-   APPROX-TSP-TOUR (`G`, `c`)'
  en: APPROX-TSP-TOUR (*G*, *c*)
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   APPROX-TSP-TOUR
    (*G*, *c*)  输出：'
  type: TYPE_NORMAL
- answer: '-   | 1 | 选择一个顶点 `r` ∈ `G.V` 作为“根”顶点 |'
  en: '| 1 | 选择一个顶点 *r* ∈ *G.V* 作为“根”顶点 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 1 | 选择一个顶点
    *r* ∈ *G.V* 作为“根”顶点 |  输出：'
  type: TYPE_TB
- answer: "-   | --- | --- |  \n-   | --- | --- |  "
  en: '| --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | --- | ---
    |  输出：'
  type: TYPE_TB
- answer: '-   | `2` | 使用 MST-PRIM (`G`, `c, r`) 为 `G` 从根 `r` 计算最小生成树 `T` |  '
  en: '| 2 | 使用 MST-PRIM (*G*, *c, r*) 为 *G* 从根 *r* 计算最小生成树 *T* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 2 | 使用 MST-PRIM
    (*G*, *c, r*) 为 *G* 从根 *r* 计算最小生成树 *T* |  输出：'
  type: TYPE_TB
- answer: '-   | 3 | 令 `H` 为一个顶点列表，按照它们在 `T` 的前序树遍历中首次访问的顺序排序 |'
  en: '| 3 | 令 *H* 为一个顶点列表，按照它们在 *T* 的前序树遍历中首次访问的顺序排序 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 3 | 令 *H*
    为一个顶点列表，按照它们在 *T* 的前序树遍历中首次访问的顺序排序 |  输出：'
  type: TYPE_TB
- answer: '-   | 4 | **返回** 哈密顿回路 `H` |'
  en: '| 4 | **返回** 哈密顿回路 *H* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 4 | **返回**
    哈密顿回路 *H* |  输出：'
  type: TYPE_TB
- answer: '-   根据练习 21.2-2，即使使用简单的 MST-PRIM 实现，APPROX-TSP-TOUR 的运行时间为 `Θ(V²)`。我们现在证明，如果旅行推销员问题的实例的成本函数满足三角不等式，则
    APPROX-TSP-TOUR 返回的路线成本最多是最佳路线成本的两倍。'
  en: 根据练习 21.2-2，即使使用简单的 MST-PRIM 实现，APPROX-TSP-TOUR 的运行时间为 Θ(*V* ²)。我们现在证明，如果旅行推销员问题的实例的成本函数满足三角不等式，则
    APPROX-TSP-TOUR 返回的路线成本最多是最佳路线成本的两倍。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   根据练习 21.2-2，即使使用简单的
    MST-PRIM 实现，APPROX-TSP-TOUR 的运行时间为 Θ(*V* ²)。我们现在证明，如果旅行推销员问题的实例的成本函数满足三角不等式，则
    APPROX-TSP-TOUR 返回的路线成本最多是最佳路线成本的两倍。  输出：'
  type: TYPE_NORMAL
- answer: '-   ***定理 35.2***'
  en: '***定理 35.2***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***定理 35.2***  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   当三角不等式成立时，`APPROX-TSP-TOUR` 是旅行推销员问题的多项式时间 2-近似算法。'
  en: 当三角不等式成立时，APPROX-TSP-TOUR 是旅行推销员问题的多项式时间 2-近似算法。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   当三角不等式成立时，APPROX-TSP-TOUR
    是旅行推销员问题的多项式时间 2-近似算法。  输出：'
  type: TYPE_NORMAL
- answer: '-   ***证明*** 我们已经看到`APPROX-TSP-TOUR`是多项式时间运行的。'
  en: '***证明*** 我们已经看到 APPROX-TSP-TOUR 是多项式时间运行的。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***证明*** 我们已经看到
    APPROX-TSP-TOUR 是多项式时间运行的。  输出：'
  type: TYPE_NORMAL
- answer: '-   设`H`表示给定顶点集的最优旅行路线。从路线中删除任意边都会得到一棵生成树，每条边的成本都是非负的。因此，`APPROX-TSP-TOUR`
    中第 2 行计算的最小生成树`T`的权重提供了最优旅行路线成本的下界：'
  en: 设*H**表示给定顶点集的最优旅行路线。从路线中删除任意边都会得到一棵生成树，每条边的成本都是非负的。因此，APPROX-TSP-TOUR 中第 2 行计算的最小生成树*T*的权重提供了最优旅行路线成本的下界：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   设*H**表示给定顶点集的最优旅行路线。从路线中删除任意边都会得到一棵生成树，每条边的成本都是非负的。因此，APPROX-TSP-TOUR
    中第 2 行计算的最小生成树*T*的权重提供了最优旅行路线成本的下界：  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   ![艺术](img/Art_P1489.jpg)  '
  en: '![艺术](img/Art_P1489.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1489.jpg)  输出：'
  type: TYPE_IMG
- answer: '---

    -   *T*的`***完整遍历***`列出了首次访问顶点以及在访问子树后返回到它们时的顺序。我们将这种完整遍历称为`*W*`。我们示例的完整遍历给出了顺序  '
  en: '*T*的***完整遍历***列出了首次访问顶点以及在访问子树后返回到它们时的顺序。我们将这种完整遍历称为*W*。我们示例的完整遍历给出了顺序'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *T*的***完整遍历***列出了首次访问顶点以及在访问子树后返回到它们时的顺序。我们将这种完整遍历称为*W*。我们示例的完整遍历给出了顺序  输出：'
  type: TYPE_NORMAL
- answer: '---

    - *a, b, c, b, h, b, a, d, e, f, e, g, e, d, a.*

    ---


    希望这样排版的话对你有所帮助！'
  en: '*a, b, c, b, h, b, a, d, e, f, e, g, e, d, a.*'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *a, b, c, b,
    h, b, a, d, e, f, e, g, e, d, a.*  输出：'
  type: TYPE_NORMAL
- en: 由于完整遍历恰好遍历树*T*的每条边两次，通过将成本*c*的定义自然地扩展以处理边的多重集，我们有
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   由于完整遍历恰好遍历树*T*的每条边两次，通过将成本*c*的定义自然地扩展以处理边的多重集，我们有  输出：'
  type: TYPE_NORMAL
- answer: '-   `![艺术](img/Art_P1490.jpg)`'
  en: '![艺术](img/Art_P1490.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1490.jpg)  输出：'
  type: TYPE_IMG
- answer: '-   不等式`(35.4)`和方程`(35.5)`意味着'
  en: 不等式(35.4)和方程(35.5)意味着
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   不等式(35.4)和方程(35.5)意味着  输出：'
  type: TYPE_NORMAL
- answer: '```

    -   ![艺术](img/Art_P1491.jpg)

    ```'
  en: '![艺术](img/Art_P1491.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1491.jpg)  输出：'
  type: TYPE_IMG
- answer: '-   因此，`W`的成本与最优旅行路线的成本相差不超过 2 倍。'
  en: 因此，*W*的成本与最优旅行路线的成本相差不超过 2 倍。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   因此，*W*的成本与最优旅行路线的成本相差不超过
    2 倍。  输出：'
  type: TYPE_NORMAL
- answer: '-   当然，完整遍历`W`不是一条旅行路线，因为它访问某些顶点超过一次。然而，根据三角不等式，从`W`中删除对任何顶点的访问不会增加成本。（当在访问*u*和*w*之间从`W`中删除顶点`v`时，得到的顺序指定直接从*u*到*w*。）重复对`W`中每次访问顶点的操作，使得`W`只保留每个顶点的第一次访问。在我们的示例中，这个过程留下了顺序'
  en: 当然，完整遍历*W*不是一条旅行路线，因为它访问某些顶点超过一次。然而，根据三角不等式，从*W*中删除对任何顶点的访问不会增加成本。（当在访问*u*和*w*之间从*W*中删除顶点*v*时，得到的顺序指定直接从*u*到*w*。）重复对*W*中每次访问顶点的操作，使得*W*只保留每个顶点的第一次访问。在我们的示例中，这个过程留下了顺序
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   当然，完整遍历*W*不是一条旅行路线，因为它访问某些顶点超过一次。然而，根据三角不等式，从*W*中删除对任何顶点的访问不会增加成本。（当在访问*u*和*w*之间从*W*中删除顶点*v*时，得到的顺序指定直接从*u*到*w*。）重复对*W*中每次访问顶点的操作，使得*W*只保留每个顶点的第一次访问。在我们的示例中，这个过程留下了顺序  输出：'
  type: TYPE_NORMAL
- en: '*a, b, c, h, d, e, f, g.*'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *a, b, c, h,
    d, e, f, g.*  输出：'
  type: TYPE_NORMAL
- en: 这种顺序与通过树*T*的前序遍历获得的顺序相同。设*H*为对应于此前序遍历的循环。它是一个汉密尔顿回路，因为每个顶点都恰好被访问一次，实际上它是由 APPROX-TSP-TOUR
    计算的循环。由于*H*是通过从完整遍历*W*中删除顶点得到的，我们有
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   这种顺序与通过树*T*的前序遍历获得的顺序相同。设*H*为对应于此前序遍历的循环。它是一个汉密尔顿回路，因为每个顶点都恰好被访问一次，实际上它是由
    APPROX-TSP-TOUR 计算的循环。由于*H*是通过从完整遍历*W*中删除顶点得到的，我们有  输出：'
  type: TYPE_NORMAL
- answer: '-   ![艺术](img/Art_P1492.jpg)'
  en: '![艺术](img/Art_P1492.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1492.jpg)  输出：'
  type: TYPE_IMG
- en: 结合不等式(35.6)和(35.7)得到*c*(*H*) ≤ 2*c*(*H**)，证毕。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   结合不等式(35.6)和(35.7)得到*c*(*H*)
    ≤ 2*c*(*H**)，证毕。  输出：'
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ▪  输出：'
  type: TYPE_NORMAL
- en: 尽管定理 35.2 提供了较小的近似比，但 APPROX-TSP-TOUR 通常不是这个问题的最佳实际选择。在实践中通常有其他近似算法表现更好。（请参阅本章末尾的参考文献。）
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   尽管定理 35.2 提供了较小的近似比，但
    APPROX-TSP-TOUR 通常不是这个问题的最佳实际选择。在实践中通常有其他近似算法表现更好。（请参阅本章末尾的参考文献。）  输出：'
  type: TYPE_NORMAL
- en: '**35.2.2    一般旅行推销员问题**'
  prefs: []
  type: TYPE_NORMAL
- en: 当成本函数*c*不满足三角不等式时，除非 P = NP，否则无法在多项式时间内找到良好的近似旅行路线。
  prefs: []
  type: TYPE_NORMAL
- en: '***定理 35.3***'
  prefs: []
  type: TYPE_NORMAL
- en: 如果 P ≠ NP，则对于任意常数*ρ* ≥ 1，一般旅行推销员问题没有近似比为*ρ*的多项式时间近似算法。
  prefs: []
  type: TYPE_NORMAL
- en: '***证明***   证明是通过反证法进行的。假设相反，对于某个数*ρ* ≥ 1，存在近似比为*ρ*的多项式时间近似算法*A*。不失一般性地，假设*ρ*是整数，必要时向上取整。我们将展示如何使用*A*在多项式时间内解决汉密尔顿回路问题的实例。由于第
    34.13 节第 1085 页的定理说汉密尔顿回路问题是 NP 完全的，第 1063 页的定理 34.4 暗示如果它有多项式时间算法，则 P = NP。'
  prefs: []
  type: TYPE_NORMAL
- en: 设*G* = (*V*, *E*)是汉密尔顿回路问题的一个实例。我们将展示如何通过使用假设的近似算法*A*高效确定*G*是否包含汉密尔顿回路。将*G*转换为旅行推销员问题的一个实例，方法如下。设*G*′
    = (*V*, *E*′)是*V*上的完全图，即，
  prefs: []
  type: TYPE_NORMAL
- en: '*E*′ = {(*u*, *v*) : *u, v* ∈ *V* and *u* ≠ *v*}.'
  prefs: []
  type: TYPE_NORMAL
- en: 为*E*′中的每条边分配一个整数成本如下：
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 给定*G*的表示，创建*G*′和*c*的表示需要多项式时间|*V*|和|*E*|。
  prefs: []
  type: TYPE_NORMAL
- en: 现在考虑旅行推销员问题（*G*′，*c*）。如果原始图 *G* 有一个哈密顿循环 *H*，那么成本函数 *c* 为 *H* 的每条边分配成本为 1，因此（*G*′，*c*）包含成本为
    |*V*| 的旅行路线。另一方面，如果 *G* 不包含哈密顿循环，则 *G*′ 的任何旅行路线必须使用一些不在 *E* 中的边。但是任何使用不在 *E* 中的边的旅行路线的成本至少为
  prefs: []
  type: TYPE_NORMAL
- en: '| (*ρ* &#124;*V*&#124; + 1) + (&#124;*V*&#124; − 1) | = | *ρ* &#124;*V*&#124;
    + &#124;*V*&#124; |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|  | > | *ρ* &#124;*V*&#124;. |'
  prefs: []
  type: TYPE_TB
- en: 因为不在 *G* 中的边成本很高，所以在一个是 *G* 中的哈密顿循环的旅行路线的成本（成本为 |*V*|）和任何其他旅行路线的成本（至少为 *ρ*|*V*|
    + |*V*|）之间存在至少 *ρ*|*V*| 的差距。因此，在 *G* 中不是哈密顿循环的旅行路线的成本至少比在 *G* 中是哈密顿循环的旅行路线的成本大
    *ρ* + 1 倍。
  prefs: []
  type: TYPE_NORMAL
- en: 将近似算法 *A* 应用于旅行推销员问题 (*G*′, *c*) 会发生什么？因为 *A* 保证返回的旅行路线成本不会超过最优路线成本的 *ρ* 倍，如果
    *G* 包含一个哈密顿循环，那么 *A* 必须返回它。如果 *G* 没有哈密顿循环，那么 *A* 返回的旅行路线成本将超过 *ρ* |*V*|。因此，使用
    *A* 可以在多项式时间内解决哈密顿循环问题。
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: 定理 35.3 的证明作为证明特定问题不存在良好近似算法的一般技术的示例。给定一个 NP 难的决策问题 *X*，在多项式时间内生成一个最小化问题 *Y*，使得
    *X* 的“是”实例对应于值最多为 *k*（对于某个 *k*）的 *Y* 实例，但 *X* 的“否”实例对应于值大于 *ρk* 的 *Y* 实例。这种技术表明，除非
    P = NP，否则问题 *Y* 没有多项式时间 *ρ* 近似算法。
  prefs: []
  type: TYPE_NORMAL
- en: '**练习**'
  prefs: []
  type: TYPE_NORMAL
- en: '***35.2-1***'
  prefs: []
  type: TYPE_NORMAL
- en: 设 *G* = (*V*, *E*) 是包含至少 3 个顶点的完全无向图，*c* 是满足三角不等式的成本函数。证明对于所有 *u, v* ∈ *V*，有
    *c*(*u, v*) ≥ 0。
  prefs: []
  type: TYPE_NORMAL
- en: '***35.2-2***'
  prefs: []
  type: TYPE_NORMAL
- en: 展示如何在多项式时间内将一个旅行推销员问题的实例转换为另一个满足三角不等式的成本函数的实例。这两个实例必须具有相同的最优路线集。解释为什么这样的多项式时间转换不会违反定理
    35.3，假设 P ≠ NP。
  prefs: []
  type: TYPE_NORMAL
- en: '***35.2-3***'
  prefs: []
  type: TYPE_NORMAL
- en: 考虑以下用于构建满足三角不等式的近似旅行推销员路线的***最近点启发式***。从一个由单个任意选择的顶点组成的平凡循环开始。在每一步中，识别不在循环上但到任何循环上顶点距离最小的顶点
    *u*。假设距离 *u* 最近的循环上的顶点是顶点 *v*。通过在 *v* 之后插入 *u* 来扩展循环以包括 *u*。重复直到所有顶点都在循环上。证明这种启发式返回的旅行路线的总成本不会超过最优路线成本的两倍。
  prefs: []
  type: TYPE_NORMAL
- en: '***35.2-4***'
  prefs: []
  type: TYPE_NORMAL
- en: '***瓶颈旅行推销员问题***的解决方案是最小化循环中成本最高的边的哈密顿循环。假设成本函数满足三角不等式，证明存在一个近似比为 3 的多项式时间近似算法解决这个问题。(*提示:*
    递归地展示如何通过在瓶颈生成树中访问所有节点一次来解决问题 21-4 中讨论的问题 21-4，通过对树进行完整遍历并跳过节点，但不跳过两个连续的中间节点。证明瓶颈生成树中成本最高的边的成本上界受到瓶颈哈密顿循环中成本最高的边的成本的限制。)'
  prefs: []
  type: TYPE_NORMAL
- en: '***35.2-5***'
  prefs: []
  type: TYPE_NORMAL
- en: 假设旅行推销员问题的实例的顶点是平面上的点，成本*c*(*u, v*)是点*u*和*v*之间的欧几里德距离。证明最优旅行路线永远不会交叉。
  prefs: []
  type: TYPE_NORMAL
- en: '***35.2-6***'
  prefs: []
  type: TYPE_NORMAL
- en: 将定理 35.3 的证明改编为证明对于任意常数*c* ≥ 0，不存在近似比为|*V*|^(*c*)的多项式时间近似算法来解决一般旅行推销员问题。
  prefs: []
  type: TYPE_NORMAL
- en: '**35.3    集盖问题**'
  prefs: []
  type: TYPE_NORMAL
- en: 集盖问题是一个优化问题，模拟了许多需要分配资源的问题。其对应的决策问题泛化了 NP 完全的顶点覆盖问题，因此也是 NP 难的。然而，用于处理顶点覆盖问题的近似算法在这里不适用。相反，本节研究了一个具有对数近似比的简单贪婪启发式算法。也就是说，随着实例的规模变大，近似解的大小可能会相对于最优解的大小增长。然而，由于对数函数增长相当缓慢，这种近似算法仍然可能给出有用的结果。
  prefs: []
  type: TYPE_NORMAL
- en: 集盖问题的实例(*X*, *ℱ*)由有限集*X*和*X*的子集族*ℱ*组成，使得*X*的每个元素至少属于*ℱ*中的一个子集：
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1494.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 我们说子族 C ⊆ *ℱ* ***覆盖*** 元素集*U*，如果
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1495.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 问题是找到一个最小大小的子族 C ⊆ *ℱ*，其成员覆盖*X*的所有元素：
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1496.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 图 35.3 展示了集盖问题。C 的大小是它包含的集合数量，而不是这些集合中的个体元素数量，因为覆盖*X*的每个子族 C 必须包含所有|*X*|个体元素。在图
    35.3 中，最小集盖的大小为 3。
  prefs: []
  type: TYPE_NORMAL
- en: 集盖问题抽象了许多常见的组合问题。举个简单的例子，假设*X*代表解决问题所需的技能集，而您有一组可用于解决问题的人员。您希望组建一个委员会，其中包含尽可能少的人员，以便对于*X*中的每个必需技能，委员会的至少一名成员具有该技能。集盖问题的决策版本询问是否存在大小最多为*k*的覆盖，其中*k*是问题实例中指定的附加参数。问题的决策版本是
    NP 完全的，正如练习 35.3-2 要求您展示的那样。
  prefs: []
  type: TYPE_NORMAL
- en: '**一种贪婪近似算法**'
  prefs: []
  type: TYPE_NORMAL
- en: 在对面页面上的 GREEDY-SET-COVER 过程中，贪婪方法通过在每个阶段选择覆盖剩余未覆盖元素最多的集合*S*来工作。在图 35.3 的例子中，GREEDY-SET-COVER
    按顺序添加到 C 中集合*S*[1]、*S*[4]和*S*[5]，然后是*S*[3]或*S*[6]。
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1497.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**图 35.3** 集盖问题的实例(*X*, *ℱ*)，其中*X*由 12 个棕色点组成，*ℱ* = {*S*[1], *S*[2], *S*[3],
    *S*[4], *S*[5], *S*[6], *S*[4], *S*[5]}，每个集合*S[i]* ∈ *ℱ*都用蓝色轮廓标出。最小大小集盖 C = {*S*[3],
    *S*[4], *S*[5]}，大小为 3。贪婪算法通过按顺序选择集合*S*[1]、*S*[4]、*S*[5]和*S*[3]或集合*S*[1]、*S*[4]、*S*[5]和*S*[6]来生成大小为
    4 的覆盖。'
  prefs: []
  type: TYPE_NORMAL
- en: GREEDY-SET-COVER (*X*, *ℱ*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | *U*[0] = *X* |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | C = Ø |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | *i* = 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | **当** *U[i]* ≠ Ø |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 选择*S* ∈ *ℱ*，使得&#124;*S* ∩ *U[i]*&#124;最大 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | *U*[*i*+1] = *U[i]* − *S* |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | C = C ∪ {*S*} |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | *i* = *i* + 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | **返回** C |'
  prefs: []
  type: TYPE_TB
- en: 贪心算法的工作方式如下。在每次迭代开始时，*U[i]*是包含剩余未覆盖元素的*X*的子集，初始子集*U*[0]包含*X*中的所有元素。集合 C 包含正在构建的子族。第
    5 行是贪心决策步骤，选择尽可能覆盖尽可能多未覆盖元素的子集*S*（任意打破平局）。选择*S*后，第 6 行更新剩余未覆盖元素的集合，用*U*[*i*+1]表示，第
    7 行将*S*放入 C。当算法终止时，C 是覆盖*X*的*ℱ*的子族。
  prefs: []
  type: TYPE_NORMAL
- en: '**分析**'
  prefs: []
  type: TYPE_NORMAL
- en: 我们现在展示贪心算法返回的集合覆盖不会比最佳集合覆盖大太多。
  prefs: []
  type: TYPE_NORMAL
- en: '***定理 35.4***'
  prefs: []
  type: TYPE_NORMAL
- en: 在集合*X*和子集族*ℱ*上运行的 GREEDY-SET-COVER 过程是一个多项式时间*O*(lg *X*)-近似算法。
  prefs: []
  type: TYPE_NORMAL
- en: '***证明***   首先我们展示算法在|*X*|和|*ℱ*|的多项式时间内运行。在���4-7 行的循环的迭代次数上界为 min {|*X*|, |*ℱ*|}
    = *O*(|*X*| + |*ℱ*|)。循环体可以实现在*O*(|*X*|·|*ℱ*|)时间内运行。因此，算法在*O*(|*X*|·|*ℱ*|·(|*X*|+|*ℱ*|))时间内运行，这是输入规模的多项式时间。（练习
    35.3-3 要求一个线性时间算法。）'
  prefs: []
  type: TYPE_NORMAL
- en: 为了证明近似界限，让 C*成为原始实例(*X*, *ℱ*)的最佳集合覆盖，并让*k* = |C*|。由于 C*也是算法构造的*X*的每个子集*U[i]*的集合覆盖，我们知道算法构造的任何子集*U[i]*都可以被*k*个集合覆盖。因此，如果(*U[i]*,
    *ℱ*)是集合覆盖问题的实例，其最佳集合覆盖的大小至多为*k*。
  prefs: []
  type: TYPE_NORMAL
- en: 如果实例(*U[i]*, *ℱ*)的最佳集合覆盖大小至多为*k*，则 C 中的至少一个集合覆盖至少|*U[i]*|/*k*个新元素。因此，GREEDY-SET-COVER
    的第 5 行，选择具有最大数量未覆盖元素的集合，必须选择一个其中新覆盖元素数量至少为|*U[i]*|/*k*的集合。在构建*U*[*i*+1]时，这些元素被移除，得到
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1498.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 迭代不等式(35.8)给出
  prefs: []
  type: TYPE_NORMAL
- en: '| &#124;*U*[0]&#124; | = | &#124;*X*&#124;, |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;*U*[1]&#124; | ≤ | &#124;*U*[0]&#124; (1 − 1/*k*), |'
  prefs: []
  type: TYPE_TB
- en: '| &#124;*U*[2]&#124; | ≤ | &#124;*U*[1]&#124; (1 − 1/*k*) = &#124;*U*&#124;
    (1 − 1/*k*)², |'
  prefs: []
  type: TYPE_TB
- en: 一般地
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1499.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 算法在*U[i]* = Ø时停止，这意味着|*U[i]*| < 1。因此，算法的迭代次数的上界是使|*U[i]*| < 1 的最小*i*值。
  prefs: []
  type: TYPE_NORMAL
- en: 由于对于所有实数*x*，都有 1 + *x* ≤ *e^x*（参见第 66 页不等式(3.14)），通过令*x* = −1/*k*，我们有 1 − 1/*k*
    ≤ *e*^(−1/*k*)，因此(1 − 1/*k*)*^k* ≤ (*e*^(−1/*k*))*^k* = 1/*e*。将迭代次数*i*表示为*ck*，其中*c*是某个非负整数，我们希望找到*c*，使得
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1500.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 将两边乘以*e^c*，然后取两边的自然对数得到*c* ≥ ln |*X*|，因此我们可以选择*c*为至少 ln |*X*|的任意整数。我们选择*c* =
    ⌈ln |*X*|⌉。由于*i* = *ck*是迭代次数的上界，等于 C 的大小，而*k* = |C*|，我们有|C| ≤ *i* = *ck* = *c*
    |C*| = |C*| ⌈ln |*X*|⌉，定理得证。
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '**练习**'
  prefs: []
  type: TYPE_NORMAL
- en: '***35.3-1***'
  prefs: []
  type: TYPE_NORMAL
- en: 将以下每个单词视为一个字母集合：{arid, dash, drain, heard, lost, nose, shun, slate, snare, thread}。展示在偏向字典中首次出现的单词的情况下，GREEDY-SET-COVER
    产生的集合覆盖。
  prefs: []
  type: TYPE_NORMAL
- en: '***35.3-2***'
  prefs: []
  type: TYPE_NORMAL
- en: 通过将顶点覆盖问题简化为决策版本的集合覆盖问题，证明集合覆盖问题是 NP 完全的。
  prefs: []
  type: TYPE_NORMAL
- en: '***35.3-3***'
  prefs: []
  type: TYPE_NORMAL
- en: 展示如何实现 GREEDY-SET-COVER 以在*O*(Σ[*S*∈*ℱ*] |*S*|)时间内运行。
  prefs: []
  type: TYPE_NORMAL
- en: '***35.3-4***'
  prefs: []
  type: TYPE_NORMAL
- en: 定理 35.4 的证明表明，当 GREEDY-SET-COVER 在实例 (*X*, *ℱ*) 上运行并返回子族 C 时，|C| ≤ |C*| ⌈ln
    *X*⌉。证明以下更弱的界是显而易见的：
  prefs: []
  type: TYPE_NORMAL
- en: '|C| ≤ |C*| max {|*S*| : *S* ∈ *ℱ*}.'
  prefs: []
  type: TYPE_NORMAL
- en: '***35.3-5***'
  prefs: []
  type: TYPE_NORMAL
- en: GREEDY-SET-COVER 可以返回多种不同的解决方案，取决于它如何在第 5 行中打破平局。给出一个过程 BAD-SET-COVER-INSTANCE
    (*n*)，返回一个包含 *n* 个元素的集合覆盖问题实例，取决于第 5 行如何打破平局，GREEDY-SET-COVER 可以返回指数级的不同解决方案。
  prefs: []
  type: TYPE_NORMAL
- en: '**35.4    随机化和线性规划**'
  prefs: []
  type: TYPE_NORMAL
- en: 本节研究了设计近似算法的两种有用技术：随机化和线性规划。它从一个简单的优化版本 3-CNF 可满足性的随机算法开始，然后展示了如何基于线性规划设计一个加权版本的顶点覆盖问题的近似算法。本节只是浅尝辄止这两种强大技术。章节注释提供了进一步研究这些领域的参考资料。
  prefs: []
  type: TYPE_NORMAL
- en: '**MAX-3-CNF 可满足性的随机近似算法**'
  prefs: []
  type: TYPE_NORMAL
- en: 就像一些随机算法计算精确解决方案一样，一些随机算法计算近似解决方案。我们说一个问题的随机算法具有*ρ*(*n*)的***近似比***，如果对于任何大小为
    *n* 的输入，随机算法产生的解的*期望*成本 *C* 与最优解的��本 *C** 之间的比例因子为 *ρ*(*n*)：
  prefs: []
  type: TYPE_NORMAL
- en: '![art](img/Art_P1501.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 我们称一个达到近似比 *ρ*(*n*) 的随机算法为***随机化 ρ*(*n*) 近似算法***。换句话说，随机近似算法类似于确定性近似算法，只是近似比是针对期望成本的。
  prefs: []
  type: TYPE_NORMAL
- en: 如 34.4 节 中定义的 3-CNF 可满足性的特定实例可能是可满足的，也可能不可满足。为了可满足，必须存在一种变量赋值，使得每个子句评估为 1。如果一个实例不可满足，你可能希望知道它距离可满足有多“接近”，也就是找到一种变量赋值，使尽可能多的子句得到满足。我们称这个结果最大化问题为***MAX-3-CNF
    可满足性***。MAX-3-CNF 可满足性的输入与 3-CNF 可满足性相同，目标是返回一种变量赋值，最大化评估为 1 的子句数量。你可能会惊讶地发现，随机将每个变量设置为
    1 的概率为 1/2，设置为 0 的概率为 1/2，会产生一个随机的 8/7 近似算法，但我们即将看到原因。回想一下 34.4 节 中对 3-CNF 可满足性的定义要求每个子句由三个不同的文字组成。我们现在进一步假设没有子句包含变量及其否定。练习
    35.4-1 要求你移除这最后一个假设。
  prefs: []
  type: TYPE_NORMAL
- en: '***定理 35.5***'
  prefs: []
  type: TYPE_NORMAL
- en: 给定具有 *n* 个变量 *x*[1]、*x*[2]、…，*x[n]* 和 *m* 个子句的 MAX-3-CNF 可满足性实例，独立将每个变量设置为 1
    的概率为 1/2，设置为 0 的概率为 1/2 的随机算法是一个随机的 8/7 近似算法。
  prefs: []
  type: TYPE_NORMAL
- en: '***证明***   假设每个变量独立地以概率 1/2 设置为 1，以概率 1/2 设置为 0。定义，对于 *i* = 1, 2, …，*m*，指示器随机变量'
  prefs: []
  type: TYPE_NORMAL
- en: '*Y*[*i*] = I {子句 *i* 被满足},'
  prefs: []
  type: TYPE_NORMAL
- en: 使得只要第*i*个子句中的文字之一设置为 1，*Y[i]* = 1。由于同一子句中没有文字出现多次，并且我们假设没有变量及其否定同时出现在同一子句中，每个子句中的三个文字的设置是独立的。只有当一个子句的三个文字都设置为
    0 时，子句才不满足，因此 Pr {子句*i*不满足} = (1/2)³ = 1/8。因此，我们有 Pr {子句*i*满足} = 1 − 1/8 = 7/8，而第
    130 页的引理 5.1 给出了 E [*Y[i]*] = 7/8。设*Y*是总体满足子句的数量，因此*Y* = *Y*[1] + *Y*[2] + ⋯ +
    *Y[m]*。那么，我们有
  prefs: []
  type: TYPE_NORMAL
- en: '![art](img/Art_P1502.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 由于*m*是满足子句数量的上界，因此近似比最多为*m*/(7*m*/8) = 8/7。
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '**使用线性规划近似加权顶点覆盖**'
  prefs: []
  type: TYPE_NORMAL
- en: '***最小权重顶点覆盖问题***的输入是一个无向图*G* = (*V*, *E*)，其中每个顶点*v*∈*V*都有一个相关的正权重*w*(*v*)。顶点覆盖*V*′⊆*V*的权重*w*(*V*′)是其顶点权重之和：*w*(*V*′)
    = Σ[*v*∈*V′*] *w*(*v*)。目标是找到最小权重的顶点覆盖。'
  prefs: []
  type: TYPE_NORMAL
- en: 来自第 35.1 节的无权顶点覆盖的近似算法在这里不起作用，因为它返回的解可能远非加权问题的最优解。相反，我们将首先通过线性规划计算最小权重顶点覆盖的下界。然后我们将“舍入”这个解并用它来获得一个顶点覆盖。
  prefs: []
  type: TYPE_NORMAL
- en: 首先，将每个顶点*v*∈*V*关联一个变量*x*(*v*)，并要求对于每个*v*∈*V*，*x*(*v*)等于 0 或 1。如果*x*(*v*) = 1，则顶点覆盖包括*v*。然后，对于任意边(*u*,
    *v*)，至少*u*和*v*中的一个必须属于顶点覆盖的约束可以表示为*x*(*u*) + *x*(*v*) ≥ 1。这个视角引出了用于寻找最小权重顶点覆盖的以下***0-1
    整数规划***：
  prefs: []
  type: TYPE_NORMAL
- en: '![art](img/Art_P1503.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 满足
  prefs: []
  type: TYPE_NORMAL
- en: '![art](img/Art_P1504.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 在所有权重*w*(*v*)均为 1 的特殊情况下，这个公式是 NP 难的顶点覆盖问题的优化版本。让我们去掉*x*(*v*)∈{0, 1}的约束，并用 0
    ≤ *x*(*v*) ≤ 1 替换它，得到以下线性规划：
  prefs: []
  type: TYPE_NORMAL
- en: '![art](img/Art_P1505.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 满足
  prefs: []
  type: TYPE_NORMAL
- en: '![art](img/Art_P1506.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 我们将这个线性规划称为***线性规划松弛***。在第(35.12)–(35.14)行中 0-1 整数规划的任何可行解也是第(35.15)–(35.18)行中其线性规划松弛的可行解。因此，线性规划松弛的最优解值提供了
    0-1 整数规划最优解值的下界，从而提供了最小权重顶点覆盖问题的最优权重下界。
  prefs: []
  type: TYPE_NORMAL
- en: 面对页面的 APPROX-MIN-WEIGHT-VC 过程从线性规划松弛的解开始，并使用它构建一个最小权重顶点覆盖问题的近似解。该过程的工作方式如下。第
    1 行将顶点覆盖初始化为空。第 2 行制定了第(35.15)–(35.18)行中的线性规划松弛，然后解决这个线性规划。最优解为每个顶点*v*分配一个相关值*x*(*v*)，其中
    0 ≤ *x*(*v*) ≤ 1。该过程使用这个值来指导在第 3–5 行中将哪些顶点添加到顶点覆盖*C*中：当且仅当*x*(*v*) ≥ 1/2 时，顶点覆盖*C*包括顶点*v*。实际上，该过程将解中的每个分数变量“舍入”为
    0 或 1，以获得第(35.12)–(35.14)行中 0-1 整数规划的解。最后，第 6 行返回顶点覆盖*C*。
  prefs: []
  type: TYPE_NORMAL
- en: '***定理 35.6***'
  prefs: []
  type: TYPE_NORMAL
- en: 算法 APPROX-MIN-WEIGHT-VC 是最小权重顶点覆盖问题的一个多项式时间 2 近似算法。
  prefs: []
  type: TYPE_NORMAL
- en: APPROX-MIN-WEIGHT-VC(*G*, *w*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | *C* = Ø |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | 计算*x*，线性规划松弛(35.15)–(35.18)行的最优解 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | **对于** 每个顶点 *v* ∈ *V* |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | **如果** *x*(*v*) ≥ 1/2 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | *C* = *C* ∪ {*v*} |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | **返回** *C* |'
  prefs: []
  type: TYPE_TB
- en: '***证明*** 因为有一个多项式时间算法来解决第 2 行中的线性规划，且因为第 3–5 行的**for**循环在多项式时间内运行，APPROX-MIN-WEIGHT-VC
    是一个多项式时间算法。'
  prefs: []
  type: TYPE_NORMAL
- en: 需要证明 APPROX-MIN-WEIGHT-VC 是一个 2 近似算法。让*C*是最小权重顶点覆盖问题的最优解，*z*是在(35.15)–(35.18)行中线性规划松弛的最优解的值。由于最优顶点覆盖是线性规划松弛的可行解，*z*必须是*w*(*C*)的下界，即，
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1507.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 接下来，我们声称在第 3–5 行中对变量*x*(*v*)的分数值四舍五入会产生一个顶点覆盖集*C*，并且满足*w*(*C*) ≤ 2*z*。要看到*C*是一个顶点覆盖，考虑任意边(*u*,
    *v*) ∈ *E*。根据约束(35.16)，我们知道*x*(*u*) + *x*(*v*) ≥ 1，这意味着*x*(*u*)和*x*(*v*)中至少一个至少为
    1/2。因此，*u*和*v*中至少一个包含在顶点覆盖中，因此每条边都被覆盖。
  prefs: []
  type: TYPE_NORMAL
- en: 现在我们考虑覆盖的重量。我们有
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1508.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 结合不等式(35.19)和(35.20)得到
  prefs: []
  type: TYPE_NORMAL
- en: '*w*(*C*) ≤ 2*z* ≤ 2*w*(*C**),'
  prefs: []
  type: TYPE_NORMAL
- en: 因此 APPROX-MIN-WEIGHT-VC 是一个 2 近似算法。
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '**练习**'
  prefs: []
  type: TYPE_NORMAL
- en: '***35.4-1***'
  prefs: []
  type: TYPE_NORMAL
- en: 显示即使一个子句允许包含一个变量及其否定，随机将每个变量设置为 1 的概率为 1/2，设置为 0 的概率为 1/2 仍会产生一个随机的 8/7 近似算法。
  prefs: []
  type: TYPE_NORMAL
- en: '***35.4-2***'
  prefs: []
  type: TYPE_NORMAL
- en: '***MAX-CNF 可满足性问题***类似于 MAX-3-CNF 可满足性问题，不过它不限制每个子句只有三个文字。给出 MAX-CNF 可满足性问题的一个随机的
    2 近似算法。'
  prefs: []
  type: TYPE_NORMAL
- en: '***35.4-3***'
  prefs: []
  type: TYPE_NORMAL
- en: 在 MAX-CUT 问题中，输入是一个无权无向图*G* = (*V*, *E*)。我们定义一个切割(*S*, *V* − *S*)如第二十一章中所述，切割的***权重***是穿过切割的边的数量。���标是找到最大权重的切割。假设每个顶点*v*以
    1/2 的概率随机且独立地放入*S*，以 1/2 的概率放入*V* −*S*。证明这个算法是一个随机的 2 近似算法。
  prefs: []
  type: TYPE_NORMAL
- en: '***35.4-4***'
  prefs: []
  type: TYPE_NORMAL
- en: 显示第(35.17)行中的约束是冗余的，即从(35.15)–(35.18)行中的线性规划松弛中删除它们会产生一个线性规划，其中任何最优解*x*必须满足对于每个*v*
    ∈ *V*，*x*(*v*) ≤ 1。
  prefs: []
  type: TYPE_NORMAL
- en: '**35.5    子集和问题**'
  prefs: []
  type: TYPE_NORMAL
- en: 从 34.5.5 节回顾，子集和问题的一个实例由一对(*S*, *t*)给出，其中*S*是一组{*x*[1], *x*[2], … , *x[n]*}的正整数，*t*是一个正整数。这个决策问题询问是否存在一个*S*的子集，其总和恰好等于目标值*t*。正如我们在
    34.5.5 节中看到的，这个问题是 NP 完全的。
  prefs: []
  type: TYPE_NORMAL
- en: 与这个决策问题相关的优化问题在实际应用中出现。优化问题寻求一个{*x*[1], *x*[2], … , *x[n]*}的子集，其总和尽可能大但不超过*t*。例如，考虑一辆最多能装载*t*磅的卡车，需要装载最多*n*个不同的箱子，第*i*个箱子的重量为*x[i]*磅。卡车可以承载多重货物而不超过*t*磅的重量限制？
  prefs: []
  type: TYPE_NORMAL
- en: 我们从一个指数时间算法开始，计算这个优化问题的最优值。然后我们展示如何修改算法，使其成为一个完全多项式时间逼近方案。（回想一下，一个完全多项式时间逼近方案的运行时间是
    1/*ϵ* 的多项式，以及输入大小的多项式。）
  prefs: []
  type: TYPE_NORMAL
- en: '**一个指数时间的精确算法**'
  prefs: []
  type: TYPE_NORMAL
- en: 假设你计算每个子集 *S*′ 的元素之和，然后在不超过 *t* 的子集中选择最接近 *t* 的子集。这个算法返回最优解，但可能需要指数时间。要实现这个算法，可以使用一个迭代过程，在第
    *i* 次迭代中，计算 {*x*[1], *x*[2], … , *x[i]*} 的所有子集的和，起始点是 {*x*[1], *x*[2], … , *x*[*i*−1]}
    的所有子集的和。在这样做时，你会意识到一旦特定子集 *S*′ 的和超过 *t*，就没有理由维护它，因为 *S*′ 的任何超集都不可能是最优解。让我们看看如何实现这个策略。
  prefs: []
  type: TYPE_NORMAL
- en: 过程 EXACT-SUBSET-SUM 接受一个输入集合 *S* = {*x*[1], *x*[2], … , *x[n]*}，大小 *n* = |*S*|，目标值
    *t*。该过程迭代计算 *L[i]*，{*x*[1], … , *x[i]*} 的所有子集的和列表，这些和不超过 *t*，然后返回 *L[n]* 中的最大值。
  prefs: []
  type: TYPE_NORMAL
- en: 如果 *L* 是一个正整数列表，*x* 是另一个正整数，则让 *L* + *x* 表示从 *L* 派生的整数列表，通过将 *L* 的每个元素增加 *x*。例如，如果
    *L* = 〈1, 2, 3, 5, 9〉，那么 *L* + 2 = 〈3, 4, 5, 7, 11〉。这种表示法扩展到集合，因此
  prefs: []
  type: TYPE_NORMAL
- en: '*S* + *x* = {*s* + *x* : *s* ∈ *S*}.'
  prefs: []
  type: TYPE_NORMAL
- en: EXACT-SUBSET-SUM (*S*, *n, t*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | *L*[0] = 〈0〉 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | **对于** *i* = 1 **到** *n* |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | *L[i]* = MERGE-LISTS (*L*[*i*−1], *L*[*i*−1] + *x[i]*) |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | 从 *L[i]* 中移除大于 *t* 的每个元素 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | **返回** *L*[*n*] 中的最大元素 |'
  prefs: []
  type: TYPE_TB
- en: EXACT-SUBSET-SUM 调用一个辅助过程 MERGE-LISTS (*L*, *L*′)，返回其两个已排序输入列表 *L* 和 *L*′ 的合并列表，去除重复值。就像我们在第
    36 页上使用的合并排序中使用的 MERGE 过程一样，MERGE-LISTS 在 *O*(|*L*| + |*L*′|) 时间内运行。我们省略了 MERGE-LISTS
    的伪代码。
  prefs: []
  type: TYPE_NORMAL
- en: 要了解 EXACT-SUBSET-SUM 的工作原理，让 *P[i]* 表示通过选择 {*x*[1], *x*[2], … , *x[i]*} 的每个（可能为空）子集并求和其成员得到的值集合。例如，如果
    *S* = {1, 4, 5}，那么
  prefs: []
  type: TYPE_NORMAL
- en: '| *P*[1] | = | {0, 1}, |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| *P*[2] | = | {0, 1, 4, 5}, |'
  prefs: []
  type: TYPE_TB
- en: '| *P*[3] | = | {0, 1, 4, 5, 6, 9, 10}. |'
  prefs: []
  type: TYPE_TB
- en: 给定身份
  prefs: []
  type: TYPE_NORMAL
- en: '![art](img/Art_P1509.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 你可以通过对 *i* 进行归纳证明（见练习 35.5-1），列表 *L[i]* 是一个排序列表，包含 *P[i]* 中值不超过 *t* 的每个元素。由于
    *L[i]* 的长度最多可以达到 2^(*i*)，所以 EXACT-SUBSET-SUM 通常是一个指数时间算法，尽管在 *t* 是 |*S*| 的多项式或
    *S* 中的所有数字受到 |*S*| 的多项式限制的特殊情况下，它是一个多项式时���算法。
  prefs: []
  type: TYPE_NORMAL
- en: '**一个完全多项式时间逼近方案**'
  prefs: []
  type: TYPE_NORMAL
- en: 设计一个完全多项式时间逼近方案的关键是在创建每个列表 *L[i]* 后“修剪”它们。修剪的背后思想是：如果 *L* 中的两个值接近，那么由于目标只是一个近似解，就没有必要显式地维护它们。更确切地说，使用修剪参数
    *δ*，使得 0 < *δ* < 1。当通过 *δ* 修剪列表 *L* 时，尽可能多地从 *L* 中移除元素，这样，如果 *L*′ 是修剪 *L* 的结果，则对于每个从
    *L* 中移除的元素 *y*，仍在 *L*′ 中的某个元素 *z* 近似于 *y*。为了使 *z* 近似于 *y*，它必须不大于 *y*，并且在 1 + *δ*
    的因子内接近 *y*，以便
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1510.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 你可以将这样的 *z* 视为在新列表 *L*′ 中“表示” *y*。每个删除的元素 *y* 都由满足不等式 (35.22) 的剩余元素 *z* 表示。例如，假设
    *δ* = 0.1 和
  prefs: []
  type: TYPE_NORMAL
- en: '*L* = 〈10, 11, 12, 15, 20, 21, 22, 23, 24, 29〉.'
  prefs: []
  type: TYPE_NORMAL
- en: 然后修剪 *L* 的结果是
  prefs: []
  type: TYPE_NORMAL
- en: '*L*′ = 〈10, 12, 15, 20, 23, 29〉,'
  prefs: []
  type: TYPE_NORMAL
- en: 其中删除的值 11 由 10 表示，删除的值 21 和 22 由 20 表示，删除的值 24 由 23 表示。因为修剪后列表的每个元素也是原始列表的元素，所以修剪可以显著减少保留的元素数量，同时保持每个删除元素的一个接近（稍小）的代表值。
  prefs: []
  type: TYPE_NORMAL
- en: 过程 TRIM 在 Θ(*m*) 时间内修剪列表 *L* = 〈*y*[1], *y*[2], … , *y[m]*〉，给定 *L* 和修剪参数 *δ*。它假设
    *L* 已按单调递增顺序排序。该过程的输出是一个修剪后的、排序后的列表。该过程按单调递增顺序扫描 *L* 的元素。仅当它是 *L*′ 中的第一个元素或者不能由最近放入
    *L*′ 的数字表示时，才将数字附加到返回的列表 *L*′ 上。
  prefs: []
  type: TYPE_NORMAL
- en: 修剪 (*L*, *δ*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | 让 *m* 为 *L* 的长度 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | *L*′ = 〈*y*[1]〉 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | *last* = *y*[1] |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | **对于** *i* = 2 **到** *m* |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | **如果** *y*[*i*] > *last* · (1 + *δ*) | **//** 因为 *L* 已排序，所以 *y[i]* ≥
    *last* |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 将 *y[i]* 附加到 *L*′ 的末尾 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | *last* = *y[i]* |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | **返回** *L*′ |'
  prefs: []
  type: TYPE_TB
- en: 给定过程 TRIM，下一页的 APPROX-SUBSET-SUM 过程实现了近似方案。该过程将一个包含 *n* 个整数（任意顺序）的集合 *S* = {*x*[1],
    *x*[2], … , *x[n]*}、大小 *n* = |*S*|、目标整数 *t* 和近似参数 *ϵ* 作为输入，其中
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1511.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 它返回一个值 *z**，其值在最优解的 1 + *ϵ* 范围内。
  prefs: []
  type: TYPE_NORMAL
- en: 近似子集和过程的工作方式如下。第 1 行将列表 *L*[0] 初始化为仅包含元素 0 的列表。第 2–5 行的 **for** 循环计算 *L[i]*，作为包含适当修剪版本的集合
    *P[i]* 的排序列表，所有大于 *t* 的元素都被移除。由于该过程从 *L*[*i*−1] 创建 *L[i]*，因此必须确保重复修剪不会引入太多的累积不准确性。这就是为什么在调用
    TRIM 时，修剪参数不是 *ϵ*，而是较��的值 *ϵ*/2*n*。我们很快将看到，如果存在正确的近似值，APPROX-SUBSET-SUM 将返回一个正确的近似值。
  prefs: []
  type: TYPE_NORMAL
- en: 近似子集和 (*S*, *n, t, ϵ*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | *L*[0] = 〈0〉 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | **对于** *i* = 1 **到** *n* |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | *L[i]* = 合并列表 (*L*[*i*−1], *L*[*i*−1] + *x[i]*) |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | *L[i]* = 修剪 (*L*[*i*], *ϵ*/2*n*) |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | 从 *L[i]* 中删除大于 *t* 的每个元素 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | 让 *z** 为 *L[n]* 中的最大值 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | **返回** *z** |'
  prefs: []
  type: TYPE_TB
- en: 举例来说，假设 APPROX-SUBSET-SUM 给出
  prefs: []
  type: TYPE_NORMAL
- en: '*S* = 〈104, 102, 201, 101〉'
  prefs: []
  type: TYPE_NORMAL
- en: 当 *t* = 308 且 *ϵ* = 0.40 时。修剪参数 *δ* 为 *ϵ*/2*n* = 0.40/80 = 0.05。该过程在指定的行上计算以下数值：
  prefs: []
  type: TYPE_NORMAL
- en: '| 第 1 行: | *L*[0] = 〈0〉, |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 第 3 行: | *L*[1] = 〈0, 104〉, |'
  prefs: []
  type: TYPE_TB
- en: '| 第 4 行: | *L*[1] = 〈0, 104〉, |'
  prefs: []
  type: TYPE_TB
- en: '| 第 5 行: | *L*[1] = 〈0, 104〉, |'
  prefs: []
  type: TYPE_TB
- en: '| 第 3 行: | *L*[2] = 〈0, 102, 104, 206〉, |'
  prefs: []
  type: TYPE_TB
- en: '| 第 4 行: | *L*[2] = 〈0, 102, 206〉, |'
  prefs: []
  type: TYPE_TB
- en: '| 第 5 行: | *L*[2] = 〈0, 102, 206〉, |'
  prefs: []
  type: TYPE_TB
- en: '| 第 3 行: | *L*[3] = 〈0, 102, 201, 206, 303, 407〉, |'
  prefs: []
  type: TYPE_TB
- en: '| 第 4 行: | *L*[3] = 〈0, 102, 201, 303, 407〉, |'
  prefs: []
  type: TYPE_TB
- en: '| 第 5 行: | *L*[3] = 〈0, 102, 201, 303〉, |'
  prefs: []
  type: TYPE_TB
- en: '| 第 3 行: | *L*[4] = 〈0, 101, 102, 201, 203, 302, 303, 404〉, |'
  prefs: []
  type: TYPE_TB
- en: '| 第 4 行: | *L*[4] = 〈0, 101, 201, 302, 404〉, |'
  prefs: []
  type: TYPE_TB
- en: '| 第 5 行: | *L*[4] = 〈0, 101, 201, 302〉。 |'
  prefs: []
  type: TYPE_TB
- en: 该过程返回 *z** = 302 作为其答案，这个答案很好地在最优答案 307 = 104 + 102 + 101 的 *ϵ* = 40% 范围内。实际上，它在
    2% 范围内。
  prefs: []
  type: TYPE_NORMAL
- en: '***定理 35.7***'
  prefs: []
  type: TYPE_NORMAL
- en: APPROX-SUBSET-SUM 是子集和问题的全多项式时间逼近方案。
  prefs: []
  type: TYPE_NORMAL
- en: '***证明***   第 4 行中修剪*L[i]* 和从*L[i]* 中删除大于*t* 的每个元素的操作保持*L[i]* 的每个元素也是*P[i]*
    的成员。因此，第 7 行返回的值*z** 确实是*S* 的某个子集的和，即*z** ∈ *P[n]*。让*y** ∈ *P[n]* 表示子集和问题的最优解，使得它是小于或等于*t*
    的*P[n]* 中的最大值。因为第 5 行确保*z** ≤ *t*，我们知道*z** ≤ *y**。根据不等式（35.1），我们需要证明*y**/*z**
    ≤ 1 + *ϵ*。我们还必须证明该算法的运行时间对 1/*ϵ* 和输入大小都是多项式的。'
  prefs: []
  type: TYPE_NORMAL
- en: 正如练习 35.5-2 要求的那样，对于*P[i]* 中最多为*t*的每个元素*y*，存在一个元素*z* ∈ *L[i]*，使得
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1512.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 不等式（35.24）必须对*P[n]* 中的*y** 成立，因此存在一个元素*z* ∈ *L[n]*，使得
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1513.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 因此
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1514.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 由于存在一个元素*z* ∈ *L[n]* 满足不等式（35.25），因此不等式必须对*z** 成立，而*z** 是*L[n]* 中的最大值，也就是说
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1515.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 现在我们要证明*y**/*z** ≤ 1 + *ϵ*。我们通过证明（1 +*ϵ*/2*n*）*^n* ≤ 1 + *ϵ* 来实现这一点。首先，不等式（35.23），0
    < *ϵ* < 1，意味着
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1516.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 接下来，根据第 66 页方程（3.16），我们有 lim*n*→∞*^n* = *e*^(*ϵ*/2)。练习 35.5-3 要求你证明
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1517.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 因此，函数(1 + *ϵ*/2*n*)*^n* 随着*n*的增加而增加，接近其极限*e*^(*ϵ*/2)，我们有
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1518.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 结合不等式（35.26）和（35.29）完成了逼近比率的分析。
  prefs: []
  type: TYPE_NORMAL
- en: 为了证明 APPROX-SUBSET-SUM 是子集和问题的全多项式时间逼近方案，我们对*L[i]* 的长度进行了限制。修剪后，连续的*L[i]* 元素*z*
    和*z*′ 必须满足*z*′/*z* > 1 + *ϵ*/2*n*。也就是说，它们之间的差异至少为 1 + *ϵ*/2*n*。因此，每个列表最多包含值 0，可能包含值
    1，以及最多⌊log[1 + *ϵ*/2*n*] *t*⌋ 个额外值。因此，每个列表*L[i]* 中的元素数量最多为
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1519.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 这个限制是输入大小的多项式——即表示*t* 所需的位数 lg *t* 加上表示集合*S* 所需的位数，而*S* 又是*n*的多项式——以及 1/*ϵ*
    的。由于 APPROX-SUBSET-SUM 的运行时间是列表*L[i]* 长度的多项式，我们得出结论，APPROX-SUBSET-SUM 是子集和问题的全多项式时间逼近方案。
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '**练习**'
  prefs: []
  type: TYPE_NORMAL
- en: '***35.5-1***'
  prefs: []
  type: TYPE_NORMAL
- en: 证明方程（35.21）。然后证明执行 EXACT-SUBSET-SUM 的第 4 行后，*L[i]* 是一个排序列表，包含每个值不超过*t* 的*P[i]*
    中的元素。
  prefs: []
  type: TYPE_NORMAL
- en: '***35.5-2***'
  prefs: []
  type: TYPE_NORMAL
- en: 使用对*i*的归纳，证明不等式（35.24）。
  prefs: []
  type: TYPE_NORMAL
- en: '***35.5-3***'
  prefs: []
  type: TYPE_NORMAL
- en: 证明不等式（35.28）。
  prefs: []
  type: TYPE_NORMAL
- en: '***35.5-4***'
  prefs: []
  type: TYPE_NORMAL
- en: 你如何修改本节中提出的逼近方案，以找到不小于*t* 且是给定输入列表的某个子集和的良好逼近值？
  prefs: []
  type: TYPE_NORMAL
- en: '***35.5-5***'
  prefs: []
  type: TYPE_NORMAL
- en: 修改 APPROX-SUBSET-SUM 过程，以返回总和为*z** 的*S* 子集。
  prefs: []
  type: TYPE_NORMAL
- en: '**问题**'
  prefs: []
  type: TYPE_NORMAL
- en: '***35-1     装箱问题***'
  prefs: []
  type: TYPE_NORMAL
- en: 给定一组*n*个对象，其中第*i*个对象的大小*s[i]* 满足 0 < *s*[*i*] < 1。你的目标是将所有对象装入最少数量的单位大小箱中。每个箱子可以容纳任何总大小不超过
    1 的对象子集。
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** 证明确定所需最小箱数的问题是 NP 难的。（*提示：*从子集和问题简化。）'
  prefs: []
  type: TYPE_NORMAL
- en: '***第一适合*** 启发式算法依次处理每个对象，并将其放入第一个能容纳它的箱子中，具体如下。它维护一个有序的箱子列表。让*b*表示列表中的箱子数，其中*b*随着算法的进行而增加，让〈*B*[1],
    … , *B[b]*〉为箱子列表。最初*b* = 0 且列表为空。算法依次处理每个对象*i*，并将其放入仍然能容纳它的编号最低的箱子中。如果没有箱子能容纳对象*i*，则增加*b*并打开一个新箱子*B[b]*，其中包含对象*i*。让![art](img/Art_P1520.jpg)。'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** 论证所需的最优箱子数量至少为⌈*S*⌉。'
  prefs: []
  type: TYPE_NORMAL
- en: '***c.*** 论证第一适合启发式算法最多使一个箱子至多填充一半。'
  prefs: []
  type: TYPE_NORMAL
- en: '***d.*** 证明第一适合启发式算法使用的箱子数量永远不会超过⌈2*S*⌉。'
  prefs: []
  type: TYPE_NORMAL
- en: '***e.*** 证明第一适合启发式算法的近似比率为 2。'
  prefs: []
  type: TYPE_NORMAL
- en: '***f.*** 给出第一适合启发式算法的高效实现，并分析其运行时间。'
  prefs: []
  type: TYPE_NORMAL
- en: '***35-2     最大团大小的近似***'
  prefs: []
  type: TYPE_NORMAL
- en: 设*G* = (*V*, *E*)为一个无向图。对于任何*k* ≥ 1，定义*G*^((*k*))为无向图(*V* ^((*k*)), *E*^((*k*)))，其中*V* ^((*k*))是*V*中所有有序*k*元组的集合，*E*^((*k*))被定义为当且仅当对于*i*
    = 1, 2, … , *k*，要么在*G*中顶点*v[i]*与*w[i]*相邻，要么*v[i]* = *w[i]*时，(*v*[1], *v*[2], …
    , *v[k]*)与(*w*[1], *w*[2], … , *w[k]*)相邻。
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** 证明*G*^((*k*))中最大团的大小等于*G*中最大团的大小的*k*次幂。'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** 论证如果存在一个近似算法，其在寻找最大团时具有恒定的近似比率，那么该问题存在一个多项式时间的近似方案。'
  prefs: []
  type: TYPE_NORMAL
- en: '***35-3     加权集覆盖问题***'
  prefs: []
  type: TYPE_NORMAL
- en: 假设集合在集覆盖问题中具有权重，因此家族*ℱ*中的每个集合*S[i]*都有一个相关的权重*w[i]*。覆盖 C 的权重是![art](img/Art_P1521.jpg)。目标是确定最小权重的覆盖。(35.3
    节处理了*w[i]* = 1 的情况。)
  prefs: []
  type: TYPE_NORMAL
- en: 展示如何将贪婪集覆盖启发式算法自然地推广以为加权集覆盖问题的任何实例提供近似解。让*d*是任何集合*S[i]*的最大大小，证明你的启发式算法具有近似比率为![art](img/Art_P1522.jpg)。
  prefs: []
  type: TYPE_NORMAL
- en: '***35-4     最大匹配***'
  prefs: []
  type: TYPE_NORMAL
- en: 回想一下对于无向图*G*，匹配是一组边，使得集合中没有两条边与同一顶点相邻。25.1 节展示了如何在二部图中找到���大匹配，即一种不包含更多边的匹配。本问题研究了不需要是二部图的无向图中的匹配。
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** 通过展示一个无向图*G*和*G*中一个最大匹配*M*的极大匹配不一定是最大匹配来展示。(*提示:* 你可以找到一个只有四个顶点的图。)'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** 考虑一个连通的无向图*G* = (*V*, *E*)。给出一个*O*(*E*)时间的贪婪算法来找到*G*中的极大匹配。'
  prefs: []
  type: TYPE_NORMAL
- en: 本问题集中在最大匹配的多项式时间近似算法上。尽管已知的最快最大匹配算法需要超线性（但是多项式）时间，但这里的近似算法将在线性时间内运行。你将证明部分(b)中极大匹配的线性时间贪婪算法是最大匹配的
    2-近似算法。
  prefs: []
  type: TYPE_NORMAL
- en: '***c.*** 证明*G*中最大匹配的大小是*G*中任何顶点覆盖的大小的下界。'
  prefs: []
  type: TYPE_NORMAL
- en: '***d.*** 考虑*G* = (*V*, *E*)中的一个最大匹配*M*。设*T* = {*v* ∈ *V* : *M*中的某条边与*v*相邻}。关于*G*中不在*T*中的顶点诱导的子图，你能说些什么？'
  prefs: []
  type: TYPE_NORMAL
- en: '***e.*** 从(d)部分得出，2 |*M*| 是*G*的一个顶点覆盖的大小。'
  prefs: []
  type: TYPE_NORMAL
- en: '***f.*** 利用(c)和(e)部分，证明(b)部分中的贪心算法是最大匹配的 2 近似算法。'
  prefs: []
  type: TYPE_NORMAL
- en: '***35-5     并行机器调度***'
  prefs: []
  type: TYPE_NORMAL
- en: '在***并行机器调度问题***中，输入有两部分：*n*个作业*J*[1]，*J*[2]，…，*J[n]*，其中每个作业*J[k]*具有非负处理时间*p[k]*，以及*m*台相同的机器*M*[1]，*M*[2]，…，*M[m]*。任何作业都可以在任何机器上运行。一个***调度***指定了每个作业*J[k]*运行的机器以及运行期间。每个作业*J[k]*必须在某台机器*M[i]*上运行*p[k]*个连续的时间单位，而在此期间内，没有其他作业可以在*M[i]*上运行。设*C[k]*表示作业*J[k]*的***完成时间***，即作业*J[k]*完成处理的时间。给定一个调度，定义*C*[max]
    = max {*C[j]* : 1 ≤ *j* ≤ *n*}为调度的***最大完成时间***。目标是找到使最大完成时间最小的调度。'
  prefs: []
  type: TYPE_NORMAL
- en: 例如，考虑有两台机器*M*[1]和*M*[2]，以及四个作业*J*[1]，*J*[2]，*J*[3]和*J*[4]，其中*p*[1] = 2，*p*[2]
    = 12，*p*[3] = 4，*p*[4] = 5。那么一个可能的调度是，在机器*M*[1]上，作业*J*[1]后跟作业*J*[2]，在机器*M*[2]上，作业*J*[4]后跟作业*J*[3]。对于这个调度，*C*[1]
    = 2，*C*[2] = 14，*C*[3] = 9，*C*[4] = 5，*C*[max] = 14。一个最优调度是在机器*M*[1]上运行作业*J*[2]，在机器*M*[2]上运行作业*J*[1]，*J*[3]和*J*[4]。对于这个调度，我们有*C*[1]
    = 2，*C*[2] = 12，*C*[3] = 6，*C*[4] = 11，因此*C*[max] = 12。
  prefs: []
  type: TYPE_NORMAL
- en: 给定并行机器调度问题的输入，让![艺术](img/Art_P1522a.jpg)表示最优调度的最大完成时间。
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** 证明最优完成时间至少与最大处理时间一样大，即'
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1522b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**b.** 证明最优完成时间至少与平均机器负载一样大，即'
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1523.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 考虑以下并行机器调度的贪心算法：每当一台机器空闲时，调度尚未被调度的任何作业。
  prefs: []
  type: TYPE_NORMAL
- en: '***c.*** 编写伪代码来实现这个贪心算法。你的算法的运行时间是多少？'
  prefs: []
  type: TYPE_NORMAL
- en: '***d.*** 对于贪心算法返回的调度，证明'
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P1524.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 得出这个算法是一个多项式时间的 2 近似算法。
  prefs: []
  type: TYPE_NORMAL
- en: '***35-6     近似计算最大生成树***'
  prefs: []
  type: TYPE_NORMAL
- en: '设*G* = (*V*, *E*)是一个具有不同边权重*w*(*u, v*)的无向图，其中每条边(*u*, *v*) ∈ *E*。对于每个顶点*v*
    ∈ *V*，用 max(*v*)表示与该顶点相邻的最大权重边。设*S*[G]= {max(*v*) : *v* ∈ *V* }为每个顶点相邻的最大权重边的集合，*T*[G]为*G*的最大权重生成树，即总权重最大的生成树。对于边的任意子集*E*′
    ⊆ *E*，定义*w*(*E*′) = Σ[(*u*,*v*)∈*E′*] *w*(*u, v*)。'
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** 给出至少有 4 个顶点的图的一个例子，其中*S*[G] = *T[G]*。'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** 给出至少有 4 个顶点的图的一个例子，其中*S*[G] ≠ *T[G]*。'
  prefs: []
  type: TYPE_NORMAL
- en: '***c.*** 证明对于任意图*G*，*S*[G] ⊆ *T*[G]。'
  prefs: []
  type: TYPE_NORMAL
- en: '***d.*** 证明对于任意图*G*，*w*(*S[G]*) ≥ *w*(*T[G]*)/2。'
  prefs: []
  type: TYPE_NORMAL
- en: '***e.*** 给出一个*O*(*V* + *E*)时间复杂度的算法，计算最大生成树的 2 近似值。'
  prefs: []
  type: TYPE_NORMAL
- en: '***35-7     0-1 背包问题的近似算法***'
  prefs: []
  type: TYPE_NORMAL
- en: 回顾来自第 15.2 节的背包问题。输入包括*n*个物品，第*i*个物品价值为*v[i]*美元，重量为*w[i]*磅。输入还包括背包的容量，即*W*磅。在这里，我们进一步假设每个重量*w[i]*最多为*W*，并且物品按照其价值的单调递减顺序进行索引：*v*[1]
    ≥ *v*[2] ≥ ⋯ ≥ *v[n]*。
  prefs: []
  type: TYPE_NORMAL
- en: 在 0-1 背包问题中，目标是找到一个物品子集，其总重量最多为*W*，总价值最大。分数背包问题类似于 0-1 背包问题，不同之处在于每个物品的一部分可以放入背包中，而不是全部或没有。如果物品*i*的一部分*x[i]*放入背包中，其中
    0 ≤ *x[i]* ≤ 1，则它对背包的重量贡献了*x[i]w[i]*，并增加了价值*x[i]v[i]*。这个问题的目标是为 0-1 背包问题设计一个多项式时间的
    2 近似算法。
  prefs: []
  type: TYPE_NORMAL
- en: 为了设计一个多项式时间算法，让我们考虑 0-1 背包问题的受限实例。给定背包问题的实例*I*，通过移除物品 1、2、…、*j* − 1 并要求解决方案包括物品*j*（在分数和
    0-1 背包问题中都包括物品*j*）来形成受限实例*I[j]*，其中*j* = 1, 2, …, *n*。在实例*I*[1]中没有移除任何物品。对于实例*I[j]*，让*P[j]*表示
    0-1 问题的最优解，*Q[j]*表示分数问题的最优解。
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** 论证 0-1 背包问题实例*I*的最优解是{*P*[1], *P*[2], …, *P*[n]*}中的一个。'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** 证明为了找到实例*I[j]*的分数问题的最优解*Q[j]*，可以包括物品*j*，然后使用贪婪算法，在每一步中尽可能多地选择具有最大单位价值*v[i]*/*w[i]*的未选择物品，其中*i*
    ∈ {*j* + 1, *j* + 2, …, *n*}。'
  prefs: []
  type: TYPE_NORMAL
- en: '***c.*** 证明总是存在一个实例*I[j]*的分数问题的最优解*Q[j]*，其中至多包含一个物品的分数部分。也就是说，除了可能有一个物品外，其他物品要么全部放入背包，要么全部不放入。'
  prefs: []
  type: TYPE_NORMAL
- en: '***d.*** 给定实例*I[j]*的分数问题的最优解*Q[j]*，通过从*Q[j]*中删除任何分数物品形成解*R[j]*。让*v*(*S*)表示解*S*中取出的物品的总价值。证明*v*(*R[j]*)
    ≥ *v*(*Q[j]*)/2 ≥ *v*(*P[j]*)/2。'
  prefs: []
  type: TYPE_NORMAL
- en: '***e.*** 给出一个多项式时间算法，从集合{*R*[1], *R*[2], …, *R*[n]*}中返回一个最��价值的解，并证明你的算法是 0-1
    背包问题的多项式时间 2 近似算法。'
  prefs: []
  type: TYPE_NORMAL
- en: '**章节注释**'
  prefs: []
  type: TYPE_NORMAL
- en: 尽管数千年来已知不一定计算出精确解的方法（例如，近似计算*π*值的方法），但近似算法的概念要新得多。Hochbaum [221] 将多项式时间近似算法的概念归功于
    Garey、Graham 和 Ullman [175] 以及 Johnson [236]。第一个这样的算法通常归功于 Graham [197]。
  prefs: []
  type: TYPE_NORMAL
- en: 从这项早期工作开始，已经为各种问题设计了成千上万个近似算法，并且在这一领域有大量的文献。Ausiello 等人[29]，Hochbaum[221]，Vazirani[446]，以及
    Williamson 和 Shmoys[459]的文本专门涉及近似算法，Shmoys[409]和 Klein 与 Young[256]的调查也是如此。其他一些文本，如
    Garey 和 Johnson[176]以及 Papadimitriou 和 Steiglitz[353]也有相当涵盖近似算法。Lawler，Lenstra，Rinnooy
    Kan 和 Shmoys[277]以及 Gutin 和 Punnen[204]编辑的书籍提供了关于旅行推销员问题的近似算法和启发式方法的广泛论述。
  prefs: []
  type: TYPE_NORMAL
- en: Papadimitriou 和 Steiglitz 将算法 APPROX-VERTEX-COVER 归因于 F. Gavril 和 M. Yannakakis。顶点覆盖问题已经得到广泛研究（Hochbaum[221]列出了
    16 种不同的近似算法），但所有的近似比至少为 2−*o*(1)。
  prefs: []
  type: TYPE_NORMAL
- en: 算法 APPROX-TSP-TOUR 出现在 Rosenkrantz，Stearns 和 Lewis 的论文中[384]。Christofides 改进了这个算法，并为具有三角不等式的旅行推销员问题提供了
    3/2 近似算法。Arora[23]和 Mitchell[330]已经证明，如果点位于欧几里得平面上，那么存在一个多项式时间的近似方案。定理 35.3 归因于
    Sahni 和 Gonzalez[392]。
  prefs: []
  type: TYPE_NORMAL
- en: 算法 APPROX-SUBSET-SUM 及其分析松散地模仿了 Ibarra 和 Kim[234]关于背包和子集和问题的相关近似算法。
  prefs: []
  type: TYPE_NORMAL
- en: 问题 35-7 是由 Bienstock 和 McClosky[55]关于近似背包型整数规划的更一般结果的组合版本。
  prefs: []
  type: TYPE_NORMAL
- en: MAX-3-CNF 可满足性的随机算法在 Johnson 的工作中是隐含的[236]。加权顶点覆盖算法由 Hochbaum[220]提出。第 35.4
    节仅涉及在设计近似算法中随机化和线性规划的力量。这两种思想的结合产生了一种称为“随机舍入”的技术，它将问题制定为整数线性规划，解决线性规划松弛问题，并将解决方案中的变量解释为概率。这些概率然后有助于指导原始问题的解决方案。这种技术首次由
    Raghavan 和 Thompson[374]使用，后来被广泛应用。（有关调查，请参见 Motwani，Naor 和 Raghavan[335]。）近似算法领域中其他一些显著的思想包括原始-对偶方法（请参见
    Goemans 和 Williamson[184]的调查），为分治算法找到稀疏切割[288]，以及使用半定规划[183]。
  prefs: []
  type: TYPE_NORMAL
- en: 正如第三十四章的章节注释中所提到的，概率可检验证明的结果导致了许多问题的近似下界，包括本章中的几个问题。除了那里的参考文献外，Arora 和 Lund
    的章节[26]中对概率可检验证明与各种问题近似难度之间的关系有很好的描述。
  prefs: []
  type: TYPE_NORMAL
- en: ¹ 当近似比率与*n*无关时，我们使用术语“*ρ*的近似比率”和“*ρ*近似算法”，表示不依赖于*n*。
  prefs: []
  type: TYPE_NORMAL
