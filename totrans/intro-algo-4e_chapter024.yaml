- en: '[**24        Maximum Flow**](toc.xhtml#chap-24)'
  prefs: []
  type: TYPE_NORMAL
- en: Just as you can model a road map as a directed graph in order to find the shortest
    path from one point to another, you can also interpret a directed graph as a “flow
    network” and use it to answer questions about material flows. Imagine a material
    coursing through a system from a source, where the material is produced, to a
    sink, where it is consumed. The source produces the material at some steady rate,
    and the sink consumes the material at the same rate. The “flow” of the material
    at any point in the system is intuitively the rate at which the material moves.
    Flow networks can model many problems, including liquids flowing through pipes,
    parts through assembly lines, current through electrical networks, and information
    through communication networks.
  prefs: []
  type: TYPE_NORMAL
- en: You can think of each directed edge in a flow network as a conduit for the material.
    Each conduit has a stated capacity, given as a maximum rate at which the material
    can flow through the conduit, such as 200 gallons of liquid per hour through a
    pipe or 20 amperes of electrical current through a wire. Vertices are conduit
    junctions, and other than the source and sink, material flows through the vertices
    without collecting in them. In other words, the rate at which material enters
    a vertex must equal the rate at which it leaves the vertex. We call this property
    “flow conservation,” and it is equivalent to Kirchhoff’s current law when the
    material is electrical current.
  prefs: []
  type: TYPE_NORMAL
- en: The goal of the maximum-flow problem is to compute the greatest rate for shipping
    material from the source to the sink without violating any capacity constraints.
    It is one of the simplest problems concerning flow networks and, as we shall see
    in this chapter, this problem can be solved by efficient algorithms. Moreover,
    other network-flow problems are solvable by adapting the basic techniques used
    in maximum-flow algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter presents two general methods for solving the maximum-flow problem.
    [Section 24.1](chapter024.xhtml#Sec_24.1) formalizes the notions of flow networks
    and flows, formally defining the maximum-flow problem. [Section 24.2](chapter024.xhtml#Sec_24.2)
    describes the classical method of Ford and Fulkerson for finding maximum flows.
    We finish up with a simple application of this method, finding a maximum matching
    in an undirected bipartite graph, in [Section 24.3](chapter024.xhtml#Sec_24.3).
    ([Section 25.1](chapter025.xhtml#Sec_25.1) will give a more efficient algorithm
    that is specifically designed to find a maximum matching in a bipartite graph.)
  prefs: []
  type: TYPE_NORMAL
- en: '[**24.1    Flow networks**](toc.xhtml#Rh1-141)'
  prefs: []
  type: TYPE_NORMAL
- en: This section gives a graph-theoretic definition of flow networks, discusses
    their properties, and defines the maximum-flow problem precisely. It also introduces
    some helpful notation.
  prefs: []
  type: TYPE_NORMAL
- en: '**Flow networks and flows**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A ***flow network*** *G* = (*V*, *E*) is a directed graph in which each edge
    (*u*, *v*) ∈ *E* has a nonnegative ***capacity*** *c*(*u*, *v*) ≥ 0\. We further
    require that if *E* contains an edge (*u*, *v*), then there is no edge (*v*, *u*)
    in the reverse direction. (We’ll see shortly how to work around this restriction.)
    If (*u*, *v*) ∉ *E*, then for convenience we define *c*(*u*, *v*) = 0, and we
    disallow self-loops. Each flow network contains two distinguished vertices: a
    ***source*** *s* and a ***sink*** *t*. For convenience, we assume that each vertex
    lies on some path from the source to the sink. That is, for each vertex *v* ∈
    *V*, the flow network contains a path *s* ⇝ *v* ⇝ *t*. Because each vertex other
    than *s* has at least one entering edge, we have |*E*| ≥ |*V* | − 1\. [Figure
    24.1](chapter024.xhtml#Fig_24-1) shows an example of a flow network.'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P753.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 24.1 (a)** A flow network *G* = (*V*, *E*) for the Lucky Puck Company’s
    trucking problem. The Vancouver factory is the source *s*, and the Winnipeg warehouse
    is the sink *t*. The company ships pucks through intermediate cities, but only
    *c*(*u*, *v*) crates per day can go from city *u* to city *v*. Each edge is labeled
    with its capacity. **(b)** A flow *f* in *G* with value |*f* | = 19\. Each edge
    (*u*, *v*) is labeled by *f* (*u*, *v*)/*c*(*u*, *v*). The slash notation merely
    separates the flow and capacity and does not indicate division.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are now ready to define flows more formally. Let *G* = (*V*, *E*) be a flow
    network with a capacity function *c*. Let *s* be the source of the network, and
    let *t* be the sink. A ***flow*** in *G* is a real-valued function *f* : *V* ×
    *V* → ℝ that satisfies the following two properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Capacity constraint:** For all *u*, *v* ∈ *V*, we require'
  prefs: []
  type: TYPE_NORMAL
- en: 0 ≤ *f*(*u*, *v*) ≤ *c*(*u*, *v*).
  prefs: []
  type: TYPE_NORMAL
- en: The flow from one vertex to another must be nonnegative and must not exceed
    the given capacity.
  prefs: []
  type: TYPE_NORMAL
- en: '**Flow conservation:** For all *u* ∈ *V* − {*s*, *t*}, we require'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P754.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The total flow into a vertex other than the source or sink must equal the total
    flow out of that vertex—informally, “flow in equals flow out.”
  prefs: []
  type: TYPE_NORMAL
- en: When (*u*, *v*) ∉ *E*, there can be no flow from *u* to *v*, and *f* (*u*, *v*)
    = 0.
  prefs: []
  type: TYPE_NORMAL
- en: We call the nonnegative quantity *f* (*u*, *v*) the flow from vertex *u* to
    vertex *v*. The ***value*** |*f* | of a flow *f* is defined as
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P755.jpg)'
  prefs: []
  type: TYPE_IMG
- en: that is, the total flow out of the source minus the flow into the source. (Here,
    the |·| notation denotes flow value, not absolute value or cardinality.) Typically,
    a flow network does not have any edges into the source, and the flow into the
    source, given by the summation Σ[*v*∈*V*] *f*(*v*, *s*), is 0\. We include it,
    however, because when we introduce residual networks later in this chapter, the
    flow into the source can be positive. In the ***maximum-flow problem***, the input
    is a flow network *G* with source *s* and sink *t*, and the goal is to find a
    flow of maximum value.
  prefs: []
  type: TYPE_NORMAL
- en: '**An example of flow**'
  prefs: []
  type: TYPE_NORMAL
- en: A flow network can model the trucking problem shown in [Figure 24.1(a)](chapter024.xhtml#Fig_24-1).
    The Lucky Puck Company has a factory (source *s*) in Vancouver that manufactures
    hockey pucks, and it has a warehouse (sink *t*) in Winnipeg that stocks them.
    Lucky Puck leases space on trucks from another firm to ship the pucks from the
    factory to the warehouse. Because the trucks travel over specified routes (edges)
    between cities (vertices) and have a limited capacity, Lucky Puck can ship at
    most *c*(*u*, *v*) crates per day between each pair of cities *u* and *v* in [Figure
    24.1(a)](chapter024.xhtml#Fig_24-1). Lucky Puck has no control over these routes
    and capacities, and so the company cannot alter the flow network shown in [Figure
    24.1(a)](chapter024.xhtml#Fig_24-1). They need to determine the largest number
    *p* of crates per day that they can ship and then to produce this amount, since
    there is no point in producing more pucks than they can ship to their warehouse.
    Lucky Puck is not concerned with how long it takes for a given puck to get from
    the factory to the warehouse. They care only that *p* crates per day leave the
    factory and *p* crates per day arrive at the warehouse.
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P756.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 24.2** Converting a network with antiparallel edges to an equivalent
    one with no antiparallel edges. **(a)** A flow network containing both the edges
    (*v*[1], *v*[2]) and (*v*[2], *v*[1]). **(b)** An equivalent network with no antiparallel
    edges. A new vertex *v*′ was added, and edge (*v*[1], *v*[2]) was replaced by
    the pair of edges (*v*[1], *v*′) and (*v*′, *v*[2]), both with the same capacity
    as (*v*[1], *v*[2]).'
  prefs: []
  type: TYPE_NORMAL
- en: A flow in this network models the “flow” of shipments because the number of
    crates shipped per day from one city to another is subject to a capacity constraint.
    Additionally, the model must obey flow conservation, for in a steady state, the
    rate at which pucks enter an intermediate city must equal the rate at which they
    leave. Otherwise, crates would accumulate at intermediate cities.
  prefs: []
  type: TYPE_NORMAL
- en: '**Modeling problems with antiparallel edges**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose that the trucking firm offers Lucky Puck the opportunity to lease space
    for 10 crates in trucks going from Edmonton to Calgary. It might seem natural
    to add this opportunity to our example and form the network shown in [Figure 24.2(a)](chapter024.xhtml#Fig_24-2).
    This network suffers from one problem, however: it violates the original assumption
    that if edge (*v*[1], *v*[2]) ∈ *E*, then (*v*[2], *v*[1]) ∉ *E*. We call the
    two edges (*v*[1], *v*[2]) and (*v*[2], *v*[1]) ***antiparallel***. Thus, to model
    a flow problem with antiparallel edges, the network must be transformed into an
    equivalent one containing no antiparallel edges. [Figure 24.2(b)](chapter024.xhtml#Fig_24-2)
    displays this equivalent network. To transform the network, choose one of the
    two antiparallel edges, in this case (*v*[1], *v*[2]), and split it by adding
    a new vertex *v*′ and replacing edge (*v*[1], *v*[2]) with the pair of edges (*v*[1],
    *v*′) and (*v*′, *v*[2]). Also set the capacity of both new edges to the capacity
    of the original edge. The resulting network satisfies the property that if an
    edge belongs to the network, the reverse edge does not. As Exercise 24.1-1 asks
    you to prove, the resulting network is equivalent to the original one.'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P757.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 24.3** Converting a multiple-source, multiple-sink maximum-flow problem
    into a problem with a single source and a single sink. **(a)** A flow network
    with three sources *S* = {*s*[1], *s*[2], *s*[3]} and two sinks *T* = {*t*[1],
    *t*[2]}. **(b)** An equivalent single-source, single-sink flow network. Add a
    supersource *s* and an edge with infinite capacity from *s* to each of the multiple
    sources. Also add a supersink *t* and an edge with infinite capacity from each
    of the multiple sinks to *t*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Networks with multiple sources and sinks**'
  prefs: []
  type: TYPE_NORMAL
- en: A maximum-flow problem may have several sources and sinks, rather than just
    one of each. The Lucky Puck Company, for example, might actually have a set of
    *m* factories {*s*[1], *s*[2], …, *s*[*m*]} and a set of *n* warehouses {*t*[1],
    *t*[2], …, *t*[*n*]}, as shown in [Figure 24.3(a)](chapter024.xhtml#Fig_24-3).
    Fortunately, this problem is no harder than ordinary maximum flow.
  prefs: []
  type: TYPE_NORMAL
- en: The problem of determining a maximum flow in a network with multiple sources
    and multiple sinks reduces to an ordinary maximum-flow problem. [Figure 24.3(b)](chapter024.xhtml#Fig_24-3)
    shows how to convert the network from (a) to an ordinary flow network with only
    a single source and a single sink. Add a ***supersource*** *s* and add a directed
    edge (*s*, *s*[*i*]) with capacity *c*(*s*, *s*[*i*]) = ∞ for each *i* = 1, 2,
    …, *m*. Similarly, create a new ***supersink*** *t* and add a directed edge (*t*[*i*],
    *t*) with capacity *c*(*t*[*i*], *t*) = ∞ for each *i* = 1, 2, …, *n*. Intuitively,
    any flow in the network in (a) corresponds to a flow in the network in (b), and
    vice versa. The single supersource *s* provides as much flow as desired for the
    multiple sources *s*[*i*], and the single supersink *t* likewise consumes as much
    flow as desired for the multiple sinks *t*[*i*]. Exercise 24.1-2 asks you to prove
    formally that the two problems are equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs: []
  type: TYPE_NORMAL
- en: '***24.1-1***'
  prefs: []
  type: TYPE_NORMAL
- en: Show that splitting an edge in a flow network yields an equivalent network.
    More formally, suppose that flow network *G* contains edge (*u*, *v*), and define
    a new flow network *G*′ by creating a new vertex *x* and replacing (*u*, *v*)
    by new edges (*u*, *x*) and (*x*, *v*) with *c*(*u*, *x*) = *c*(*x*, *v*) = *c*(*u*,
    *v*). Show that a maximum flow in *G*′ has the same value as a maximum flow in
    *G*.
  prefs: []
  type: TYPE_NORMAL
- en: '***24.1-2***'
  prefs: []
  type: TYPE_NORMAL
- en: Extend the flow properties and definitions to the multiple-source, multiple-sink
    problem. Show that any flow in a multiple-source, multiple-sink flow network corresponds
    to a flow of identical value in the single-source, single-sink network obtained
    by adding a supersource and a supersink, and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: '***24.1-3***'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that a flow network *G* = (*V*, *E*) violates the assumption that the
    network contains a path *s* ⇝ *v* ⇝ *t* for all vertices *v* ∈ *V*. Let *u* be
    a vertex for which there is no path *s* ⇝ *u* ⇝ *t*. Show that there must exist
    a maximum flow *f* in *G* such that *f* (*u*, *v*) = *f* (*v*, *u*) = 0 for all
    vertices *v* ∈ *V*.
  prefs: []
  type: TYPE_NORMAL
- en: '***24.1-4***'
  prefs: []
  type: TYPE_NORMAL
- en: Let *f* be a flow in a network, and let *α* be a real number. The ***scalar
    flow product***, denoted *αf*, is a function from *V* × *V* to ℝ defined by
  prefs: []
  type: TYPE_NORMAL
- en: (*αf*)(*u*, *v*) = *α* · *f* (*u*, *v*).
  prefs: []
  type: TYPE_NORMAL
- en: Prove that the flows in a network form a ***convex set***. That is, show that
    if *f*[1] and *f*[2] are flows, then so is *αf*[1] + (1 − *α*) *f*[2] for all
    *α* in the range 0 ≤ *α* ≤ 1.
  prefs: []
  type: TYPE_NORMAL
- en: '***24.1-5***'
  prefs: []
  type: TYPE_NORMAL
- en: State the maximum-flow problem as a linear-programming problem.
  prefs: []
  type: TYPE_NORMAL
- en: '***24.1-6***'
  prefs: []
  type: TYPE_NORMAL
- en: Professor Adam has two children who, unfortunately, dislike each other. The
    problem is so severe that not only do they refuse to walk to school together,
    but in fact each one refuses to walk on any block that the other child has stepped
    on that day. The children have no problem with their paths crossing at a corner.
    Fortunately both the professor’s house and the school are on corners, but beyond
    that he is not sure if it is going to be possible to send both of his children
    to the same school. The professor has a map of his town. Show how to formulate
    the problem of determining whether both his children can go to the same school
    as a maximum-flow problem.
  prefs: []
  type: TYPE_NORMAL
- en: '***24.1-7***'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that, in addition to edge capacities, a flow network has ***vertex capacities***.
    That is each vertex *v* has a limit *l*(*v*) on how much flow can pass through
    *v*. Show how to transform a flow network *G* = (*V*, *E*) with vertex capacities
    into an equivalent flow network *G*′ = (*V*′, *E*′) without vertex capacities,
    such that a maximum flow in *G*′ has the same value as a maximum flow in *G*.
    How many vertices and edges does *G*′ have?
  prefs: []
  type: TYPE_NORMAL
- en: '[**24.2    The Ford-Fulkerson method**](toc.xhtml#Rh1-142)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This section presents the Ford-Fulkerson method for solving the maximum-flow
    problem. We call it a “method” rather than an “algorithm” because it encompasses
    several implementations with differing running times. The Ford-Fulkerson method
    depends on three important ideas that transcend the method and are relevant to
    many flow algorithms and problems: residual networks, augmenting paths, and cuts.
    These ideas are essential to the important max-flow min-cut theorem (Theorem 24.6),
    which characterizes the value of a maximum flow in terms of cuts of the flow network.
    We end this section by presenting one specific implementation of the Ford-Fulkerson
    method and analyzing its running time.'
  prefs: []
  type: TYPE_NORMAL
- en: The Ford-Fulkerson method iteratively increases the value of the flow. It starts
    with *f* (*u*, *v*) = 0 for all *u*, *v* ∈ *V*, giving an initial flow of value
    0\. Each iteration increases the flow value in *G* by finding an “augmenting path”
    in an associated “residual network” *G*[*f*]. The edges of the augmenting path
    in *G*[*f*] indicate on which edges in *G* to update the flow in order to increase
    the flow value. Although each iteration of the Ford-Fulkerson method increases
    the value of the flow, we’ll see that the flow on any particular edge of *G* may
    increase or decrease. Although it might seem counterintuitive to decrease the
    flow on an edge, doing so may enable flow to increase on other edges, allowing
    more flow to travel from the source to the sink. The Ford-Fulkerson method, given
    in the procedure FORD-FULKERSON-METHOD, repeatedly augments the flow until the
    residual network has no more augmenting paths. The max-flow min-cut theorem shows
    that upon termination, this process yields a maximum flow.
  prefs: []
  type: TYPE_NORMAL
- en: FORD-FULKERSON-METHOD (*G*, *s*, *t*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | initialize flow *f* to 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | **while** there exists an augmenting path *p* in the residual network
    *G*[*f*] |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | augment flow *f* along *p* |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | **return** *f* |'
  prefs: []
  type: TYPE_TB
- en: In order to implement and analyze the Ford-Fulkerson method, we need to introduce
    several additional concepts.
  prefs: []
  type: TYPE_NORMAL
- en: '**Residual networks**'
  prefs: []
  type: TYPE_NORMAL
- en: Intuitively, given a flow network *G* and a flow *f*, the residual network *G*[*f*]
    consists of edges whose capacities represent how the flow can change on edges
    of *G*. An edge of the flow network can admit an amount of additional flow equal
    to the edge’s capacity minus the flow on that edge. If that value is positive,
    that edge goes into *G*[*f*] with a “residual capacity” of *c*[*f*] (*u*, *v*)
    = *c*(*u*, *v*) − *f* (*u*, *v*). The only edges of *G* that belong to *G*[*f*]
    are those that can admit more flow. Those edges (*u*, *v*) whose flow equals their
    capacity have *c*[*f*] (*u*, *v*) = 0, and they do not belong to *G*[*f*].
  prefs: []
  type: TYPE_NORMAL
- en: You might be surprised that the residual network *G*[*f*] can also contain edges
    that are not in *G*. As an algorithm manipulates the flow, with the goal of increasing
    the total flow, it might need to decrease the flow on a particular edge in order
    to increase the flow elsewhere. In order to represent a possible decrease in the
    positive flow *f* (*u*, *v*) on an edge in *G*, the residual network *G*[*f*]
    contains an edge (*v*, *u*) with residual capacity *c*[*f*] (*v*, *u*) = *f* (*u*,
    *v*)—that is, an edge that can admit flow in the opposite direction to (*u*, *v*),
    at most canceling out the flow on (*u*, *v*). These reverse edges in the residual
    network allow an algorithm to send back flow it has already sent along an edge.
    Sending flow back along an edge is equivalent to *decreasing* the flow on the
    edge, which is a necessary operation in many algorithms.
  prefs: []
  type: TYPE_NORMAL
- en: More formally, for a flow network *G* = (*V*, *E*) with source *s*, sink *t*,
    and a flow *f*, consider a pair of vertices *u*, *v* ∈ *V*. We define the ***residual
    capacity*** *c*[*f*] (*u*, *v*) by
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P758.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In a flow network, (*u*, *v*) ∈ *E* implies (*v*, *u*) ∉ *E*, and so exactly
    one case in equation (24.2) applies to each ordered pair of vertices.
  prefs: []
  type: TYPE_NORMAL
- en: As an example of equation (24.2), if *c*(*u*, *v*) = 16 and *f* (*u*, *v*) =
    11, then *f* (*u*, *v*) can increase by up to *c*[*f*] (*u*, *v*) = 5 units before
    exceeding the capacity constraint on edge (*u*, *v*). Alternatively, up to 11
    units of flow can return from *v* to *u*, so that *c*[*f*] (*v*, *u*) = 11.
  prefs: []
  type: TYPE_NORMAL
- en: Given a flow network *G* = (*V*, *E*) and a flow *f*, the ***residual network***
    of *G* induced by *f* is *G*[*f*] = (*V*, *E*[*f*]), where
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P759.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '![art](images/Art_P760.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 24.4 (a)** The flow network *G* and flow *f* of [Figure 24.1(b)](chapter024.xhtml#Fig_24-1).
    **(b)** The residual network *G*[*f*] with augmenting path *p*, having residual
    capacity *c*[*f*] (*p*) = *c*[*f*] (*v*[2], *v*[3]) = 4, in blue. Edges with residual
    capacity equal to 0, such as (*v*[1], *v*[3]), are not shown, a convention we
    follow in the remainder of this section. **(c)** The flow in *G* that results
    from augmenting along path *p* by its residual capacity 4\. Edges carrying no
    flow, such as (*v*[3], *v*[2]), are labeled only by their capacity, another convention
    we follow throughout. **(d)** The residual network induced by the flow in (c).'
  prefs: []
  type: TYPE_NORMAL
- en: That is, as promised above, each edge of the residual network, or ***residual
    edge***, can admit a flow that is greater than 0\. [Figure 24.4(a)](chapter024.xhtml#Fig_24-4)
    repeats the flow network *G* and flow *f* of [Figure 24.1(b)](chapter024.xhtml#Fig_24-1),
    and [Figure 24.4(b)](chapter024.xhtml#Fig_24-4) shows the corresponding residual
    network *G*[*f*]. The edges in *E*[*f*] are either edges in *E* or their reversals,
    and thus
  prefs: []
  type: TYPE_NORMAL
- en: '|*E*[*f*]| ≤ 2 |*E*|.'
  prefs: []
  type: TYPE_NORMAL
- en: Observe that the residual network *G*[*f*] is similar to a flow network with
    capacities given by *c*[*f*]. It does not satisfy the definition of a flow network,
    however, because it could contain antiparallel edges. Other than this difference,
    a residual network has the same properties as a flow network, and we can define
    a flow in the residual network as one that satisfies the definition of a flow,
    but with respect to capacities *c*[*f*] in the residual network *G*[*f*].
  prefs: []
  type: TYPE_NORMAL
- en: A flow in a residual network provides a roadmap for adding flow to the original
    flow network. If *f* is a flow in *G* and *f*′ is a flow in the corresponding
    residual network *G*[*f*], we define *f* ↑ *f*′, the ***augmentation*** of flow
    *f* by *f* ′, to be a function from *V* × *V* to ℝ, defined by
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P761.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The intuition behind this definition follows the definition of the residual
    network. The flow on (*u*, *v*) increases by *f* ′(*u*, *v*), but decreases by
    *f* ′(*v*, *u*) because pushing flow on the reverse edge in the residual network
    signifies decreasing the flow in the original network. Pushing flow on the reverse
    edge in the residual network is also known as ***cancellation***. For example,
    suppose that 5 crates of hockey pucks go from *u* to *v* and 2 crates go from
    *v* to *u*. That is equivalent (from the perspective of the final result) to sending
    3 crates from *u* to *v* and none from *v* to *u*. Cancellation of this type is
    crucial for any maximum-flow algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: The following lemma shows that augmenting a flow in *G* by a flow in *G*[*f*]
    yields a new flow in *G* with a greater flow value.
  prefs: []
  type: TYPE_NORMAL
- en: '***Lemma 24.1***'
  prefs: []
  type: TYPE_NORMAL
- en: Let *G* = (*V*, *E*) be a flow network with source *s* and sink *t*, and let
    *f* be a flow in *G*. Let *G*[*f*] be the residual network of *G* induced by *f*,
    and let *f* ′ be a flow in *G*[*f*]. Then the function *f* ↑ *f* ′ defined in
    equation (24.4) is a flow in *G* with value |*f* ↑ *f* ′| = |*f* | + |*f* ′|.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   We first verify that *f* ↑ *f* ′ obeys the capacity constraint
    for each edge in *E* and flow conservation at each vertex in *V* − {*s*, *t*}.'
  prefs: []
  type: TYPE_NORMAL
- en: For the capacity constraint, first observe that if (*u*, *v*) ∈ *E*, then *c*[*f*]
    (*v*, *u*) = *f* (*u*, *v*). Because *f* ′ is a flow in *G*[*f*], we have *f*
    ′(*v*, *u*) ≤ *c*[*f*] (*v*, *u*), which gives *f* ′(*v*, *u*) ≤ *f* (*u*, *v*).
    Therefore,
  prefs: []
  type: TYPE_NORMAL
- en: '| (*f* ↑ *f*′)(*u*, *v*) | = | *f* (*u*, *v*) + *f* ′(*u*, *v*) − *f* ′(*v*,
    *u*) | (by equation (24.4)) |'
  prefs: []
  type: TYPE_TB
- en: '|  | ≥ | *f* (*u*, *v*) + *f* ′(*u*, *v*) − *f* (*u*, *v*) | (because *f* ′(*v*,
    *u*) ≤ *f* (*u*, *v*)) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | *f* ′(*u*, *v*) |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | ≥ | 0. |  |'
  prefs: []
  type: TYPE_TB
- en: In addition,
  prefs: []
  type: TYPE_NORMAL
- en: '| (*f* ↑ *f*′)(*u*, *v*) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | *f* (*u*, *v*) + *f* ′(*u*, *v*) − *f* ′(*v*, *u*) | (by equation
    (24.4)) |'
  prefs: []
  type: TYPE_TB
- en: '|  | ≤ | *f* (*u*, *v*) + *f* ′(*u*, *v*) | (because flows are nonnegative)
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | ≤ | *f* (*u*, *v*) + *c*[*f*] (*u*, *v*) | (capacity constraint) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | *f* (*u*, *v*) + *c*(*u*, *v*) − *f* (*u*, *v*) | (definition of *c*[*f*])
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | *c*(*u*, *v*). |  |'
  prefs: []
  type: TYPE_TB
- en: To show that flow conservation holds and that |*f* ↑ *f* ′| = |*f* | + |*f*
    ′|, we first prove the claim that for all *u* ∈ *V*, we have
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P762.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Because we disallow antiparallel edges in *G* (but not in *G*[*f*]), we know
    that for each vertex *u*, there can be an edge (*u*, *v*) or (*v*, *u*) in *G*,
    but never both. For a fixed vertex *u*, define *V*[*l*](*u*) = {*v* : (*u*, *v*)
    ∈ *E*} to be the set of vertices with edges in *G* leaving *u*, and define *V*[*e*](*u*)
    = {*v* : (*v*, *u*) ∈ *E*} to be the set of vertices with edges in *G* entering
    *u*. We have *V*[*l*](*u*) ∪ *V*[*e*](*u*) ⊆ *V* and, because *G* contains no
    antiparallel edges, *V*[*l*](*u*) ∩ *V*[*e*](*u*) = ∅. By the definition of flow
    augmentation in equation (24.4), only vertices *v* in *V*[*l*](*u*) can have positive
    (*f* ↑ *f*′)(*u*, *v*), and only vertices *v* in *V*[*e*](*u*) can have positive
    (*f* ↑ *f* ′)(*v*, *u*). Starting from the left-hand side of equation (24.5),
    we use this fact and then reorder and group terms, giving'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P763.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In equation (24.6), all four summations can extend to sum over *V*, since each
    additional term has value 0\. (Exercise 24.2-1 asks you to prove this formally.)
    Taking all four summations over *V*, instead of just subsets of *V*, proves the
    claim in equation (24.5).
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to prove flow conservation for *f* ↑ *f* ′ and that |*f* ↑
    *f*′| = | *f* | + |*f* ′|. For the latter property, let *u* = *s* in equation
    (24.5). Then, we have
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P764.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For flow conservation, observe that for any vertex *u* that is neither *s* nor
    *t*, flow conservation for *f* and *f* ′ means that the right-hand side of equation
    (24.5) is 0, and thus Σ[*v*∈*V*] (*f* ↑ *f*′)(*u*, *v*) = Σ[*v*∈*V*] (*f* ↑ *f*′)(*v*,
    *u*).
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '**Augmenting paths**'
  prefs: []
  type: TYPE_NORMAL
- en: Given a flow network *G* = (*V*, *E*) and a flow *f*, an ***augmenting path*** *p*
    is a simple path from *s* to *t* in the residual network *G*[*f*]. By the definition
    of the residual network, the flow on an edge (*u*, *v*) of an augmenting path
    may increase by up to *c*[*f*] (*u*, *v*) without violating the capacity constraint
    on whichever of (*u*, *v*) and (*v*, *u*) belongs to the original flow network
    *G*.
  prefs: []
  type: TYPE_NORMAL
- en: The blue path in [Figure 24.4(b)](chapter024.xhtml#Fig_24-4) is an augmenting
    path. Treating the residual network *G*[*f*] in the figure as a flow network,
    the flow through each edge of this path can increase by up to 4 units without
    violating a capacity constraint, since the smallest residual capacity on this
    path is *c*[*f*] (*v*[2], *v*[3]) = 4\. We call the maximum amount by which we
    can increase the flow on each edge in an augmenting path *p* the ***residual capacity***
    of *p*, given by
  prefs: []
  type: TYPE_NORMAL
- en: '*c*[*f*] (*p*) = min {*c*[*f*] (*u*, *v*) : (*u*, *v*) is in *p*}.'
  prefs: []
  type: TYPE_NORMAL
- en: The following lemma, which Exercise 24.2-7 asks you to prove, makes the above
    argument more precise.
  prefs: []
  type: TYPE_NORMAL
- en: '***Lemma 24.2***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let *G* = (*V*, *E*) be a flow network, let *f* be a flow in *G*, and let *p*
    be an augmenting path in *G*[*f*]. Define a function *f*[*p*] : *V* × *V* → ℝ
    by'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P765.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then, *f*[*p*] is a flow in *G*[*f*] with value |*f*[*p*]| = *c*[*f*] (*p*)
    > 0.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: The following corollary shows that augmenting *f* by *f*[*p*] produces another
    flow in *G* whose value is closer to the maximum. [Figure 24.4(c)](chapter024.xhtml#Fig_24-4)
    shows the result of augmenting the flow *f* from [Figure 24.4(a)](chapter024.xhtml#Fig_24-4)
    by the flow *f*[*p*] in [Figure 24.4(b)](chapter024.xhtml#Fig_24-4), and [Figure
    24.4(d)](chapter024.xhtml#Fig_24-4) shows the ensuing residual network.
  prefs: []
  type: TYPE_NORMAL
- en: '***Corollary 24.3***'
  prefs: []
  type: TYPE_NORMAL
- en: Let *G* = (*V*, *E*) be a flow network, let *f* be a flow in *G*, and let *p*
    be an augmenting path in *G*[*f*]. Let *f*[*p*] be defined as in equation (24.7),
    and suppose that *f* is augmented by *f*[*p*]. Then the function *f* ↑ *f*[*p*]
    is a flow in *G* with value |*f* ↑ *f*[*p*]| = |*f*| + |*f*[*p*]| > |*f*|.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   Immediate from Lemmas 24.1 and 24.2.'
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '**Cuts of flow networks**'
  prefs: []
  type: TYPE_NORMAL
- en: The Ford-Fulkerson method repeatedly augments the flow along augmenting paths
    until it has found a maximum flow. How do we know that when the algorithm terminates,
    it has actually found a maximum flow? The max-flow min-cut theorem, which we will
    prove shortly, tells us that a flow is maximum if and only if its residual network
    contains no augmenting path. To prove this theorem, though, we must first explore
    the notion of a cut of a flow network.
  prefs: []
  type: TYPE_NORMAL
- en: A ***cut*** (*S*, *T*) of flow network *G* = (*V*, *E*) is a partition of *V*
    into *S* and *T* = *V* − *S* such that *s* ∈ *S* and *t* ∈ *T*. (This definition
    is similar to the definition of “cut” that we used for minimum spanning trees
    in [Chapter 21](chapter021.xhtml), except that here we are cutting a directed
    graph rather than an undirected graph, and we insist that *s* ∈ *S* and *t* ∈
    *T*.) If *f* is a flow, then the ***net flow*** *f*(*S*, *T*) across the cut (*S*,
    *T*) is defined to be
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P766.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ***capacity*** of the cut (*S*, *T*) is
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P767.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A ***minimum cut*** of a network is a cut whose capacity is minimum over all
    cuts of the network.
  prefs: []
  type: TYPE_NORMAL
- en: You probably noticed that the definitions of flow across a cut and capacity
    of a cut differ in that flow counts edges going in both directions across the
    cut, but capacity counts only edges going from the source side of the cut toward
    the sink side. This asymmetry is intentional and important. The reason for this
    difference will become apparent later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 24.5](chapter024.xhtml#Fig_24-5) shows the cut ({*s*, *v*[1], *v*[2]},
    {*v*[3], *v*[4], *t*}) in the flow network of [Figure 24.1(b)](chapter024.xhtml#Fig_24-1).
    The net flow across this cut is'
  prefs: []
  type: TYPE_NORMAL
- en: '| *f* (*v*[1], *v*[3]) + *f* (*v*[2], *v*[4]) − *f* (*v*[3], *v*[2]) | = |
    12 + 11 − 4 |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | 19, |'
  prefs: []
  type: TYPE_TB
- en: and the capacity of this cut is
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P768.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 24.5** A cut (*S*, *T*) in the flow network of [Figure 24.1(b)](chapter024.xhtml#Fig_24-1),
    where *S* = {*s*, *v*[1], *v*[2]} and *T* = {*v*[3], *v*[4], *t*}. The vertices
    in *S* are orange, and the vertices in *T* are tan. The net flow across (*S*,
    *T*) is *f* (*S*, *T*) = 19, and the capacity is *c*(*S*, *T*) = 26.'
  prefs: []
  type: TYPE_NORMAL
- en: '| *c*(*v*[1], *v*[3]) + *c*(*v*[2], *v*[4]) | = | 12 + 14 |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | 26. |'
  prefs: []
  type: TYPE_TB
- en: The following lemma shows that, for a given flow *f*, the net flow across any
    cut is the same, and it equals |*f*|, the value of the flow.
  prefs: []
  type: TYPE_NORMAL
- en: '***Lemma 24.4***'
  prefs: []
  type: TYPE_NORMAL
- en: Let *f* be a flow in a flow network *G* with source *s* and sink *t*, and let
    (*S*, *T*) be any cut of *G*. Then the net flow across (*S*, *T*) is *f* (*S*,
    *T*) =| *f*|.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   For any vertex *u* ∈ *V* − {*s*, *t*}, rewrite the flow-conservation
    condition as'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P769.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Taking the definition of| *f*| from equation (24.1) and adding the left-hand
    side of equation (24.10), which equals 0, summed over all vertices in *S* − {*s*},
    gives
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P770.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Expanding the right-hand summation and regrouping terms yields
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P771.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because *V* = *S* ∪ *T* and *S* ∩ *T* = ∅, splitting each summation over *V*
    into summations over *S* and *T* gives
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P772.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The two summations within the parentheses are actually the same, since for all
    vertices *x*, *y* ∈ *S*, the term *f* (*x*, *y*) appears once in each summation.
    Hence, these summations cancel, yielding
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P773.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: A corollary to Lemma 24.4 shows how cut capacities bound the value of a flow.
  prefs: []
  type: TYPE_NORMAL
- en: '***Corollary 24.5***'
  prefs: []
  type: TYPE_NORMAL
- en: The value of any flow *f* in a flow network *G* is bounded from above by the
    capacity of any cut of *G*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   Let (*S*, *T*) be any cut of *G* and let *f* be any flow. By
    Lemma 24.4 and the capacity constraint,'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P774.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: Corollary 24.5 yields the immediate consequence that the value of a maximum
    flow in a network is bounded from above by the capacity of a minimum cut of the
    network. The important max-flow min-cut theorem, which we now state and prove,
    says that the value of a maximum flow is in fact equal to the capacity of a minimum
    cut.
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 24.6 (Max-flow min-cut theorem)***'
  prefs: []
  type: TYPE_NORMAL
- en: 'If *f* is a flow in a flow network *G* = (*V*, *E*) with source *s* and sink
    *t*, then the following conditions are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '*f* is a maximum flow in *G*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The residual network *G*[*f*] contains no augmenting paths.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '|*f*| = *c*(*S*, *T*) for some cut (*S*, *T*) of *G*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***Proof***   (1) ⇒ (2): Suppose for the sake of contradiction that *f* is
    a maximum flow in *G* but that *G*[*f*] has an augmenting path *p*. Then, by Corollary
    24.3, the flow found by augmenting *f* by *f*[*p*], where *f*[*p*] is given by
    equation (24.7), is a flow in *G* with value strictly greater than |*f*|, contradicting
    the assumption that *f* is a maximum flow.'
  prefs: []
  type: TYPE_NORMAL
- en: '(2) ⇒ (3): Suppose that *G*[*f*] has no augmenting path, that is, that *G*[*f*]
    contains no path from *s* to *t*. Define'
  prefs: []
  type: TYPE_NORMAL
- en: '*S* = {*v* ∈ *V* : there exists a path from *s* to *v* in *G*[*f*] }'
  prefs: []
  type: TYPE_NORMAL
- en: 'and *T* = *V* − *S*. The partition (*S*, *T*) is a cut: we have *s* ∈ *S* trivially
    and *t* ∉ *S* because there is no path from *s* to *t* in *G*[*f*]. Now consider
    a pair of vertices *u* ∈ *S* and *v* ∈ *T*. If (*u*, *v*) ∈ *E*, we must have
    *f* (*u*, *v*) = *c*(*u*, *v*), since otherwise (*u*, *v*) ∈ *E*[*f*], which would
    place *v* in set *S*. If (*v*, *u*) ∈ *E*, we must have *f* (*v*, *u*) = 0, because
    otherwise *c*[*f*] (*u*, *v*) = *f* (*v*, *u*) would be positive and we would
    have (*u*, *v*) ∈ *E*[*f*], which again would place *v* in *S*. Of course, if
    neither (*u*, *v*) nor (*v*, *u*) belongs to *E*, then *f* (*u*, *v*) = *f* (*v*,
    *u*) = 0\. We thus have'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P775.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By Lemma 24.4, therefore, |*f*| = *f* (*S*, *T*) = *c*(*S*, *T*).
  prefs: []
  type: TYPE_NORMAL
- en: '(3) ⇒ (1): By Corollary 24.5, |*f*| ≤ *c*(*S*, *T*) for all cuts (*S*, *T*).
    The condition |*f*| = *c*(*S*, *T*) thus implies that *f* is a maximum flow.'
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '**The basic Ford-Fulkerson algorithm**'
  prefs: []
  type: TYPE_NORMAL
- en: Each iteration of the Ford-Fulkerson method finds *some* augmenting path *p*
    and uses *p* to modify the flow *f*. As Lemma 24.2 and Corollary 24.3 suggest,
    replacing *f* by *f* ↑ *f*[*p*] produces a new flow whose value is |*f*| + |*f*[*p*]|.
    The procedure FORD-FULKERSON on the next page implements the method by updating
    the flow attribute (*u*, *v*).*f* for each edge (*u*, *v*) ∈ *E*.^([1](#footnote_1))
    It assumes implicitly that (*u*, *v*).*f* = 0 if (*u*, *v*) ∉ *E*. The procedure
    also assumes that the capacities *c*(*u*, *v*) come with the flow network, and
    that *c*(*u*, *v*) = 0 if (*u*, *v*) ∉ *E*. The procedure computes the residual
    capacity *c*[*f*] (*u*, *v*) in accordance with the formula (24.2). The expression
    *c*[*f*] (*p*) in the code is just a temporary variable that stores the residual
    capacity of the path *p*.
  prefs: []
  type: TYPE_NORMAL
- en: FORD-FULKERSON (*G*, *s*, *t*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | **for** each edge (*u*, *v*) ∈ *G*.*E* |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | (*u*, *v*).*f* = 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | **while** there exists a path *p* from *s* to *t* in the residual network
    *G*[*f*] |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | *c*[*f*] (*p*) = min {*c*[*f*] (*u*, *v*) : (*u*, *v*) is in *p*} |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | **for** each edge (*u*, *v*) in *p* |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | **if** (*u*, *v*) ∈ *G*.*E* |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | (*u*, *v*).*f* = (*u*, *v*).*f* + *c*[*f*] (*p*) |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | **else** (*v*, *u*).*f* = (*v*, *u*).*f* − *c*[*f*] (*p*) |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | **return** *f* |'
  prefs: []
  type: TYPE_TB
- en: The FORD-FULKERSON procedure simply expands on the FORD-FULKERSON-METHOD pseudocode
    given earlier. [Figure 24.6](chapter024.xhtml#Fig_24-6) shows the result of each
    iteration in a sample run. Lines 1–2 initialize the flow *f* to 0\. The **while**
    loop of lines 3–8 repeatedly finds an augmenting path *p* in *G*[*f*] and augments
    flow *f* along *p* by the residual capacity *c*[*f*] (*p*). Each residual edge
    in path *p* is either an edge in the original network or the reversal of an edge
    in the original network. Lines 6–8 update the flow in each case appropriately,
    adding flow when the residual edge is an original edge and subtracting it otherwise.
    When no augmenting paths exist, the flow *f* is a maximum flow.
  prefs: []
  type: TYPE_NORMAL
- en: '**Analysis of Ford-Fulkerson**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The running time of FORD-FULKERSON depends on the augmenting path *p* and how
    it’s found in line 3\. If the edge capacities are irrational numbers, it’s possible
    to choose the augmenting path so that the algorithm never terminates: the value
    of the flow increases with successive augmentations, but never converges to the
    maximum flow value. The good news is that if the algorithm finds the augmenting
    path by using a breadth-first search (which we saw in [Section 20.2](chapter020.xhtml#Sec_20.2)),
    it runs in polynomial time. Before proving this result, we obtain a simple bound
    for the case in which all capacities are integers and the algorithm finds any
    augmenting path.'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P776.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 24.6** The execution of the basic Ford-Fulkerson algorithm. **(a)–(e)**
    Successive iterations of the **while** loop. The left side of each part shows
    the residual network *G*[*f*] from line 3 with a blue augmenting path *p*. The
    right side of each part shows the new flow *f* that results from augmenting *f*
    by *f*[*p*]. The residual network in (a) is the input flow network *G*. **(f)**
    The residual network at the last **while** loop test. It has no augmenting paths,
    and the flow *f* shown in (e) is therefore a maximum flow. The value of the maximum
    flow found is 23.'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P777.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 24.7 (a)** A flow network for which FORD-FULKERSON can take Θ(*E*
    | *f**|) time, where *f** is a maximum flow, shown here with |*f**| = 2,000,000\.
    The blue path is an augmenting path with residual capacity 1\. **(b)** The resulting
    residual network, with another augmenting path whose residual capacity is 1\.
    **(c)** The resulting residual network.'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, the maximum-flow problem often arises with integer capacities.
    If the capacities are rational numbers, an appropriate scaling transformation
    can make them all integers. If *f** denotes a maximum flow in the transformed
    network, then a straightforward implementation of FORD-FULKERSON executes the
    **while** loop of lines 3–8 at most |*f**| times, since the flow value increases
    by at least 1 unit in each iteration.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good implementation should perform the work done within the **while** loop
    efficiently. It should represent the flow network *G* = (*V*, *E*) with the right
    data structure and find an augmenting path by a linear-time algorithm. Let’s assume
    that the implementation keeps a data structure corresponding to a directed graph
    *G*′ = (*V*, *E*′), where *E*′ = {(*u*, *v*) : (*u*, *v*) ∈ *E* or (*v*, *u*)
    ∈ *E*}. Edges in the network *G* are also edges in *G*′, making it straightforward
    to maintain capacities and flows in this data structure. Given a flow *f* on *G*,
    the edges in the residual network *G*[*f*] consist of all edges (*u*, *v*) of
    *G*′ such that *c*[*f*] (*u*, *v*) > 0, where *c*[*f*] conforms to equation (24.2).
    The time to find a path in a residual network is therefore *O*(*V* + *E*′) = *O*(*E*)
    using either depth-first search or breadth-first search. Each iteration of the
    **while** loop thus takes *O*(*E*) time, as does the initialization in lines 1–2,
    making the total running time of the FORD-FULKERSON algorithm *O*(*E* |*f**|).'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the capacities are integers and the optimal flow value |*f**| is small,
    the running time of the Ford-Fulkerson algorithm is good. [Figure 24.7(a)](chapter024.xhtml#Fig_24-7)
    shows an example of what can happen on a simple flow network for which |*f**|
    is large. A maximum flow in this network has value 2,000,000: 1,000,000 units
    of flow traverse the path *s* → *u* → *t*, and another 1,000,000 units traverse
    the path *s* → *v* → *t*. If the first augmenting path found by FORD-FULKERSON
    is *s* → *u* → *v* → *t*, shown in [Figure 24.7(a)](chapter024.xhtml#Fig_24-7),
    the flow has value 1 after the first iteration. The resulting residual network
    appears in [Figure 24.7(b)](chapter024.xhtml#Fig_24-7). If the second iteration
    finds the augmenting path *s* → *v* → *u* → *t*, as shown in [Figure 24.7(b)](chapter024.xhtml#Fig_24-7),
    the flow then has value 2\. [Figure 24.7(c)](chapter024.xhtml#Fig_24-7) shows
    the resulting residual network. If the algorithm continues alternately choosing
    the augmenting paths *s* → *u* → *v* → *t* and *s* → *v* → *u* → *t*, it performs
    a total of 2,000,000 augmentations, increasing the flow value by only 1 unit in
    each.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The Edmonds-Karp algorithm**'
  prefs: []
  type: TYPE_NORMAL
- en: In the example of [Figure 24.7](chapter024.xhtml#Fig_24-7), the algorithm never
    chooses the augmenting path with the fewest edges. It should have. By using breadth-first
    search to find an augmenting path in the residual network, the algorithm runs
    in polynomial time, independent of the maximum flow value. We call the Ford-Fulkerson
    method so implemented the ***Edmonds-Karp algorithm***.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now prove that the Edmonds-Karp algorithm runs in *O*(*VE*²) time. The
    analysis depends on the distances to vertices in the residual network *G*[*f*].
    The notation *δ*[*f*] (*u*, *v*) denotes the shortest-path distance from *u* to
    *v* in *G*[*f*], where each edge has unit distance.
  prefs: []
  type: TYPE_NORMAL
- en: '***Lemma 24.7***'
  prefs: []
  type: TYPE_NORMAL
- en: If the Edmonds-Karp algorithm is run on a flow network *G* = (*V*, *E*) with
    source *s* and sink *t*, then for all vertices *v* ∈ *V* − {*s*, *t*}, the shortest-path
    distance *δ*[*f*] (*s*, *v*) in the residual network *G*[*f*] increases monotonically
    with each flow augmentation.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   We’ll suppose that a flow augmentation occurs that causes the
    shortest-path distance from *s* to some vertex *v* ∈ *V* − {*s*, *t*} to decrease
    and then derive a contradiction. Let *f* be the flow just before an augmentation
    that decreases some shortest-path distance, and let *f*′ be the flow just afterward.
    Let *v* be a vertex with the minimum *δ*[*f′*] (*s*, *v*) whose distance was decreased
    by the augmentation, so that *δ*[*f*]′ (*s*, *v*) < *δ*[*f*] (*s*, *v*). Let *p*
    = *s* ⇝ *u* → *v* be a shortest path from *s* to *v* in *G*[*f*]′, so that (*u*,
    *v*) ∈ *E*[*f*]′ and'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P778.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Because of how we chose *v*, we know that the distance of vertex *u* from the
    source *s* did not decrease, that is,
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P779.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We claim that (*u*, *v*) ∉ *E*[*f*]. Why? If we have (*u*, *v*) ∈ *E*[*f*],
    then we also have
  prefs: []
  type: TYPE_NORMAL
- en: '| *δ*[*f*] (*s*, *v*) | ≤ | *δ[f]* (*s*, *u*) + 1 | (by Lemma 22.10, the triangle
    inequality) |'
  prefs: []
  type: TYPE_TB
- en: '|  | ≤ | *δ[f]*′ (*s*, *u*) + 1 | (by inequality (24.12)) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | *δ*[*f*]′ (*s*, *v*) | (by equation (24.11)), |'
  prefs: []
  type: TYPE_TB
- en: which contradicts our assumption that *δ*[*f*′] (*s*, *v*) < *δ*[*f*] (*s*,
    *v*).
  prefs: []
  type: TYPE_NORMAL
- en: How can we have (*u*, *v*) ∉ *E*[*f*] and (*u*, *v*) ∈ *E*[*f*′]? The augmentation
    must have increased the flow from *v* to *u*, so that edge (*v*, *u*) was in the
    augmenting path. The augmenting path was a shortest path from *s* to *t* in *G*[*f*],
    and since any subpath of a shortest path is itself a shortest path, this augmenting
    path includes a shortest path from *s* to *u* in *G*[*f*] that has (*v*, *u*)
    as its last edge. Therefore,
  prefs: []
  type: TYPE_NORMAL
- en: '| *δ*[*f*] (*s*, *v*) | = | *δ*[*f*] (*s*, *u*) − 1 |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | ≤ | *δ*[*f*′] (*s*, *u*) − 1 | (by inequality (24.12)) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | *δ*[*f*′] (*s*, *v*) − 2 | (by equation (24.11)), |'
  prefs: []
  type: TYPE_TB
- en: so that *δ*[*f*′] (*s*, *v*) > *δ*[*f*] (*s*, *v*), contradicting our assumption
    that *δ*[*f*′] (*s*, *v*) < *δ*[*f*] (*s*, *v*). We conclude that our assumption
    that such a vertex *v* exists is incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: The next theorem bounds the number of iterations of the Edmonds-Karp algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 24.8***'
  prefs: []
  type: TYPE_NORMAL
- en: If the Edmonds-Karp algorithm is run on a flow network *G* = (*V*, *E*) with
    source *s* and sink *t*, then the total number of flow augmentations performed
    by the algorithm is *O*(*VE*).
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   We say that an edge (*u*, *v*) in a residual network *G*[*f*]
    is ***critical*** on an augmenting path *p* if the residual capacity of *p* is
    the residual capacity of (*u*, *v*), that is, if *c*[*f*] (*p*) = *c*[*f*] (*u*,
    *v*). After flow is augmented along an augmenting path, any critical edge on the
    path disappears from the residual network. Moreover, at least one edge on any
    augmenting path must be critical. We’ll show that each of the |*E*| edges can
    become critical at most |*V*|/2 times.'
  prefs: []
  type: TYPE_NORMAL
- en: Let *u* and *v* be vertices in *V* that are connected by an edge in *E*. Since
    augmenting paths are shortest paths, when (*u*, *v*) is critical for the first
    time, we have
  prefs: []
  type: TYPE_NORMAL
- en: '*δ*[*f*] (*s*, *v*) = *δ*[*f*] (*s*, *u*) + 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the flow is augmented, the edge (*u*, *v*) disappears from the residual
    network. It cannot reappear later on another augmenting path until after the flow
    from *u* to *v* is decreased, which occurs only if (*v*, *u*) appears on an augmenting
    path. If *f* ′ is the flow in *G* when this event occurs, then we have
  prefs: []
  type: TYPE_NORMAL
- en: '*δ*[*f*′] (*s*, *u*) = *δ*[*f*′] (*s*, *v*) + 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Since *δ*[*f*] (*s*, *v*) ≤ *δ*[*f*′] (*s*, *v*) by Lemma 24.7, we have
  prefs: []
  type: TYPE_NORMAL
- en: '| *δ*[*f*′] (*s*, *u*) | = | *δ*[*f*′] (*s*, *v*) + 1 |'
  prefs: []
  type: TYPE_TB
- en: '|  | ≥ | *δ*[*f*] (*s*, *v*) + 1 |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | *δ*[*f*] (*s*, *u*) + 2. |'
  prefs: []
  type: TYPE_TB
- en: Consequently, from the time (*u*, *v*) becomes critical to the time when it
    next becomes critical, the distance of *u* from the source increases by at least
    2\. The distance of *u* from the source is initially at least 0\. Because edge
    (*u*, *v*) is on an augmenting path, and augmenting paths end at *t*, we know
    that *u* cannot be *t*, so that in any residual network that has a path from *s*
    to *u*, the shortest such path has at most |*V*| − 2 edges. Thus, after the first
    time that (*u*, *v*) becomes critical, it can become critical at most (|*V*| −
    2)/2 = |*V*|/2 − 1 times more, for a total of at most |*V*|/2 times. Since there
    are *O*(*E*) pairs of vertices that can have an edge between them in a residual
    network, the total number of critical edges during the entire execution of the
    Edmonds-Karp algorithm is *O*(*VE*). Each augmenting path has at least one critical
    edge, and hence the theorem follows.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: Because each iteration of FORD-FULKERSON takes *O*(*E*) time when it uses breadth-first
    search to find the augmenting path, the total running time of the Edmonds-Karp
    algorithm is *O*(*VE*²).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs: []
  type: TYPE_NORMAL
- en: '***24.2-1***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove that the summations in equation (24.6) equal the summations on the right-hand
    side of equation (24.5).
  prefs: []
  type: TYPE_NORMAL
- en: '***24.2-2***'
  prefs: []
  type: TYPE_NORMAL
- en: In [Figure 24.1(b)](chapter024.xhtml#Fig_24-1), what is the net flow across
    the cut ({*s*, *v*[2], *v*[4]}, {*v*[1], *v*[3], *t*})? What is the capacity of
    this cut?
  prefs: []
  type: TYPE_NORMAL
- en: '***24.2-3***'
  prefs: []
  type: TYPE_NORMAL
- en: Show the execution of the Edmonds-Karp algorithm on the flow network of [Figure
    24.1(a)](chapter024.xhtml#Fig_24-1).
  prefs: []
  type: TYPE_NORMAL
- en: '***24.2-4***'
  prefs: []
  type: TYPE_NORMAL
- en: In the example of [Figure 24.6](chapter024.xhtml#Fig_24-6), what is the minimum
    cut corresponding to the maximum flow shown? Of the augmenting paths appearing
    in the example, which one cancels flow?
  prefs: []
  type: TYPE_NORMAL
- en: '***24.2-5***'
  prefs: []
  type: TYPE_NORMAL
- en: The construction in [Section 24.1](chapter024.xhtml#Sec_24.1) to convert a flow
    network with multiple sources and sinks into a single-source, single-sink network
    adds edges with infinite capacity. Prove that any flow in the resulting network
    has a finite value if the edges of the original network with multiple sources
    and sinks have finite capacity.
  prefs: []
  type: TYPE_NORMAL
- en: '***24.2-6***'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that each source *s*[*i*] in a flow network with multiple sources and
    sinks produces exactly *p*[*i*] units of flow, so that Σ[*v*∈*V*] *f* (*s*[*i*],
    *v*) = *p*[*i*]. Suppose also that each sink *t*[*j*] consumes exactly *q*[*j*]
    units, so that Σ[*v*∈*V*] *f* (*v*, *t*[*j*]) = *q*[*j*], where Σ[*i*] *p[i]*
    = Σ[*j*] *q[j]*. Show how to convert the problem of finding a flow *f* that obeys
    these additional constraints into the problem of finding a maximum flow in a single-source,
    single-sink flow network.
  prefs: []
  type: TYPE_NORMAL
- en: '***24.2-7***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove Lemma 24.2.
  prefs: []
  type: TYPE_NORMAL
- en: '***24.2-8***'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that we redefine the residual network to disallow edges into *s*. Argue
    that the procedure FORD-FULKERSON still correctly computes a maximum flow.
  prefs: []
  type: TYPE_NORMAL
- en: '***24.2-9***'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that both *f* and *f* ′ are flows in a flow network. Does the augmented
    flow *f* ↑ *f* ′ satisfy the flow conservation property? Does it satisfy the capacity
    constraint?
  prefs: []
  type: TYPE_NORMAL
- en: '***24.2-10***'
  prefs: []
  type: TYPE_NORMAL
- en: Show how to find a maximum flow in a flow network *G* = (*V*, *E*) by a sequence
    of at most |*E*| augmenting paths. (*Hint:* Determine the paths *after* finding
    the maximum flow.)
  prefs: []
  type: TYPE_NORMAL
- en: '***24.2-11***'
  prefs: []
  type: TYPE_NORMAL
- en: The ***edge connectivity*** of an undirected graph is the minimum number *k*
    of edges that must be removed to disconnect the graph. For example, the edge connectivity
    of a tree is 1, and the edge connectivity of a cyclic chain of vertices is 2\.
    Show how to determine the edge connectivity of an undirected graph *G* = (*V*,
    *E*) by running a maximum-flow algorithm on at most |*V*| flow networks, each
    having *O*(*V* + *E*) vertices and *O*(*E*) edges.
  prefs: []
  type: TYPE_NORMAL
- en: '***24.2-12***'
  prefs: []
  type: TYPE_NORMAL
- en: You are given a flow network *G*, where *G* contains edges entering the source
    *s*. Let *f* be a flow in *G* with |*f*| ≥ 0 in which one of the edges (*v*, *s*)
    entering the source has *f* (*v*, *s*) = 1\. Prove that there must exist another
    flow *f* ′ with *f* ′(*v*, *s*) = 0 such that |*f*| = |*f*′|. Give an *O*(*E*)-time
    algorithm to compute *f*′, given *f* and assuming that all edge capacities are
    integers.
  prefs: []
  type: TYPE_NORMAL
- en: '***24.2-13***'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that you wish to find, among all minimum cuts in a flow network *G*
    with integer capacities, one that contains the smallest number of edges. Show
    how to modify the capacities of *G* to create a new flow network *G*′ in which
    any minimum cut in *G*′ is a minimum cut with the smallest number of edges in
    *G*.
  prefs: []
  type: TYPE_NORMAL
- en: '[**24.3    Maximum bipartite matching**](toc.xhtml#Rh1-143)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Some combinatorial problems can be cast as maximum-flow problems, such as the
    multiple-source, multiple-sink maximum-flow problem from [Section 24.1](chapter024.xhtml#Sec_24.1).
    Other combinatorial problems seem on the surface to have little to do with flow
    networks, but they can in fact be reduced to maximum-flow problems. This section
    presents one such problem: finding a maximum matching in a bipartite graph. In
    order to solve this problem, we’ll take advantage of an integrality property provided
    by the Ford-Fulkerson method. We’ll also see how to use the Ford-Fulkerson method
    to solve the maximum-bipartite-matching problem on a graph *G* = (*V*, *E*) in
    *O*(*VE*) time. [Section 25.1](chapter025.xhtml#Sec_25.1) will present an algorithm
    specifically designed to solve this problem.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The maximum-bipartite-matching problem**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Given an undirected graph *G* = (*V*, *E*), a ***matching*** is a subset of
    edges *M* ⊆ *E* such that for all vertices *v* ∈ *V*, at most one edge of *M*
    is incident on *v*. We say that a vertex *v* ∈ *V* is ***matched*** by the matching
    *M* if some edge in *M* is incident on *v*, and otherwise, *v* is ***unmatched***.
    A ***maximum matching*** is a matching of maximum cardinality, that is, a matching
    *M* such that for any matching *M*′, we have |*M*| ≥ |*M*′|. In this section,
    we restrict our attention to finding maximum matchings in bipartite graphs: graphs
    in which the vertex set can be partitioned into *V* = *L* ∪ *R*, where *L* and
    *R* are disjoint and all edges in *E* go between *L* and *R*. We further assume
    that every vertex in *V* has at least one incident edge. [Figure 24.8](chapter024.xhtml#Fig_24-8)
    illustrates the notion of a matching in a bipartite graph.'
  prefs: []
  type: TYPE_NORMAL
- en: The problem of finding a maximum matching in a bipartite graph has many practical
    applications. As an example, consider matching a set *L* of machines with a set
    *R* of tasks to be performed simultaneously. An edge (*u*, *v*) in *E* signifies
    that a particular machine *u* ∈ *L* is capable of performing a particular task
    *v* ∈ *R*. A maximum matching provides work for as many machines as possible.
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P780.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 24.8** A bipartite graph *G* = (*V*, *E*) with vertex partition *V*
    = *L* ∪ *R*. **(a)** A matching with cardinality 2, indicated by blue edges. **(b)**
    A maximum matching with cardinality 3\. **(c)** The corresponding flow network
    *G*′ with a maximum flow shown. Each edge has unit capacity. Blue edges have a
    flow of 1, and all other edges carry no flow. The blue edges from *L* to *R* correspond
    to those in the maximum matching from (b).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Finding a maximum bipartite matching**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Ford-Fulkerson method provides a basis for finding a maximum matching in
    an undirected bipartite graph *G* = (*V*, *E*) in time polynomial in |*V*| and
    |*E*|. The trick is to construct a flow network in which flows correspond to matchings,
    as shown in [Figure 24.8(c)](chapter024.xhtml#Fig_24-8). We define the ***corresponding
    flow network*** *G*′ = (*V*′, *E*′) for the bipartite graph *G* as follows. Let
    the source *s* and sink *t* be new vertices not in *V*, and let *V*′ = *V* ∪ {*s*,
    *t*}. If the vertex partition of *G* is *V* = *L* ∪ *R*, the directed edges of
    *G*′ are the edges of *E*, directed from *L* to *R*, along with |*V* | new directed
    edges:'
  prefs: []
  type: TYPE_NORMAL
- en: '| *E*′ | = | {(*s*, *u*) : *u* ∈ *L*} |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | ∪ {(*u*, *v*) : *u* ∈ *L*, *v* ∈ *R*, and (*u*, *v*) ∈ *E*} |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | ∪ {(*v*, *t*) : *v* ∈ *R*}. |'
  prefs: []
  type: TYPE_TB
- en: To complete the construction, assign unit capacity to each edge in *E*′. Since
    each vertex in *V* has at least one incident edge, |*E*| ≥ |*V*|/2\. Thus, |*E*|
    ≤ |*E*′| = |*E*| + |*V*| ≤ 3 |*E*|, and so |*E*′| = Θ(*E*).
  prefs: []
  type: TYPE_NORMAL
- en: The following lemma shows that a matching in *G* corresponds directly to a flow
    in *G*’s corresponding flow network *G*′. We say that a flow *f* on a flow network
    *G* = (*V*, *E*) is ***integer-valued*** if *f* (*u*, *v*) is an integer for all
    (*u*, *v*) ∈ *V* × *V*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Lemma 24.9***'
  prefs: []
  type: TYPE_NORMAL
- en: Let *G* = (*V*, *E*) be a bipartite graph with vertex partition *V* = *L* ∪
    *R*, and let *G*′ = (*V*′, *E*′) be its corresponding flow network. If *M* is
    a matching in *G*, then there is an integer-valued flow *f* in *G*′ with value
    |*f*| = |*M*|. Conversely, if *f* is an integer-valued flow in *G*′, then there
    is a matching *M* in *G* with cardinality |*M*| = |*f*| consisting of edges (*u*,
    *v*) ∈ *E* such that *f* (*u*, *v*) > 0.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   We first show that a matching *M* in *G* corresponds to an integer-valued
    flow *f* in *G*′. Define *f* as follows. If (*u*, *v*) ∈ *M*, then *f* (*s*, *u*)
    = *f* (*u*, *v*) = *f* (*v*, *t*) = 1\. For all other edges (*u*, *v*) ∈ *E*′,
    define *f* (*u*, *v*) = 0\. It is simple to verify that *f* satisfies the capacity
    constraint and flow conservation.'
  prefs: []
  type: TYPE_NORMAL
- en: Intuitively, each edge (*u*, *v*) ∈ *M* corresponds to 1 unit of flow in *G*′
    that traverses the path *s* → *u* → *v* → *t*. Moreover, the paths induced by
    edges in *M* are vertex-disjoint, except for *s* and *t*. The net flow across
    cut (*L* ∪ {*s*}, *R* ∪ {*t*}) is equal to |*M*|, and thus, by Lemma 24.4, the
    value of the flow is |*f*| = |*M*|.
  prefs: []
  type: TYPE_NORMAL
- en: To prove the converse, let *f* be an integer-valued flow in *G*′ and, as in
    the statement of the lemma, let
  prefs: []
  type: TYPE_NORMAL
- en: '*M* = {(*u*, *v*) : *u* ∈ *L*, *v* ∈ *R*, and *f* (*u*, *v*) > 0}.'
  prefs: []
  type: TYPE_NORMAL
- en: Each vertex *u* ∈ *L* has only one entering edge, namely (*s*, *u*), and its
    capacity is 1\. Thus, each *u* ∈ *L* has at most 1 unit of flow entering it, and
    if 1 unit of flow does enter, by flow conservation, 1 unit of flow must leave.
    Furthermore, since the flow *f* is integer-valued, for each *u* ∈ *L*, the 1 unit
    of flow can enter on at most one edge and can leave on at most one edge. Thus,
    1 unit of flow enters *u* if and only if there is exactly one vertex *v* ∈ *R*
    such that *f* (*u*, *v*) = 1, and at most one edge leaving each *u* ∈ *L* carries
    positive flow. A symmetric argument applies to each *v* ∈ *R*. The set *M* is
    therefore a matching.
  prefs: []
  type: TYPE_NORMAL
- en: To see that |*M*| = |*f*|, observe that of the edges (*u*, *v*) ∈ *E*′ such
    that *u* ∈ *L* and *v* ∈ *R*,
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P781.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Consequently, *f* (*L* ∪ {*s*}, *R* ∪ {*t*}), the net flow across cut (*L* ∪
    {*s*}, *R* ∪ {*t*}), is equal to |*M*|. Lemma 24.4 gives that |*f*| = *f* (*L*
    ∪ {*s*}, *R* ∪ {*t*}) = |*M*|.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: Based on Lemma 24.9, we would like to conclude that a maximum matching in a
    bipartite graph *G* corresponds to a maximum flow in its corresponding flow network
    *G*′, and therefore running a maximum-flow algorithm on *G*′ provides a maximum
    matching in *G*. The only hitch in this reasoning is that the maximum-flow algorithm
    might return a flow in *G*′ for which some *f* (*u*, *v*) is not an integer, even
    though the flow value |*f*| must be an integer. The following theorem shows that
    the Ford-Fulkerson method cannot produce a solution with this problem.
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 24.10 (Integrality theorem)***'
  prefs: []
  type: TYPE_NORMAL
- en: If the capacity function *c* takes on only integer values, then the maximum
    flow *f* produced by the Ford-Fulkerson method has the property that |*f*| is
    an integer. Moreover, for all vertices *u* and *v*, the value of *f* (*u*, *v*)
    is an integer.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   Exercise 24.3-2 asks you to provide the proof by induction on
    the number of iterations.'
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: We can now prove the following corollary to Lemma 24.9.
  prefs: []
  type: TYPE_NORMAL
- en: '***Corollary 24.11***'
  prefs: []
  type: TYPE_NORMAL
- en: The cardinality of a maximum matching *M* in a bipartite graph *G* equals the
    value of a maximum flow *f* in its corresponding flow network *G*′.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   We use the nomenclature from Lemma 24.9\. Suppose that *M* is
    a maximum matching in *G* and that the corresponding flow *f* in *G*′ is not maximum.
    Then there is a maximum flow *f*′ in *G*′ such that |*f*′| > |*f*|. Since the
    capacities in *G*′ are integer-valued, by Theorem 24.10, we can assume that *f*′
    is integer-valued. Thus, *f*′ corresponds to a matching *M*′ in *G* with cardinality
    |*M*′| = |*f*′| > |*f*| = |*M*|, contradicting our assumption that *M* is a maximum
    matching. In a similar manner, we can show that if *f* is a maximum flow in *G*′,
    its corresponding matching is a maximum matching on *G*.'
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: Thus, to find a maximum matching in a bipartite undirected graph *G*, create
    the flow network *G*′, run the Ford-Fulkerson method on *G*′, and convert the
    integer-valued maximum flow found into a maximum matching for *G*. Since any matching
    in a bipartite graph has cardinality at most min {|*L*|, |*R*|} = *O*(*V*), the
    value of the maximum flow in *G*′ is *O*(*V*). Therefore, finding a maximum matching
    in a bipartite graph takes *O*(*VE*′) = *O*(*VE*) time, since |*E*′| = Θ(*E*).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs: []
  type: TYPE_NORMAL
- en: '***24.3-1***'
  prefs: []
  type: TYPE_NORMAL
- en: Run the Ford-Fulkerson algorithm on the flow network in [Figure 24.8(c)](chapter024.xhtml#Fig_24-8)
    and show the residual network after each flow augmentation. Number the vertices
    in *L* top to bottom from 1 to 5 and in *R* top to bottom from 6 to 9\. For each
    iteration, pick the augmenting path that is lexicographically smallest.
  prefs: []
  type: TYPE_NORMAL
- en: '***24.3-2***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove Theorem 24.10\. Use induction on the number of iterations of the Ford-Fulkerson
    method.
  prefs: []
  type: TYPE_NORMAL
- en: '***24.3-3***'
  prefs: []
  type: TYPE_NORMAL
- en: Let *G* = (*V*, *E*) be a bipartite graph with vertex partition *V* = *L* ∪
    *R*, and let *G*′ be its corresponding flow network. Give a good upper bound on
    the length of any augmenting path found in *G*′ during the execution of FORD-FULKERSON.
  prefs: []
  type: TYPE_NORMAL
- en: '**Problems**'
  prefs: []
  type: TYPE_NORMAL
- en: '***24-1     Escape problem***'
  prefs: []
  type: TYPE_NORMAL
- en: An *n*×*n* ***grid*** is an undirected graph consisting of *n* rows and *n*
    columns of vertices, as shown in [Figure 24.9](chapter024.xhtml#Fig_24-9). We
    denote the vertex in the *i*th row and the *j* th column by (*i*, *j*). All vertices
    in a grid have exactly four neighbors, except for the boundary vertices, which
    are the points (*i*, *j*) for which *i* = 1, *i* = *n*, *j* = 1, or *j* = *n*.
  prefs: []
  type: TYPE_NORMAL
- en: Given *m* ≤ *n*² starting points (*x*[1], *y*[1]), (*x*[2], *y*[2]), …, (*x*[*m*],
    *y*[*m*]) in the grid, the ***escape problem*** is to determine whether there
    are *m* vertex-disjoint paths from the starting points to any *m* different points
    on the boundary. For example, the grid in [Figure 24.9(a)](chapter024.xhtml#Fig_24-9)
    has an escape, but the grid in [Figure 24.9(b)](chapter024.xhtml#Fig_24-9) does
    not.
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P782.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 24.9** Grids for the escape problem. Starting points are blue, and
    other grid vertices are tan. **(a)** A grid with an escape, shown by blue paths.
    **(b)** A grid with no escape.'
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** Consider a flow network in which vertices, as well as edges, have
    capacities. That is, the total positive flow entering any given vertex is subject
    to a capacity constraint. Show how to reduce the problem of determining the maximum
    flow in a network with edge and vertex capacities to an ordinary maximum-flow
    problem on a flow network of comparable size.'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** Describe an efficient algorithm to solve the escape problem, and analyze
    its running time.'
  prefs: []
  type: TYPE_NORMAL
- en: '***24-2     Minimum path cover***'
  prefs: []
  type: TYPE_NORMAL
- en: A ***path cover*** of a directed graph *G* = (*V*, *E*) is a set *P* of vertex-disjoint
    paths such that every vertex in *V* is included in exactly one path in *P*. Paths
    may start and end anywhere, and they may be of any length, including 0\. A ***minimum
    path cover*** of *G* is a path cover containing the fewest possible paths.
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** Give an efficient algorithm to find a minimum path cover of a directed
    acyclic graph *G* = (*V*, *E*). (*Hint:* Assuming that *V* = {1, 2, …, *n*}, construct
    a flow network based on the graph *G*′ = (*V*′, *E*′), where'
  prefs: []
  type: TYPE_NORMAL
- en: '*V*′ = {*x*[0], *x*[1], …, *x*[*n*]} ∪ {*y*[0], *y*[1], …, *y*[*n*]},'
  prefs: []
  type: TYPE_NORMAL
- en: '*E*′ = {(*x*[0], *x*[*i*]) : *i* ∈ *V* } ∪ {(*y*[*i*], *y*[0]) : *i* ∈ *V*
    } ∪ {(*x*[*i*], *y*[*j*]) : (*i*, *j*) ∈ *E*},'
  prefs: []
  type: TYPE_NORMAL
- en: and run a maximum-flow algorithm.)
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** Does your algorithm work for directed graphs that contain cycles?
    Explain.'
  prefs: []
  type: TYPE_NORMAL
- en: '***24-3     Hiring consulting experts***'
  prefs: []
  type: TYPE_NORMAL
- en: Professor Fieri wants to open a consulting company for the food industry. He
    has identified *n* important food categories, which he represents by the set *C*
    = {*C*[1], *C*[2], …, *C*[*n*]}. In each category *C*[*k*], he can hire an expert
    in that category for *e*[*k*] > 0 dollars. The consulting company has lined up
    a set *J* = {*J*[1], *J*[2], …, *J*[*m*]} of potential jobs. In order to perform
    job *J*[*i*], the company needs to have hired experts in a subset *R*[*i*] ⊆ *C*
    of categories. Each expert can work on multiple jobs simultaneously. If the company
    chooses to accept job *J*[*i*], it must have hired experts in all categories in
    *R*[*i*], and it takes in revenue of *p*[*i*] > 0 dollars.
  prefs: []
  type: TYPE_NORMAL
- en: Professor Fieri’s job is to determine which categories to hire experts in and
    which jobs to accept in order to maximize the net revenue, which is the total
    income from jobs accepted minus the total cost of employing the experts.
  prefs: []
  type: TYPE_NORMAL
- en: Consider the following flow network *G*. It contains a source vertex *s*, vertices
    *C*[1], *C*[2], …, *C*[*n*], vertices *J*[1], *J*[2], …, *J*[*m*], and a sink
    vertex *t*. For *k* = 1, 2 …, *n*, the flow network contains an edge (*s*, *C*[*k*])
    with capacity *c*(*s*, *C[k]*) = *e*[*k*], and for *i* = 1, 2, …, *m*, the flow
    network contains an edge (*J*[*i*], *t*) with capacity *c*(*J[i]*, *t*) = *p*[*i*].
    For *k* = 1, 2, …, *n* and *i* = 1, 2, …, *m*, if *C*[*k*] ∈ *R*[*i*], then *G*
    contains an edge (*C*[*k*], *J*[*i*]) with capacity *c*(*C*[*k*], *J*[*i*]) =
    ∞.
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** Show that if *J*[*i*] ∈ *T* for a finite-capacity cut (*S*, *T*) of
    *G*, then *C*[*k*] ∈ *T* for each *C*[*k*] ∈ *R*[*i*].'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** Show how to determine the maximum net revenue from the capacity of
    a minimum cut of *G* and the given *p*[*i*] values.'
  prefs: []
  type: TYPE_NORMAL
- en: '***c.*** Give an efficient algorithm to determine which jobs to accept and
    which experts to hire. Analyze the running time of your algorithm in terms of
    *m*, *n*, and ![art](images/Art_P783.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: '***24-4     Updating maximum flow***'
  prefs: []
  type: TYPE_NORMAL
- en: Let *G* = (*V*, *E*) be a flow network with source *s*, sink *t*, and integer
    capacities. Suppose that you are given a maximum flow in *G*.
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** Suppose that the capacity of a single edge (*u*, *v*) ∈ *E* increases
    by 1\. Give an *O*(*V* + *E*)-time algorithm to update the maximum flow.'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** Suppose that the capacity of a single edge (*u*, *v*) ∈ *E* decreases
    by 1\. Give an *O*(*V* + *E*)-time algorithm to update the maximum flow.'
  prefs: []
  type: TYPE_NORMAL
- en: '***24-5     Maximum flow by scaling***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let *G* = (*V*, *E*) be a flow network with source *s*, sink *t*, and an integer
    capacity *c*(*u*, *v*) on each edge (*u*, *v*) ∈ *E*. Let *C* = max {*c*(*u*,
    *v*) : (*u*, *v*) ∈ *E*}.'
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** Argue that a minimum cut of *G* has capacity at most *C* |*E*|.'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** For a given number *K*, show how to find an augmenting path of capacity
    at least *K* in *O*(*E*) time, if such a path exists.'
  prefs: []
  type: TYPE_NORMAL
- en: The procedure MAX-FLOW-BY-SCALING appearing on the following page modifies the
    basic FORD-FULKERSON-METHOD procedure to compute a maximum flow in *G*.
  prefs: []
  type: TYPE_NORMAL
- en: '***c.*** Argue that MAX-FLOW-BY-SCALING returns a maximum flow.'
  prefs: []
  type: TYPE_NORMAL
- en: '***d.*** Show that the capacity of a minimum cut of the residual network *G*[*f*]
    is less than 2*K* |*E*| each time line 4 executes.'
  prefs: []
  type: TYPE_NORMAL
- en: '***e.*** Argue that the inner **while** loop of lines 5–6 executes *O*(*E*)
    times for each value of *K*.'
  prefs: []
  type: TYPE_NORMAL
- en: MAX-FLOW-BY-SCALING (*G*, *s*, *t*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | *C* = max {*c*(*u*, *v*) : (*u*, *v*) ∈ *E*} |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | initialize flow *f* to 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | *K* = 2^(⌊lg *C*⌋) |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | **while** *K* ≥ 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | **while** there exists an augmenting path *p* of capacity at least *K*
    |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | augment flow *f* along *p* |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | *K* = *K*/2 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | **return** *f* |'
  prefs: []
  type: TYPE_TB
- en: '***f.*** Conclude that MAX-FLOW-BY-SCALING can be implemented so that it runs
    in *O*(*E*² lg *C*) time.'
  prefs: []
  type: TYPE_NORMAL
- en: '***24-6     Widest augmenting path***'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Edmonds-Karp algorithm implements the Ford-Fulkerson algorithm by always
    choosing a shortest augmenting path in the residual network. Suppose instead that
    the Ford-Fulkerson algorithm chooses a ***widest augmenting path***: an augmenting
    path with the greatest residual capacity. Assume that *G* = (*V*, *E*) is a flow
    network with source *s* and sink *t*, that all capacities are integer, and that
    the largest capacity is *C*. In this problem, you will show that choosing a widest
    augmenting path results in at most |*E*| ln |*f**| augmentations to find a maximum
    flow *f**.'
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** Show how to adjust Dijkstra’s algorithm to find the widest augmenting
    path in the residual network.'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** Show that a maximum flow in *G* can be formed by successive flow augmentations
    along at most |*E*| paths from *s* to *t*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***c.*** Given a flow *f*, argue that the residual network *G*[*f*] has an
    augmenting path *p* with residual capacity *c*[*f*] (*p*) ≥ (|*f**| − |*f*|)/|*E*|.'
  prefs: []
  type: TYPE_NORMAL
- en: '***d.*** Assuming that each augmenting path is a widest augmenting path, let
    *f*[*i*] be the flow after augmenting the flow by the *i*th augmenting path, where
    *f*[0] has *f* (*u*, *v*) = 0 for all edges (*u*, *v*). Show that |*f**| − |*f*[*i*]|
    ≤ |*f**| (1 − 1/|*E*|)^(*i*).'
  prefs: []
  type: TYPE_NORMAL
- en: '***e.*** Show that |*f** | − |*f*[*i*]| < |*f**| *e*^(−*i*/|*E*|).'
  prefs: []
  type: TYPE_NORMAL
- en: '***f.*** Conclude that after the flow is augmented at most |*E*| ln |*f**|
    times, the flow is a maximum flow.'
  prefs: []
  type: TYPE_NORMAL
- en: '***24-7     Global minimum cut***'
  prefs: []
  type: TYPE_NORMAL
- en: A ***global cut*** in an undirected graph *G* = (*V*, *E*) is a partition (see
    page 1156) of *V* into two nonempty sets *V*[1] and *V*[2]. This definition is
    like the definition of cut that we have used in this chapter, except that we no
    longer have distinguished vertices *s* and *t*. Any edge (*u*, *v*) with *u* ∈
    *V*[1] and *v* ∈ *V*[2] is said to ***cross*** the cut.
  prefs: []
  type: TYPE_NORMAL
- en: We can extend this definition of a cut to a multigraph *G* = (*V*, *E*) (see
    page 1167), and we denote by *c*(*u*, *v*) the number of edges in the multigraph
    with endpoints *u* and *v*. A global cut in a multigraph is still a partition
    of the vertices, and the value of a global cut (*V*[1], *V*[2]) is ![art](images/Art_P784.jpg).
    A solution to the ***global-minimum-cut problem*** is a cut (*V*[1], *V*[2]) such
    that *c*(*V*[1], *V*[2]) is minimum. Let *μ*(*G*) denote the value of a global
    minimum cut in a graph or multigraph *G*.
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** Show how to find a global minimum cut of a graph *G* = (*V*, *E*)
    by solving ![art](images/Art_P785.jpg) maximum-flow problems, each with a different
    pair of vertices as the source and sink, and taking the mininum value of the cuts
    found.'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** Give an algorithm to find a global minimum cut by solving only Θ(*V*)
    maximum-flow problems. What is the running time of your algorithm?'
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of this problem develops an algorithm for the global-minimum-cut
    problem that does not use any maximum-flow computations. It uses the notion of
    an edge contraction, defined on page 1168, with one crucial difference. The algorithm
    maintains a multigraph, so that upon contracting an edge (*u*, *v*), it creates
    a new vertex *x*, and for any other vertex *y* ∈ *V*, the number of edges between
    *x* and *y* is *c*(*u*, *y*) + *c*(*v*, *y*). The algorithm does not maintain
    self-loops, and so it sets *c*(*x*, *x*) to 0\. Denote by *G*/(*u*, *v*) the multigraph
    that results from contracting edge (*u*, *v*) in multigraph *G*.
  prefs: []
  type: TYPE_NORMAL
- en: Consider what can happen to the minimum cut when an edge is contracted. Assume
    that, at all points, the minimum cut in a multigraph *G* is unique. We’ll remove
    this assumption later.
  prefs: []
  type: TYPE_NORMAL
- en: '***c.*** Show that for any edge (*u*, *v*), we have *μ*(*G*/(*u*, *v*)) ≤ *μ*(*G*).
    Under what conditions is *μ*(*G*/(*u*, *v*)) < *μ*(*G*)?'
  prefs: []
  type: TYPE_NORMAL
- en: Next, you will show that if you pick an edge uniformly at random, the probability
    that it belongs to the minimum cut is small.
  prefs: []
  type: TYPE_NORMAL
- en: '***d.*** Show that for any multigraph *G* = (*V*, *E*), the value of the global
    minimum cut is at most the average degree of a vertex: that *μ*(*G*) ≤ 2 |*E*|/|*V*|,
    where |*E*| denotes the total number of edges in the multigraph.'
  prefs: []
  type: TYPE_NORMAL
- en: '***e.*** Using the results from parts (c) and (d), show that, if we pick an
    edge (*u*, *v*) uniformly at random, then the probability that (*u*, *v*) belongs
    to the minimum cut is at most 2/*V*.'
  prefs: []
  type: TYPE_NORMAL
- en: Consider the algorithm that repeatedly chooses an edge at random and contracts
    it until the multigraph has exactly two vertices, say *u* and *v*. At that point,
    the multigraph corresponds to a cut in the original graph, with vertex *u* representing
    all the nodes in one side of the original graph, and *v* representing all the
    vertices on the other side. The number of edges given by *c*(*u*, *v*) corresponds
    exactly to the number of edges crossing the corresponding cut in the original
    graph. We call this algorithm the ***contraction algorithm***.
  prefs: []
  type: TYPE_NORMAL
- en: '***f.*** Suppose that the contraction algorithm terminates with a multigraph
    whose only vertices are *u* and *v*. Show that ![art](images/Art_P786.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: '***g.*** Prove that if the contraction algorithm repeats ![art](images/Art_P787.jpg)
    times, then the probability that at least one of the runs returns the minimum
    cut is at least 1 − 1/|*V*|.'
  prefs: []
  type: TYPE_NORMAL
- en: '***h.*** Give a detailed implementation of the contraction algorithm that runs
    in *O*(*V*²) time.'
  prefs: []
  type: TYPE_NORMAL
- en: '***i.*** Combine the previous parts and remove the assumption that the minimum
    cut must be unique, to conclude that running the contraction algorithm ![art](images/Art_P788.jpg)
    times yields an algorithm that runs in *O*(*V*⁴ lg *V*) time and returns a minimum
    cut with probability at least 1 − 1/*V*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter notes**'
  prefs: []
  type: TYPE_NORMAL
- en: Ahuja, Magnanti, and Orlin [[7](bibliography001.xhtml#endnote_7)], Even [[137](bibliography001.xhtml#endnote_137)],
    Lawler [[276](bibliography001.xhtml#endnote_276)], Papadimitriou and Steiglitz
    [[353](bibliography001.xhtml#endnote_353)], Tarjan [[429](bibliography001.xhtml#endnote_429)],
    and Williamson [[458](bibliography001.xhtml#endnote_458)] are good references
    for network flows and related algorithms. Schrijver [[399](bibliography001.xhtml#endnote_399)]
    has written an interesting review of historical developments in the field of network
    flows.
  prefs: []
  type: TYPE_NORMAL
- en: The Ford-Fulkerson method is due to Ford and Fulkerson [[149](bibliography001.xhtml#endnote_149)],
    who originated the formal study of many of the problems in the area of network
    flow, including the maximum-flow and bipartite-matching problems. Many early implementations
    of the Ford-Fulkerson method found augmenting paths using breadth-first search.
    Edmonds and Karp [[132](bibliography001.xhtml#endnote_132)], and independently
    Dinic [[119](bibliography001.xhtml#endnote_119)], proved that this strategy yields
    a polynomial-time algorithm. A related idea, that of using “blocking flows,” was
    also first developed by Dinic [[119](bibliography001.xhtml#endnote_119)].
  prefs: []
  type: TYPE_NORMAL
- en: A class of algorithms known as ***push-relabel algorithms***, due to Goldberg
    [[185](bibliography001.xhtml#endnote_185)] and Goldberg and Tarjan [[188](bibliography001.xhtml#endnote_188)],
    takes a different approach from the Ford-Fulkerson method. Push-relabel algorithms
    allow flow conservation to be violated at vertices other than the source and sink
    as they execute. Using an idea first developed by Karzonov [[251](bibliography001.xhtml#endnote_251)],
    they allow a ***preflow*** in which the flow into a vertex may exceed the flow
    out of the vertex. Such a vertex is said to be ***overflowing***. Initially, every
    edge leaving the source is filled to capacity, so that all neighbors of the source
    are overflowing. In a push-relabel algorithm, each vertex is assigned an integer
    height. An overflowing vertex may push flow to a neighboring vertex to which it
    has a residual edge provided that it is higher than the neighbor. If all residual
    edges from an overflowing vertex go to neighbors with equal or greater heights,
    then the vertex may increase its height. Once all vertices other than the sink
    are no longer overflowing, the preflow is not only a legal flow, but also a maximum
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: Goldberg and Tarjan [[188](bibliography001.xhtml#endnote_188)] gave an *O*(*V*³)-time
    algorithm that uses a queue to maintain the set of overflowing vertices, as well
    as an algorithm that uses dynamic trees to achieve a running time of *O*(*VE*
    lg(*V*²/*E* + 2)). Several other researchers developed improved variants and implementations
    [[9](bibliography001.xhtml#endnote_9), [10](bibliography001.xhtml#endnote_10),
    [15](bibliography001.xhtml#endnote_15), [86](bibliography001.xhtml#endnote_86),
    [87](bibliography001.xhtml#endnote_87), [255](bibliography001.xhtml#endnote_255),
    [358](bibliography001.xhtml#endnote_358)], the fastest of which, by King, Rao,
    and Tarjan [[255](bibliography001.xhtml#endnote_255)], runs in *O*(*VE* log[*E*/(*V*
    lg *V*)] *V*) time.
  prefs: []
  type: TYPE_NORMAL
- en: Another efficient algorithm for maximum flow, by Goldberg and Rao [[187](bibliography001.xhtml#endnote_187)],
    runs in *O* (min{*V*^(2/3), *E*^(1/2)} *E* lg (*V*²/*E* + 2) lg *C*) time, where
    *C* is the maximum capacity any edge. Orlin [[350](bibliography001.xhtml#endnote_350)]
    gave an algorithm in the same spirit as this algorithm that runs in *O*(*VE* +
    *E*^(31/16) lg² *V*) time. Combining it with the algorithm of King, Rao, and Tarjan
    results in an *O*(*VE*)-time algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: A different approach to maximum flows and related problems is to use techniques
    from continuous optimization including electrical flows and interior-point methods.
    The first breakthrough in this line of work is due to Madry [[308](bibliography001.xhtml#endnote_308)],
    who gave an *Õ*(*E*^(10/7))-time algorithm for unit-capacity maximum flow and
    bipartite maximum matching. (See Problem 3-6 on page 73 for a definition of *Õ*.)
    There has been a series of papers in this area for matchings, maximum flows, and
    minimum-cost flows. The fastest algorithm to date in this line of work for maximum
    flow is due to Lee and Sidford [[285](bibliography001.xhtml#endnote_285)], taking
    ![art](images/Art_P789.jpg) time. If the capacities are not too large, this algorithm
    is faster than the *O*(*VE*)-time algorithm mentioned above. Another algorithm,
    due to Liu and Sidford [[303](bibliography001.xhtml#endnote_303)] runs in *Õ*(*E*^(11/8)*C*^(1/4))
    time, where *C* is the maximum capacity of any edge. This algorithm does not run
    in polynomial time, but for small enough capacities, it is faster than the previous
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: In practice, push-relabel algorithms currently dominate algorithms based on
    augmenting paths, continuous-optimization, and linear programming for the maximum-flow
    problem [[88](bibliography001.xhtml#endnote_88)].
  prefs: []
  type: TYPE_NORMAL
- en: '[¹](#footnote_ref_1) Recall from [Section 20.1](chapter020.xhtml#Sec_20.1)
    that we represent an attribute *f* for edge (*u*, *v*) with the same style of
    notation—(*u*, *v*).*f*—that we use for an attribute of any other object.'
  prefs: []
  type: TYPE_NORMAL
