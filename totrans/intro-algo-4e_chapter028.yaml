- answer: '-   **`28`        矩阵运算**'
  en: '**28        矩阵运算**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。


    ## 要求


    +   将公式使用内联代码符号（`...`）包围，其它文本原样输出

    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分

    +   输入可能有多行，不要遗漏其中任何一行

    +   输出的每一行前面需要有分隔符（-   ），不然我无法处理



    ## 示例


    输入：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。



    输出：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆
    V`，使得如果`(u, v)`是`G`的一条边，则`u ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。


    ## 需要排版的段落


    输入：


    -   **28        矩阵运算**


    输出：

    '
  type: TYPE_NORMAL
  zh: '**`28`        矩阵运算**'
- answer: '-   因为矩阵操作是科学计算的核心，对于处理矩阵的高效算法有许多实际应用。本章重点讨论如何乘法矩阵和解决一组同时线性方程。附录 `D` 回顾了矩阵的基础知识。'
  en: 因为矩阵操作是科学计算的核心，对于处理矩阵的高效算法有许多实际应用。本章重点讨论如何乘法矩阵和解决一组同时线性方程。附录 D 回顾了矩阵的基础知识。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   因为矩阵操作是科学计算的核心，对于处理矩阵的高效算法有许多实际应用。本章重点讨论如何乘法矩阵和解决一组同时线性方程。附录
    D 回顾了矩阵的基础知识。  输出：'
  type: TYPE_NORMAL
  zh: 因为矩阵操作是科学计算的核心，对于处理矩阵的高效算法有许多实际应用。本章重点讨论如何乘法矩阵和解决一组同时线性方程。附录 `D` 回顾了矩阵的基础知识。
- answer: '-   第 28.1 节 展示了如何使用 LUP 分解解决一组线性方程。然后，第 28.2 节 探讨了矩阵乘法和求逆之间的密切关系。最后，第
    28.3 节 讨论了对称正定矩阵的重要类，并展示了如何使用它们找到过定线性方程组的最小二乘解。'
  en: 第 28.1 节 展示了如何使用 LUP 分解解决一组线性方程。然后，第 28.2 节 探讨了矩阵乘法和求逆之间的密切关系。最后，第 28.3 节 讨论了对称正定矩阵的重要类，并展示了如何使用它们找到过定线性方程组的最小二乘解。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   第 28.1 节 展示了如何使用
    LUP 分解解决一组线性方程。然后，第 28.2 节 探讨了矩阵乘法和求逆之间的密切关系。最后，第 28.3 节 讨论了对称正定矩阵的重要类，并展示了如何使用它们找到过定线性方程组的最小二乘解。  输出：'
  type: TYPE_NORMAL
  zh: 第 28.1 节 展示了如何使用 LUP 分解解决一组线性方程。然后，第 28.2 节 探讨了矩阵乘法和求逆之间的密切关系。最后，第 28.3 节 讨论了对称正定矩阵的重要类，并展示了如何使用它们找到过定线性方程组的最小二乘解。
- answer: '-   在实践中出现的一个重要问题是***数值稳定性***。因为实际计算机对浮点数的表示精度有限，数值计算中的舍入误差可能在计算过程中被放大，导致错误的结果。这样的计算被称为***数值不稳定***。虽然我们偶尔会简要讨论数值稳定性，但本章不会重点讨论它。我们建议您参考
    Higham 的优秀著作[216]，对稳定性问题进行深入讨论。'
  en: 在实践中出现的一个重要问题是***数值稳定性***。因为实际计算机对浮点数的表示精度有限，数值计算中的舍入误差可能在计算过程中被放大，导致错误的结果。这样的计算被称为***数值不稳定***。虽然我们偶尔会简要讨论数值稳定性，但本章不会重点讨论它。我们建议您参考
    Higham 的优秀著作[216]，对稳定性问题进行深入讨论。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   在实践中出现的一个重要问题是***数值稳定性***。因为实际计算机对浮点数的表示精度有限，数值计算中的舍入误差可能在计算过程中被放大，导致错误的结果。这样的计算被称为***数值不稳定***。虽然我们偶尔会简要讨论数值稳定性，但本章不会重点讨论它。我们建议您参考
    Higham 的优秀著作[216]，对稳定性问题进行深入讨论。  输出：'
  type: TYPE_NORMAL
  zh: 在实践中出现的一个重要问题是***数值稳定性***。因为实际计算机对浮点数的表示精度有限，数值计算中的舍入误差可能在计算过程中被放大，导致错误的结果。这样的计算被称为***数值不稳定***。虽然我们偶尔会简要讨论数值稳定性，但本章不会重点讨论它。我们建议您参考
    Higham 的优秀著作[216]，对稳定性问题进行深入讨论。
- answer: '-   **28.1 解线性方程组**'
  en: '**28.1    解线性方程组**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **28.1    解线性方程组**  输出：'
  type: TYPE_NORMAL
  zh: '**28.1 解线性方程组**'
- answer: '---

    -   许多应用需要解决一组同时线性方程。线性系统可以被转化为一个矩阵方程，其中每个矩阵或向量元素属于一个域，通常是实数 `ℝ`。本节讨论如何使用一种称为
    LUP 分解的方法解决线性方程组。'
  en: 许多应用需要解决一组同时线性方程。线性系统可以被转化为一个矩阵方程，其中每个矩阵或向量元素属于一个域，通常是实数 ℝ。本节讨论如何使用一种称为 LUP
    分解的方法解决线性方程组。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   许多应用需要解决一组同时线性方程。线性系统可以被转化为一个矩阵方程，其中每个矩阵或向量元素属于一个域，通常是实数
    ℝ。本节讨论如何使用一种称为 LUP 分解的方法解决线性方程组。  输出：'
  type: TYPE_NORMAL
  zh: 许多应用需要解决一组同时线性方程。线性系统可以被转化为一个矩阵方程，其中每个矩阵或向量元素属于一个域，通常是实数 `ℝ`。本节讨论如何使用一种称为 LUP
    分解的方法解决线性方程组。
- answer: '-   这个过程从一个包含 `n` 个未知数 `x[1]`、`x[2]`、…，`x[n]` 的线性方程组开始：'
  en: 这个过程从一个包含 *n* 个未知数 *x*[1]、*x*[2]、…，*x[n]* 的线性方程组开始：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   这个过程从一个包含 *n*
    个未知数 *x*[1]、*x*[2]、…，*x[n]* 的线性方程组开始：  输出：'
  type: TYPE_NORMAL
  zh: 这个过程从一个包含 `n` 个未知数 `x[1]`、`x[2]`、…，`x[n]` 的线性方程组开始：
- answer: '---

    -   ![艺术](img/Art_P897.jpg)'
  en: '![艺术](img/Art_P897.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P897.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P897.jpg)'
- answer: '---

    -   方程（`28.1`）的一个***解***是一组值 `x[1]`、`x[2]`、…，`x[n]`，满足所有方程。在本节中，我们只处理恰好有 `n` 个方程和
    `n` 个未知数的情况。'
  en: 方程（28.1）的一个***解***是一组值 *x*[1]、*x*[2]、…，*x[n]*，满足所有方程。在本节中，我们只处理恰好有 *n* 个方程和
    *n* 个未知数的情况。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   方程（28.1）的一个***解***是一组值
    *x*[1]、*x*[2]、…，*x[n]*，满足所有方程。在本节中，我们只处理恰好有 *n* 个方程和 *n* 个未知数的情况。  输出：'
  type: TYPE_NORMAL
  zh: 方程（`28.1`）的一个***解***是一组值 `x[1]`、`x[2]`、…，`x[n]`，满足所有方程。在本节中，我们只处理恰好有 `n` 个方程和
    `n` 个未知数的情况。
- answer: '-   接下来，将方程`（28.1）`重写为矩阵-向量方程'
  en: 接下来，将方程（28.1）重写为矩阵-向量方程
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   接下来，将方程（28.1）重写为矩阵-向量方程  输出：'
  type: TYPE_NORMAL
  zh: 接下来，将方程`（28.1）`重写为矩阵-向量方程
- answer: '```

    -   ![艺术](img/Art_P898.jpg)

    ```'
  en: '![艺术](img/Art_P898.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P898.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P898.jpg)'
- answer: '-   或者，等价地，让 `A = (a[ij])`，`x = (x[i])`，`b = (b[i])`，如下所示'
  en: 或者，等价地，让 *A* = (*a[ij]*)，*x* = (*x[i]*)，*b* = (*b[i]*)，如下所示
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   或者，等价地，让 *A*
    = (*a[ij]*)，*x* = (*x[i]*)，*b* = (*b[i]*)，如下所示  输出：'
  type: TYPE_NORMAL
  zh: 或者，等价地，让 `A = (a[ij])`，`x = (x[i])`，`b = (b[i])`，如下所示
- answer: '---

    -   `![艺术](img/Art_P899.jpg)`'
  en: '![艺术](img/Art_P899.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P899.jpg)  输出：'
  type: TYPE_IMG
  zh: '`![艺术](img/Art_P899.jpg)`'
- answer: '-   如果 `A` 是非奇异的，它具有逆 `A^(−1)`，并且'
  en: 如果 *A* 是非奇异的，它具有逆 *A*^(−1)，并且
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   如果 *A* 是非奇异的，它具有逆
    *A*^(−1)，并且  输出：'
  type: TYPE_NORMAL
  zh: 如果 `A` 是非奇异的，它具有逆 `A^(−1)`，并且
- answer: '-   `![艺术](img/Art_P900.jpg)`'
  en: '![艺术](img/Art_P900.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P900.jpg)  输出：'
  type: TYPE_IMG
  zh: '`![艺术](img/Art_P900.jpg)`'
- answer: '---

    -   是解向量。我们可以证明 `x` 是方程（28.2）的唯一解如下。如果有两个解，`x` 和 `x''`，那么 `Ax = Ax'' = b`，并且，让
    `I` 表示单位矩阵，'
  en: 是解向量。我们可以证明 *x* 是方程（28.2）的唯一解如下。如果有两个解，*x* 和 *x*′，那么 *Ax* = *Ax*′ = *b*，并且，让
    *I* 表示单位矩阵，
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   是解向量。我们可以证明
    *x* 是方程（28.2）的唯一解如下。如果有两个解，*x* 和 *x*′，那么 *Ax* = *Ax*′ = *b*，并且，让 *I* 表示单位矩阵，  输出：'
  type: TYPE_NORMAL
  zh: 是解向量。我们可以证明 `x` 是方程（28.2）的唯一解如下。如果有两个解，`x` 和 `x'`，那么 `Ax = Ax' = b`，并且，让 `I`
    表示单位矩阵，
- answer: '-   | `x` | = | `Ix` |'
  en: '| *x* | = | *Ix* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *x* | = |
    *Ix* |  输出：'
  type: TYPE_TB
  zh: '| `x` | = | `Ix` |'
- answer: '-   | --- | --- | --- |'
  en: '| --- | --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。


    ## 要求


    +   将公式使用内联代码符号（`...`）包围，其它文本原样输出

    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分

    +   输入可能有多行，不要遗漏其中任何一行

    +   输出的每一行前面需要有分隔符（-   ），不然我无法处理



    ## 示例


    输入：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。



    输出：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆
    V`，使得如果`(u, v)`是`G`的一条边，则`u ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。


    ## 需要排版的段落


    输入：


    -   | --- | --- | --- |


    输出：

    '
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- answer: '-   \|  \| = \| \((*A*\^(-1)*A*\)\*x* \|'
  en: '|  | = | (*A*^(−1)*A*)*x* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |  | = | (*A*^(−1)*A*)*x*
    |  输出：'
  type: TYPE_TB
  zh: \|  \| = \| \((*A*\^(-1)*A*\)\*x* \|
- answer: '```

    -   |  | = `A^(-1)(Ax)`

    ```'
  en: '|  | = | *A*^(−1)(*Ax*) |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |  | = | *A*^(−1)(*Ax*)
    |  输出：'
  type: TYPE_TB
  zh: '|  | = `A^(-1)(Ax)`'
- answer: '-   `| | = | A^(−1)(Ax′) |`'
  en: '|  | = | *A*^(−1)(*Ax*′) |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |  | = | *A*^(−1)(*Ax*′)
    |  输出：'
  type: TYPE_TB
  zh: '`| | = | A^(−1)(Ax′) |`'
- answer: '-   `|  | = | (A^(-1)A)x'' |`'
  en: '|  | = | (*A*^(−1)*A*)*x*′ |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |  | = | (*A*^(−1)*A*)*x*′
    |  输出：'
  type: TYPE_TB
  zh: '`|  | = | (A^(-1)A)x'' |`'
- answer: '-   `|  | = | Ix′ |`  '
  en: '|  | = | *Ix*′ |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |  | = | *Ix*′
    |  输出：'
  type: TYPE_TB
  zh: '`|  | = | Ix′ |`  '
- answer: '-   | | = `x''`. |'
  en: '|  | = | *x*′. |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |  | = | *x*′.
    |  输出：'
  type: TYPE_TB
  zh: '| | = `x''`. |'
- answer: '-   当 `A` 是非奇异的时候，或者等价地（根据第 1220 页的定理 D.1），`A` 的秩等于未知数的个数 `n` 时，本节重点讨论这种情况。然而，还有其他可能性，值得简要讨论。如果方程的数量少于未知数的个数
    `n`，或者更一般地说，如果 `A` 的秩小于 `n`，那么这个系统是***欠定***的。一个欠定系统通常有无穷多个解，尽管如果方程不一致的话可能根本没有解。如果方程的数量超过未知数的个数
    `n`，那么这个系统是***过定***的，可能根本没有解。第 28.3 节 解决了如何找到过定线性方程组的良好近似解的重要问题。'
  en: 当 *A* 是非奇异的时候，或者等价地（根据第 1220 页的定理 D.1），*A* 的秩等于未知数的个数 *n* 时，本节重点讨论这种情况。然而，还有其他可能性，值得简要讨论。如果方程的数量少于未知数的个数
    *n*，或者更一般地说，如果 *A* 的秩小于 *n*，那么这个系统是***欠定***的。一个欠定系统通常有无穷多个解，尽管如果方程不一致的话可能根本没有解。如果方程的数量超过未知数的个数
    *n*，那么这个系统是***过定***的，可能根本没有解。第 28.3 节 解决了如何找到过定线性方程组的良好近似解的重要问题。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   当 *A* 是非奇异的时候，或者等价地（根据第
    1220 页的定理 D.1），*A* 的秩等于未知数的个数 *n* 时，本节重点讨论这种情况。然而，还有其他可能性，值得简要讨论。如果方程的数量少于未知数的个数
    *n*，或者更一般地说，如果 *A* 的秩小于 *n*，那么这个系统是***欠定***的。一个欠定系统通常有无穷多个解，尽管如果方程不一致的话可能根本没有解。如果方程的数量超过未知数的个数
    *n*，那么这个系统是***过定***的，可能根本没有解。第 28.3 节 解决了如何找到过定线性方程组的良好近似解的重要问题。  输出：'
  type: TYPE_NORMAL
  zh: 当 `A` 是非奇异的时候，或者等价地（根据第 1220 页的定理 D.1），`A` 的秩等于未知数的个数 `n` 时，本节重点讨论这种情况。然而，还有其他可能性，值得简要讨论。如果方程的数量少于未知数的个数
    `n`，或者更一般地说，如果 `A` 的秩小于 `n`，那么这个系统是***欠定***的。一个欠定系统通常有无穷多个解，尽管如果方程不一致的话可能根本没有解。如果方程的数量超过未知数的个数
    `n`，那么这个系统是***过定***的，可能根本没有解。第 28.3 节 解决了如何找到过定线性方程组的良好近似解的重要问题。
- answer: '-   让我们回到解决`n`个未知数的`n`个方程组`Ax = b`的问题。一种选择是计算`A^(−1)`，然后使用方程（28.3），将`b`乘以`A^(−1)`，得到`x
    = A^(−1)b`。这种方法在实践中存在数值不稳定性。幸运的是，另一种方法——LUP 分解——在实践中是数值稳定的，并且在实践中更快。'
  en: 让我们回到解决*n*个未知数的*n*个方程组*Ax* = *b*的问题。一种选择是计算*A*^(−1)，然后使用方程（28.3），将*b*乘以*A*^(−1)，得到*x*
    = *A*^(−1)*b*。这种方法在实践中存在数值不稳定性。幸运的是，另一种方法——LUP 分解——在实践中是数值稳定的，并且在实践中更快。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   让我们回到解决*n*个未知数的*n*个方程组*Ax*
    = *b*的问题。一种选择是计算*A*^(−1)，然后使用方程（28.3），将*b*乘以*A*^(−1)，得到*x* = *A*^(−1)*b*。这种方法在实践中存在数值不稳定性。幸运的是，另一种方法——LUP
    分解——在实践中是数值稳定的，并且在实践中更快。  输出：'
  type: TYPE_NORMAL
  zh: 让我们回到解决`n`个未知数的`n`个方程组`Ax = b`的问题。一种选择是计算`A^(−1)`，然后使用方程（28.3），将`b`乘以`A^(−1)`，得到`x
    = A^(−1)b`。这种方法在实践中存在数值不稳定性。幸运的是，另一种方法——LUP 分解——在实践中是数值稳定的，并且在实践中更快。
- answer: '-   **LUP 分解概述**'
  en: '**LUP 分解概述**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **LUP 分解概述**  输出：'
  type: TYPE_NORMAL
  zh: '**LUP 分解概述**'
- answer: '-   LUP 分解的思想是找到三个`n × n`矩阵`L`、`U`和`P`，使得'
  en: LUP 分解的思想是找到三个*n* × *n*矩阵*L*、*U*和*P*，使得
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   LUP 分解的思想是找到三个*n*
    × *n*矩阵*L*、*U*和*P*，使得  输出：'
  type: TYPE_NORMAL
  zh: LUP 分解的思想是找到三个`n × n`矩阵`L`、`U`和`P`，使得
- answer: '-   `![art](img/Art_P901.jpg)`'
  en: '![art](img/Art_P901.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P901.jpg)  输出：'
  type: TYPE_IMG
  zh: '`![art](img/Art_P901.jpg)`'
- answer: '-   其中'
  en: 其中
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。


    ## 要求


    +   将公式使用内联代码符号（`...`）包围，其它文本原样输出

    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分

    +   输入可能有多行，不要遗漏其中任何一行

    +   输出的每一行前面需要有分隔符（-   ），不然我无法处理



    ## 示例


    输入：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。



    输出：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆
    V`，使得如果`(u, v)`是`G`的一条边，则`u ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。


    ## 需要排版的段落


    输入：


    -   其中


    输出：

    '
  type: TYPE_NORMAL
  zh: 其中
- answer: '-   `L`是一个单位下三角矩阵，'
  en: '*L*是一个单位下三角矩阵，'
  prefs:
  - PREF_UL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *L*是一个单位下三角矩阵，  输出：'
  type: TYPE_NORMAL
  zh: '`L`是一个单位下三角矩阵，'
- answer: '-   `U`是一个上三角矩阵，而'
  en: '*U*是一个上三角矩阵，而'
  prefs:
  - PREF_UL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *U*是一个上三角矩阵，而  输出：'
  type: TYPE_NORMAL
  zh: '`U`是一个上三角矩阵，而'
- answer: '-   `P`是一个置换矩阵。'
  en: '*P*是一个置换矩阵。'
  prefs:
  - PREF_UL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *P*是一个置换矩阵。  输出：'
  type: TYPE_NORMAL
  zh: '`P`是一个置换矩阵。'
- answer: '-   我们称满足方程(`28.4`)的矩阵`L`、`U`和`P`为矩阵`A`的***LUP 分解***。我们将展示每个非奇异矩阵`A`都具有这样的分解。'
  en: 我们称满足方程（28.4）的矩阵*L*、*U*和*P*为矩阵*A*的***LUP 分解***。我们将展示每个非奇异矩阵*A*都具有这样的分解。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   我们称满足方程（28.4）的矩阵*L*、*U*和*P*为矩阵*A*的***LUP
    分解***。我们将展示每个非奇异矩阵*A*都具有这样的分解。  输出：'
  type: TYPE_NORMAL
  zh: 我们称满足方程(`28.4`)的矩阵`L`、`U`和`P`为矩阵`A`的***LUP 分解***。我们将展示每个非奇异矩阵`A`都具有这样的分解。
- answer: '-   为矩阵`A`计算 LUP 分解的优势在于，当矩阵`L`和`U`都是三角形时，线性系统可以高效地解决。如果你有矩阵`A`的 LUP 分解，你可以通过仅解决三角形线性系统来解决方程（28.2），`Ax
    = b`。将`Ax = b`两边乘以`P`，得到等价方程`PAx = Pb`。根据第 1219 页的练习 D.1-4，将方程乘以置换矩阵相当于重新排列方程（28.1）。通过分解（28.4），用`LU`代替`PA`得到'
  en: 为矩阵*A*计算 LUP 分解的优势在于，当矩阵*L*和*U*都是三角形时，线性系统可以高效地解决��如果你有矩阵*A*的 LUP 分解，你可以通过仅解决三角形线性系统来解决方程（28.2），*Ax*
    = *b*。将*Ax* = *b*两边乘以*P*，得到等价方程*PAx* = *Pb*。根据第 1219 页的练习 D.1-4，将方程乘以置换矩阵相当于重新排列方程（28.1）。通过分解（28.4），用*LU*代替*PA*得到
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   为矩阵*A*计算 LUP
    分解的优势在于，当矩阵*L*和*U*都是三角形时，线性系统可以高效地解决��如果你有矩阵*A*的 LUP 分解，你可以通过仅解决三角形线性系统来解决方程（28.2），*Ax*
    = *b*。将*Ax* = *b*两边乘以*P*，得到等价方程*PAx* = *Pb*。根据第 1219 页的练习 D.1-4，将方程乘以置换矩阵相当于重新排列方程（28.1）。通过分解（28.4），用*LU*代替*PA*得到  输出：'
  type: TYPE_NORMAL
  zh: 为矩阵`A`计算 LUP 分解的优势在于，当矩阵`L`和`U`都是三角形时，线性系统可以高效地解决。如果你有矩阵`A`的 LUP 分解，你可以通过仅解决三角形线性系统来解决方程（28.2），`Ax
    = b`。将`Ax = b`两边乘以`P`，得到等价方程`PAx = Pb`。根据第 1219 页的练习 D.1-4，将方程乘以置换矩阵相当于重新排列方程（28.1）。通过分解（28.4），用`LU`代替`PA`得到
- answer: '-   `LUx = Pb`。'
  en: '*LUx* = *Pb*。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *LUx* = *Pb*。  输出：'
  type: TYPE_NORMAL
  zh: '`LUx = Pb`。'
- answer: '---

    -   现在你可以通过解两个三角线性系统来解决这个方程。定义`y = Ux`，其中`x`是所需的解向量。首先解决下三角系统'
  en: 现在你可以通过解两个三角线性系统来解决这个方程。定义*y* = *Ux*，其中*x*是所需的解向量。首先解决下三角系统
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   现在你可以通过解两个三角线性系统来解决这个方程。定义*y*
    = *Ux*，其中*x*是所需的解向量。首先解决下三角系统  输出：'
  type: TYPE_NORMAL
  zh: 现在你可以通过解两个三角线性系统来解决这个方程。定义`y = Ux`，其中`x`是所需的解向量。首先解决下三角系统
- answer: '-   ![art](img/Art_P902.jpg)'
  en: '![art](img/Art_P902.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P902.jpg)  输出：'
  type: TYPE_IMG
  zh: '![art](img/Art_P902.jpg)'
- answer: '-   通过一种称为“向前替换”的方法解出未知向量`y`。解出`y`后，解上三角系统'
  en: 通过一种称为“向前替换”的方法解出未知向量*y*。解出*y*后，解上三角系统
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   通过一种称为“向前替换”的方法解出未知向量*y*。解出*y*后，解上三角系统  输出：'
  type: TYPE_NORMAL
  zh: 通过一种称为“向前替换”的方法解出未知向量`y`。解出`y`后，解上三角系统
- answer: '-   `![art](img/Art_P903.jpg)`  '
  en: '![art](img/Art_P903.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P903.jpg)  输出：'
  type: TYPE_IMG
  zh: '`![art](img/Art_P903.jpg)`  '
- answer: '-   通过一种称为“向后替换”的方法解出未知的`x`。为什么这个过程能解决`Ax` = `b`？因为置换矩阵`P`是可逆的（参见第 1223
    页的练习 D.2-3），将方程（28.4）两边乘以`P^(-1)`得到`P^(-1)PA` = `P^(-1)LU`，因此'
  en: 通过一种称为“向后替换”的方法解出未知的*x*。为什么这个过程能解决*Ax* = *b*？因为置换矩阵*P*是可逆的（参见第 1223 页的练习 D.2-3），将方程（28.4）两边乘以*P*^(−1)得到*P*^(−1)*PA*
    = *P*^(−1)*LU*，因此
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   通过一种称为“向后替换”的方法解出未知的*x*。为什么这个过程能解决*Ax*
    = *b*？因为置换矩阵*P*是可逆的（参见第 1223 页的练习 D.2-3），将方程（28.4）两边乘以*P*^(−1)得到*P*^(−1)*PA* =
    *P*^(−1)*LU*，因此  输出：'
  type: TYPE_NORMAL
  zh: 通过一种称为“向后替换”的方法解出未知的`x`。为什么这个过程能解决`Ax` = `b`？因为置换矩阵`P`是可逆的（参见第 1223 页的练习 D.2-3），将方程（28.4）两边乘以`P^(-1)`得到`P^(-1)PA`
    = `P^(-1)LU`，因此
- answer: '---

    -   `![art](img/Art_P905.jpg)`

    ---'
  en: '![art](img/Art_P905.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P905.jpg)  输出：'
  type: TYPE_IMG
  zh: '`![art](img/Art_P905.jpg)`'
- answer: '-   因此，满足`Ux = y`的向量`x`就是满足`Ax = b`的解：'
  en: 因此，满足*Ux* = *y*的向量*x*就是满足*Ax* = *b*的解：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   因此，满足*Ux* =
    *y*的向量*x*就是满足*Ax* = *b*的解：  输出：'
  type: TYPE_NORMAL
  zh: 因此，满足`Ux = y`的向量`x`就是满足`Ax = b`的解：
- answer: '-   | `Ax` | = | `P^(-1)LUx` | （根据方程`28.7`） |  '
  en: '| *Ax* | = | *P*^(−1)*LUx* | （根据方程（28.7）） |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *Ax* | =
    | *P*^(−1)*LUx* | （根据方程（28.7）） |  输出：'
  type: TYPE_TB
  zh: '| `Ax` | = | `P^(-1)LUx` | （根据方程`28.7`） |  '
- answer: '-   | --- | --- | --- | --- |'
  en: '| --- | --- | --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | --- | ---
    | --- | --- |  输出：'
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |'
- answer: '---

    -   \|  | = \| `P^(-1)Ly` \| （根据方程（28.6）） \|'
  en: '|  | = | *P*^(−1)*Ly* | （根据方程（28.6）） |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |  | = | *P*^(−1)*Ly*
    | （根据方程（28.6）） |  输出：'
  type: TYPE_TB
  zh: \|  | = \| `P^(-1)Ly` \| （根据方程（28.6）） \|
- answer: '-   |  | = | `P^(-1)Pb` | （根据方程`28.5`） |  '
  en: '|  | = | *P*^(−1)*Pb* | （根据方程（28.5）） |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |  | = | *P*^(−1)*Pb*
    | （根据方程（28.5）） |  输出：'
  type: TYPE_TB
  zh: '|  | = | `P^(-1)Pb` | （根据方程`28.5`） |  '
- answer: '-   `|  | = | b |。`'
  en: '|  | = | *b*。 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |  | = | *b*。
    |  输出：'
  type: TYPE_TB
  zh: '`|  | = | b |。`'
- answer: '-   下一步是展示向前替换和向后替换的工作原理，然后解决计算 LUP 分解本身的问题。'
  en: 下一步是展示向前替换和向后替换的工作原理，然后解决计算 LUP 分解本身的问题。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   下一步是展示向前替换和向后替换的工作原理，然后解决计算
    LUP 分解本身的问题。  输出：'
  type: TYPE_NORMAL
  zh: 下一步是展示向前替换和向后替换的工作原理，然后解决计算 LUP 分解本身的问题。
- answer: '-   **向前替换和向后替换**'
  en: '**向前替换和向后替换**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **向前替换和向后替换**  输出：'
  type: TYPE_NORMAL
  zh: '**向前替换和向后替换**'
- answer: '-   `***向前替换***`可以在Θ(`n²`)的时间内解决下三角系统（28.5），给定`L`、`P`和`b`。数组`π[1 : n]`提供了一种更紧凑的格式来表示置换`P`，而不是一个大部分为
    0 的`n × n`矩阵。对于`i = 1, 2, …, n`，条目`π[i]`表示`P[i,π[i]] = 1`和`P[ij] = 0`（`j ≠ π[i]`）。因此，`PA`在第`i`行第`j`列有`a[π[i],j]`，`Pb`的第`i`个元素为`b[π[i]]`。由于`L`是单位下三角矩阵，矩阵方程`Ly
    = Pb`等价于`n`个方程'
  en: '***向前替换***可以在Θ(*n*²)的时间内解决下三角系统（28.5），给定*L*、*P*和*b*。数组*π*[1 : *n*]提供了一种更紧凑的格式来表示置换*P*，而不是一个大部分为
    0 的*n* × *n*矩阵。对于*i* = 1, 2, …, *n*，条目*π*[*i*]表示*P*[*i,π*[*i*]] = 1 和*P[ij]* =
    0（*j* ≠ *π*[*i*]）。因此，*PA*在第*i*行第*j*列有*a*[*π*[*i*],*j*]，*Pb*的第*i*个元素为*b*[*π*[*i*]]。由于*L*是单位下三角矩阵，矩阵方程*Ly*
    = *Pb*等价于*n*个方程'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***向前替换***可以在Θ(*n*²)的时间内解决下三角系统（28.5），给定*L*、*P*和*b*。数组*π*[1
    : *n*]提供了一种更紧凑的格式来表示置换*P*，而不是一个大部分为 0 的*n* × *n*矩阵。对于*i* = 1, 2, …, *n*，条目*π*[*i*]表示*P*[*i,π*[*i*]]
    = 1 和*P[ij]* = 0（*j* ≠ *π*[*i*]）。因此，*PA*在第*i*行第*j*列有*a*[*π*[*i*],*j*]，*Pb*的第*i*个元素为*b*[*π*[*i*]]。由于*L*是单位下三角矩阵，矩阵方程*Ly*
    = *Pb*等价于*n*个方程  输出：'
  type: TYPE_NORMAL
  zh: '`***向前替换***`可以在Θ(`n²`)的时间内解决下三角系统（28.5），给定`L`、`P`和`b`。数组`π[1 : n]`提供了一种更紧凑的格式来表示置换`P`，而不是一个大部分为
    0 的`n × n`矩阵。对于`i = 1, 2, …, n`，条目`π[i]`表示`P[i,π[i]] = 1`和`P[ij] = 0`（`j ≠ π[i]`）。因此，`PA`在第`i`行第`j`列有`a[π[i],j]`，`Pb`的第`i`个元素为`b[π[i]]`。由于`L`是单位下三角矩阵，矩阵方程`Ly
    = Pb`等价于`n`个方程'
- answer: '-   `*y*[1]` | = | `*b*[*π*[1]]`'
  en: '|    *y*[1] | = | *b*[*π*[1]]， |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |    *y*[1]
    | = | *b*[*π*[1]]， |  输出：'
  type: TYPE_TB
  zh: '`*y*[1]` | = | `*b*[*π*[1]]`'
- answer: '```

    -   | --- | --- | --- |

    ```'
  en: '| --- | --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | --- | ---
    | --- |  输出：'
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- answer: '-   | `l[21]y[1] + y[2]` | = | `b[π[2]]，` |'
  en: '| *l*[21]*y*[1] + *y*[2] | = | *b*[*π*[2]]， |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *l*[21]*y*[1]
    + *y*[2] | = | *b*[*π*[2]]， |  输出：'
  type: TYPE_TB
  zh: '| `l[21]y[1] + y[2]` | = | `b[π[2]]，` |'
- answer: '```

    -   | `l[31]y[1] + l[32]y[2] + y[3]` | = | `b[π[3]]，` |

    ```'
  en: '| *l*[31]*y*[1] + *l*[32]*y*[2] + *y*[3] | = | *b*[*π*[3]]， |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *l*[31]*y*[1]
    + *l*[32]*y*[2] + *y*[3] | = | *b*[*π*[3]]， |  输出：'
  type: TYPE_TB
  zh: '| `l[31]y[1] + l[32]y[2] + y[3]` | = | `b[π[3]]，` |'
- answer: "```\n-   |  | ⋮ |  |  \n```"
  en: '|  | ⋮ |  |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |  | ⋮ |  |  输出：'
  type: TYPE_TB
  zh: '|  | ⋮ |  |  '
- answer: '-   | `l[n1]*y[1] + l[n2]*y[2] + l[n3]*y[3] + ⋯ + y[n]` | = | `b[π[n]]`。
    |  '
  en: '| *l*[*n*1]*y*[1] + *l*[*n*2]*y*[2] + *l*[*n*3]*y*[3] + ⋯ + *y[n]* | = | *b*[*π*[*n*]]。
    |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *l*[*n*1]*y*[1]
    + *l*[*n*2]*y*[2] + *l*[*n*3]*y*[3] + ⋯ + *y[n]* | = | *b*[*π*[*n*]]。 |  输出：'
  type: TYPE_TB
  zh: '| `l[n1]*y[1] + l[n2]*y[2] + l[n3]*y[3] + ⋯ + y[n]` | = | `b[π[n]]`。 |  '
- answer: '-   第一个方程直接给出`y[1] = b[π[1]]`。知道`y[1]`的值后，你可以将其代入第二个方程，得到'
  en: 第一个方程直接给出*y*[1] = *b*[*π*[1]]。知道*y*[1]的值后，你可以将其代入第二个方程，得到
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   第一个方程直接给出*y*[1]
    = *b*[*π*[1]]。知道*y*[1]的值后，你可以将其代入第二个方程，得到  输出：'
  type: TYPE_NORMAL
  zh: 第一个方程直接给出`y[1] = b[π[1]]`。知道`y[1]`的值后，你可以将其代入第二个方程，得到
- answer: '-   `y[2] = b[π[2]] − l[21]y[1]`'
  en: '*y*[2] = *b*[*π*[2]] − *l*[21]*y*[1]。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *y*[2] = *b*[*π*[2]]
    − *l*[21]*y*[1]。  输出：'
  type: TYPE_NORMAL
  zh: '`y[2] = b[π[2]] − l[21]y[1]`'
- answer: '-   接下来，你可以将`y[1]`和`y[2]`都代入第三个方程，得到'
  en: 接下来，你可以将*y*[1]和*y*[2]都代入第三个方程，得到
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   接下来，你可以将*y*[1]和*y*[2]都代入第三个方程，得到  输出：'
  type: TYPE_NORMAL
  zh: 接下来，你可以将`y[1]`和`y[2]`都代入第三个方程，得到
- answer: '-   `y[3] = b[π[3]] − (l[31]y[1] + l[32]y[2])`'
  en: '*y*[3] = *b*[*π*[3]] − (*l*[31]*y*[1] + *l*[32]*y*[2])。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *y*[3] = *b*[*π*[3]]
    − (*l*[31]*y*[1] + *l*[32]*y*[2])。  输出：'
  type: TYPE_NORMAL
  zh: '`y[3] = b[π[3]] − (l[31]y[1] + l[32]y[2])`'
- answer: '-   一般来说，你将`y[1]`、`y[2]`、…、`y[i-1]`“向前”代入第`i`个方程中，解出`y[i]`：'
  en: 一般来说，你将*y*[1]、*y*[2]、…、*y*[*i*−1]“向前”代入第*i*个方程中，解出*y[i]*：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   一般来说，你将*y*[1]、*y*[2]、…、*y*[*i*−1]“向前”代入第*i*个方程中，解出*y[i]*：  输出：'
  type: TYPE_NORMAL
  zh: 一般来说，你将`y[1]`、`y[2]`、…、`y[i-1]`“向前”代入第`i`个方程中，解出`y[i]`：
- answer: '---

    -   ![art](img/Art_P906.jpg)  '
  en: '![art](img/Art_P906.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P906.jpg)  输出：'
  type: TYPE_IMG
  zh: '![art](img/Art_P906.jpg)  '
- answer: '---

    -   一旦你解出了`y`，你可以使用***回代法***在方程（28.6）中解出`x`，这类似于前代法。这一次，你首先解出第`n`个方程，然后向前解决第一个方程。与前代法类似，这个过程的时间复杂度为Θ(`n`²)。由于`U`是上三角矩阵，矩阵方程`Ux
    = y`等价于`n`个方程

    ---'
  en: 一旦你解出了*y*，你可以使用***回代法***在方程（28.6）中解出*x*，这类似于前代法。这一次，你首先解出第*n*个方程，然后向前解决第一个方程。与前代法类似，这个过程的时间复杂度为Θ(*n*²)。由于*U*是上三角矩阵，矩阵方程*Ux*
    = *y*等价于*n*个方程
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   一旦你解出了*y*，你可以使用***回代法***在方程（28.6）中解出*x*，这类似于前代法。这一次，你首先解出第*n*个方程，然后向前解决第一个方程。与前代法类似，这个过程的时间复杂度为Θ(*n*²)。由于*U*是上三角矩阵，矩阵方程*Ux*
    = *y*等价于*n*个方程  输出：'
  type: TYPE_NORMAL
  zh: 一旦你解出了`y`，你可以使用***回代法***在方程（28.6）中解出`x`，这类似于前代法。这一次，你首先解出第`n`个方程，然后向前解决第一个方程。与前代法类似，这个过程的时间复杂度为Θ(`n`²)。由于`U`是上三角矩阵，矩阵方程`Ux
    = y`等价于`n`个方程
- answer: '-   | `u[11]*x[1] + u[12]*x[2] + ⋯ + | u[1,n−2]*x[n−2] + | u[1,n−1]*x[n−1]
    + | u[1*n]*x[n]` | = | `y[1], |`'
  en: '| *u*[11]*x*[1] + *u*[12]*x*[2] + ⋯ + | *u*[1,*n*−2]*x*[*n*−2] + | *u*[1,*n*−1]*x*[*n*−1]
    + | *u*[1*n*]*x*[*n*] | = | *y*[1], |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *u*[11]*x*[1]
    + *u*[12]*x*[2] + ⋯ + | *u*[1,*n*−2]*x*[*n*−2] + | *u*[1,*n*−1]*x*[*n*−1] + |
    *u*[1*n*]*x*[*n*] | = | *y*[1], |  输出：'
  type: TYPE_TB
  zh: '| `u[11]*x[1] + u[12]*x[2] + ⋯ + | u[1,n−2]*x[n−2] + | u[1,n−1]*x[n−1] + |
    u[1*n]*x[n]` | = | `y[1], |`'
- answer: '-   | --- | --- | --- | --- | --- | --- |'
  en: '| --- | --- | --- | --- | --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | --- | ---
    | --- | --- | --- | --- |  输出：'
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- | --- |'
- answer: '-   | `u[22]x[2]` + ⋯ + | `u[2,n−2]x[n−2]` + | `u[2,n−1]x[n−1]` + | `u[2n]x[n]`
    | = | `y[2]`, |'
  en: '| *u*[22]*x*[2] + ⋯ + | *u*[2,*n*−2]*x*[*n*−2] + | *u*[2,*n*−1]*x*[*n*−1] +
    | *u*[2*n*]*x*[*n*] | = | *y*[2], |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *u*[22]*x*[2]
    + ⋯ + | *u*[2,*n*−2]*x*[*n*−2] + | *u*[2,*n*−1]*x*[*n*−1] + | *u*[2*n*]*x*[*n*]
    | = | *y*[2], |  输出：'
  type: TYPE_TB
  zh: '| `u[22]x[2]` + ⋯ + | `u[2,n−2]x[n−2]` + | `u[2,n−1]x[n−1]` + | `u[2n]x[n]`
    | = | `y[2]`, |'
- answer: '-   `|  |  |  |  | ⋮ |  |`'
  en: '|  |  |  |  | ⋮ |  |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。


    ## 要求


    +   将公式使用内联代码符号（`...`）包围，其它文本原样输出

    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分

    +   输入可能有多行，不要遗漏其中任何一行

    +   输出的每一行前面需要有分隔符（-   ），不然我无法处理



    ## 示例


    输入：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。



    输出：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆
    V`，使得如果`(u, v)`是`G`的一条边，则`u ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。


    ## 需要排版的段落


    输入：


    -   |  |  |  |  | ⋮ |  |


    输出：

    '
  type: TYPE_TB
  zh: '`|  |  |  |  | ⋮ |  |`'
- answer: '-   |  | `u[n−2,n−2]*x[n−2]` + | `u[n−2,n−1]*x[n−1]` + | `u[n−2,n]*x[n]`
    | = | `y[n−2],` |'
  en: '|  | *u*[*n*−2,*n*−2]*x*[*n*−2] + | *u*[*n*−2,*n*−1]*x*[*n*−1] + | *u*[*n*−2,*n*]*x*[*n*]
    | = | *y*[*n*−2], |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |  | *u*[*n*−2,*n*−2]*x*[*n*−2]
    + | *u*[*n*−2,*n*−1]*x*[*n*−1] + | *u*[*n*−2,*n*]*x*[*n*] | = | *y*[*n*−2], |  输出：'
  type: TYPE_TB
  zh: '|  | `u[n−2,n−2]*x[n−2]` + | `u[n−2,n−1]*x[n−1]` + | `u[n−2,n]*x[n]` | = |
    `y[n−2],` |'
- answer: '-   `|  |  | u[n-1,n-1]x[n-1] + | u[n-1,n]x[n] | = | y[n-1], |`'
  en: '|  |  | *u*[*n*−1,*n*−1]*x*[*n*−1] + | *u*[*n*−1,*n*]*x[n]* | = | *y*[*n*−1],
    |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |  |  | *u*[*n*−1,*n*−1]*x*[*n*−1]
    + | *u*[*n*−1,*n*]*x[n]* | = | *y*[*n*−1], |  输出：'
  type: TYPE_TB
  zh: '`|  |  | u[n-1,n-1]x[n-1] + | u[n-1,n]x[n] | = | y[n-1], |`'
- answer: '-   `|  |  |  | u[n,n]x[n] | = | y[n]. |`'
  en: '|  |  |  | *u*[*n,n*]*x[n]* | = | *y[n]*. |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |  |  |  |
    *u*[*n,n*]*x[n]* | = | *y[n]*. |  输出：'
  type: TYPE_TB
  zh: '`|  |  |  | u[n,n]x[n] | = | y[n]. |`'
- answer: '-   因此，你可以依次解出`x[n]`，`x[n−1]`，…，`x[1]`如下：  '
  en: 因此，你可以依次解出*x[n]*，*x*[*n*−1]，…，*x*[1]如下：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   因此，你可以依次解出*x[n]*，*x*[*n*−1]，…，*x*[1]如下：  输出：'
  type: TYPE_NORMAL
  zh: '因此，你可以依次解出`x[n]`，`x[n−1]`，…，`x[1]`如下：  '
- answer: '-   | `x[n]` | = | `y[n]`/`u[n,n]`, |  '
  en: '| *x[n]* | = | *y[n]*/*u*[*n,n*], |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *x[n]* |
    = | *y[n]*/*u*[*n,n*], |  输出：'
  type: TYPE_TB
  zh: '| `x[n]` | = | `y[n]`/`u[n,n]`, |  '
- en: '| --- | --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。


    ## 要求


    +   将公式使用内联代码符号（`...`）包围，其它文本原样输出

    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分

    +   输入可能有多行，不要遗漏其中任何一行

    +   输出的每一行前面需要有分隔符（-   ），不然我无法处理



    ## 示例


    输入：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。



    输出：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆
    V`，使得如果`(u, v)`是`G`的一条边，则`u ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。


    ## 需要排版的段落


    输入：


    -   | --- | --- | --- |


    输出：

    '
  type: TYPE_TB
- answer: '-   | `x[n-1]` | = | (`y[n-1] - u[n-1,n]*x[n]`)/`u[n-1,n-1]`, |'
  en: '| *x*[*n*−1] | = | (*y*[*n*−1] − *u*[*n*−1,*n*]*x[n]*)/*u*[*n*−1,*n*−1], |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *x*[*n*−1]
    | = | (*y*[*n*−1] − *u*[*n*−1,*n*]*x[n]*)/*u*[*n*−1,*n*−1], |  输出：'
  type: TYPE_TB
  zh: '| `x[n-1]` | = | (`y[n-1] - u[n-1,n]*x[n]`)/`u[n-1,n-1]`, |'
- answer: '```

    -   | `x[n-2]` | = | (`y[n-2] - (u[n-2,n-1]*x[n-1] + u[n-2,n]*x[n]))/u[n-2,n-2]
    |

    ```'
  en: '| *x*[*n*−2] | = | (*y*[*n*−2] − (*u*[*n*−2,*n*−1]*x*[*n*−1] + *u*[*n*−2,*n*]*x[n]*))/*u*[*n*−2,*n*−2,]
    |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *x*[*n*−2]
    | = | (*y*[*n*−2] − (*u*[*n*−2,*n*−1]*x*[*n*−1] + *u*[*n*−2,*n*]*x[n]*))/*u*[*n*−2,*n*−2,]
    |  输出：'
  type: TYPE_TB
  zh: '| `x[n-2]` | = | (`y[n-2] - (u[n-2,n-1]*x[n-1] + u[n-2,n]*x[n]))/u[n-2,n-2]
    |'
- answer: '-   |  | ⋮ |  |'
  en: '|  | ⋮ |  |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |  | ⋮ |  |  输出：'
  type: TYPE_TB
  zh: '|  | ⋮ |  |'
- answer: '-   或者，一般地说，'
  en: 或者，一般地说，
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   或者，一般地说，  输出：'
  type: TYPE_NORMAL
  zh: 或者，一般地说，
- answer: '-   ![艺术](img/Art_P907.jpg)'
  en: '![艺术](img/Art_P907.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P907.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P907.jpg)'
- answer: '-   给定`P`，`L`，`U`和`b`，下一页的 LUP-SOLVE 过程通过结合前代和回代来解出`x`。置换矩阵`P`由数组`π`表示。该过程首先在第
    2-3 行使用前代解出`y`，然后在第 4-5 行使用回代解出`x`。由于**for**循环内的求和包含一个隐式循环，运行时间为Θ(`n`²)。'
  en: 给定*P*，*L*，*U*和*b*，下一页的 LUP-SOLVE 过程通过结合前代和回代来解出*x*。置换矩阵*P*由数组*π*表示。该过程首先在第 2-3
    行使用前代解出*y*，然后在第 4-5 行使用回代解出*x*。由于**for**循环内的求和包含一个隐式循环，运行时间为Θ(*n*²)。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   给定*P*，*L*，*U*和*b*，下一页的
    LUP-SOLVE 过程通过结合前代和回代来解出*x*。置换矩阵*P*由数组*π*表示。该过程首先在第 2-3 行使用前代解出*y*，然后在第 4-5 行使用回代解出*x*。由于**for**循环内的求和包含一个隐式循环，运行时间为Θ(*n*²)。  输出：'
  type: TYPE_NORMAL
  zh: 给定`P`，`L`，`U`和`b`，下一页的 LUP-SOLVE 过程通过结合前代和回代来解出`x`。置换矩阵`P`由数组`π`表示。该过程首先在第 2-3
    行使用前代解出`y`，然后在第 4-5 行使用回代解出`x`。由于**for**循环内的求和包含一个隐式循环，运行时间为Θ(`n`²)。
- answer: '---

    -   作为这些方法的一个示例，考虑由`Ax = b`定义的线性方程组，其中  '
  en: 作为这些方法的一个示例，考虑由*Ax* = *b*定义的线性方程组，其中
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   作为这些方法的一个示例，考虑由*Ax*
    = *b*定义的线性方程组，其中  输出：'
  type: TYPE_NORMAL
  zh: '作为这些方法的一个示例，考虑由`Ax = b`定义的线性方程组，其中  '
- answer: '-   `![艺术](img/Art_P908.jpg)`'
  en: '![艺术](img/Art_P908.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P908.jpg)  输出：'
  type: TYPE_IMG
  zh: '`![艺术](img/Art_P908.jpg)`'
- answer: '-   `LUP-SOLVE(L, U, π, b, n)`  '
  en: LUP-SOLVE(*L*, *U*, *π*, *b*, *n*)
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   LUP-SOLVE(*L*,
    *U*, *π*, *b*, *n*)  输出：'
  type: TYPE_NORMAL
  zh: '`LUP-SOLVE(L, U, π, b, n)`  '
- answer: '-   | 1 | 让`x`和`y`成为长度为`n`的新向量 | '
  en: '| 1 | 让*x*和*y*成为长度为*n*的新向量 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 1 | 让*x*和*y*成为长度为*n*的新向量
    |  输出：'
  type: TYPE_TB
  zh: '| 1 | 让`x`和`y`成为长度为`n`的新向量 | '
- answer: '-   | --- | --- |'
  en: '| --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | --- | ---
    |  输出：'
  type: TYPE_TB
  zh: '| --- | --- |'
- answer: '-   `| 2 | **对于** *i* = 1 **到** *n* |`'
  en: '| 2 | **对于** *i* = 1 **到** *n* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 2 | **对于** *i*
    = 1 **到** *n* |  输出：'
  type: TYPE_TB
  zh: '`| 2 | **对于** *i* = 1 **到** *n* |`'
- answer: '-   | `3` | ![艺术](img/Art_P909.jpg) |'
  en: '| 3 | ![艺术](img/Art_P909.jpg) |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 3 | ![艺术](img/Art_P909.jpg)
    |  输出：'
  type: TYPE_TB
  zh: '| `3` | ![艺术](img/Art_P909.jpg) |'
- answer: '-   | 4 | **对于** `i = n` **向下**到 1 |'
  en: '| 4 | **对于** *i* = *n* **向下**到 1 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 4 | **对于** *i*
    = *n* **向下**到 1 |  输出：'
  type: TYPE_TB
  zh: '| 4 | **对于** `i = n` **向下**到 1 |'
- answer: '-   | `5` | ![艺术](img/Art_P910.jpg) |'
  en: '| 5 | ![艺术](img/Art_P910.jpg) |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 5 | ![艺术](img/Art_P910.jpg)
    |  输出：'
  type: TYPE_TB
  zh: '| `5` | ![艺术](img/Art_P910.jpg) |'
- answer: '-   | 6 | **返回** `x` |  '
  en: '| 6 | **返回** *x* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 6 | **返回** *x*
    |  输出：'
  type: TYPE_TB
  zh: '| 6 | **返回** `x` |  '
- answer: '```

    -   我们想要解出未知的`x`。LUP 分解为

    ```'
  en: 我们想要解出未知的*x*。LUP 分解为
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   我们想要解出未知的*x*。LUP
    分解为  输出：'
  type: TYPE_NORMAL
  zh: 我们想要解出未知的`x`。LUP 分解为
- answer: '---

    -   ![艺术](img/Art_P911.jpg)  '
  en: '![艺术](img/Art_P911.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P911.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P911.jpg)  '
- answer: '-   （你可能想要验证`PA = LU`。）使用前代法，解出`Ly = Pb`的`y`：'
  en: （你可能想要验证*PA* = *LU*。）使用前代法，解出*Ly* = *Pb*的*y*：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   （你可能想要验证*PA*
    = *LU*。）使用前代法，解出*Ly* = *Pb*的*y*：  输出：'
  type: TYPE_NORMAL
  zh: （你可能想要验证`PA = LU`。）使用前代法，解出`Ly = Pb`的`y`：
- answer: '---

    -   ![艺术](img/Art_P912.jpg)'
  en: '![艺术](img/Art_P912.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P912.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P912.jpg)'
- answer: '-   获得  输出：'
  en: 获得
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   获得  输出：'
  type: TYPE_NORMAL
  zh: 获得  输出：
- answer: '---

    -   ![艺术](img/Art_P913.jpg)'
  en: '![艺术](img/Art_P913.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P913.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P913.jpg)'
- answer: '-   首先计算`y[1]`，然后计算`y[2]`，最后计算`y[3]`。然后，使用回代法解出`Ux = y`的`x`：'
  en: 首先计算*y*[1]，然后计算*y*[2]，最后计算*y*[3]。然后，使用回代法解出*Ux* = *y*的*x*：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   首先计算*y*[1]，然后计算*y*[2]，最后计算*y*[3]。然后，使用回代法解出*Ux*
    = *y*的*x*：  输出：'
  type: TYPE_NORMAL
  zh: 首先计算`y[1]`，然后计算`y[2]`，最后计算`y[3]`。然后，使用回代法解出`Ux = y`的`x`：
- answer: '---

    -   ![艺术](img/Art_P914.jpg)'
  en: '![艺术](img/Art_P914.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P914.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P914.jpg)'
- answer: '---

    -   从而获得所需的答案'
  en: 从而获得所需的答案
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   从而获得所需的答案  输出：'
  type: TYPE_NORMAL
  zh: 从而获得所需的答案
- answer: '---

    -   ![艺术](img/Art_P915.jpg)'
  en: '![艺术](img/Art_P915.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P915.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P915.jpg)'
- answer: '-   首先计算`x[3]`，然后计算`x[2]`，最后计算`x[1]`。'
  en: 首先计算*x*[3]，然后计算*x*[2]，最后计算*x*[1]。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   首先计算*x*[3]，然后计算*x*[2]，最后计算*x*[1]。  输出：'
  type: TYPE_NORMAL
  zh: 首先计算`x[3]`，然后计算`x[2]`，最后计算`x[1]`。
- answer: '-   **计算 LU 分解**'
  en: '**计算 LU 分解**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **计算 LU 分解**  输出：'
  type: TYPE_NORMAL
  zh: '**计算 LU 分解**'
- answer: '-   给定一个非奇异矩阵`A`的 LUP 分解，你可以使用前代和回代来解决线性方程组`Ax = b`。现在让我们看看如何高效地计算矩阵`A`的
    LUP 分解。我们从更简单的情况开始，即`A`是一个*n* × *n*的非奇异矩阵，`P`不存在（或者等价地，`P` = `I[n]`，*n* × *n*单位矩阵），这样`A`
    = `LU`。我们称这两个矩阵`L`和`U`为矩阵`A`的***LU 分解***。'
  en: 给定一个非奇异矩阵*A*的 LUP 分解，你可以使用前代和回代来解决线性方程组*Ax* = *b*。现在让我们看看如何高效地计算矩阵*A*的 LUP 分解。我们从更简单的情况开始，即*A*是一个*n*
    × *n*的非奇异矩阵，*P*不存在（或者等价地，*P* = *I[n]*，*n* × *n*单位矩阵），这样*A* = *LU*。我们称这两个矩阵*L*和*U*为矩阵*A*的***LU
    分解***。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   给定一个非奇异矩阵*A*的
    LUP 分解，你可以使用前代和回代来解决线性方程组*Ax* = *b*。现在让我们看看如何高效地计算矩阵*A*的 LUP 分解。我们从更简单的情况开始，即*A*是一个*n*
    × *n*的非奇异矩阵，*P*不存在（或者等价地，*P* = *I[n]*，*n* × *n*单位矩阵），这样*A* = *LU*。我们称这两个矩阵*L*和*U*为矩阵*A*的***LU
    分解***。  输出：'
  type: TYPE_NORMAL
  zh: 给定一个非奇异矩阵`A`的 LUP 分解，你可以使用前代和回代来解决线性方程组`Ax = b`。现在让我们看看如何高效地计算矩阵`A`的 LUP 分解。我们从更简单的情况开始，即`A`是一个*n*
    × *n*的非奇异矩阵，`P`不存在（或者等价地，`P` = `I[n]`，*n* × *n*单位矩阵），这样`A` = `LU`。我们称这两个矩阵`L`和`U`为矩阵`A`的***LU
    分解***。
- answer: '-   要创建 LU 分解，我们将使用一种称为`高斯消元法`的过程。首先，从其他方程中减去第一个方程的倍数，以消除这些方程中的第一个变量。然后，从第二个方程中减去第三个及后续方程的倍数，以便现在从中删除第一个和第二个变量。继续这个过程，直到剩下的系统具有上三角形式—这就是矩阵`U`。矩阵`L`包括导致变量被消除的行乘数。'
  en: 要创建 LU 分解，我们将使用一种称为***高斯消元法***的过程。首先，从其他方程中减去第一个方程的倍数，以消除这些方程中的第一个变量。然后，从第二个方程中减去第三个及后续方程的倍数，以便现在从中删除第一个和第二个变量。继续这个过程，直到剩下的系统具有上三角形式—这就是矩阵*U*。矩阵*L*包括导致变量被消除的行乘数。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   要创建 LU 分解，我们将使用一种称为***高斯消元法***的过程。首先，从其他方程中减去第一个方程的倍数，以消除这些方程中的第一个变量。然后，从第二个方程中减去第三个及后续方程的倍数，以便现在从中删除第一个和第二个变量。继续这个过程，直到剩下的系统具有上三角形式—这就是矩阵*U*。矩阵*L*包括导致变量被消除的行乘数。  输出：'
  type: TYPE_NORMAL
  zh: 要创建 LU 分解，我们将使用一种称为`高斯消元法`的过程。首先，从其他方程中减去第一个方程的倍数，以消除这些方程中的第一个变量。然后，从第二个方程中减去第三个及后续方程的倍数，以便现在从中删除第一个和第二个变量。继续这个过程，直到剩下的系统具有上三角形式—这就是矩阵`U`。矩阵`L`包括导致变量被消除的行乘数。
- answer: '-   要实现这一策略，让我们从一个递归公式开始。输入是一个`n × n`的非奇异矩阵`A`。如果`n = 1`，则无需做任何操作：只需选择`L
    = I`[1]和`U = A`。对于`n` > 1，将`A`分成四部分：'
  en: 要实现这一策略，让我们从一个递归公式开始。输入是一个*n* × *n*的非奇异矩阵*A*。如果*n* = 1，则无需做任何操作：只需选择*L* = *I*[1]和*U*
    = *A*。对于*n* > 1，将*A*分成四部分：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   要实现这一策略，让我们从一个递归公式开始。输入是一个*n*
    × *n*的非奇异矩阵*A*。如果*n* = 1，则无需做任何操作：只需选择*L* = *I*[1]和*U* = *A*。对于*n* > 1，将*A*分成四部分：  输出：'
  type: TYPE_NORMAL
  zh: 要实现这一策略，让我们从一个递归公式开始。输入是一个`n × n`的非奇异矩阵`A`。如果`n = 1`，则无需做任何操作：只需选择`L = I`[1]和`U
    = A`。对于`n` > 1，将`A`分成四部分：
- answer: '---

    -   ![艺术](img/Art_P916.jpg)'
  en: '![艺术](img/Art_P916.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P916.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P916.jpg)'
- answer: '-   其中`v = (a[21], a[31], … , a[n1])`是一个列(n−1)向量，`w^T = (a[12], a[13],
    … , a[1n])^T`是一个行(n − 1)向量，`A''`是一个(n − 1) × (n − 1)矩阵。然后，使用矩阵代数（通过简单相乘验证方程），将`A`因子化为'
  en: 其中*v* = (*a*[21], *a*[31], … , *a*[*n*1])是一个列(*n*−1)向量，*w*^T = (*a*[12], *a*[13],
    … , *a*[1*n*])^T 是一个行(*n* − 1)向量，*A*′是一个(*n* − 1) × (*n* − 1)矩阵。然后，使用矩阵代数（通过简单相乘验证方程），将*A*因子化为
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   其中*v* = (*a*[21],
    *a*[31], … , *a*[*n*1])是一个列(*n*−1)向量，*w*^T = (*a*[12], *a*[13], … , *a*[1*n*])^T
    是一个行(*n* − 1)向量，*A*′是一个(*n* − 1) × (*n* − 1)矩阵。然后，使用矩阵代数（通过简单相乘验证方程），将*A*因子化为  输出：'
  type: TYPE_NORMAL
  zh: 其中`v = (a[21], a[31], … , a[n1])`是一个列(n−1)向量，`w^T = (a[12], a[13], … , a[1n])^T`是一个行(n
    − 1)向量，`A'`是一个(n − 1) × (n − 1)矩阵。然后，使用矩阵代数（通过简单相乘验证方程），将`A`因子化为
- answer: '```

    -   ![艺术](img/Art_P917.jpg)

    ```'
  en: '![艺术](img/Art_P917.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P917.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P917.jpg)'
- answer: '-   方程`(28.9)`中的第一个和第二个矩阵中的 `0` 是行和列(`n − 1`)向量，`vw^T/a[11]` 是一个(`n − 1`)
    × (`n − 1`)矩阵，通过取`v`和`w`的外积并将结果的每个元素除以`a[11]`形成。因此，它的大小与从中减去的矩阵`A''`相符。得到的(`n
    − 1`) × (`n − 1`)矩阵'
  en: 方程(28.9)中的第一个和第二个矩阵中的 0 是行和列(*n* − 1)向量，*vw*^T/*a*[11]是一个(*n* − 1) × (*n* −
    1)矩阵，通过取*v*和*w*的外积并将结果的每个元素除以*a*[11]形成。因此，它的大小与从中减去的矩阵*A*′相符。得到的(*n* − 1) × (*n*
    − 1)矩阵
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   方程(28.9)中的第一个和第二个矩阵中的
    0 是行和列(*n* − 1)向量，*vw*^T/*a*[11]是一个(*n* − 1) × (*n* − 1)矩阵，通过取*v*和*w*的外积并将结果的每个元素除以*a*[11]形成。因此，它的大小与从中减去的矩阵*A*′相符。得到的(*n*
    − 1) × (*n* − 1)矩阵  输出：'
  type: TYPE_NORMAL
  zh: 方程`(28.9)`中的第一个和第二个矩阵中的 `0` 是行和列(`n − 1`)向量，`vw^T/a[11]` 是一个(`n − 1`) × (`n
    − 1`)矩阵，通过取`v`和`w`的外积并将结果的每个元素除以`a[11]`形成。因此，它的大小与从中减去的矩阵`A'`相符。得到的(`n − 1`) ×
    (`n − 1`)矩阵
- answer: '---

    -   ![艺术](img/Art_P918.jpg)  '
  en: '![艺术](img/Art_P918.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P918.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P918.jpg)  '
- answer: '-   称为`舒尔补`，相对于`a[11]`的`A`。'
  en: 称为***舒尔补***，相对于*a*[11]的*A*。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   称为***舒尔补***，相对于*a*[11]的*A*。  输出：'
  type: TYPE_NORMAL
  zh: 称为`舒尔补`，相对于`a[11]`的`A`。
- answer: '-   我们声称，如果`A`是非奇异的，则舒尔补也是非奇异的。为什么？假设舒尔补（(`n` − 1) × (`n` − 1)）是奇异的。然后根据定理
    D.1，它的行秩严格小于`n` − 1。因为矩阵的第一列中的底部`n` − 1 个条目'
  en: 我们声称，如果*A*是非奇异的，则舒尔补也是非奇异的。为什么？假设舒尔补（(*n* − 1) × (*n* − 1)）是奇异的。然后根据定理 D.1，它的行秩严格小于*n*
    − 1。因为矩阵的第一列中的底部*n* − 1 个条目
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   我们声称，如果*A*是非奇异的，则舒尔补也是非奇异的。为什么？假设舒尔补（(*n*
    − 1) × (*n* − 1)）是奇异的。然后根据定理 D.1，它的行秩严格小于*n* − 1。因为矩阵的第一列中的底部*n* − 1 个条目  输出：'
  type: TYPE_NORMAL
  zh: 我们声称，如果`A`是非奇异的，则舒尔补也是非奇异的。为什么？假设舒尔补（(`n` − 1) × (`n` − 1)）是奇异的。然后根据定理 D.1，它的行秩严格小于`n`
    − 1。因为矩阵的第一列中的底部`n` − 1 个条目
- answer: '```

    -   ![艺术](img/Art_P919.jpg)

    ```'
  en: '![艺术](img/Art_P919.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P919.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P919.jpg)'
- answer: '-   如果矩阵的所有行都是 0，则该矩阵的底部`n` − 1 行的行秩必须严格小于`n` − 1。因此，整个矩阵的行秩严格小于`n`。将第
    1223 页上方程`(28.9)`应用于练习 D.2-8，`A`的秩严格小于`n`，根据定理 D.1，我们得出结论，`A`是奇异的。'
  en: 如果矩阵的所有行都是 0，则该矩阵的底部*n* − 1 行的行秩必须严格小于*n* − 1。因此，整个矩阵的行秩严格小于*n*。将第 1223 页上方程(28.9)应用于练习
    D.2-8，*A*的秩严格小于*n*，根据定理 D.1，我们得出结论，*A*是奇异的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   如果矩阵的所有行都是
    0，则该矩阵的底部*n* − 1 行的行秩必须严格小于*n* − 1。因此，整个矩阵的行秩严格小于*n*。将第 1223 页上方程(28.9)应用于练习 D.2-8，*A*的秩严格小于*n*，根据定理
    D.1，我们得出结论，*A*是奇异的。  输出：'
  type: TYPE_NORMAL
  zh: 如果矩阵的所有行都是 0，则该矩阵的底部`n` − 1 行的行秩必须严格小于`n` − 1。因此，整个矩阵的行秩严格小于`n`。将第 1223 页上方程`(28.9)`应用于练习
    D.2-8，`A`的秩严格小于`n`，根据定理 D.1，我们得出结论，`A`是奇异的。
- answer: '-   因为舒尔补是非奇异的，它也有一个 LU 分解，我们可以递归地找到。假设'
  en: 因为舒尔补是非奇异的，它也有一个 LU 分解，我们可以递归地找到。假设
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   因为舒尔补是非奇异的，它也有一个
    LU 分解，我们可以递归地找到。假设  输出：'
  type: TYPE_NORMAL
  zh: 因为舒尔补是非奇异的，它也有一个 LU 分解，我们可以递归地找到。假设
- answer: '-   `A'' - vw^T/a[11] = L''U''`,  '
  en: '*A*′ − *vw*^T/*a*[11] = *L*′*U*′，'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *A*′ − *vw*^T/*a*[11]
    = *L*′*U*′，  输出：'
  type: TYPE_NORMAL
  zh: '`A'' - vw^T/a[11] = L''U''`,  '
- answer: '-   其中`L′`是单位下三角矩阵，`U′`是上三角矩阵。然后`A`的 LU 分解为`A = LU`，其中'
  en: 其中*L*′是单位下三角矩阵，*U*′是上三角矩阵。然后*A*的 LU 分解为*A* = *LU*，其中
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   其中*L*′是单位下三角矩阵，*U*′是上三角矩阵。然后*A*的
    LU 分解为*A* = *LU*，其中  输出：'
  type: TYPE_NORMAL
  zh: 其中`L′`是单位下三角矩阵，`U′`是上三角矩阵。然后`A`的 LU 分解为`A = LU`，其中
- answer: '-   ![艺术](img/Art_P920.jpg)'
  en: '![艺术](img/Art_P920.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P920.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P920.jpg)'
- answer: '```

    -   如下所示

    ```'
  en: 如下所示
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   如下所示  输出：'
  type: TYPE_NORMAL
  zh: 如下所示
- answer: '-   `![艺术](img/Art_P921.jpg)`  '
  en: '![艺术](img/Art_P921.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P921.jpg)  输出：'
  type: TYPE_IMG
  zh: '`![艺术](img/Art_P921.jpg)`  '
- answer: '-   因为`L′`是单位下三角矩阵，所以`L`也是，因为`U′`是上三角矩阵，所以`U`也是。  '
  en: 因为*L*′是单位下三角矩阵，所以*L*也是，因为*U*′是上三角矩阵，所���*U*也是。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   因为*L*′是单位下三角矩阵，所以*L*也是，因为*U*′是上三角矩阵，所���*U*也是。  输出：'
  type: TYPE_NORMAL
  zh: '因为`L′`是单位下三角矩阵，所以`L`也是，因为`U′`是上三角矩阵，所以`U`也是。  '
- answer: '-   当然，如果`a[11]` = 0，则此方法不起作用，因为它会除以 0。如果舒尔补`A′ − vw^T/a[11]`的左上角条目为 0，那么递归的下一步将除以它。LU
    分解每一步中的分母称为***枢轴***，它们占据矩阵`U`的对角线元素。包含在 LUP 分解中的排列矩阵`P`提供了一种避免除以 0 的方法，我们将在下面看到。使用排列来避免除以
    0（或由于小数值而导致数值不稳定）称为***枢轴调整***。'
  en: 当然，如果*a*[11] = 0，则此方法不起作用，因为它会除以 0。如果舒尔补*A*′ − *vw*^T/*a*[11]的左上角条目为 0，那么递归的下一步将除以它。LU
    分解每一步中的分母称为***枢轴***，它们占据矩阵*U*的对角线元素。包含在 LUP 分解中的排列矩阵*P*提供了一种避免除以 0 的方法，我们将在下面看到。使用排列来避免除以
    0（或由于小数值而导致数值不稳定）称为***枢轴调整***。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   当然，如果*a*[11]
    = 0，则此方法不起作用，因为它会除以 0。如果舒尔补*A*′ − *vw*^T/*a*[11]的左上角条目为 0，那么递归的下一步将除以它。LU 分解每一步中的分母称为***枢轴***，它们占据矩阵*U*的对角线元素。包含在
    LUP 分解中的排列矩阵*P*提供了一种避免除以 0 的方法，我们将在下面看到。使用排列来避免除以 0（或由于小数值而导致数值不稳定）称为***枢轴调整***。  输出：'
  type: TYPE_NORMAL
  zh: 当然，如果`a[11]` = 0，则此方法不起作用，因为它会除以 0。如果舒尔补`A′ − vw^T/a[11]`的左上角条目为 0，那么递归的下一步将除以它。LU
    分解每一步中的分母称为***枢轴***，它们占据矩阵`U`的对角线元素。包含在 LUP 分解中的排列矩阵`P`提供了一种避免除以 0 的方法，我们将在下面看到。使用排列来避免除以
    0（或由于小数值而导致数值不稳定）称为***枢轴调整***。
- answer: '-   对于 LU 分解始终正确的重要矩阵类是对称正定矩阵类。这些矩阵在上述递归策略中不需要进行任何枢轴调整以避免除以 0。我们将在第 `28.3`
    节中证明这一结果，以及其他几个结果。'
  en: 对于 LU 分解始终正确的重要矩阵类是对称正定矩阵类。这些矩阵在上述递归策略中不需要进行任何枢轴调整以避免除以 0。我们将在第 28.3 节中证明这一结果，以及其他几个结果。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于 LU 分解始终正确的重要矩阵类是对称正定矩阵类。这些矩阵在上述递归策略中不需要进行任何枢轴调整以避免除以
    0。我们将在第 28.3 节中证明这一结果，以及其他几个结果。  输出：'
  type: TYPE_NORMAL
  zh: 对于 LU 分解始终正确的重要矩阵类是对称正定矩阵类。这些矩阵在上述递归策略中不需要进行任何枢轴调整以避免除以 0。我们将在第 `28.3` 节中证明这一结果，以及其他几个结果。
- answer: '-   程序 `LU-DECOMPOSITION` 中的伪代码遵循递归策略，只是用迭代循环替代了递归。（这种转换是对“尾递归”程序的标准优化，即其最后一个操作是对自身的递归调用。参见第
    202 页的问题 7-5。）该程序将矩阵`U`初始化为对角线以下的 0，将矩阵`L`初始化为对角线上的 1 和对角线以上的 0。每次迭代都处理一个方阵子矩阵，使用其左上角元素作为枢轴来计算`v`和`w`向量以及舒尔补，舒尔补成为下一次迭代处理的方阵子矩阵。'
  en: 程序 LU-DECOMPOSITION 中的伪代码遵循递归策略，只是用迭代循环替代了递归。（这种转换是对“尾递归”程序的标准优化，即其最后一个操作是对自身的递归调用。参见第
    202 页的问题 7-5。）该程序将矩阵*U*初始化为对角线以下的 0，将矩阵*L*初始化为对角线上的 1 和对角线以上的 0。每次迭代都处理一个方阵子矩阵，使用其左上角元素作为枢轴来计算*v*和*w*向量以及舒尔补，舒尔补成为下一次迭代处理的方阵子矩阵。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   程序 LU-DECOMPOSITION
    中的伪代码遵循递归策略，只是用迭代循环替代了递归。（这种转换是对“尾递归”程序的标准优化，即其最后一个操作是对自身的递归调用。参见第 202 页的问题 7-5。）该程序将矩阵*U*初始化为对角线以下的
    0，将矩阵*L*初始化为对角线上的 1 和对角线以上的 0。每次迭代都处理一个方阵子矩阵，使用其左上角元素作为枢轴来计算*v*和*w*向量以及舒尔补，舒尔补成为下一次迭代处理的方阵子矩阵。  输出：'
  type: TYPE_NORMAL
  zh: 程序 `LU-DECOMPOSITION` 中的伪代码遵循递归策略，只是用迭代循环替代了递归。（这种转换是对“尾递归”程序的标准优化，即其最后一个操作是对自身的递归调用。参见第
    202 页的问题 7-5。）该程序将矩阵`U`初始化为对角线以下的 0，将矩阵`L`初始化为对角线上的 1 和对角线以上的 0。每次迭代都处理一个方阵子矩阵，使用其左上角元素作为枢轴来计算`v`和`w`向量以及舒尔补，舒尔补成为下一次迭代处理的方阵子矩阵。
- answer: '-   `LU-DECOMPOSITION(A, n)`'
  en: LU-DECOMPOSITION(*A*, *n*)
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   LU-DECOMPOSITION(*A*,
    *n*)  输出：'
  type: TYPE_NORMAL
  zh: '`LU-DECOMPOSITION(A, n)`'
- answer: '```

    -   |   1 | 让`L`和`U`成为新的`n` × `n`矩阵 |

    ```'
  en: '|   1 | 让*L*和*U*成为新的*n* × *n*矩阵 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |   1 | 让*L*和*U*成为新的*n*
    × *n*矩阵 |  输出：'
  type: TYPE_TB
  zh: '|   1 | 让`L`和`U`成为新的`n` × `n`矩阵 |'
- answer: '-   `| --- | --- |`'
  en: '| --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。


    ## 要求


    +   将公式使用内联代码符号（`...`）包围，其它文本原样输出

    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分

    +   输入可能有多行，不要遗漏其中任何一行

    +   输出的每一行前面需要有分隔符（-   ），不然我无法处理



    ## 示例


    输入：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。



    输出：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆
    V`，使得如果`(u, v)`是`G`的一条边，则`u ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。


    ## 需要排版的段落


    输入：


    -   | --- | --- |


    输出：

    '
  type: TYPE_TB
  zh: '`| --- | --- |`'
- answer: '---

    -   |   2 | 用 0 初始化`U`的对角线以下 | '
  en: '|   2 | 用 0 初始化*U*的对角线以下 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |   2 | 用 0
    初始化*U*的对角线以下 |  输出：'
  type: TYPE_TB
  zh: '|   2 | 用 0 初始化`U`的对角线以下 | '
- answer: '---

    -   | `3` | 用 1 初始化*L*的对角线和 0 初始化对角线以上 |

    ---'
  en: '|   3 | 用 1 初始化*L*的对角线和 0 初始化对角线以上 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |   3 | 用 1
    初始化*L*的对角线和 0 初始化对角线以上 |  输出：'
  type: TYPE_TB
  zh: '| `3` | 用 1 初始化*L*的对角线和 0 初始化对角线以上 |'
- answer: '-   |   4 | `对于` `k` = 1 `到` `n` |'
  en: '|   4 | **对于** *k* = 1 **到** *n* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |   4 | **对于** *k*
    = 1 **到** *n* |  输出：'
  type: TYPE_TB
  zh: '|   4 | `对于` `k` = 1 `到` `n` |'
- answer: '-   |   5 | `u[kk] = a[kk]` |  '
  en: '|   5 | *u[kk]* = *a[kk]* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |   5 | *u[kk]*
    = *a[kk]* |  输出：'
  type: TYPE_TB
  zh: '|   5 | `u[kk] = a[kk]` |  '
- answer: '```

    -   |   6 | **对于** `i = k + 1 **到** n` |

    ```'
  en: '|   6 | **对于** *i* = *k* + 1 **到** *n* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |   6 | **对于** *i*
    = *k* + 1 **到** *n* |  输出：'
  type: TYPE_TB
  zh: '|   6 | **对于** `i = k + 1 **到** n` |'
- answer: '-   |   7 | `l[ik]` = `a[ik]`/`a[kk]` | **//** `a[ik]`保存`v[i]` |  '
  en: '|   7 | *l[ik]* = *a[ik]*/*a[kk]* | **//** *a[ik]*保存*v[i]* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |   7 | *l[ik]*
    = *a[ik]*/*a[kk]* | **//** *a[ik]*保存*v[i]* |  输出：'
  type: TYPE_TB
  zh: '|   7 | `l[ik]` = `a[ik]`/`a[kk]` | **//** `a[ik]`保存`v[i]` |  '
- answer: '---

    -   |   8 | `u[ki]` = `a[ki]` | **//** `a[ki]`保存`w[i]` |'
  en: '|   8 | *u[ki]* = *a[ki]* | **//** *a[ki]*保存*w[i]* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |   8 | *u[ki]*
    = *a[ki]* | **//** *a[ki]*保存*w[i]* |  输出：'
  type: TYPE_TB
  zh: '|   8 | `u[ki]` = `a[ki]` | **//** `a[ki]`保存`w[i]` |'
- answer: '---

    -   |   9 | **对于** `i = k + 1` **到** `n` | **//** 计算舒尔补 … |'
  en: '|   9 | **对于** *i* = *k* + 1 **到** *n* | **//** 计算舒尔补 … |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |   9 | **对于**
    *i* = *k* + 1 **到** *n* | **//** 计算舒尔补 … |  输出：'
  type: TYPE_TB
  zh: '|   9 | **对于** `i = k + 1` **到** `n` | **//** 计算舒尔补 … |'
- answer: '-   `| 10 | **对于** j = k + 1 **到** n |`'
  en: '| 10 | **对于** *j* = *k* + 1 **到** *n* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 10 | **对于**
    *j* = *k* + 1 **到** *n* |  输出：'
  type: TYPE_TB
  zh: '`| 10 | **对于** j = k + 1 **到** n |`'
- answer: '---

    -   | 11 | `a[ij]` = `a[ij]` − `l[ik]u[kj]` | **//** … 并将其存回`A`中 |'
  en: '| 11 | *a[ij]* = *a[ij]* − *l[ik]u[kj]* | **//** … 并将其存回*A*中 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 11 | *a[ij]*
    = *a[ij]* − *l[ik]u[kj]* | **//** … 并将其存回*A*中 |  输出：'
  type: TYPE_TB
  zh: '| 11 | `a[ij]` = `a[ij]` − `l[ik]u[kj]` | **//** … 并将其存回`A`中 |'
- answer: '-   | `12` | **返回** `L` 和 `U` |  '
  en: '| 12 | **返回** *L* 和 *U* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 12 | **返回**
    *L* 和 *U* |  输出：'
  type: TYPE_TB
  zh: '| `12` | **返回** `L` 和 `U` |  '
- answer: '-   上述描述中的每个递归步骤都在行 4-11 的外部`for`循环的一次迭代中发生。在这个循环中，行 5 确定主元为`u[kk]` = `a[kk]`。行
    6-8 中的`for`循环（当`k` = `n`时不执行）使用`v`和`w`向量更新`L`和`U`。行 7 确定`L`的下对角线元素，将`v[i]`/`a[kk]`存储在`l[ik]`中，行
    8 计算`U`的上对角线元素，将`w[i]`存储在`u[ki]`中。最后，行 9-11 计算舒尔补的元素，并将它们存回矩阵`A`中。（在行 11 中不需要除以`a[kk]`，因为当行
    7 计算`l[ik]`时已经发生过。）由于行 11 是三重嵌套的，LU-分解的运行时间为Θ(`n`³)。'
  en: 上述描述中的每个递归步骤都在行 4-11 的外部**for**循环的一次迭代中发生。在这个循环中，行 5 确定主元为*u[kk]* = *a[kk]*。行
    6-8 中的**for**循环（当*k* = *n*时不执行）使用*v*和*w*向量更新*L*和*U*。行 7 确定*L*的下对角线元素，将*v[i]*/*a[kk]*存储在*l[ik]*中，行
    8 计算*U*的上对角线元素，将*w[i]*存储在*u[ki]*中。最后，行 9-11 计算舒尔补的元素，并将它们存回矩阵*A*中。（在行 11 中不需要除以*a[kk]*，因为当行
    7 计算*l[ik]*时已经发生过。）由于行 11 是三重嵌套的，LU-分解的运行时间为Θ(*n*³)。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   上述描述中的每个递归步骤都在行
    4-11 的外部**for**循环的一次迭代中发生。在这个循环中，行 5 确定主元为*u[kk]* = *a[kk]*。行 6-8 中的**for**循环（当*k*
    = *n*时不执行）使用*v*和*w*向量更新*L*和*U*。行 7 确定*L*的下对角线元素，将*v[i]*/*a[kk]*存储在*l[ik]*中，行 8
    计算*U*的上对角线元素，将*w[i]*存储在*u[ki]*中。最后，行 9-11 计算舒尔补的元素，并将它们存回矩阵*A*中。（在行 11 中不需要除以*a[kk]*，因为当行
    7 计算*l[ik]*时已经发生过。）由于行 11 是三重嵌套的，LU-分解的运行时间为Θ(*n*³)。  输出：'
  type: TYPE_NORMAL
  zh: 上述描述中的每个递归步骤都在行 4-11 的外部`for`循环的一次迭代中发生。在这个循环中，行 5 确定主元为`u[kk]` = `a[kk]`。行
    6-8 中的`for`循环（当`k` = `n`时不执行）使用`v`和`w`向量更新`L`和`U`。行 7 确定`L`的下对角线元素，将`v[i]`/`a[kk]`存储在`l[ik]`中，行
    8 计算`U`的上对角线元素，将`w[i]`存储在`u[ki]`中。最后，行 9-11 计算舒尔补的元素，并将它们存回矩阵`A`中。（在行 11 中不需要除以`a[kk]`，因为当行
    7 计算`l[ik]`时已经发生过。）由于行 11 是三重嵌套的，LU-分解的运行时间为Θ(`n`³)。
- answer: '-   图 28.1 说明了 LU-分解的操作。它展示了该过程的标准优化，将`*L*`和`*U*`的重要元素就地存储在矩阵`*A*`中。每个元素`a[ij]`对应于`l[ij]`（如果`i`
    > `j`）或`u[ij]`（如果`i` ≤ `j`），因此当过程终止时，矩阵`A`同时保存`L`和`U`。要从 LU-分解过程的伪代码中获得此优化的伪代码，只需将对`l`或`u`的每个引用替换为`a`。您可以验证此转换保持正确性。'
  en: 图 28.1 说明了 LU-分解的操作。它展示了该过程的标准优化，将*L*和*U*的重要元素就地存储在矩阵*A*中。每个元素*a[ij]*对应于*l[ij]*（如果*i*
    > *j*）或*u[ij]*（如果*i* ≤ *j*），因此当过程终止时，矩阵*A*同时保存*L*和*U*。要从 LU-分解过程的伪代码中获得此优化的伪代码，只需将对*l*或*u*的每个引用替换为*a*。您可以验证此转换保持正确性。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   图 28.1 说明了
    LU-分解的操作。它展示了该过程的标准优化，将*L*和*U*的重要元素就地存储在矩阵*A*中。每个元素*a[ij]*对应于*l[ij]*（如果*i* > *j*）或*u[ij]*（如果*i*
    ≤ *j*），因此当过程终止时，矩阵*A*同时保存*L*和*U*。要从 LU-分解过程的伪代码中获得此优化的伪代码，只需将对*l*或*u*的每个引用替换为*a*。您可以验证此转换保持正确性。  输出：'
  type: TYPE_NORMAL
  zh: 图 28.1 说明了 LU-分解的操作。它展示了该过程的标准优化，将`*L*`和`*U*`的重要元素就地存储在矩阵`*A*`中。每个元素`a[ij]`对应于`l[ij]`（如果`i`
    > `j`）或`u[ij]`（如果`i` ≤ `j`），因此当过程终止时，矩阵`A`同时保存`L`和`U`。要从 LU-分解过程的伪代码中获得此优化的伪代码，只需将对`l`或`u`的每个引用替换为`a`。您可以验证此转换保持正确性。
- answer: '```

    -   ![艺术](img/Art_P922.jpg)

    ```'
  en: '![艺术](img/Art_P922.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P922.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P922.jpg)'
- answer: '-   **图 28.1** LU-分解的操作。**(a)** 矩阵`A`。**(b)** 第一次外部`for`循环的结果，行 4-11。蓝色突出显示的元素`a[11]
    = 2` 是主元，棕色列是`v/a[11]`，棕色行是`w^T`。到目前为止计算出的`U`元素在水平线上方，`L`元素在垂直线左侧。舒尔补矩阵`A′ - vw^T/a[11]`占据右下角。**(c)**
    对来自(b)部分的舒尔补矩阵的下一次外部`for`循环的结果。蓝色突出显示的元素`a[22] = 4` 是主元，棕色列和行分别是`v/a[22]`和`w^T`（在舒尔补分区中）。线将矩阵分为到目前为止计算出的`U`元素（上方），到目前为止计算出的`L`元素（左侧）和新的舒尔补（右下角）。**(d)**
    经过下一次迭代后，矩阵`A`被分解。当递归终止时，新舒尔补中的元素 3 成为`U`的一部分。**(e)** 分解`A = LU`。'
  en: '**图 28.1** LU-分解的操作。**(a)** 矩阵*A*。**(b)** 第一次外部**for**循环的结果，行 4-11。蓝色突出显示的元素*a*[11]
    = 2 是主元，棕色列是*v*/*a*[11]，棕色行是*w*^T。到目前为止计算出的*U*元素在水平线上方，*L*元素在垂直线左侧。舒尔补矩阵*A*′ −
    *vw*^T/*a*[11]占据右下角。**(c)** 对来自(b)部分的舒尔补矩阵的下一次外部**for**循环的结果。蓝色突出显示的元素*a*[22]
    = 4 是主元，棕色列和行分别是*v*/*a*[22]和*w*^T（在舒尔补分区中）。线将矩阵分为到目前为止计算出的*U*元素（上方），到目前为止计算出的*L*元素（左侧）和新的舒尔补（右下角）。**(d)**
    经过下一次迭代后，矩阵*A*被分解。当递归终止时，新舒尔补中的元素 3 成为*U*的一部分。**(e)** 分解*A* = *LU*。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **图 28.1**
    LU-分解的操作。**(a)** 矩阵*A*。**(b)** 第一次外部**for**循环的结果，行 4-11。蓝色突出显示的元素*a*[11] = 2 是主元，棕色列是*v*/*a*[11]，棕色行是*w*^T。到目前为止计算出的*U*元素在水平线上方，*L*元素在垂直线左侧。舒尔补矩阵*A*′
    − *vw*^T/*a*[11]占据右下角。**(c)** 对来自(b)部分的舒尔补矩阵的下一次外部**for**循环的结果。蓝色突出显示的元素*a*[22]
    = 4 是主元，棕色列和行分别是*v*/*a*[22]和*w*^T（在舒尔补分区中）。线将矩阵分为到目前为止计算出的*U*元素（上方），到目前为止计算出的*L*元素（左侧）和新的舒尔补（右下角）。**(d)**
    经过下一次迭代后，矩阵*A*被分解。当递归终止时，新舒尔补中的元素 3 成为*U*的一部分。**(e)** 分解*A* = *LU*。  输出：'
  type: TYPE_NORMAL
  zh: '**图 28.1** LU-分解的操作。**(a)** 矩阵`A`。**(b)** 第一次外部`for`循环的结果，行 4-11。蓝色突出显示的元素`a[11]
    = 2` 是主元，棕色列是`v/a[11]`，棕色行是`w^T`。到目前为止计算出的`U`元素在水平线上方，`L`元素在垂直线左侧。舒尔补矩阵`A′ - vw^T/a[11]`占据右下角。**(c)**
    对来自(b)部分的舒尔补矩阵的下一次外部`for`循环的结果。蓝色突出显示的元素`a[22] = 4` 是主元，棕色列和行分别是`v/a[22]`和`w^T`（在舒尔补分区中）。线将矩阵分为到目前为止计算出的`U`元素（上方），到目前为止计算出的`L`元素（左侧）和新的舒尔补（右下角）。**(d)**
    经过下一次迭代后，矩阵`A`被分解。当递归终止时，新舒尔补中的元素 3 成为`U`的一部分。**(e)** 分解`A = LU`。'
- answer: '---

    -   **计算 LUP 分解**'
  en: '**计算 LUP 分解**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **计算 LUP 分解**  输出：'
  type: TYPE_NORMAL
  zh: '**计算 LUP 分解**'
- answer: '-   如果提供给`LU-分解`的矩阵的对角线包含任何 0，那么该过程将尝试除以 0，这将导致灾难。即使对角线不包含 0，但包含绝对值较小的数字，除以这样的数字可能导致数值不稳定。因此，`LUP
    分解`会在能找到的具有最大绝对值的条目上进行主元选取。  '
  en: 如果提供给 LU-分解的矩阵的对角线包含任何 0，那么该过程将尝试除以 0，这将导致灾难。即使对角线不包含 0，但包含绝对值较小的数字，除以这样的数字可能导致数值不稳定。因此，LUP
    分解会在能找到的具有最大绝对值的条目上进行主元选取。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   如果提供给 LU-分解的矩阵的对角线包含任何
    0，那么该过程将尝试除以 0，这将导致灾难。即使对角线不包含 0，但包含绝对值较小的数字，除以这样的数字可能导致数值不稳定。因此，LUP 分解会在能找到的具有最大绝对值的条目上进行主元选取。  输出：'
  type: TYPE_NORMAL
  zh: '如果提供给`LU-分解`的矩阵的对角线包含任何 0，那么该过程将尝试除以 0，这将导致灾难。即使对角线不包含 0，但包含绝对值较小的数字，除以这样的数字可能导致数值不稳定。因此，`LUP
    分解`会在能找到的具有最大绝对值的条目上进行主元选取。  '
- answer: '-   在 LUP 分解中，输入是一个`n` × `n`非奇异矩阵`A`，目标是找到一个置换矩阵`P`，一个单位下三角矩阵`L`，和一个上三角矩阵`U`，使得`PA`
    = `LU`。在将矩阵`A`分割之前，与 LU 分解不同，LUP 分解将一个非零元素，比如`a[k1]`，从第一列的某处移动到矩阵的(1, 1)位置。为了获得最大的数值稳定性，LUP
    分解选择第一列中绝对值最大的元素作为`a[k1]`。（第一列不能只包含 0，否则`A`将是奇异的，因为根据第 1221 页的定理 D.4 和 D.5，它的行列式为
    0。）为了保持方程组，LUP 分解交换第 1 行和第`k`行，这等效于在左边将`A`乘以置换矩阵`Q`（第 1219 页的练习 D.1-4）。因此，类似于方程(28.8)，`QA`表示为'
  en: 在 LUP 分解中，输入是一个*n* × *n*非奇异矩阵*A*，目标是找到一个置换矩阵*P*，一个单位下三角矩阵*L*，和一个上三角矩阵*U*，使得*PA*
    = *LU*。在将矩阵*A*分割之前，与 LU 分解不同，LUP 分解将一个非零元素，比如*a*[*k*1]，从第一列的某处移动到矩阵的(1, 1)位置。为了获得最大的数值稳定性，LUP
    分解选择第一列中绝对值最大的元素作为*a*[*k*1]。（第一列不能只包含 0，否则*A*将是奇异的，因为根据第 1221 页的定理 D.4 和 D.5，它的行列式为
    0。）为了保持方程组，LUP 分解交换第 1 行和第*k*行，这等效于在左边将*A*乘以置换矩阵*Q*（第 1219 页的练习 D.1-4）。因此，类似于方程(28.8)，*QA*表示为
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   在 LUP 分解中，输入是一个*n*
    × *n*非奇异矩阵*A*，目标是找到一个置换矩阵*P*，一个单位下三角矩阵*L*，和一个上三角矩阵*U*，使得*PA* = *LU*。在将矩阵*A*分割之前，与
    LU 分解不同，LUP 分解将一个非零元素，比如*a*[*k*1]，从第一列的某处移动到矩阵的(1, 1)位置。为了获得最大的数值稳定性，LUP 分解选择第一列中绝对值最大的元素作为*a*[*k*1]。（第一列不能只包含
    0，否则*A*将是奇异的，因为根据第 1221 页的定理 D.4 和 D.5，它的行列式为 0。）为了保持方程组，LUP 分解交换第 1 行和第*k*行，这等效于在左边将*A*乘以置换矩阵*Q*（第
    1219 页的练习 D.1-4）。因此，类似于方程(28.8)，*QA*表示为  输出：'
  type: TYPE_NORMAL
  zh: 在 LUP 分解中，输入是一个`n` × `n`非奇异矩阵`A`，目标是找到一个置换矩阵`P`，一个单位下三角矩阵`L`，和一个上三角矩阵`U`，使得`PA`
    = `LU`。在将矩阵`A`分割之前，与 LU 分解不同，LUP 分解将一个非零元素，比如`a[k1]`，从第一列的某处移动到矩阵的(1, 1)位置。为了获得最大的数值稳定性，LUP
    分解选择第一列中绝对值最大的元素作为`a[k1]`。（第一列不能只包含 0，否则`A`将是奇异的，因为根据第 1221 页的定理 D.4 和 D.5，它的行列式为
    0。）为了保持方程组，LUP 分解交换第 1 行和第`k`行，这等效于在左边将`A`乘以置换矩阵`Q`（第 1219 页的练习 D.1-4）。因此，类似于方程(28.8)，`QA`表示为
- answer: '---

    -   ![艺术](img/Art_P923.jpg)'
  en: '![艺术](img/Art_P923.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P923.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P923.jpg)'
- answer: '-   其中`v = (a[21], a[31], … , a[n1])`，除了`a[11]`替换为`a[k1]`；`w^T = (a[k2],
    a[k3], … , a[kn])^T`；`A''`是一个`(n - 1) × (n - 1)`矩阵。由于`a[k1] ≠ 0`，类似于方程(28.9)，不会出现除以
    0 的情况：  '
  en: 其中*v* = (*a*[21], *a*[31], … , *a*[*n*1])，除了*a*[11]替换为*a*[*k*1]；*w*^T = (*a*[*k*2],
    *a*[*k*3], … , *a[kn]*)^T；*A*′是一个(*n* − 1) × (*n* − 1)矩阵。由于*a*[*k*1] ≠ 0，类似于方程(28.9)，不会出现除以
    0 的情况：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   其中*v* = (*a*[21],
    *a*[31], … , *a*[*n*1])，除了*a*[11]替换为*a*[*k*1]；*w*^T = (*a*[*k*2], *a*[*k*3], …
    , *a[kn]*)^T；*A*′是一个(*n* − 1) × (*n* − 1)矩阵。由于*a*[*k*1] ≠ 0，类似于方程(28.9)，不会出现除以
    0 的情况：  输出：'
  type: TYPE_NORMAL
  zh: '其中`v = (a[21], a[31], … , a[n1])`，除了`a[11]`替换为`a[k1]`；`w^T = (a[k2], a[k3],
    … , a[kn])^T`；`A''`是一个`(n - 1) × (n - 1)`矩阵。由于`a[k1] ≠ 0`，类似于方程(28.9)，不会出现除以 0
    的情况：  '
- answer: '-   ![艺术](img/Art_P924.jpg)'
  en: '![艺术](img/Art_P924.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P924.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P924.jpg)'
- answer: '-   就像 LU 分解一样，如果`A`是非奇异的，那么舒尔补`A′ − vw^T/a[k1]`也是非奇异的。因此，你可以递归地为其找到一个
    LUP 分解，其中包括单位下三角矩阵`L′`，上三角矩阵`U′`，和置换矩阵`P′`，使得'
  en: 就像 LU 分解一样，如果*A*是非奇异的，那么舒尔补*A*′ − *vw*^T/*a*[*k*1]也是非奇异的。因此，你可以递归地为其找到一个 LUP
    分解，其中包括单位下三角矩阵*L*′，上三角矩阵*U*′，和置换矩阵*P*′，使得
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   就像 LU 分解一样，如果*A*是非奇异的，那么舒尔补*A*′
    − *vw*^T/*a*[*k*1]也是非奇异的。因此，你可以递归地为其找到一个 LUP 分解，其中包括单位下三角矩阵*L*′，上三角矩阵*U*′，和置换矩阵*P*′，使得  输出：'
  type: TYPE_NORMAL
  zh: 就像 LU 分解一样，如果`A`是非奇异的，那么舒尔补`A′ − vw^T/a[k1]`也是非奇异的。因此，你可以递归地为其找到一个 LUP 分解，其中包括单位下三角矩阵`L′`，上三角矩阵`U′`，和置换矩阵`P′`，使得
- answer: '-   `P′(A′ − vw^T/a[k1]) = L′U′`'
  en: '*P*′(*A*′ − *vw*^T/*a*[*k*1]) = *L*′*U*′。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *P*′(*A*′ −
    *vw*^T/*a*[*k*1]) = *L*′*U*′。  输出：'
  type: TYPE_NORMAL
  zh: '`P′(A′ − vw^T/a[k1]) = L′U′`'
- answer: '-   定义'
  en: 定义
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   定义  输出：'
  type: TYPE_NORMAL
  zh: 定义
- answer: '-   ![艺术](img/Art_P925.jpg)'
  en: '![艺术](img/Art_P925.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P925.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P925.jpg)'
- answer: '-   这是一个置换矩阵，因为它是两个置换矩阵的乘积（第 1219 页的练习 D.1-4）。这个`P`的定义为'
  en: 这是一个置换矩阵，因为它是两个置换矩阵的乘积（第 1219 页的练习 D.1-4）。这个*P*的定义为
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   这是一个置换矩阵，因为它是两个置换矩阵的乘积（第
    1219 页的练习 D.1-4）。这个*P*的定义为  输出：'
  type: TYPE_NORMAL
  zh: 这是一个置换矩阵，因为它是两个置换矩阵的乘积（第 1219 页的练习 D.1-4）。这个`P`的定义为
- answer: '-   ![艺术](img/Art_P926.jpg)'
  en: '![艺术](img/Art_P926.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P926.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P926.jpg)'
- answer: '-   这导致了 LUP 分解。因为`L′`是单位下三角形的，所以`L`也是；因为`U′`是上三角形的，所以`U`也是。'
  en: 这导致了 LUP 分解。因为*L*′是单位下三角形的，所以*L*也是；因为*U*′是上三角形的，所以*U*也是。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   这导致了 LUP 分解。因为*L*′是单位下三角形的，所以*L*也是；因为*U*′是上三角形的，所以*U*也是。  输出：'
  type: TYPE_NORMAL
  zh: 这导致了 LUP 分解。因为`L′`是单位下三角形的，所以`L`也是；因为`U′`是上三角形的，所以`U`也是。
- answer: '---

    -   注意，在这个推导中，与 LU 分解不同，列向量`v/a[k1]`和舒尔补`A′ - vw^T/a[k1]`都乘以置换矩阵`P′`。LUP-DECOMPOSITION
    过程给出了 LUP 分解的伪代码。

    ---'
  en: 注意，在这个推导中，与 LU 分解不同，列向量*v*/*a*[*k*1]和舒尔补*A*′ − *vw*^T/*a*[*k*1]都乘以置换矩阵*P*′。LUP-DECOMPOSITION
    过程给出了 LUP 分解的伪代码。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   注意，在这个推导中，与
    LU 分解不同，列向量*v*/*a*[*k*1]和舒尔补*A*′ − *vw*^T/*a*[*k*1]都乘以置换矩阵*P*′。LUP-DECOMPOSITION
    过程给出了 LUP 分解的伪代码。  输出：'
  type: TYPE_NORMAL
  zh: 注意，在这个推导中，与 LU 分解不同，列向量`v/a[k1]`和舒尔补`A′ - vw^T/a[k1]`都乘以置换矩阵`P′`。LUP-DECOMPOSITION
    过程给出了 LUP 分解的伪代码。
- answer: '-   `LUP-DECOMPOSITION(A, n)`  '
  en: LUP-DECOMPOSITION(*A*, *n*)
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   LUP-DECOMPOSITION(*A*,
    *n*)  输出：'
  type: TYPE_NORMAL
  zh: '`LUP-DECOMPOSITION(A, n)`  '
- answer: '---

    -   |   1 | 让 `π[1 : n]` 成为一个新数组 |'
  en: '|   1 | 让 *π*[1 : *n*] 成为一个新数组 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |   1 | 让 *π*[1
    : *n*] 成为一个新数组 |  输出：'
  type: TYPE_TB
  zh: '|   1 | 让 `π[1 : n]` 成为一个新数组 |'
- answer: '-   | --- | --- |'
  en: '| --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | --- | ---
    |  输出：'
  type: TYPE_TB
  zh: '| --- | --- |'
- answer: '-   `| 2 |` **对于** `i = 1` **到** `n` |  '
  en: '|   2 | **对于** *i* = 1 **到** *n* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |   2 | **对于** *i*
    = 1 **到** *n* |  输出：'
  type: TYPE_TB
  zh: '`| 2 |` **对于** `i = 1` **到** `n` |  '
- answer: '-   |   3 | `π[i] = i` | **//** 将`π`初始化为单位置换 |'
  en: '|   3 | *π*[*i*] = *i* | **//** 将*π*初始化为单位置换 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |   3 | *π*[*i*]
    = *i* | **//** 将*π*初始化为单位置换 |  输出：'
  type: TYPE_TB
  zh: '|   3 | `π[i] = i` | **//** 将`π`初始化为单位置换 |'
- answer: '-   |   4 | **对于** `k` = 1 **到** `n` |'
  en: '|   4 | **对于** *k* = 1 **到** *n* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |   4 | **对于** *k*
    = 1 **到** *n* |  输出：'
  type: TYPE_TB
  zh: '|   4 | **对于** `k` = 1 **到** `n` |'
- answer: '-   |   `5` | *p* = `0` |  '
  en: '|   5 | *p* = 0 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |   5 | *p*
    = 0 |  输出：'
  type: TYPE_TB
  zh: '|   `5` | *p* = `0` |  '
- answer: '-   |   6 | `**对于** i = k **到** n` | **//** 找到第`k`列中绝对值最大的值 |'
  en: '|   6 | **对于** *i* = *k* **到** *n* | **//** 找到第*k*列中绝对值最大的值 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |   6 | **对于** *i*
    = *k* **到** *n* | **//** 找到第*k*列中绝对值最大的值 |  输出：'
  type: TYPE_TB
  zh: '|   6 | `**对于** i = k **到** n` | **//** 找到第`k`列中绝对值最大的值 |'
- answer: '```

    -   |   7 | **如果** |*a[ik]*| > *p* |

    ```'
  en: '|   7 | **如果** &#124;*a[ik]*&#124; > *p* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |   7 | **如果**
    &#124;*a[ik]*&#124; > *p* |  输出：'
  type: TYPE_TB
  zh: '|   7 | **如果** |*a[ik]*| > *p* |'
- answer: '-   `|   8 | p = |a[ik]|`'
  en: '|   8 | *p* = &#124;*a[ik]*&#124; |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |   8 | *p*
    = &#124;*a[ik]*&#124; |  输出：'
  type: TYPE_TB
  zh: '`|   8 | p = |a[ik]|`'
- answer: '---

    -   |   9 | `k′ = i` | **//** 到目前为止找到的最大值所在的行号 |'
  en: '|   9 | *k*′ = *i* | **//** 到目前为止找到的最大值所在的行号 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |   9 | *k*′
    = *i* | **//** 到目前为止找到的最大值所在的行号 |  输出：'
  type: TYPE_TB
  zh: '|   9 | `k′ = i` | **//** 到目前为止找到的最大值所在的行号 |'
- answer: '---

    -   | `10` | **如果** *p* == 0 | '
  en: '| 10 | **如果** *p* == 0 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 10 | **如果** *p*
    == 0 |  输出：'
  type: TYPE_TB
  zh: '| `10` | **如果** *p* == 0 | '
- answer: '-   | `11` | **错误** “奇异矩阵” |'
  en: '| 11 | **错误** “奇异矩阵” |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 11 | **错误**
    “奇异矩阵” |  输出：'
  type: TYPE_TB
  zh: '| `11` | **错误** “奇异矩阵” |'
- answer: '-   | 12 | 用`π[k]`交换`π[k′]` |  '
  en: '| 12 | 用*π*[*k*]交换*π*[*k*′] |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 12 | 用*π*[*k*]交换*π*[*k*′]
    |  输出：'
  type: TYPE_TB
  zh: '| 12 | 用`π[k]`交换`π[k′]` |  '
- answer: '---

    -   | 13 | **对于** `i = 1` **到** `n` | '
  en: '| 13 | **对于** *i* = 1 **到** *n* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 13 | **对于** *i*
    = 1 **到** *n* |  输出：'
  type: TYPE_TB
  zh: '| 13 | **对于** `i = 1` **到** `n` | '
- answer: '-   | `14` | 用`a[ki]`交换`a[ki'']` | **//** 交换行`k`和`k''` |'
  en: '| 14 | 用*a[ki]*交换*a[k′i]* | **//** 交换行*k*和*k*′ |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 14 | 用*a[ki]*交换*a[k′i]*
    | **//** 交换行*k*和*k*′ |  输出：'
  type: TYPE_TB
  zh: '| `14` | 用`a[ki]`交换`a[ki'']` | **//** 交换行`k`和`k''` |'
- answer: '-   `| 15 |` **对于** `i = k + 1` **到** `n` |'
  en: '| 15 | **对于** *i* = *k* + 1 **到** *n* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 15 | **对于** *i*
    = *k* + 1 **到** *n* |  输出：'
  type: TYPE_TB
  zh: '`| 15 |` **对于** `i = k + 1` **到** `n` |'
- answer: '-   | 16 | `a[ik] = a[ik]/a[kk]` |'
  en: '| 16 | *a[ik]* = *a[ik]*/*a[kk]* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 16 | *a[ik]*
    = *a[ik]*/*a[kk]* |  输出：'
  type: TYPE_TB
  zh: '| 16 | `a[ik] = a[ik]/a[kk]` |'
- answer: '-   | 17 | **对于** `j = k + 1` **到** `n` |'
  en: '| 17 | **对于** *j* = *k* + 1 **到** *n* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 17 | **对于** *j*
    = *k* + 1 **到** *n* |  输出：'
  type: TYPE_TB
  zh: '| 17 | **对于** `j = k + 1` **到** `n` |'
- answer: '-   | `18` | `a[ij]` = `a[ij]` − `a[ik]a[kj]` | **//** 在`A`中就地计算`L`和`U`
    |  '
  en: '| 18 | *a[ij]* = *a[ij]* − *a[ik]a[kj]* | **//** 在*A*中就地计算*L*和*U* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 18 | *a[ij]*
    = *a[ij]* − *a[ik]a[kj]* | **//** 在*A*中就地计算*L*和*U* |  输出：'
  type: TYPE_TB
  zh: '| `18` | `a[ij]` = `a[ij]` − `a[ik]a[kj]` | **//** 在`A`中就地计算`L`和`U` |  '
- answer: '-   类似于 LU-DECOMPOSITION，LUP-DECOMPOSITION 过程用迭代循环替换了递归。作为对递归的直接实现的改进，该过程动态地将置换矩阵`P`维护为一个数组`π`，其中`π[i]
    = j`表示`P`的第`i`行在第`j`列包含一个 1。LUP-DECOMPOSITION 过程还实现了前面提到的改进，就地在矩阵`A`中计算`L`和`U`。因此，当过程终止时，'
  en: 类似于 LU-DECOMPOSITION，LUP-DECOMPOSITION 过程用迭代循环替换了递归。作为对递归的直接实现的改进，该过程动态地将置换矩阵*P*维护为一个数组*π*��其中*π*[*i*]
    = *j*表示*P*的第*i*行在第*j*列包含一个 1。LUP-DECOMPOSITION 过程还实现了前面提到的改进，就地在矩阵*A*中计算*L*和*U*。因此，当过程终止时，
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   类似于 LU-DECOMPOSITION，LUP-DECOMPOSITION
    过程用迭代循环替换了递归。作为对递归的直接实现的改进，该过程动态地将置换矩阵*P*维护为一个数组*π*��其中*π*[*i*] = *j*表示*P*的第*i*行在第*j*列包含一个
    1。LUP-DECOMPOSITION 过程还实现了前面提到的改进，就地在矩阵*A*中计算*L*和*U*。因此，当过程终止时，  输出：'
  type: TYPE_NORMAL
  zh: 类似于 LU-DECOMPOSITION，LUP-DECOMPOSITION 过程用迭代循环替换了递归。作为对递归的直接实现的改进，该过程动态地将置换矩阵`P`维护为一个数组`π`，其中`π[i]
    = j`表示`P`的第`i`行在第`j`列包含一个 1。LUP-DECOMPOSITION 过程还实现了前面提到的改进，就地在矩阵`A`中计算`L`和`U`。因此，当过程终止时，
- answer: '---

    -   ![艺术](img/Art_P927.jpg)'
  en: '![艺术](img/Art_P927.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P927.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P927.jpg)'
- answer: '-   图 28.2 说明了 LUP-分解如何分解矩阵。第 2–3 行初始化数组`π`以表示身份置换。第 4–18 行的外部**for**循环实现了递归，找到一个(`n`
    − `k` + 1) × (`n` − `k` + 1)子矩阵的 LUP 分解，其左上角在第`k`行和第`k`列。每次通过外部循环时，第 5–9 行确定当前第一列（第`k`列）中绝对值最大的元素`a[k′k]`，该元素位于当前工作的(`n`
    − `k` + 1) × (`n` − `k` + 1)子矩阵中���如果当前第一列中的所有元素都为 0，则第 10–11 行报告矩阵是奇异的。为了进行枢轴，第
    12 行交换`π[k′]`和`π[k]`，第 13–14 行交换`A`的第`k`行和第`k′`行，从而使枢轴元素为`a[kk]`。（整行交换是因为在上面的方法推导中，不仅`A′
    − vw^T/a[k1]`被`P′`乘以，`v/a[k1]`也是如此。）最后，通过第 15–18 行计算舒尔补，方式与 LU-分解的第 6–11 行计算方式基本相同，只是这里的操作被写成就地工作。  '
  en: 图 28.2 说明了 LUP-分解如何分解矩阵。第 2–3 行初始化数组*π*以表示身份置换。第 4–18 行的外部**for**循环实现了递归，找到一个(*n*
    − *k* + 1) × (*n* − *k* + 1)子矩阵的 LUP 分解，其左上角在第*k*行和第*k*列。每次通过外部循环时，第 5–9 行确定当前第一列（第*k*列）中绝对值最大的元素*a*[*k′k*]，该元素位于当前工作的(*n*
    − *k* + 1) × (*n* − *k* + 1)子矩阵中���如果当前第一列中的所有元素都为 0，则第 10–11 行报告矩阵是奇异的。为了进行枢轴，第
    12 行交换*π*[*k*′]和*π*[*k*]，第 13–14 行交换*A*的第*k*行和第*k*′行，从而使枢轴元素为*a[kk]*。（整行交换是因为在上面的方法推导中，不仅*A*′
    − *vw*^T/*a*[*k*1]被*P*′乘以，*v*/*a*[*k*1]也是如此。）最后，通过第 15–18 行计算舒尔补，方式与 LU-分解的第 6–11
    行计算方式基本相同，只是这里的操作被写成就地工作。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   图 28.2 说明了
    LUP-分解如何分解矩阵。第 2–3 行初始化数组*π*以表示身份置换。第 4–18 行的外部**for**循环实现了递归，找到一个(*n* − *k* +
    1) × (*n* − *k* + 1)子矩阵的 LUP 分解，其左上角在第*k*行和第*k*列。每次通过外部循环时，第 5–9 行确定当前第一列（第*k*列）中绝对值最大的元素*a*[*k′k*]，该元素位于当前工作的(*n*
    − *k* + 1) × (*n* − *k* + 1)子矩阵中���如果当前第一列中的所有元素都为 0，则第 10–11 行报告矩阵是奇异的。为了进行枢轴，第
    12 行交换*π*[*k*′]和*π*[*k*]，第 13–14 行交换*A*的第*k*行和第*k*′行，从而使枢轴元素为*a[kk]*。（整行交换是因为在上面的方法推导中，不仅*A*′
    − *vw*^T/*a*[*k*1]被*P*′乘以，*v*/*a*[*k*1]也是如此。）最后，通过第 15–18 行计算舒尔补，方式与 LU-分解的第 6–11
    行计算方式基本相同，只是这里的操作被写成就地工作。  输出：'
  type: TYPE_NORMAL
  zh: '图 28.2 说明了 LUP-分解如何分解矩阵。第 2–3 行初始化数组`π`以表示身份置换。第 4–18 行的外部**for**循环实现了递归，找到一个(`n`
    − `k` + 1) × (`n` − `k` + 1)子矩阵的 LUP 分解，其左上角在第`k`行和第`k`列。每次通过外部循环时，第 5–9 行确定当前第一列（第`k`列）中绝对值最大的元素`a[k′k]`，该元素位于当前工作的(`n`
    − `k` + 1) × (`n` − `k` + 1)子矩阵中���如果当前第一列中的所有元素都为 0，则第 10–11 行报告矩阵是奇异的。为了进行枢轴，第
    12 行交换`π[k′]`和`π[k]`，第 13–14 行交换`A`的第`k`行和第`k′`行，从而使枢轴元素为`a[kk]`。（整行交换是因为在上面的方法推导中，不仅`A′
    − vw^T/a[k1]`被`P′`乘以，`v/a[k1]`也是如此。）最后，通过第 15–18 行计算舒尔补，方式与 LU-分解的第 6–11 行计算方式基本相同，只是这里的操作被写成就地工作。  '
- answer: '-   `![艺术](img/Art_P928.jpg)`  '
  en: '![艺术](img/Art_P928.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P928.jpg)  输出：'
  type: TYPE_IMG
  zh: '`![艺术](img/Art_P928.jpg)`  '
- answer: '-   **图 28.2** LUP-分解的操作。**(a)** 输入矩阵`A`，左侧为黄色的行的身份置换。算法的第一步确定了第一列的主元为第三行中突出显示的蓝色元素
    5。**(b)** 交换第 1 行和第 3 行，并更新置换。棕色的列和行代表`v`和`w^T`。**(c)** 向量`v`被`v/5` 替换，并且右下角的矩阵使用舒尔补更新。线将矩阵分为三个区域：`U`的元素（上方）、`L`的元素（左侧）和舒尔补的元素（右下角）。**(d)–(f)**
    第二步。**(g)–(i)** 第三步。在第四（最后）步中不会发生进一步的更改。**(j)** LUP 分解`PA = LU`。'
  en: '**图 28.2** LUP-分解的操作。**(a)** 输入矩阵*A*，左侧为黄色的行的身份置换。算法的第一步确定了第一列的主元为第三行中突出显示的蓝色元素
    5。**(b)** 交换第 1 行和第 3 行，并更新置换。棕色的列和行代表*v*和*w*^T。**(c)** 向量*v*被*v*/5 替换，并且右下角的矩阵使用舒尔补更新。线将矩阵分为三个区域：*U*的元素（上方）、*L*的元素（左侧）和舒尔补的元素（右下角）。**(d)–(f)**
    第二步。**(g)–(i)** 第三步。在第四（最后）步中不会发生进一步的更改。**(j)** LUP 分解*PA* = *LU*。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **图 28.2**
    LUP-分解的操作。**(a)** 输入矩阵*A*，左侧为黄色的行的身份置换。算法的第一步确定了第一列的主元为第三行中突出显示的蓝色元素 5。**(b)**
    交换第 1 行和第 3 行，并更新置换。棕色的列和行代表*v*和*w*^T。**(c)** 向量*v*被*v*/5 替换，并且右下角的矩阵使用舒尔补更新。线将矩阵分为三个区域：*U*的元素（上方）、*L*的元素（左侧）和舒尔补的元素（右下角）。**(d)–(f)**
    第二步。**(g)–(i)** 第三步。在第四（最后）步中不会发生进一步的更改。**(j)** LUP 分解*PA* = *LU*。  输出：'
  type: TYPE_NORMAL
  zh: '**图 28.2** LUP-分解的操作。**(a)** 输入矩阵`A`，左侧为黄色的行的身份置换。算法的第一步确定了第一列的主元为第三行中突出显示的蓝色元素
    5。**(b)** 交换第 1 行和第 3 行，并更新置换。棕色的列和行代表`v`和`w^T`。**(c)** 向量`v`被`v/5` 替换，并且右下角的矩阵使用舒尔补更新。线将矩阵分为三个区域：`U`的元素（上方）、`L`的元素（左侧）和舒尔补的元素（右下角）。**(d)–(f)**
    第二步。**(g)–(i)** 第三步。在第四（最后）步中不会发生进一步的更改。**(j)** LUP 分解`PA = LU`。'
- answer: '-   由于其三重嵌套循环结构，LUP-分解的运行时间为`Θ(n³)`，与 LU-分解相同。因此，枢轴成本最多只是一个常数因子的时间。'
  en: 由于其三重嵌套循环结构，LUP-分解的运行时间为Θ(*n*³)，与 LU-分解相同。因此，枢轴成本最多只是一个常数因子的时间。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   由于其三重嵌套循环结构，LUP-分解的运行时间为Θ(*n*³)，与
    LU-分解相同。因此，枢轴成本最多只是一个常数因子的时间。  输出：'
  type: TYPE_NORMAL
  zh: 由于其三重嵌套循环结构，LUP-分解的运行时间为`Θ(n³)`，与 LU-分解相同。因此，枢轴成本最多只是一个常数因子的时间。
- answer: '-   `练习`'
  en: '**练习**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **练习**  输出：'
  type: TYPE_NORMAL
  zh: '`练习`'
- answer: '---

    -   ***28.1-1***'
  en: '***28.1-1***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28.1-1***  输出：'
  type: TYPE_NORMAL
  zh: '***28.1-1***'
- answer: '-   解方程'
  en: 解方程
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   解方程  输出：'
  type: TYPE_NORMAL
  zh: 解方程
- answer: '---

    -   ![艺术](img/Art_P929.jpg)'
  en: '![艺术](img/Art_P929.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P929.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P929.jpg)'
- answer: '-   通过使用前向替换。'
  en: 通过使用前向替换。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   通过使用前向替换。  输出：'
  type: TYPE_NORMAL
  zh: 通过使用前向替换。
- answer: '-   `28.1-2`'
  en: '***28.1-2***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28.1-2***  输出：'
  type: TYPE_NORMAL
  zh: '`28.1-2`'
- answer: '-   找到矩阵的`LU`分解。'
  en: 找到矩阵的 LU 分解。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   找到矩阵的 LU 分解。  输出：'
  type: TYPE_NORMAL
  zh: 找到矩阵的`LU`分解。
- answer: '---

    -   ![艺术](img/Art_P930.jpg)'
  en: '![艺术](img/Art_P930.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P930.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P930.jpg)'
- answer: '-   ***28.1-3***'
  en: '***28.1-3***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28.1-3***  输出：'
  type: TYPE_NORMAL
  zh: '***28.1-3***'
- answer: '-   解方程'
  en: 解方程
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   解方程  输出：'
  type: TYPE_NORMAL
  zh: 解方程
- answer: '---

    -   ![艺术](img/Art_P931.jpg)'
  en: '![艺术](img/Art_P931.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P931.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P931.jpg)'
- answer: '-   通过使用 LUP 分解。'
  en: 通过使用 LUP 分解。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   通过使用 LUP 分解。  输出：'
  type: TYPE_NORMAL
  zh: 通过使用 LUP 分解。
- answer: '-   ***`28.1-4`***'
  en: '***28.1-4***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28.1-4***  输出：'
  type: TYPE_NORMAL
  zh: '***`28.1-4`***'
- answer: '-   描述对角矩阵的 LUP 分解。'
  en: 描述对角矩阵的 LUP 分解。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   描述对角矩阵的 LUP
    分解。  输出：'
  type: TYPE_NORMAL
  zh: 描述对角矩阵的 LUP 分解。
- answer: '-   ***28.1-5***


    '
  en: '***28.1-5***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28.1-5***  输出：'
  type: TYPE_NORMAL
  zh: '***28.1-5***'
- answer: '-   描述置换矩阵的`LUP`分解，并证明其唯一性。'
  en: 描述置换矩阵的 LUP 分解，并证明其唯一性。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   描述置换矩阵的 LUP
    分解，并证明其唯一性。  输出：'
  type: TYPE_NORMAL
  zh: 描述置换矩阵的`LUP`分解，并证明其唯一性。
- answer: '-   ***28.1-6***'
  en: '***28.1-6***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28.1-6***  输出：'
  type: TYPE_NORMAL
  zh: '***28.1-6***'
- answer: '-   证明对于所有`n` ≥ 1，存在一个奇异的`n × n`矩阵，它有一个 LU 分解。'
  en: 证明对于所有*n* ≥ 1，存在一个奇异的*n* × *n*矩阵，它有一个 LU 分解。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   证明对于所有*n* ≥
    1，存在一个奇异的*n* × *n*矩阵，它有一个 LU 分解。  输出：'
  type: TYPE_NORMAL
  zh: 证明对于所有`n` ≥ 1，存在一个奇异的`n × n`矩阵，它有一个 LU 分解。
- answer: '-   `28.1-7`  '
  en: '***28.1-7***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28.1-7***  输出：'
  type: TYPE_NORMAL
  zh: '`28.1-7`  '
- answer: '---

    -   在 LU-分解中，当`k` = `n`时，是否需要执行最外层的**for**循环迭代？LUP-分解呢？

    ---'
  en: 在 LU-分解中，当*k* = *n*时，是否需要执行最外层的**for**循环迭代？LUP-分解呢？
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   在 LU-分解中，当*k*
    = *n*时，是否需要执行最外层的**for**循环迭代？LUP-分解呢？  输出：'
  type: TYPE_NORMAL
  zh: 在 LU-分解中，当`k` = `n`时，是否需要执行最外层的**for**循环迭代？LUP-分解呢？
- answer: '-   **28.2 求逆矩阵**'
  en: '**28.2    求逆矩阵**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **28.2    求逆矩阵**  输出：'
  type: TYPE_NORMAL
  zh: '**28.2 求逆矩阵**'
- answer: '-   尽管你可以使用方程`（28.3）`通过计算矩阵的逆矩阵来解线性方程组，在实践中，最好使用更稳定的技术，如 LUP 分解。然而，有时你确实需要计算矩阵的逆。本节展示了如何使用
    LUP 分解来计算矩阵的逆。它还证明了矩阵乘法和计算矩阵的逆是等价困难的问题，即（在技术条件下）一个算法可以在相同的渐近运行时间内解决另一个问题。因此，你可以使用
    Strassen 算法（参见第 `4.2` 节）来求逆矩阵。事实上，Strassen 的原始论文是受到这样一个想法的启发，即一组线性方程可以比通常的方法更快地解决。'
  en: 尽管你可以使用方程（28.3）通过计算矩阵的逆矩阵来解线性方程组，在实践中，最好使用更稳定的技术，如 LUP 分解。然而，有时你确实需要计算矩阵的逆。本节展示了如何使用
    LUP 分解来计算矩阵的逆。它还证明了矩阵乘法和计算矩阵的逆是等价困难的问题，即（在技术条件下）一个算法可以在相同的渐近运行时间内解决另一个问题。因此，你可以使用
    Strassen 算法（参见第 4.2 节）来求逆矩阵。事实上，Strassen 的原始论文是受到这样一个想法的启发，即一组线性方程可以比通常的方法更快地解决。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   尽管你可以使用方程（28.3）通过计算矩阵的逆矩阵来解线性方程组，在实践中，最好使用更稳定的技术，如
    LUP 分解。然而，有时你确实需要计算矩阵的逆。本节展示了如何使用 LUP 分解来计算矩阵的逆。它还证明了矩阵乘法和计算矩阵的逆是等价困难的问题，即（在技术条件下）一个算法可以在相同的渐近运行时间内解决另一个问题。因此，你可以使用
    Strassen 算法（参见第 4.2 节）来求逆矩阵。事实上，Strassen 的原始论文是受到这样一个想法的启发，即一组线性方程可以比通常的方法更快地解决。  输出：'
  type: TYPE_NORMAL
  zh: 尽管你可以使用方程`（28.3）`通过计算矩阵的逆矩阵来解线性方程组，在实践中，最好使用更稳定的技术，如 LUP 分解。然而，有时你确实需要计算矩阵的逆。本节展示了如何使用
    LUP 分解来计算矩阵的逆。它还证明了矩阵乘法和计算矩阵的逆是等价困难的问题，即（在技术条件下）一个算法可以在相同的渐近运行时间内解决另一个问题。因此，你可以使用
    Strassen 算法（参见第 `4.2` 节）来求逆矩阵。事实上，Strassen 的原始论文是受到这样一个想法的启发，即一组线性方程可以比通常的方法更快地解决。
- answer: '-   **从 LUP 分解计算矩阵的逆矩阵**。'
  en: '**从 LUP 分解计算矩阵的逆矩阵**。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **从 LUP 分解计算矩阵的逆矩阵**。  输出：'
  type: TYPE_NORMAL
  zh: '**从 LUP 分解计算矩阵的逆矩阵**。'
- answer: '-   假设你有一个矩阵`A`的 LUP 分解，形式为三个矩阵`L`、`U`和`P`，使得`PA = LU`。使用 LUP-SOLVE，你可以在Θ(`n`²)的时间内解决形式为`Ax
    = b`的方程。由于 LUP 分解取决于`A`而不是`b`，你可以在额外的Θ(`n`²)时间内对形式为`Ax = b''`的第二组方程运行 LUP-SOLVE。一般来说，一旦你有了矩阵`A`的
    LUP 分解，你可以在Θ(`kn`²)的时间内解决`k`个仅在向量`b`中有所不同的方程`Ax = b`。'
  en: 假设你有一个矩阵*A*的 LUP 分解，形式为三个矩阵*L*、*U*和*P*，使得*PA* = *LU*。使用 LUP-SOLVE，你可以在Θ(*n*²)的时间内解决形式为*Ax*
    = *b*的方程。由于 LUP 分解取决于*A*而不是*b*，你可以在额外的Θ(*n*²)时间内对形式为*Ax* = *b*′的第二组方程运行 LUP-SOLVE。一般来说，一旦你有了矩阵*A*的
    LUP 分解，你可以在Θ(*kn*²)的时间内解决*k*个仅在向量*b*中有所不同的方程*Ax* = *b*。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   假设你有一个矩阵*A*的
    LUP 分解，形式为三个矩阵*L*、*U*和*P*，使得*PA* = *LU*。使用 LUP-SOLVE，你可以在Θ(*n*²)的时间内解决形式为*Ax*
    = *b*的方程。由于 LUP 分解取决于*A*而不是*b*，你可以在额外的Θ(*n*²)时间内对形式为*Ax* = *b*′的第二组方程运行 LUP-SOLVE。一般来说，一旦你有了矩阵*A*的
    LUP 分解，你可以在Θ(*kn*²)的时间内解决*k*个仅在向量*b*中有所不同的方程*Ax* = *b*。  输出：'
  type: TYPE_NORMAL
  zh: 假设你有一个矩阵`A`的 LUP 分解，形式为三个矩阵`L`、`U`和`P`，使得`PA = LU`。使用 LUP-SOLVE，你可以在Θ(`n`²)的时间内解决形式为`Ax
    = b`的方程。由于 LUP 分解取决于`A`而不是`b`，你可以在额外的Θ(`n`²)时间内对形式为`Ax = b'`的第二组方程运行 LUP-SOLVE。一般来说，一旦你有了矩阵`A`的
    LUP 分解，你可以在Θ(`kn`²)的时间内解决`k`个仅在向量`b`中有所不同的方程`Ax = b`。
- answer: '-   让我们考虑方程'
  en: 让我们考虑方程
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   让我们考虑方程  输出：'
  type: TYPE_NORMAL
  zh: 让我们考虑方程
- answer: '---

    -   ![艺术](img/Art_P932.jpg)  '
  en: '![艺术](img/Art_P932.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P932.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P932.jpg)  '
- answer: '-   定义矩阵`X`，即`A`的逆，为一组形式为`Ax = b`的`n`个不同方程。具体来说，让`X[i]`表示`X`的第`i`列，并回忆单位向量`e[i]`是`I[n]`的第`i`列。然后，通过使用`A`的
    LUP 分解来解决每个方程，可以解决`X`的方程(28.11)'
  en: 定义矩阵*X*，即*A*的逆，为一组形式为*Ax* = *b*的*n*个不同方程。具体来说，让*X[i]*表示*X*的第*i*列，并回忆单位向量*e[i]*是*I[n]*的第*i*列。然后，通过使用*A*的
    LUP 分解来解决每个方程，可以解决*X*的方程(28.11)
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   定义矩阵*X*，即*A*的逆，为一组形式为*Ax*
    = *b*的*n*个不同方程。具体来说，让*X[i]*表示*X*的第*i*列，并回忆单位向量*e[i]*是*I[n]*的第*i*列。然后，通过使用*A*的
    LUP 分解来解决每个方程，可以解决*X*的方程(28.11)  输出：'
  type: TYPE_NORMAL
  zh: 定义矩阵`X`，即`A`的逆，为一组形式为`Ax = b`的`n`个不同方程。具体来说，让`X[i]`表示`X`的第`i`列，并回忆单位向量`e[i]`是`I[n]`的第`i`列。然后，通过使用`A`的
    LUP 分解来解决每个方程，可以解决`X`的方程(28.11)
- answer: '-   `AX[i]` = `e[i]`'
  en: '*AX[i]* = *e[i]*'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *AX[i]* = *e[i]*  输出：'
  type: TYPE_NORMAL
  zh: '`AX[i]` = `e[i]`'
- answer: '-   分别对`X[i]`进行计算。一旦你有了 LUP 分解，你可以在Θ(`n`²)的时间内计算每个`X[i]`的`n`列，因此你可以在Θ(`n`³)的时间内从`A`的
    LUP 分解计算`X`。由于你在Θ(`n`³)的时间内找到了`A`的 LUP 分解，你可以在Θ(`n`³)的时间内计算矩阵`A`的逆`A^(−1)`。'
  en: 分别对*X[i]*进行计算。一旦你有了 LUP 分解，你可以在Θ(*n*²)的时间内计算每个*X[i]*的*n*列，因此你可以在Θ(*n*³)的时间内从*A*的
    LUP 分解计算*X*。由于你在Θ(*n*³)的时间内找到了*A*的 LUP 分解，你可以在Θ(*n*³)的时间内计算矩阵*A*的逆*A*^(−1)。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   分别对*X[i]*进行计算。一旦你有了
    LUP 分解，你可以在Θ(*n*²)的时间内计算每个*X[i]*的*n*列，因此你可以在Θ(*n*³)的时间内从*A*的 LUP 分解计算*X*。由于你在Θ(*n*³)的时间内找到了*A*的
    LUP 分解，你可以在Θ(*n*³)的时间内计算矩阵*A*的逆*A*^(−1)。  输出：'
  type: TYPE_NORMAL
  zh: 分别对`X[i]`进行计算。一旦你有了 LUP 分解，你可以在Θ(`n`²)的时间内计算每个`X[i]`的`n`列，因此你可以在Θ(`n`³)的时间内从`A`的
    LUP 分解计算`X`。由于你在Θ(`n`³)的时间内找到了`A`的 LUP 分解，你可以在Θ(`n`³)的时间内计算矩阵`A`的逆`A^(−1)`。
- answer: '-   **矩阵乘法和矩阵求逆**'
  en: '**矩阵乘法和矩阵求逆**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **矩阵乘法和矩阵求逆**  输出：'
  type: TYPE_NORMAL
  zh: '**矩阵乘法和矩阵求逆**'
- answer: '-   现在让我们看看为矩阵乘法获得的理论加速如何转化为矩阵求逆的加速。事实上，我们将证明更强的结论：矩阵求逆等价于矩阵乘法。如果`M(n)`表示两个`n
    × n`矩阵相乘的时间，则非奇异的`n × n`矩阵可以在`O(M(n))`的时间内求逆。此外，如果`I(n)`表示求逆一个非奇异的`n × n`矩阵的时间，��两个`n
    × n`矩阵可以在`O(I(n))`的时间内相乘。我们将这些结果作为两个单独的定理证明。  '
  en: 现在让我们看看为矩阵乘法获得的理论加速如何转化为矩阵求逆的加速。事实上，我们将证明更强的结论：矩阵求逆等价于矩阵乘法。如果*M*(*n*)表示两个*n*
    × *n*矩阵相乘的时间，则非奇异的*n* × *n*矩阵可以在*O*(*M*(*n*))的时间内求逆。此外，如果*I*(*n*)表示求逆一个非奇异的*n*
    × *n*矩阵的时间，��两个*n* × *n*矩阵可以在*O*(*I*(*n*))的时间内相乘。我们将这些结果作为两个单独的定理证明。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   现在让我们看看为矩阵乘法获得的理论加速如何转化为矩阵求逆的加速。事实上，我们将证明更强的结论：矩阵求逆等价于矩阵乘法。如果*M*(*n*)表示两个*n*
    × *n*矩阵相乘的时间，则非奇异的*n* × *n*矩阵可以在*O*(*M*(*n*))的时间内求逆。此外，如果*I*(*n*)表示求逆一个非奇异的*n*
    × *n*矩阵的时间，��两个*n* × *n*矩阵可以在*O*(*I*(*n*))的时间内相乘。我们将这些结果作为两个单独的定理证明。  输出：'
  type: TYPE_NORMAL
  zh: '现在让我们看看为矩阵乘法获得的理论加速如何转化为矩阵求逆的加速。事实上，我们将证明更强的结论：矩阵求逆等价于矩阵乘法。如果`M(n)`表示两个`n ×
    n`矩阵相乘的时间，则非奇异的`n × n`矩阵可以在`O(M(n))`的时间内求逆。此外，如果`I(n)`表示求逆一个非奇异的`n × n`矩阵的时间，��两个`n
    × n`矩阵可以在`O(I(n))`的时间内相乘。我们将这些结果作为两个单独的定理证明。  '
- answer: '-   ***定理 28.1（乘法不比求逆更难）***'
  en: '***定理 28.1（乘法不比求逆更难）***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***定理 28.1（乘法不比求逆更难）***  输出：'
  type: TYPE_NORMAL
  zh: '***定理 28.1（乘法不比求逆更难）***'
- answer: '---

    -   如果一个`n` × `n`矩阵可以在`I(n)`的时间内求逆，其中`I(n)` = Ω(`n`²)，且`I(n)`满足`I(3n)` = `O(I(n))`的正则条件，则两个`n`
    × `n`矩阵可以在`O(I(n))`的时间内相乘。  '
  en: 如果一个*n* × *n*矩阵可以在*I*(*n*)的时间内求逆，其中*I*(*n*) = Ω(*n*²)，且*I*(*n*)满足*I*(3*n*) =
    *O*(*I*(*n*))的正则条件，则两个*n* × *n*矩阵可以在*O*(*I*(*n*))的时间内相乘。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   如果一个*n* × *n*矩阵可以在*I*(*n*)的时间内求逆，其中*I*(*n*)
    = Ω(*n*²)，且*I*(*n*)满足*I*(3*n*) = *O*(*I*(*n*))的正则条件，则两个*n* × *n*矩阵可以在*O*(*I*(*n*))的时间内相乘。  输出：'
  type: TYPE_NORMAL
  zh: '如果一个`n` × `n`矩阵可以在`I(n)`的时间内求逆，其中`I(n)` = Ω(`n`²)，且`I(n)`满足`I(3n)` = `O(I(n))`的正则条件，则两个`n`
    × `n`矩阵可以在`O(I(n))`的时间内相乘。  '
- answer: '---

    -   ***证明*** 让`A`和`B`为`n` × `n`矩阵。为了计算它们的乘积`C` = `AB`，定义 3`n` × 3`n`矩阵`D`为'
  en: '***证明*** 让*A*和*B*为*n* × *n*矩阵。为了计算它们的乘积*C* = *AB*，定义 3*n* × 3*n*矩阵*D*为'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***证明*** 让*A*和*B*为*n*
    × *n*矩阵。为了计算它们的乘积*C* = *AB*，定义 3*n* × 3*n*矩阵*D*为  输出：'
  type: TYPE_NORMAL
  zh: '***证明*** 让`A`和`B`为`n` × `n`矩阵。为了计算它们的乘积`C` = `AB`，定义 3`n` × 3`n`矩阵`D`为'
- answer: '```

    -   ![艺术](img/Art_P933.jpg)

    ```'
  en: '![艺术](img/Art_P933.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P933.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P933.jpg)'
- answer: '-   *D*的逆是 `D`'
  en: '*D*的逆是'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *D*的逆是  输出：'
  type: TYPE_NORMAL
  zh: '*D*的逆是 `D`'
- answer: '---

    -   ![艺术](img/Art_P934.jpg)'
  en: '![艺术](img/Art_P934.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P934.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P934.jpg)'
- answer: '-   因此，要计算乘积`AB`，只需取`D^(-1)`的右上*n* × *n*子矩阵。'
  en: 因此，要计算乘积*AB*，只需取*D*^(−1)的右上*n* × *n*子矩阵。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   因此，要计算乘积*AB*，只需取*D*^(−1)的右上*n*
    × *n*子矩阵。  输出：'
  type: TYPE_NORMAL
  zh: 因此，要计算乘积`AB`，只需取`D^(-1)`的右上*n* × *n*子矩阵。
- answer: '---

    -   构造矩阵`D`需要Θ(n²)的时间，根据假设*I(n)* = Ω(n²)，求逆`D`需要*O*(I(3*n*)) = *O*(I(n))的时间，根据*I(n)*的正则条件。因此，我们有*M(n)*
    = *O*(I(n))。  '
  en: 构造矩阵*D*需要Θ(*n*²)的时间，根据假设*I*(*n*) = Ω(*n*²)，求逆*D*需要*O*(*I*(3*n*)) = *O*(*I*(*n*))的时间，根据*I*(*n*)的正则条件。因此，我们有*M*(*n*)
    = *O*(*I*(*n*))。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   构造矩阵*D*需要Θ(*n*²)的时间，根据假设*I*(*n*)
    = Ω(*n*²)，求逆*D*需要*O*(*I*(3*n*)) = *O*(*I*(*n*))的时间，根据*I*(*n*)的正则条件。因此，我们有*M*(*n*)
    = *O*(*I*(*n*))。  输出：'
  type: TYPE_NORMAL
  zh: '构造矩阵`D`需要Θ(n²)的时间，根据假设*I(n)* = Ω(n²)，求逆`D`需要*O*(I(3*n*)) = *O*(I(n))的时间，根据*I(n)*的正则条件。因此，我们有*M(n)*
    = *O*(I(n))。  '
- answer: '---

    -   ▪ 输出：

    '
  en: ▪
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ▪  输出：'
  type: TYPE_NORMAL
  zh: ▪ 输出：
- answer: '-   注意当`I(n) = Θ(n^c lg^(d)n)`时，`I(n)`满足正则条件，其中*任意常数 c > 0*，*d ≥ 0*。'
  en: 注意当*I*(*n*) = Θ(*n^c* lg^(*d*)*n*)时，*I*(*n*)满足正则条件，其中*任意常数 c > 0*，*d ≥ 0*。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   注意当*I*(*n*)
    = Θ(*n^c* lg^(*d*)*n*)时，*I*(*n*)满足正则条件，其中*任意常数 c > 0*，*d ≥ 0*。  输出：'
  type: TYPE_NORMAL
  zh: 注意当`I(n) = Θ(n^c lg^(d)n)`时，`I(n)`满足正则条件，其中*任意常数 c > 0*，*d ≥ 0*。
- answer: '-   矩阵求逆不比矩阵乘法更难的证明依赖于对对称正定矩阵的一些性质的证明，详见第 `28.3` 节。'
  en: 矩阵求逆不比矩阵乘法更难的证明依赖于对对称正定矩阵的一些性质的证明，详见第 28.3 节。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   矩阵求逆不比矩阵乘法更难的证明依赖于对对称正定矩阵的一些性质的证明，详见第
    28.3 节。  输出：'
  type: TYPE_NORMAL
  zh: 矩阵求逆不比矩阵乘法更难的证明依赖于对对称正定矩阵的一些性质的证明，详见第 `28.3` 节。
- answer: '-   ***定理 28.2（求逆不比乘法更难）***'
  en: '***定理 28.2（求逆不比乘法更难）***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***定理 28.2（求逆不比乘法更难）***  输出：'
  type: TYPE_NORMAL
  zh: '***定理 28.2（求逆不比乘法更难）***'
- answer: '-   假设两个`n` × `n`实矩阵可以在`M(n)`的时间内相乘，其中`M(n)` = Ω(`n`²)，且`M(n)`满足以下两个正则条件：'
  en: 假设两个*n* × *n*实矩阵可以在*M*(*n*)的时间内相乘，其中*M*(*n*) = Ω(*n*²)，且*M*(*n*)满足以下两个正则条件：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   假设两个*n* × *n*实矩阵可以在*M*(*n*)的时间内相乘，其中*M*(*n*)
    = Ω(*n*²)，且*M*(*n*)满足以下两个正则条件：  输出：'
  type: TYPE_NORMAL
  zh: 假设两个`n` × `n`实矩阵可以在`M(n)`的时间内相乘，其中`M(n)` = Ω(`n`²)，且`M(n)`满足以下两个正则条件：
- answer: '-   `M(n + k) = O(M(n))`，其中`0 ≤ k < n`。'
  en: '*M*(*n* + *k*) = *O*(*M*(*n*))，其中*0 ≤ k < n*，'
  prefs:
  - PREF_OL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *M*(*n* + *k*)
    = *O*(*M*(*n*))，其中*0 ≤ k < n*，  输出：'
  type: TYPE_NORMAL
  zh: '`M(n + k) = O(M(n))`，其中`0 ≤ k < n`。'
- answer: '-   `M(n/2) ≤ cM(n)`，其中*某个常数 c < 1/2*。'
  en: '*M*(*n*/2) ≤ *cM*(*n*)，其中*某个常数 c < 1/2*。'
  prefs:
  - PREF_OL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *M*(*n*/2)
    ≤ *cM*(*n*)，其中*某个常数 c < 1/2*。  输出：'
  type: TYPE_NORMAL
  zh: '`M(n/2) ≤ cM(n)`，其中*某个常数 c < 1/2*。'
- answer: '-   那么任何实非奇异`n`×`n`矩阵的逆都可以在`O(M(n))`的时间内计算。'
  en: 那么任何实非奇异*n*×*n*矩阵的逆都可以在*O*(*M*(*n*))的时间内计算。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   那么任何实非奇异*n*×*n*矩阵的逆都可以在*O*(*M*(*n*))的时间内计算。  输出：'
  type: TYPE_NORMAL
  zh: 那么任何实非奇异`n`×`n`矩阵的逆都可以在`O(M(n))`的时间内计算。
- answer: '-   ***证明*** 让`A`为具有实值条目的非奇异`n` × `n`矩阵。假设`n`是 2 的整数幂（即`n` = 2^l^，其中`l`是整数）；我们将在证明的最后看到如果`n`不是
    2 的整数幂该怎么办。  '
  en: '***证明*** 让*A*为具有实值条目的非奇异*n* × *n*矩阵。假设*n*是 2 的整数幂（即*n* = 2*^l*，其中*l*是整数）；我们将在证明的最后看到如果*n*不是
    2 的整数幂该怎么办。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***证明*** 让*A*为具有实值条目的非奇异*n*
    × *n*矩阵。假设*n*是 2 的整数幂（即*n* = 2*^l*，其中*l*是整数）；我们将在证明的最后看到如果*n*不是 2 的整数幂该怎么办。  输出：'
  type: TYPE_NORMAL
  zh: '***证明*** 让`A`为具有实值条目的非奇异`n` × `n`矩阵。假设`n`是 2 的整数幂（即`n` = 2^l^，其中`l`是整数）；我们将在证明的最后看到如果`n`不是
    2 的整数幂该怎么办。  '
- answer: '-   暂时假设`n` × `n`矩阵`A`是对称的且正定的。将`A`及其逆`A^(−1)`分成四个`n/2` × `n/2` 子矩阵：'
  en: 暂时假设*n* × *n*矩阵*A*是对称的且正定的。将*A*及其逆*A*^(−1)分成四个*n*/2 × *n*/2 子矩阵：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   暂时假设*n* × *n*矩阵*A*是对称的且正定的。将*A*及其逆*A*^(−1)分成四个*n*/2
    × *n*/2 子矩阵：  输出：'
  type: TYPE_NORMAL
  zh: 暂时假设`n` × `n`矩阵`A`是对称的且正定的。将`A`及其逆`A^(−1)`分成四个`n/2` × `n/2` 子矩阵：
- answer: '---

    -   ![艺术](img/Art_P935.jpg)'
  en: '![艺术](img/Art_P935.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P935.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P935.jpg)'
- answer: '---

    -   然后，如果我们让 '
  en: 然后，如果我们让
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   然后，如果我们让  输出：'
  type: TYPE_NORMAL
  zh: '然后，如果我们让 '
- answer: '---

    -   ![艺术](img/Art_P936.jpg)  '
  en: '![艺术](img/Art_P936.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P936.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P936.jpg)  '
- answer: '-   是 `A` 相对于 `B` 的舒尔补（我们将在 第 28.3 节 中更多地了解这种形式的舒尔补），我们有'
  en: 是 *A* 相对于 *B* 的舒尔补（我们将在 第 28.3 节 中更多地了解这种形式的舒尔补），我们有
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   是 *A* 相对于 *B*
    的舒尔补（我们将在 第 28.3 节 中更多地了解这种形式的舒尔补），我们有  输出：'
  type: TYPE_NORMAL
  zh: 是 `A` 相对于 `B` 的舒尔补（我们将在 第 28.3 节 中更多地了解这种形式的舒尔补），我们有
- answer: '-   `![艺术](img/Art_P937.jpg)`  '
  en: '![艺术](img/Art_P937.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P937.jpg)  输出：'
  type: TYPE_IMG
  zh: '`![艺术](img/Art_P937.jpg)`  '
- answer: '-   由于 `AA^(-1) = I[n]`，您可以通过执行矩阵乘法来验证。因为 *A* 是对称且正定的，所以 第 28.3 节 中的引理
    28.4 和 28.5 意味着 *B* 和 *S* 都是对称且正定的。因此，根据 第 28.3 节 中的引理 28.3，逆 `B^(-1)` 和 `S^(-1)`
    存在，并且根据第 1223 页的练习 D.2-6，`B^(-1)` 和 `S^(-1)` 都是对称的，因此 `(B^(-1))^T = B^(-1)` 和
    `(S^(-1))^T = S^(-1)`。因此，要计算子矩阵'
  en: 由于 *AA*^(−1) = *I[n]*，您可以通过执行矩阵乘法来验证。因为 *A* 是对称且正定的，所以 第 28.3 节 中的引理 28.4 和
    28.5 意味着 *B* 和 *S* 都是对称且正定的。因此，根据 第 28.3 节 中的引理 28.3，逆 *B*^(−1) 和 *S*^(−1) 存在，并且根据第
    1223 页的练习 D.2-6，*B*^(−1) 和 *S*^(−1) 都是对称的，因此 (*B*^(−1))^T = *B*^(−1) 和 (*S*^(−1))^T
    = *S*^(−1)。因此，要计算子矩阵
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   由于 *AA*^(−1)
    = *I[n]*，您可以通过执行矩阵乘法来验证。因为 *A* 是对称且正定的，所以 第 28.3 节 中的引理 28.4 和 28.5 意味着 *B* 和
    *S* 都是对称且正定的。因此，根据 第 28.3 节 中的引理 28.3，逆 *B*^(−1) 和 *S*^(−1) 存在，并且根据第 1223 页的练习
    D.2-6，*B*^(−1) 和 *S*^(−1) 都是对称的，因此 (*B*^(−1))^T = *B*^(−1) 和 (*S*^(−1))^T = *S*^(−1)。因此，要计算子矩阵  输出：'
  type: TYPE_NORMAL
  zh: 由于 `AA^(-1) = I[n]`，您可以通过执行矩阵乘法来验证。因为 *A* 是对称且正定的，所以 第 28.3 节 中的引理 28.4 和 28.5
    意味着 *B* 和 *S* 都是对称且正定的。因此，根据 第 28.3 节 中的引理 28.3，逆 `B^(-1)` 和 `S^(-1)` 存在，并且根据第
    1223 页的练习 D.2-6，`B^(-1)` 和 `S^(-1)` 都是对称的，因此 `(B^(-1))^T = B^(-1)` 和 `(S^(-1))^T
    = S^(-1)`。因此，要计算子矩阵
- answer: '-   | `R` | = | `B^(-1) + B^(-1)C^T*S^(-1)*CB^(-1)` |'
  en: '| *R* | = | *B*^(−1) + *B*^(−1)*C*^T*S*^(−1)*CB*^(−1), |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *R* | = |
    *B*^(−1) + *B*^(−1)*C*^T*S*^(−1)*CB*^(−1), |  输出：'
  type: TYPE_TB
  zh: '| `R` | = | `B^(-1) + B^(-1)C^T*S^(-1)*CB^(-1)` |'
- answer: '-   `| --- | --- | --- |`'
  en: '| --- | --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。


    ## 要求


    +   将公式使用内联代码符号（`...`）包围，其它文本原样输出

    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分

    +   输入可能有多行，不要遗漏其中任何一行

    +   输出的每一行前面需要有分隔符（-   ），不然我无法处理



    ## 示例


    输入：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。



    输出：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆
    V`，使得如果`(u, v)`是`G`的一条边，则`u ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。


    ## 需要排版的段落


    输入：


    -   | --- | --- | --- |


    输出：

    '
  type: TYPE_TB
  zh: '`| --- | --- | --- |`'
- answer: '-   | `T` | = | −`B`^(−1)`C`^T`S`^(−1), |  '
  en: '| *T* | = | −*B*^(−1)*C*^T*S*^(−1), |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *T* | = |
    −*B*^(−1)*C*^T*S*^(−1), |  输出：'
  type: TYPE_TB
  zh: '| `T` | = | −`B`^(−1)`C`^T`S`^(−1), |  '
- answer: '-   | `U` | = | −`S^(-1)CB^(-1)`, and |'
  en: '| *U* | = | −*S*^(−1)*CB*^(−1), and |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *U* | = |
    −*S*^(−1)*CB*^(−1), and |  输出：'
  type: TYPE_TB
  zh: '| `U` | = | −`S^(-1)CB^(-1)`, and |'
- answer: '-   | `V` | = | `S^(-1)` |'
  en: '| *V* | = | *S*^(−1) |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *V* | = |
    *S*^(−1) |  输出：'
  type: TYPE_TB
  zh: '| `V` | = | `S^(-1)` |'
- answer: '-   对于 `A^(-1)`，执行以下操作，其中提到的所有矩阵都是 `n/2 × n/2`：'
  en: 对于 *A*^(−1)，执行以下操作，其中提到的所有矩阵都是 *n*/2 × *n*/2：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于 *A*^(−1)，执行以下操作，其中提到的所有矩阵都是
    *n*/2 × *n*/2：  输出：'
  type: TYPE_NORMAL
  zh: 对于 `A^(-1)`，执行以下操作，其中提到的所有矩阵都是 `n/2 × n/2`：
- answer: '-   构造矩阵 `A` 的子矩阵 `B`、`C`、`C`^T 和 `D`。  '
  en: 构造矩阵 *A* 的子矩阵 *B*、*C*、*C*^T 和 *D*。
  prefs:
  - PREF_OL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   构造矩阵 *A* 的子矩阵
    *B*、*C*、*C*^T 和 *D*。  输出：'
  type: TYPE_NORMAL
  zh: '构造矩阵 `A` 的子矩阵 `B`、`C`、`C`^T 和 `D`。  '
- answer: '-   递归计算 `B^(-1)` 的逆 `B`。'
  en: 递归计算 *B*^(−1) 的逆 *B*。
  prefs:
  - PREF_OL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   递归计算 *B*^(−1)
    的逆 *B*。  输出：'
  type: TYPE_NORMAL
  zh: 递归计算 `B^(-1)` 的逆 `B`。
- answer: '-   计算矩阵乘积 `W = CB^(-1)`，然后计算其转置 `W^T`，等于 `B^(-1)C^T`（根据第 1219 页的练习 D.1-2
    和 (`B^(-1))^T = B^(-1)`）。'
  en: 计算矩阵乘积 *W* = *CB*^(−1)，然后计算其转置 *W*^T，等于 *B*^(−1)*C*^T（根据第 1219 页的练习 D.1-2 和
    (*B*^(−1))^T = *B*^(−1)）。
  prefs:
  - PREF_OL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   计算矩阵乘积 *W*
    = *CB*^(−1)，然后计算其转置 *W*^T，等于 *B*^(−1)*C*^T（根据第 1219 页的练习 D.1-2 和 (*B*^(−1))^T
    = *B*^(−1)）。  输出：'
  type: TYPE_NORMAL
  zh: 计算矩阵乘积 `W = CB^(-1)`，然后计算其转置 `W^T`，等于 `B^(-1)C^T`（根据第 1219 页的练习 D.1-2 和 (`B^(-1))^T
    = B^(-1)`）。
- answer: '-   计算矩阵乘积 `X = WC^T`，等于 `CB^(-1)C^T`，然后计算矩阵 `S = D - X = D - CB^(-1)C^T`。'
  en: 计算矩阵乘积 *X* = *WC*^T，等于 *CB*^(−1)*C*^T，然后计算矩阵 *S* = *D* − *X* = *D* − *CB*^(−1)*C*^T。
  prefs:
  - PREF_OL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   计算矩阵乘积 *X*
    = *WC*^T，等于 *CB*^(−1)*C*^T，然后计算矩阵 *S* = *D* − *X* = *D* − *CB*^(−1)*C*^T。  输出：'
  type: TYPE_NORMAL
  zh: 计算矩阵乘积 `X = WC^T`，等于 `CB^(-1)C^T`，然后计算矩阵 `S = D - X = D - CB^(-1)C^T`。
- answer: '-   递归计算 `S^(-1)` 的逆 `S`。'
  en: 递归计算 *S*^(−1) 的逆 *S*。
  prefs:
  - PREF_OL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   递归计算 *S*^(−1)
    的逆 *S*。  输出：'
  type: TYPE_NORMAL
  zh: 递归计算 `S^(-1)` 的逆 `S`。
- answer: '-   计算矩阵乘积 `Y = S^(-1)W`，等于 `S^(-1)CB^(-1)`，然后计算其转置 `Y^T`，等于 `B^(-1)C^TS^(-1)`（根据练习
    D.1-2，`(B^(-1))^T = B^(-1)`，以及 `(S^(-1))^T = S^(-1)`）。'
  en: 计算矩阵乘积 *Y* = *S*^(−1)*W*，等于 *S*^(−1)*CB*^(−1)，然后计算其转置 *Y*^T，等于 *B*^(−1)*C*^T*S*^(−1)（根据练习
    D.1-2，(*B*^(−1))^T = *B*^(−1)，以及 (*S*^(−1))^T = *S*^(−1)）。
  prefs:
  - PREF_OL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   计算矩阵乘积 *Y*
    = *S*^(−1)*W*，等于 *S*^(−1)*CB*^(−1)，然后计算其转置 *Y*^T，等于 *B*^(−1)*C*^T*S*^(−1)（根据练习
    D.1-2，(*B*^(−1))^T = *B*^(−1)，以及 (*S*^(−1))^T = *S*^(−1)）。  输出：'
  type: TYPE_NORMAL
  zh: 计算矩阵乘积 `Y = S^(-1)W`，等于 `S^(-1)CB^(-1)`，然后计算其转置 `Y^T`，等于 `B^(-1)C^TS^(-1)`（根据练习
    D.1-2，`(B^(-1))^T = B^(-1)`，以及 `(S^(-1))^T = S^(-1)`）。
- answer: '-   计算矩阵乘积 `Z = W^T*Y`，等于 `B^(-1)*C^T*S^(-1)*CB^(-1)`。  '
  en: 计算矩阵乘积 *Z* = *W*^T*Y*，等于 *B*^(−1)*C*^T*S*^(−1)*CB*^(−1)。
  prefs:
  - PREF_OL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   计算矩阵乘积 *Z*
    = *W*^T*Y*，等于 *B*^(−1)*C*^T*S*^(−1)*CB*^(−1)。  输出：'
  type: TYPE_NORMAL
  zh: '计算矩阵乘积 `Z = W^T*Y`，等于 `B^(-1)*C^T*S^(-1)*CB^(-1)`。  '
- answer: '-   设 `R = B^(-1) + Z`。'
  en: 设 *R* = *B*^(−1) + *Z*。
  prefs:
  - PREF_OL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   设 *R* = *B*^(−1)
    + *Z*。  输出：'
  type: TYPE_NORMAL
  zh: 设 `R = B^(-1) + Z`。
- answer: '-   设 `T = -Y^T`。'
  en: 设 *T* = −*Y*^T。
  prefs:
  - PREF_OL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   设 *T* = −*Y*^T。  输出：'
  type: TYPE_NORMAL
  zh: 设 `T = -Y^T`。
- answer: '-   设 `U = -Y`。'
  en: 设 *U* = −*Y*。
  prefs:
  - PREF_OL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   设 *U* = −*Y*。  输出：'
  type: TYPE_NORMAL
  zh: 设 `U = -Y`。
- answer: '-   设 `V = S^(-1)`。'
  en: 设 *V* = *S*^(−1)。
  prefs:
  - PREF_OL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   设 *V* = *S*^(−1)。  输出：'
  type: TYPE_NORMAL
  zh: 设 `V = S^(-1)`。
- answer: '-   因此，要求一个 `n`×`n` 对称正定矩阵的逆，需要在步骤 2 和 5 中求解两个 `n/2`×`n/2` 矩阵的逆；在步骤 3、4、6
    和 7 中进行四次 `n/2` × `n/2` 矩阵的乘法；并额外花费 `O(n²)` 的成本从 `A` 中提取子矩阵，将子矩阵插入 `A⁻¹`，以及在 `n/2`×`n/2`
    矩阵上执行常数次加法、减法和转置。运行时间由递归式给出'
  en: 因此，要求一个 *n*×*n* 对称正定矩阵的逆，需要在步骤 2 和 5 中求解两个 *n*/2×*n*/2 矩阵的逆；在步骤 3、4、6 和 7 中进行四次
    *n*/2 × *n*/2 矩阵的乘法；并额外花费 *O*(*n*²) 的成本从 *A* 中提取子矩阵，将子矩阵插入 *A*^(−1)，以及在 *n*/2×*n*/2
    矩阵上执行常数次加法、减法和转置。运行时间由递归式给出
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   因此，要求一个 *n*×*n*
    对称正定矩阵的逆，需要在步骤 2 和 5 中求解两个 *n*/2×*n*/2 矩阵的逆；在步骤 3、4、6 和 7 中进行四次 *n*/2 × *n*/2
    矩阵的乘法；并额外花费 *O*(*n*²) 的成本从 *A* 中提取子矩阵，将子矩阵插入 *A*^(−1)，以及在 *n*/2×*n*/2 矩阵上执行常数次加法、减法和转置。运行时间由递归式给出  输出：'
  type: TYPE_NORMAL
  zh: 因此，要求一个 `n`×`n` 对称正定矩阵的逆，需要在步骤 2 和 5 中求解两个 `n/2`×`n/2` 矩阵的逆；在步骤 3、4、6 和 7 中进行四次
    `n/2` × `n/2` 矩阵的乘法；并额外花费 `O(n²)` 的成本从 `A` 中提取子矩阵，将子矩阵插入 `A⁻¹`，以及在 `n/2`×`n/2`
    矩阵上执行常数次加法、减法和转置。运行时间由递归式给出
- answer: '---

    -   ![艺术](img/Art_P938.jpg)'
  en: '![艺术](img/Art_P938.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P938.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P938.jpg)'
- answer: '-   第二行是基于 `M(n) = Ω(n²)` 和定理陈述中的第二个正则条件，这意味着 `4*M(n/2) < 2*M(n)`。由于 `M(n)
    = Ω(n²)`，所以主定理（定理 4.1）的第三种情况适用于递归式（28.15），得到 `O(M(n))` 的结果。  '
  en: 第二行是基于 *M*(*n*) = Ω(*n*²) 和定理陈述中的第二个正则条件，这意味着 4*M*(*n*/2) < 2*M*(*n*)。由于 *M*(*n*)
    = Ω(*n*²)，所以主定理（定理 4.1）的第三种情况适用于递归式（28.15），得到 *O*(*M*(*n*)) 的结果。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   第二行是基于 *M*(*n*)
    = Ω(*n*²) 和定理陈述中的第二个正则条件，这意味着 4*M*(*n*/2) < 2*M*(*n*)。由于 *M*(*n*) = Ω(*n*²)，所以主定理（定理
    4.1）的第三种情况适用于递归式（28.15），得到 *O*(*M*(*n*)) 的结果。  输出：'
  type: TYPE_NORMAL
  zh: '第二行是基于 `M(n) = Ω(n²)` 和定理陈述中的第二个正则条件，这意味着 `4*M(n/2) < 2*M(n)`。由于 `M(n) = Ω(n²)`，所以主定理（定理
    4.1）的第三种情况适用于递归式（28.15），得到 `O(M(n))` 的结果。  '
- answer: '-   仍需证明当 `A` 可逆但不对称且正定时，如何获得与矩阵求逆相同的渐近运行时间。基本思想是对于任何非奇异矩阵 `A`，矩阵 `A^T*A`
    是对称的（根据练习 D.1-2）且正定的（根据第 1222 页的定理 D.6）。因此，关键在于将求逆 `A` 的问题简化为求逆 `A^T*A` 的问题。'
  en: 仍需证明当 *A* 可逆但不对称且正定时，如何获得与矩阵求逆相同的渐近运行时间。基本思想是对于任何非奇异矩阵 *A*，矩阵 *A*^T*A* 是对称的（根据练习
    D.1-2）且正定的（根据第 1222 页的定理 D.6）。因此，关键在于将求逆 *A* 的问题简化为求逆 *A*^T*A* 的问题。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   仍需证明当 *A* 可逆但不对称且正定时，如何获得与矩阵求逆相同的渐近运行时间。基本思想是对于任何非奇异矩阵
    *A*，矩阵 *A*^T*A* 是对称的（根据练习 D.1-2）且正定的（根据第 1222 页的定理 D.6）。因此，关键在于将求逆 *A* 的问题简化为求逆
    *A*^T*A* 的问题。  输出：'
  type: TYPE_NORMAL
  zh: 仍需证明当 `A` 可逆但不对称且正定时，如何获得与矩阵求逆相同的渐近运行时间。基本思想是对于任何非奇异矩阵 `A`，矩阵 `A^T*A` 是对称的（根据练习
    D.1-2）且正定的（根据第 1222 页的定理 D.6）。因此，关键在于将求逆 `A` 的问题简化为求逆 `A^T*A` 的问题。
- answer: '-   这种简化基于以下观察：当 `A` 是一个 `n` × `n` 非奇异矩阵时，我们有'
  en: 这种简化基于以下观察：当 *A* 是一个 *n* × *n* 非奇异矩阵时，我们有
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   这种简化基于以下观察：当
    *A* 是一个 *n* × *n* 非奇异矩阵时，我们有  输出：'
  type: TYPE_NORMAL
  zh: 这种简化基于以下观察：当 `A` 是一个 `n` × `n` 非奇异矩阵时，我们有
- answer: '-   `A^(-1) = (A^T*A)^(-1)A^T`,  '
  en: '*A*^(−1) = (*A*^T*A*)^(−1)*A*^T，'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *A*^(−1) =
    (*A*^T*A*)^(−1)*A*^T，  输出：'
  type: TYPE_NORMAL
  zh: '`A^(-1) = (A^T*A)^(-1)A^T`,  '
- answer: '-   因为 ((*A*^T*A*)^(-1)*A*^T)*A* = ((*A*^T*A*)^(-1)(*A*^T))*A* = *I[n]*，且矩阵求逆是唯一的。因此，要计算
    *A*^(-1)，首先将 *A*^T 乘以 *A* 得到 *A*^T*A*，然后使用上述分治算法求逆对称正定矩阵 *A*^T*A*，最后将结果乘以 *A*^T。这三个步骤每个都需要
    *O*(*M*(*n*)) 的时间，因此任何具有实数元素的非奇异矩阵都可以在 *O*(*M*(*n*)) 的时间内求逆。  '
  en: 因为 ((*A*^T*A*)^(−1)*A*^T)*A* = (*A*^T*A*)^(−1)(*A*^T*A*) = *I[n]*，且矩阵求逆是唯一的。因此，要计算
    *A*^(−1)，首先将 *A*^T 乘以 *A* 得到 *A*^T*A*，然后使用上述分治算法求逆对称正定矩阵 *A*^T*A*，最后将结果乘以 *A*^T。这三个步骤每个都需要
    *O*(*M*(*n*)) 的时间，因此任何具有实数元素的非奇异矩阵都可以在 *O*(*M*(*n*)) 的时间内求逆。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   因为 ((*A*^T*A*)^(−1)*A*^T)*A*
    = (*A*^T*A*)^(−1)(*A*^T*A*) = *I[n]*，且矩阵求逆是唯一的。因此，要计算 *A*^(−1)，首先将 *A*^T 乘以 *A*
    得到 *A*^T*A*，然后使用上述分治算法求逆对称正定矩阵 *A*^T*A*，最后将结果乘以 *A*^T。这三个步骤每个都需要 *O*(*M*(*n*))
    的时间，因此任何具有实数元素的非奇异矩阵都可以在 *O*(*M*(*n*)) 的时间内求逆。  输出：'
  type: TYPE_NORMAL
  zh: '因为 ((*A*^T*A*)^(-1)*A*^T)*A* = ((*A*^T*A*)^(-1)(*A*^T))*A* = *I[n]*，且矩阵求逆是唯一的。因此，要计算
    *A*^(-1)，首先将 *A*^T 乘以 *A* 得到 *A*^T*A*，然后使用上述分治算法求逆对称正定矩阵 *A*^T*A*，最后将结果乘以 *A*^T。这三个步骤每个都需要
    *O*(*M*(*n*)) 的时间，因此任何具有实数元素的非奇异矩阵都可以在 *O*(*M*(*n*)) 的时间内求逆。  '
- answer: '-   上述证明假设 `A` 是一个 `n` × `n` 矩阵，其中 `n` 是 2 的幂。如果 `n` 不是 2 的幂，则令 `k` < `n`
    使得 `n` + `k` 是 2 的幂，并定义 (`n` + `k`) × (`n` + `k`) 矩阵 `A`′ 为  '
  en: 上述证明假设 *A* 是一个 *n* × *n* 矩阵，其中 *n* 是 2 的幂。如果 *n* 不是 2 的幂，则令 *k* < *n* 使得 *n*
    + *k* 是 2 的幂，并定义 (*n* + *k*) × (*n* + *k*) 矩阵 *A*′ 为
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   上述证明假设 *A*
    是一个 *n* × *n* 矩阵，其中 *n* 是 2 的幂。如果 *n* 不是 2 的幂，则令 *k* < *n* 使得 *n* + *k* 是 2 的幂，并定义
    (*n* + *k*) × (*n* + *k*) 矩阵 *A*′ 为  输出：'
  type: TYPE_NORMAL
  zh: '上述证明假设 `A` 是一个 `n` × `n` 矩阵，其中 `n` 是 2 的幂。如果 `n` 不是 2 的幂，则令 `k` < `n` 使得 `n`
    + `k` 是 2 的幂，并定义 (`n` + `k`) × (`n` + `k`) 矩阵 `A`′ 为  '
- answer: '---

    -   ![艺术](img/Art_P939.jpg)'
  en: '![艺术](img/Art_P939.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P939.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P939.jpg)'
- answer: '```

    -   那么`A′`的逆矩阵是

    ```'
  en: 那么*A*′的逆矩阵是
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   那么*A*′的逆矩阵是  输出：'
  type: TYPE_NORMAL
  zh: 那么`A′`的逆矩阵是
- answer: '```

    -   ![art](img/Art_P940.jpg)

    ```'
  en: '![art](img/Art_P940.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P940.jpg)  输出：'
  type: TYPE_IMG
  zh: '![art](img/Art_P940.jpg)'
- answer: '-   将证明的方法应用于`A′`来计算`A′`的逆，并将结果的前`n`行和前`n`列作为所需答案`A⁻¹`。关于`M(n)`的第一个规则条件确保以这种方式扩大矩阵最多只会增加一个常数因子的运行时间。'
  en: 将证明的方法应用于*A*′来计算*A*′的逆，并将结果的前*n*行和前*n*列作为所需答案*A*^(−1)。关于*M*(*n*)的第一个规则条件确保以这种方式扩大矩阵最多只会增加一个常数因子的运行时间。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   将证明的方法应用于*A*′来计算*A*′的逆，并将结果的前*n*行和前*n*列作为所需答案*A*^(−1)。关于*M*(*n*)的第一个规则条件确保以这种方式扩大矩阵最多只会增加一个常数因子的运行时间。  输出：'
  type: TYPE_NORMAL
  zh: 将证明的方法应用于`A′`来计算`A′`的逆，并将结果的前`n`行和前`n`列作为所需答案`A⁻¹`。关于`M(n)`的第一个规则条件确保以这种方式扩大矩阵最多只会增加一个常数因子的运行时间。
- en: ▪
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。


    ## 要求


    +   将公式使用内联代码符号（`...`）包围，其它文本原样输出

    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分

    +   输入可能有多行，不要遗漏其中任何一行

    +   输出的每一行前面需要有分隔符（-   ），不然我无法处理



    ## 示例


    输入：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。



    输出：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆
    V`，使得如果`(u, v)`是`G`的一条边，则`u ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。


    ## 需要排版的段落


    输入：


    -   ▪


    输出：

    '
  type: TYPE_NORMAL
- answer: '-   定理 28.2 的证明建议如何使用不进行主元置换的 LU 分解来解方程`Ax = b`，只要`A`是非奇异的。令`y = A^Tb`。将方程`Ax
    = b`的两边都乘以`A^T`，得到`(A^TA)x = A^Tb = y`。这种转换不会影响解`x`，因为`A^T` 是可逆的。因为`A^TA`是对称正定的，可以通过计算
    LU 分解来因式分解。然后，使用前向和后向替换来解方程`(A^TA)x = y`中的`x`。尽管这种方法在理论上是正确的，但在实践中，LUP-DECOMPOSITION
    过程效果要好得多。LUP 分解需要的算术运算次数少了一个常数因子，并且具有更好的数值特性。'
  en: 定理 28.2 的证明建议如何使用不进行主元置换的 LU 分解来解方程*A*x* = *b*，只要*A*是非奇异的。令*y* = *A*^T*b*。将方程*A*x*
    = *b*的两边都乘以*A*^T，得到(*A*^T*A*)*x* = *A*^T*b* = *y*。这种转换不会影响解*x*，因为*A*^T 是可逆的。因为*A*^T*A*是对称正定的，可以通过计算
    LU 分解来因式分解。然后，使用前向和后向替换来解方程(*A*^T*A*)*x* = *y*中的*x*。尽管这种方法在理论上是正确的，但在实践中，LUP-DECOMPOSITION
    过程效果要好得多。LUP 分解需要的算术运算次数少了一个常数因子，并且具有更好的数值特性。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   定理 28.2 的证明建议如何使用不进行主元置换的
    LU 分解来解方程*A*x* = *b*，只要*A*是非奇异的。令*y* = *A*^T*b*。将方程*A*x* = *b*的两边都乘以*A*^T，得到(*A*^T*A*)*x*
    = *A*^T*b* = *y*。这种转换不会影响解*x*，因为*A*^T 是可逆的。因为*A*^T*A*是对称正定的，可以通过计算 LU 分解来因式分解。然后，使用前向和后向替换来解方程(*A*^T*A*)*x*
    = *y*中的*x*。尽管这种方法在理论上是正确的，但在实践中，LUP-DECOMPOSITION 过程效果要好得多。LUP 分解需要的算术运算次数少了一个常数因子，并且具有更好的数值特性。  输出：'
  type: TYPE_NORMAL
  zh: 定理 28.2 的证明建议如何使用不进行主元置换的 LU 分解来解方程`Ax = b`，只要`A`是非奇异的。令`y = A^Tb`。将方程`Ax =
    b`的两边都乘以`A^T`，得到`(A^TA)x = A^Tb = y`。这种转换不会影响解`x`，因为`A^T` 是可逆的。因为`A^TA`是对称正定的，可以通过计算
    LU 分解来因式分解。然后，使用前向和后向替换来解方程`(A^TA)x = y`中的`x`。尽管这种方法在理论上是正确的，但在实践中，LUP-DECOMPOSITION
    过程效果要好得多。LUP 分解需要的算术运算次数少了一个常数因子，并且具有更好的数值特性。
- answer: '-   **习题**'
  en: '**习题**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **习题**  输出：'
  type: TYPE_NORMAL
  zh: '**习题**'
- answer: '---

    -   ***28.2-1***  '
  en: '***28.2-1***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28.2-1***  输出：'
  type: TYPE_NORMAL
  zh: '***28.2-1***  '
- answer: '-   让`M(n)`表示两个`n × n`矩阵相乘的时间，让`S(n)`表示求解一个`n × n`矩阵的平方所需的时间。证明矩阵相乘和矩阵平方具有基本相同的难度：一个`M(n)`时间的矩阵乘法算法意味着一个`O(M(n))`时间的矩阵平方算法，一个`S(n)`时间的矩阵平方算法意味着一个`O(S(n))`时间的矩阵乘法算法。'
  en: 让*M*(*n*)表示两个*n* × *n*矩阵相乘的时间，让*S*(*n*)表示求解一个*n* × *n*矩阵的平方所需的时间。证明矩阵相乘和矩阵平方具有基本相同的难度：一个*M*(*n*)时间的矩阵乘法算法意味着一个*O*(*M*(*n*))时间的矩阵平方算法，一个*S*(*n*)时间的矩阵平方算法意味着一个*O*(*S*(*n*))时间的矩阵乘法算法。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   让*M*(*n*)表示两个*n*
    × *n*矩阵相乘的时间，让*S*(*n*)表示求解一个*n* × *n*矩阵的平方所需的时间。证明矩阵相乘和矩阵平方具有基本相同的难度：一个*M*(*n*)时间的矩阵乘法算法意味着一个*O*(*M*(*n*))时间的矩阵平方算法，一个*S*(*n*)时间的矩阵平方算法意味着一个*O*(*S*(*n*))时间的矩阵乘法算法。  输出：'
  type: TYPE_NORMAL
  zh: 让`M(n)`表示两个`n × n`矩阵相乘的时间，让`S(n)`表示求解一个`n × n`矩阵的平方所需的时间。证明矩阵相乘和矩阵平方具有基本相同的难度：一个`M(n)`时间的矩阵乘法算法意味着一个`O(M(n))`时间的矩阵平方算法，一个`S(n)`时间的矩阵平方算法意味着一个`O(S(n))`时间的矩阵乘法算法。
- answer: '```

    -   ***28.2-2***

    ```'
  en: '***28.2-2***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28.2-2***  输出：'
  type: TYPE_NORMAL
  zh: '***28.2-2***'
- answer: '---

    -   让`M(n)`表示两个`n × n`矩阵相乘的时间。证明一个`M(n)`时间的矩阵乘法算法意味着一个`O(M(n))`时间的 LUP 分解算法。（你的方法产生的
    LUP 分解不一定与 LUP-DECOMPOSITION 过程产生的结果相同。）'
  en: 让*M*(*n*)表示两个*n* × *n*矩阵相乘的时间。证明一个*M*(*n*)时间的矩阵乘法算法意味着一个*O*(*M*(*n*))时间的 LUP
    分解算法。（你的方法产生的 LUP 分解不一定与 LUP-DECOMPOSITION 过程产生的结果相同。）
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   让*M*(*n*)表示两个*n*
    × *n*矩阵相乘的时间。证明一个*M*(*n*)时间的矩阵乘法算法意味着一个*O*(*M*(*n*))时间的 LUP 分解算法。（你的方法产生的 LUP
    分解不一定与 LUP-DECOMPOSITION 过程产生的结果相同。）  输出：'
  type: TYPE_NORMAL
  zh: 让`M(n)`表示两个`n × n`矩阵相乘的时间。证明一个`M(n)`时间的矩阵乘法算法意味着一个`O(M(n))`时间的 LUP 分解算法。（你的方法产生的
    LUP 分解不一定与 LUP-DECOMPOSITION 过程产生的结果相同。）
- answer: '-   ***28.2-3***'
  en: '***28.2-3***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28.2-3***  输出：'
  type: TYPE_NORMAL
  zh: '***28.2-3***'
- answer: '-   让`M(n)`表示两个`n × n`布尔矩阵相乘的时间，让`T(n)`表示找到一个`n × n`布尔矩阵的传递闭包所需的时间。（参见第
    23.2 节。）证明一个`M(n)`时间的布尔矩阵乘法算法意味着一个`O(M(n) lg n)`时间的传递闭包算法，一个`T(n)`时间的传递闭包算法意味着一个`O(T(n))`时间的布尔矩阵乘法算法。'
  en: 让*M*(*n*)表示两个*n* × *n*布尔矩阵相乘的时间，让*T*(*n*)表示找到一个*n* × *n*布尔矩阵的传递闭包所需的时间。（参见第
    23.2 节。）证明一个*M*(*n*)时间的布尔矩阵乘法算法意味着一个*O*(*M*(*n*) lg *n*)时间的传递闭包算法，一个*T*(*n*)时间的传递闭包算法意味着一个*O*(*T*
    (*n*))时间的布尔矩阵乘法算法。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   让*M*(*n*)表示两个*n*
    × *n*布尔矩阵相乘的时间，让*T*(*n*)表示找到一个*n* × *n*布尔矩阵的传递闭包所需的时间。（参见第 23.2 节。）证明一个*M*(*n*)时间的布尔矩阵乘法算法意味着一个*O*(*M*(*n*)
    lg *n*)时间的传递闭包算法，一个*T*(*n*)时间的传递闭包算法意味着一个*O*(*T* (*n*))时间的布尔矩阵乘法算法。  输出：'
  type: TYPE_NORMAL
  zh: 让`M(n)`表示两个`n × n`布尔矩阵相乘的时间，让`T(n)`表示找到一个`n × n`布尔矩阵的传递闭包所需的时间。（参见第 23.2 节。）证明一个`M(n)`时间的布尔矩阵乘法算法意味着一个`O(M(n)
    lg n)`时间的传递闭包算法，一个`T(n)`时间的传递闭包算法意味着一个`O(T(n))`时间的布尔矩阵乘法算法。
- answer: '-   `28.2-4`'
  en: '***28.2-4***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28.2-4***  输出：'
  type: TYPE_NORMAL
  zh: '`28.2-4`'
- answer: '-   基于定理 `28.2` 的矩阵求逆算法在矩阵元素来自模 `2` 整数域时是否有效？解释。'
  en: 基于定理 28.2 的矩阵求逆算法在矩阵元素来自模 2 整数域时是否有效？解释。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   基于定理 28.2 的矩阵求逆算法在矩阵元素来自模
    2 整数域时是否有效？解释。  输出：'
  type: TYPE_NORMAL
  zh: 基于定理 `28.2` 的矩阵求逆算法在矩阵元素来自模 `2` 整数域时是否有效？解释。
- answer: '-   *`28.2-5`*'
  en: ★ ***28.2-5***
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ★ ***28.2-5***  输出：'
  type: TYPE_NORMAL
  zh: '*`28.2-5`*'
- answer: '-   将定理 28.2 的矩阵求逆算法推广到处理复数矩阵，并证明你的推广是正确的。（*提示：*不要使用`A`的转置，而是使用***共轭转置***
    `A*`，通过用每个条目的复共轭替换`A`的转置来获得。不要考虑对称矩阵，考虑***Hermite***矩阵，即满足`A = A*`的矩阵。）'
  en: 将定理 28.2 的矩阵求逆算法推广到处理复数矩阵，并证明你的推广是正确的。（*提示：*不要使用*A*的转置，而是使用***共��转置*** *A**，通过用每个条目的复共轭替换*A*的转置来获得。不要考虑对称矩阵，考虑***Hermite***矩阵，即满足*A*
    = *A**的矩阵。）
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   将定理 28.2 的矩阵求逆算法推广到处理复数矩阵，并证明你的推广是正确的。（*提示：*不要使用*A*的转置，而是使用***共��转置*** *A**，通过用每个条目的复共轭替换*A*的转置来获得。不要考虑对称矩阵，考虑***Hermite***矩阵，即满足*A*
    = *A**的矩阵。）  输出：'
  type: TYPE_NORMAL
  zh: 将定理 28.2 的矩阵求逆算法推广到处理复数矩阵，并证明你的推广是正确的。（*提示：*不要使用`A`的转置，而是使用***共轭转置*** `A*`，通过用每个条目的复共轭替换`A`的转置来获得。不要考虑对称矩阵，考虑***Hermite***矩阵，即满足`A
    = A*`的矩阵。）
- answer: '-   **28.3**    对称正定矩阵和最小二乘逼近  '
  en: '**28.3    对称正定矩阵和最小二乘逼近**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **28.3    对称正定矩阵和最小二乘逼近**  输出：'
  type: TYPE_NORMAL
  zh: '**28.3**    对称正定矩阵和最小二乘逼近  '
- answer: '-   对称正定矩阵具有许多有趣和理想的性质。一个*n* × *n*矩阵`A`是***对称正定***的，如果`A` = `A`^T（`A`是对称的），且对于所有*n*维向量`x`
    ≠ 0，有`x`^T`Ax` > 0（`A`是正定的）。对称正定矩阵是非奇异的，对它们进行 LU 分解不会除以 0。本节证明了对称正定矩阵的这些以及其他几个重要性质。我们还将看到一个有趣的应用，即通过最小二乘逼近进行曲线拟合。'
  en: 对称正定矩阵具有许多有趣和理想的性质。一个*n* × *n*矩阵*A*是***对称正定***的，如果*A* = *A*^T（*A*是对称的），且对于所有*n*维向量*x*
    ≠ 0，有*x*^T*Ax* > 0（*A*是正定的）。对称正定矩阵是非奇异的，对它们进行 LU 分解不会除以 0。本节证明了对称正定矩阵的这些以及其他几个重要性质。我们还将看到一个有趣的应用，即通过最小二乘逼近进行曲线拟合。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对称正定矩阵具有许多有趣和理想的性质。一个*n*
    × *n*矩阵*A*是***对称正定***的，如果*A* = *A*^T（*A*是对称的），且对于所有*n*维向量*x* ≠ 0，有*x*^T*Ax* >
    0（*A*是正定的）。对称正定矩阵是非奇异的，对它们进行 LU 分解不会除以 0。本节证明了对称正定矩阵的这些以及其他几个重要性质。我们还将看到一个有趣的应用，即通过最小二乘逼近进行曲线拟合。  输出：'
  type: TYPE_NORMAL
  zh: 对称正定矩阵具有许多有趣和理想的性质。一个*n* × *n*矩阵`A`是***对称正定***的，如果`A` = `A`^T（`A`是对称的），且对于所有*n*维向量`x`
    ≠ 0，有`x`^T`Ax` > 0（`A`是正定的）。对称正定矩阵是非奇异的，对它们进行 LU 分解不会除以 0。本节证明了对称正定矩阵的这些以及其他几个重要性质。我们还将看到一个有趣的应用，即通过最小二乘逼近进行曲线拟合。
- answer: '-   我们证明的第一个性质可能是最基本的。'
  en: 我们证明的第一个性质可能是最基本的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   我们证明的第一个性质可能是最基本的。  输出：'
  type: TYPE_NORMAL
  zh: 我们证明的第一个性质可能是最基本的。
- answer: '-   ***引理 28.3***'
  en: '***引理 28.3***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***引理 28.3***  输出：'
  type: TYPE_NORMAL
  zh: '***引理 28.3***'
- answer: '-   任何正定矩阵都是非奇异的。'
  en: 任何正定矩阵都是非奇异的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   任何正定矩阵都是非奇异的。  输出：'
  type: TYPE_NORMAL
  zh: 任何正定矩阵都是非奇异的。
- answer: '-   ***证明*** 假设矩阵`A`是奇异的。那么根据第 1221 页的推论 D.3，存在一个非零向量`x`使得`A*x* = 0`。因此，`x^TAx
    = 0`，`A`不可能是正定的。  '
  en: '***证明*** 假设矩阵*A*是奇异的。那么根据第 1221 页的推论 D.3，存在一个非零向量*x*使得*A*x* = 0。因此，*x*^T*Ax*
    = 0，*A*不可能是正定的。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***证明*** 假设矩阵*A*是奇异的。那么根据第
    1221 页的推论 D.3，存在一个非零向量*x*使得*A*x* = 0。因此，*x*^T*Ax* = 0，*A*不可能是正定的。  输出：'
  type: TYPE_NORMAL
  zh: '***证明*** 假设矩阵`A`是奇异的。那么根据第 1221 页的推论 D.3，存在一个非零向量`x`使得`A*x* = 0`。因此，`x^TAx
    = 0`，`A`不可能是正定的。  '
- answer: '```

    -   ▪  输出：

    ```'
  en: ▪
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ▪  输出：'
  type: TYPE_NORMAL
  zh: ▪  输出：
- answer: '---

    -   证明对称正定矩阵`A`的 LU 分解不会除以 0 更加复杂。我们首先证明关于`A`的某些子矩阵的性质。定义`A`的第`k`个***主子矩阵***为由`A`的前`k`行和前`k`列的交集组成的矩阵`A[k]`。  '
  en: 证明对称正定矩阵*A*的 LU 分解不会除以 0 更加复杂。我们首先证明关于*A*的某些子矩阵的性质。定义*A*的第*k*个***主子矩阵***为由*A*的前*k*行和前*k*列的交集组成的矩阵*A[k]*。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   证明对称正定矩阵*A*的
    LU 分解不会除以 0 更加复杂。我们首先证明关于*A*的某些子矩阵的性质。定义*A*的第*k*个***主子矩阵***为由*A*的前*k*行和前*k*列的交集组成的矩阵*A[k]*。  输出：'
  type: TYPE_NORMAL
  zh: '证明对称正定矩阵`A`的 LU 分解不会除以 0 更加复杂。我们首先证明关于`A`的某些子矩阵的性质。定义`A`的第`k`个***主子矩阵***为由`A`的前`k`行和前`k`列的交集组成的矩阵`A[k]`。  '
- answer: '-   **`引理 28.4`**'
  en: '***引理 28.4***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***引理 28.4***  输出：'
  type: TYPE_NORMAL
  zh: '**`引理 28.4`**'
- answer: '-   如果`A`是对称正定矩阵，则`A`的每个主子矩阵都是对称的且正定的。'
  en: 如果*A*是对称正定矩阵，则*A*的每个主子矩阵都是对称的且正定的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   如果*A*是对称正定矩阵，则*A*的每个主子矩阵都是对称的且正定的。  输出：'
  type: TYPE_NORMAL
  zh: 如果`A`是对称正定矩阵，则`A`的每个主子矩阵都是对称的且正定的。
- answer: "```\n-   ***证明***   由于*A*是对称的，每个主子矩阵`A[k]`也是对称的。我们将通过反证法证明`A[k]`是正定的。如果`A[k]`不是正定的，那么存在一个`k`向量`x[k]`\
    \ ≠ 0，使得`x[k]' A[k] x[k] ≤ 0`。令`A`为`n × n`，并且  \n```"
  en: '***证明***   由于*A*是对称的，每个主子矩阵*A[k]*也是对称的。我们将通过反证法证明*A[k]*是正定的。如果*A[k]*不是正定的，那么存在一个*k*向量*x[k]*
    ≠ 0，使得![art](img/Art_P941.jpg)。令*A*为*n* × *n*，并且'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***证明***   由于*A*是对称的，每个主子矩阵*A[k]*也是对称的。我们将通过反证法证明*A[k]*是正定的。如果*A[k]*不是正定的，那么存在一个*k*向量*x[k]*
    ≠ 0，使得![art](img/Art_P941.jpg)。令*A*为*n* × *n*，并且  输出：'
  type: TYPE_NORMAL
  zh: '***证明***   由于*A*是对称的，每个主子矩阵`A[k]`也是对称的。我们将通过反证法证明`A[k]`是正定的。如果`A[k]`不是正定的，那么存在一个`k`向量`x[k]`
    ≠ 0，使得`x[k]'' A[k] x[k] ≤ 0`。令`A`为`n × n`，并且  '
- answer: '-   ![art](img/Art_P942.jpg)'
  en: '![art](img/Art_P942.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P942.jpg)  输出：'
  type: TYPE_IMG
  zh: '![art](img/Art_P942.jpg)'
- answer: '-   对于子矩阵`B`（大小为(`n`−`k`)×`k`）和`C`（大小为(`n`−`k`)×(`n`−`k`)）。定义`n`向量![art](img/Art_P943.jpg)，其中有`n`−`k`个
    0 跟在`x[k]`后面。然后我们有'
  en: 对于子矩阵*B*（大小为(*n*−*k*)×*k*）和*C*（大小为(*n*−*k*)×(*n*−*k*)）。定义*n*向量![art](img/Art_P943.jpg)，其中有*n*−*k*个
    0 跟在*x[k]*后面。然后我们有
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于子矩阵*B*（大小为(*n*−*k*)×*k*）和*C*（大小为(*n*−*k*)×(*n*−*k*)）。定义*n*向量![art](img/Art_P943.jpg)，其中有*n*−*k*个
    0 跟在*x[k]*后面。然后我们有  输出：'
  type: TYPE_NORMAL
  zh: 对于子矩阵`B`（大小为(`n`−`k`)×`k`）和`C`（大小为(`n`−`k`)×(`n`−`k`)）。定义`n`向量![art](img/Art_P943.jpg)，其中有`n`−`k`个
    0 跟在`x[k]`后面。然后我们有
- answer: '```

    -   ![art](img/Art_P944.jpg)

    ```'
  en: '![art](img/Art_P944.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P944.jpg)  输出：'
  type: TYPE_IMG
  zh: '![art](img/Art_P944.jpg)'
- answer: '-   这与`A`是正定的相矛盾。'
  en: 这与*A*是正定的相矛盾。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   这与*A*是正定的相矛盾。  输出：'
  type: TYPE_NORMAL
  zh: 这与`A`是正定的相矛盾。
- answer: '-   ▪  输出：'
  en: ▪
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ▪  输出：'
  type: TYPE_NORMAL
  zh: ▪  输出：
- answer: '-   现在我们转向 Schur 补的一些基本性质。让`A`是一个对称正定矩阵，让`A[k]`是`A`的一个主要的`k` × `k`子矩阵。根据方程（28.16）再次对`A`进行分区。方程（28.10）推广定义了相对于`A[k]`的***Schur
    补*** `S`为  '
  en: 现在我们转向 Schur 补的一些基本性质。让*A*是一个对称正定矩阵，让*A[k]*是*A*的一个主要的*k* × *k*子矩阵。根据方程（28.16）再次对*A*进行分区。方程（28.10）推广定义了相对于*A[k]*的***Schur
    补*** *S*为
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   现在我们转向 Schur
    补的一些基本性质。让*A*是一个对称正定矩阵，让*A[k]*是*A*的一个主要的*k* × *k*子矩阵。根据方程（28.16）再次对*A*进行分区。方程（28.10）推广定义了相对于*A[k]*的***Schur
    补*** *S*为  输出：'
  type: TYPE_NORMAL
  zh: '现在我们转向 Schur 补的一些基本性质。让`A`是一个对称正定矩阵，让`A[k]`是`A`的一个主要的`k` × `k`子矩阵。根据方程（28.16）再次对`A`进行分区。方程（28.10）推广定义了相对于`A[k]`的***Schur
    补*** `S`为  '
- answer: '---

    -   `![art](img/Art_P945.jpg)`'
  en: '![art](img/Art_P945.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P945.jpg)  输出：'
  type: TYPE_IMG
  zh: '`![art](img/Art_P945.jpg)`'
- answer: '-   （根据引理 28.4，`A[k]`是对称的且正定的，因此，根据引理 28.3，存在![art](img/Art_P946.jpg)，`S`是良定义的。）通过让`k`=1，方程（28.17）与
    Schur 补的早期定义（28.10）是一致的。'
  en: （根据引理 28.4，*A[k]*是对称的且正定的，因此，根据引理 28.3，存在![art](img/Art_P946.jpg)，*S*是良定义的。）通过让*k*=1，方程（28.17）与
    Schur 补的早期定义（28.10）是一致的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   （根据引理 28.4，*A[k]*是对称的且正定的，因此，根据引理
    28.3，存在![art](img/Art_P946.jpg)，*S*是良定义的。）通过让*k*=1，方程（28.17）与 Schur 补的早期定义（28.10）是一致的。  输出：'
  type: TYPE_NORMAL
  zh: （根据引理 28.4，`A[k]`是对称的且正定的，因此，根据引理 28.3，存在![art](img/Art_P946.jpg)，`S`是良定义的。）通过让`k`=1，方程（28.17）与
    Schur 补的早期定义（28.10）是一致的。
- answer: '-   下一个引理表明对称正定矩阵的 Schur 补矩阵本身也是对称的且正定的。我们在定理 `28.2` 中使用了这个结果，其推论将有助于证明
    LU 分解适用于对称正定矩阵。'
  en: 下一个引理表明对称正定矩阵的 Schur 补矩阵本身也是对称的且正定的。我们在定理 28.2 中使用了这个结果，其推论将有助于证明 LU 分解适用于对称正定矩阵。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   下一个引理表明对称正定矩阵的
    Schur 补矩阵本身也是对称的且正定的。我们在定理 28.2 中使用了这个结果，其推论将有助于证明 LU 分解适用于对称正定矩阵。  输出：'
  type: TYPE_NORMAL
  zh: 下一个引理表明对称正定矩阵的 Schur 补矩阵本身也是对称的且正定的。我们在定理 `28.2` 中使用了这个结果，其推论将有助于证明 LU 分解适用于对称正定矩阵。
- answer: '-   ***引理 28.5(Schur 补引理)***'
  en: '***引理 28.5（Schur 补引理）***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***引理 28.5（Schur
    补引理）***  输出：'
  type: TYPE_NORMAL
  zh: '***引理 28.5(Schur 补引理)***'
- answer: '-   如果`A`是对称正定矩阵，而`A[k]`是`A`的一个主要的`k × k`子矩阵，则相对于`A[k]`的 Schur 补`S`是对称的且正定的。'
  en: 如果*A*是对称正定矩阵，而*A[k]*是*A*的一个主要的*k* × *k*子矩阵，则相对于*A[k]*的 Schur 补*S*是对称的且正定的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   如果*A*是对称正定矩阵，而*A[k]*是*A*的一个主要的*k*
    × *k*子矩阵，则相对于*A[k]*的 Schur 补*S*是对称的且正定的。  输出：'
  type: TYPE_NORMAL
  zh: 如果`A`是对称正定矩阵，而`A[k]`是`A`的一个主要的`k × k`子矩阵，则相对于`A[k]`的 Schur 补`S`是对称的且正定的。
- answer: '-   ***证明***   因为*A*是对称的，所以子矩阵`C`也是对称的。根据第 1223 页的练习 D.2-6，乘积`![art](img/BA.jpg)`是对称的。由于`C`和`![art](img/BA.jpg)`是对称的，根据第
    1219 页的练习 D.1-1，`S`也是对称的。'
  en: '***证明***   因为*A*是对称的，所以子矩阵*C*也是对称的。根据第 1223 页的练习 D.2-6，乘积![art](img/BA.jpg)是对称的。由于*C*和![art](img/BA.jpg)是对称的，根据第
    1219 页的练习 D.1-1，*S*也是对称的。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***证明***   因为*A*是对称的，所以子矩阵*C*也是对称的。根据第
    1223 页的练习 D.2-6，乘积![art](img/BA.jpg)是对称的。由于*C*和![art](img/BA.jpg)是对称的，根据第 1219
    页的练习 D.1-1，*S*也是对称的。  输出：'
  type: TYPE_NORMAL
  zh: '***证明***   因为*A*是对称的，所以子矩阵`C`也是对称的。根据第 1223 页的练习 D.2-6，乘积`![art](img/BA.jpg)`是对称的。由于`C`和`![art](img/BA.jpg)`是对称的，根据第
    1219 页的练习 D.1-1，`S`也是对称的。'
- answer: '-   仍需证明`S`是正定的。考虑方程（28.16）中给出的`A`的分区。对于任何非零向量`x`，根据`A`是正定的假设，我们有`x^TAx
    > 0`。让子向量`y`和`z`包含`x`中的前`k`个元素和后`n-k`个元素，因此它们与`A[k]`和`C`兼容。因为`![art](img/Art_P947.jpg)`存在，我们有'
  en: 仍需证明*S*是正定的。考虑方程（28.16）中给出的*A*的分区。对于任何非零向量*x*，根据*A*是正定的假设，我们有*x*^T*Ax* > 0。让子向量*y*和*z*包含*x*中的前*k*个元素和后*n*−*k*个元素，因此它们与*A[k]*和*C*兼容。因为![art](img/Art_P947.jpg)存在，我们有
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   仍需证明*S*是正定的。考虑方程（28.16）中给出的*A*的分区。对于任何非零向量*x*，根据*A*是正定的假设，我们有*x*^T*Ax*
    > 0。让子向量*y*和*z*包含*x*中的前*k*个元素和后*n*−*k*个元素，因此它们与*A[k]*和*C*兼容。因为![art](img/Art_P947.jpg)存在，我们有  输出：'
  type: TYPE_NORMAL
  zh: 仍需证明`S`是正定的。考虑方程（28.16）中给出的`A`的分区。对于任何非零向量`x`，根据`A`是正定的假设，我们有`x^TAx > 0`。让子向量`y`和`z`包含`x`中的前`k`个元素和后`n-k`个元素，因此它们与`A[k]`和`C`兼容。因为`![art](img/Art_P947.jpg)`存在，我们有
- answer: '---

    -   ![art](img/Art_P948.jpg)'
  en: '![art](img/Art_P948.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P948.jpg)  输出：'
  type: TYPE_IMG
  zh: '![art](img/Art_P948.jpg)'
- answer: '-   这最后一个等式，你可以通过乘法验证，相当于对二次形式进行“完全平方”（见练习 `28.3-2`）。'
  en: 这最后一个等式，你可以通过乘法验证，相当于对二次形式进行“完全平方”（见练习 28.3-2）。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   这最后一个等式，你可以通过乘法验证，相当于对二次形式进行“完全平方”（见练习
    28.3-2）。  输出：'
  type: TYPE_NORMAL
  zh: 这最后一个等式，你可以通过乘法验证，相当于对二次形式进行“完全平方”（见练习 `28.3-2`）。
- answer: '-   由于对于任何非零向量`x`，`x^TAx > 0` 成立，选择任意非零`z`，然后选择![art](img/Art_P949.jpg)，这导致方程（28.18）中的第一项消失，留下'
  en: 由于对于任何非零向量*x*，*x*^T*Ax* > 0 成立，选择任意非零*z*，然后选择![art](img/Art_P949.jpg)，这导致方程（28.18）中的第一项消失，留下
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   由于对于任何非零向量*x*，*x*^T*Ax*
    > 0 成立，选择任意非零*z*，然后选择![art](img/Art_P949.jpg)，这导致方程（28.18）中的第一项消失，留下  输出：'
  type: TYPE_NORMAL
  zh: 由于对于任何非零向量`x`，`x^TAx > 0` 成立，选择任意非零`z`，然后选择![art](img/Art_P949.jpg)，这导致方程（28.18）中的第一项消失，留下
- answer: '```

    -   ![art](img/Art_P950.jpg)

    ```'
  en: '![art](img/Art_P950.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。


    ## 要求


    +   将公式使用内联代码符号（`...`）包围，其它文本原样输出

    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分

    +   输入可能有多行，不要遗漏其中任何一行

    +   输出的每一行前面需要有分隔符（-   ），不然我无法处理



    ## 示例


    输入：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。



    输出：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆
    V`，使得如果`(u, v)`是`G`的一条边，则`u ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。


    ## 需要排版的段落


    输入：


    -   ![art](img/Art_P950.jpg)


    输出：

    '
  type: TYPE_IMG
  zh: '![art](img/Art_P950.jpg)'
- answer: '-   作为表达式的值。对于任意`z ≠ 0`，我们因此有`z^T*Sz = x^T*Ax > 0`，因此`S`是正定的。'
  en: 作为表达式的值。对于任意*z* ≠ 0，我们因此有*z*^T*Sz* = *x*^T*Ax* > 0，因此*S*是正定的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   作为表达式的值。对于任意*z*
    ≠ 0，我们因此有*z*^T*Sz* = *x*^T*Ax* > 0，因此*S*是正定的。  输出：'
  type: TYPE_NORMAL
  zh: 作为表达式的值。对于任意`z ≠ 0`，我们因此有`z^T*Sz = x^T*Ax > 0`，因此`S`是正定的。
- answer: '---

    -   ▪  输出：'
  en: ▪
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ▪  输出：'
  type: TYPE_NORMAL
  zh: ▪  输出：
- answer: '-   ***推论 28.6***'
  en: '***推论 28.6***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***推论 28.6***  输出：'
  type: TYPE_NORMAL
  zh: '***推论 28.6***'
- answer: '---

    -   对称正定矩阵的 LU 分解永远不会导致除以 0。'
  en: 对称正定矩阵的 LU 分解永远不会导致除以 0。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对称正定矩阵的 LU
    分解永远不会导致除以 0。  输出：'
  type: TYPE_NORMAL
  zh: 对称正定矩阵的 LU 分解永远不会导致除以 0。
- answer: '-   ***证明*** 让`A`是一个`n` × `n`对称正定矩阵。实际上，我们将证明一个比推论陈述更强的结果：每个主元都是严格正的。第一个主元是`a[11]`。让`e[1]`是长度为`n`的单位向量(
    1 0 0 ⋯ 0 )^T，所以 `e[1]^T A e[1]`，这是正的，因为`e[1]`是非零的，`A`是正定的。由于 LU 分解的第一步产生了关于`A[1]`
    = (`a[11]`)的舒尔补引理 28.5 暗示通过归纳所有主元都是正的。  '
  en: '***证明*** 让*A*是一个*n* × *n*对称正定矩阵。实际上，我们将证明一个比推论陈述更强的结果：每个主元都是严格正的。第一个主元是*a*[11]。让*e*[1]是长度为*n*的单位向量(
    1 0 0 ⋯ 0 )^T，所以 ![art](img/Art_P951.jpg)，这是正的，因为*e*[1]是非零的，*A*是正定的。由于 LU 分解的第一步产生了关于*A*[1]
    = (*a*[11])的舒尔补引理 28.5 暗示通过归纳所有主元都是正的。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***证明*** 让*A*是一个*n*
    × *n*对称正定矩阵。实际上，我们将证明一个比推论陈述更强的结果：每个主元都是严格正的。第一个主元是*a*[11]。让*e*[1]是长度为*n*的单位向量(
    1 0 0 ⋯ 0 )^T，所以 ![art](img/Art_P951.jpg)，这是正的，因为*e*[1]是非零的，*A*是正定的。由于 LU 分解的第一步产生了关于*A*[1]
    = (*a*[11])的舒尔补引理 28.5 暗示通过归纳所有主元都是正的。  输出：'
  type: TYPE_NORMAL
  zh: '***证明*** 让`A`是一个`n` × `n`对称正定矩阵。实际上，我们将证明一个比推论陈述更强的结果：每个主元都是严格正的。第一个主元是`a[11]`。让`e[1]`是长度为`n`的单位向量(
    1 0 0 ⋯ 0 )^T，所以 `e[1]^T A e[1]`，这是正的，因为`e[1]`是非零的，`A`是正定的。由于 LU 分解的第一步产生了关于`A[1]`
    = (`a[11]`)的舒尔补引理 28.5 暗示通过归纳所有主元都是正的。  '
- answer: '-   ▪ 输出：'
  en: ▪
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ▪  输出：'
  type: TYPE_NORMAL
  zh: ▪ 输出：
- answer: '-   **最小二乘逼近**'
  en: '**最小二乘逼近**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **最小二乘逼近**  输出：'
  type: TYPE_NORMAL
  zh: '**最小二乘逼近**'
- answer: '-   对称正定矩阵的一个重要应用是将曲线拟合给定的数据点集。给定一组`m`个数据点'
  en: 对称正定矩阵的一个重要应用是将曲线拟合给定的数据点集。给定一组*m*个数据点
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对称正定矩阵的一个重要应用是将曲线拟合给定的数据点集。给定一组*m*个数据点  输出：'
  type: TYPE_NORMAL
  zh: 对称正定矩阵的一个重要应用是将曲线拟合给定的数据点集。给定一组`m`个数据点
- answer: '-   `(*x*[1], *y*[1]), (*x*[2], *y*[2]), … , (*x[m]*, *y*[m]*)`,'
  en: (*x*[1], *y*[1]), (*x*[2], *y*[2]), … , (*x[m]*, *y[m]*),
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   (*x*[1], *y*[1]),
    (*x*[2], *y*[2]), … , (*x[m]*, *y[m]*),  输出：'
  type: TYPE_NORMAL
  zh: '`(*x*[1], *y*[1]), (*x*[2], *y*[2]), … , (*x[m]*, *y*[m]*)`,'
- answer: '-   你知道`y[i]`受测量误差影响。你希望确定一个函数`F(x)`，使得逼近误差'
  en: 你知道*y[i]*受测量误差影响。你希望确定一个函数*F*(*x*)，使得逼近误差
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   你知道*y[i]*受测量误差影响。你希望确定一个函数*F*(*x*)，使得逼近误差  输出：'
  type: TYPE_NORMAL
  zh: 你知道`y[i]`受测量误差影响。你希望确定一个函数`F(x)`，使得逼近误差
- answer: '-   ![art](img/Art_P952.jpg)  '
  en: '![art](img/Art_P952.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P952.jpg)  输出：'
  type: TYPE_IMG
  zh: '![art](img/Art_P952.jpg)  '
- answer: '-   对于`i` = 1, 2, … , `m`。函数`F`的形式取决于手头的问题。让我们假设它具有线性加权和的形式'
  en: 对于*i* = 1, 2, … , *m*。函数*F*的形式取决于手头的问题。让我们假设它具有线性加权和的形式
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于*i* = 1,
    2, … , *m*。函数*F*的形式取决于手头的问题。让我们假设它具有线性加权和的形式  输出：'
  type: TYPE_NORMAL
  zh: 对于`i` = 1, 2, … , `m`。函数`F`的形式取决于手头的问题。让我们假设它具有线性加权和的形式
- answer: '```

    -   ![art](img/Art_P953.jpg)

    ```'
  en: '![art](img/Art_P953.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P953.jpg)  输出：'
  type: TYPE_IMG
  zh: '![art](img/Art_P953.jpg)'
- answer: '---

    -   其中求和的数量`n`和特定的***基函数*** `f[j]`是基于问题的知识选择的。一个常见的选择是`f[j](x) = x^(j−1)`，这意味着'
  en: 其中求和的数量*n*和特定的***基函数*** *f[j]*是基于问题的知识选择的。一个常见的选择是*f[j]*(*x*) = *x*^(*j*−1)，这意味着
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   其中求和的数量*n*和特定的***基函数*** *f[j]*是基于问题的知识选择的。一个常见的选择是*f[j]*(*x*)
    = *x*^(*j*−1)，这意味着  输出：'
  type: TYPE_NORMAL
  zh: 其中求和的数量`n`和特定的***基函数*** `f[j]`是基于问题的知识选择的。一个常见的选择是`f[j](x) = x^(j−1)`，这意味着
- answer: '-   `F(x) = c[1] + c[2]*x + c[3]*x² + ⋯ + c[n]*x^(n−1)`'
  en: '*F*(*x*) = *c*[1] + *c*[2]*x* + *c*[3]*x*² + ⋯ + *c*[*n*]*x*^(*n*−1)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *F*(*x*) =
    *c*[1] + *c*[2]*x* + *c*[3]*x*² + ⋯ + *c*[*n*]*x*^(*n*−1)  输出：'
  type: TYPE_NORMAL
  zh: '`F(x) = c[1] + c[2]*x + c[3]*x² + ⋯ + c[n]*x^(n−1)`'
- answer: '-   是`x`的`n - 1`次多项式。因此，如果给定`m`个数据点`(x[1], y[1])`, `(x[2], y[2])`, … ,
    `(x[m], y[m])`，你需要计算`n`个系数`c[1]`, `c[2]`, … , `c[n]`，使逼近误差`η[1]`, `η[2]`, … ,
    `η[m]`最小化。'
  en: 是*x*的*n* − 1 次多项式。因此，如果给定*m*个数据点(*x*[1], *y*[1]), (*x*[2], *y*[2]), … , (*x[m]*,
    *y[m]*)，你需要计算*n*个系数*c*[1], *c*[2], … , *c[n]*，使逼近误差*η*[1], *η*[2], … , *η[m]*最小化。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   是*x*的*n* −
    1 次多项式。因此，如果给定*m*个数据点(*x*[1], *y*[1]), (*x*[2], *y*[2]), … , (*x[m]*, *y[m]*)，你需要计算*n*个系数*c*[1],
    *c*[2], … , *c[n]*，使逼近误差*η*[1], *η*[2], … , *η[m]*最小化。  输出：'
  type: TYPE_NORMAL
  zh: 是`x`的`n - 1`次多项式。因此，如果给定`m`个数据点`(x[1], y[1])`, `(x[2], y[2])`, … , `(x[m], y[m])`，你需要计算`n`个系数`c[1]`,
    `c[2]`, … , `c[n]`，使逼近误差`η[1]`, `η[2]`, … , `η[m]`最小化。
- answer: '-   通过选择`n` = `m`，你可以在方程(28.19)中*精确*计算每个`y[i]`。这样一个高次多项式`F`“适应噪音”以及数据，但通常在用于预测先前未见的`x`值的`y`时效果不佳。通常最好选择明显小于`m`的`n`，希望通过选择系数`c[j]`得当，你可以获得一个函数`F`，它在不过分关注噪音的情况下找到数据点中的显著模式。有一些选择`n`的理论原则，但它们超出了本文的范围。无论如何，一旦选择了小于`m`的`n`值，你就会得到一个过度确定的方程组，你希望近似其解。让我们看看如何做到这一点。'
  en: 通过选择*n* = *m*，你可以在方程(28.19)中*精确*计算每个*y[i]*。这样一个高次多项式*F*“适应噪音”以及数据，但通常在用于预测先前未见的*x*值的*y*时效果不佳。通常最好选择明显小于*m*的*n*，希望通过选择系数*c[j]*得当，你可以获得一个函数*F*，它在不过分关注噪音的情况下找到数据点中的显著模式。有一些选择*n*的理论原则，但它们超出了本文的范围。无论如何，一旦选择了小于*m*的*n*值，你就会得到一个过度确定的方程组，你希望近似其解。让我们看看如何做到这一点。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   通过选择*n* = *m*，你可以在方程(28.19)中*精确*计算每个*y[i]*。这样一个高次多项式*F*“适应噪音”以及数据，但通常在用于预测先前未见的*x*值的*y*时效果不佳。通常最好选择明显小于*m*的*n*，希望通过选择系数*c[j]*得当，你可以获得一个函数*F*，它在不过分关注噪音的情况下找到数据点中的显著模式。有一些选择*n*的理论原则，但它们超出了本文的范围。无论如何，一旦选择了小于*m*的*n*值，你就会得到一个过度确定的方程组，你希望近似其解。让我们看看如何做到这一点。  输出：'
  type: TYPE_NORMAL
  zh: 通过选择`n` = `m`，你可以在方程(28.19)中*精确*计算每个`y[i]`。这样一个高次多项式`F`“适应噪音”以及数据，但通常在用于预测先前未见的`x`值的`y`时效果不佳。通常最好选择明显小于`m`的`n`，希望通过选择系数`c[j]`得当，你可以获得一个函数`F`，它在不过分关注噪音的情况下找到数据点中的显著模式。有一些选择`n`的理论原则，但它们超出了本文的范围。无论如何，一旦选择了小于`m`的`n`值，你就会得到一个过度确定的方程组，你希望近似其解。让我们看看如何做到这一点。
- answer: '-   让

    '
  en: 让
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   让  输出：'
  type: TYPE_NORMAL
  zh: 让
- answer: '```

    -   ![art](img/Art_P954.jpg)

    ```'
  en: '![art](img/Art_P954.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P954.jpg)  输出：'
  type: TYPE_IMG
  zh: '![art](img/Art_P954.jpg)'
- answer: '```

    -   表示给定点处基函数值的矩阵，即`a[ij]` = `f[j]`(x[i])。让`c` = (c[k])表示所需的`n`个系数向量。然后，

    ```'
  en: 表示给定点处基函数值的矩阵，即*a[ij]* = *f[j]*(*x[i]*)。让*c* = (*c[k]*)表示所需的*n*个系数向量。然后，
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   表示给定点处基函数值的矩阵，即*a[ij]*
    = *f[j]*(*x[i]*)。让*c* = (*c[k]*)表示所需的*n*个系数向量。然后，  输出：'
  type: TYPE_NORMAL
  zh: 表示给定点处基函数值的矩阵，即`a[ij]` = `f[j]`(x[i])。让`c` = (c[k])表示所需的`n`个系数向量。然后，
- answer: '---

    -   ![art](img/Art_P955.jpg)'
  en: '![art](img/Art_P955.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P955.jpg)  输出：'
  type: TYPE_IMG
  zh: '![art](img/Art_P955.jpg)'
- answer: '---

    -   是`y`的“预测值”的`m`向量。因此，'
  en: 是*y*的“预测值”的*m*向量。因此，
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   是*y*的“预测值”的*m*向量。因此，  输出：'
  type: TYPE_NORMAL
  zh: 是`y`的“预测值”的`m`向量。因此，
- answer: '-   `η = Ac - y`  '
  en: '*η* = *Ac* − *y*'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *η* = *Ac*
    − *y*  输出：'
  type: TYPE_NORMAL
  zh: '`η = Ac - y`  '
- answer: '```

    -   是**逼近误差**的`m`向量。

    ```'
  en: 是***逼近误差***的*m*向量。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   是***逼近误差***的*m*向量。  输出：'
  type: TYPE_NORMAL
  zh: 是**逼近误差**的`m`向量。
- answer: '-   为了最小化逼近误差，让我们最小化误差向量`η`的范数，这给出了一个***最小二乘解***，因为'
  en: 为了最小化逼近误差，让我们最小化误差向量*η*的范数，这给出了一个***最小二乘解***，因为
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   为了最小化逼近误差，让我们最小化误差向量*η*的范数，这给出了一个***最小二乘解***，因为  输出：'
  type: TYPE_NORMAL
  zh: 为了最小化逼近误差，让我们最小化误差向量`η`的范数，这给出了一个***最小二乘解***，因为
- answer: '-   ![art](img/Art_P956.jpg)'
  en: '![art](img/Art_P956.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P956.jpg)  输出：'
  type: TYPE_IMG
  zh: '![art](img/Art_P956.jpg)'
- answer: '---

    -   因为

    ---'
  en: 因为
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   因为  输出：'
  type: TYPE_NORMAL
  zh: 因为
- answer: '-   ![art](img/Art_P957.jpg)'
  en: '![art](img/Art_P957.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。


    ## 要求


    +   将公式使用内联代码符号（`...`）包围，其它文本原样输出

    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分

    +   输入可能有多行，不要遗漏其中任何一行

    +   输出的每一行前面需要有分隔符（-   ），不然我无法处理



    ## 示例


    输入：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。



    输出：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆
    V`，使得如果`(u, v)`是`G`的一条边，则`u ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。


    ## 需要排版的段落


    输入：


    -   ![art](img/Art_P957.jpg)


    输出：

    '
  type: TYPE_IMG
  zh: '![art](img/Art_P957.jpg)'
- answer: '-   为了最小化`∥η∥`，对`∥η∥²`关于每个`c[k]`求导，然后将结果设为 0：'
  en: 为了最小化∥*η*∥，对∥*η*∥²关于每个*c[k]*求导，然后将结果设为 0：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   为了最小化∥*η*∥，对∥*η*∥²关于每个*c[k]*求导，然后将结果设为
    0：  输出：'
  type: TYPE_NORMAL
  zh: 为了最小化`∥η∥`，对`∥η∥²`关于每个`c[k]`求导，然后将结果设为 0：
- answer: '---

    -   ![art](img/Art_P958.jpg)'
  en: '![art](img/Art_P958.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P958.jpg)  输出：'
  type: TYPE_IMG
  zh: '![art](img/Art_P958.jpg)'
- answer: '-   对于`k` = 1, 2, … , `n`的`n`个方程(28.20)等价于单个矩阵方程'
  en: 对于*k* = 1, 2, … , *n*的*n*个方程(28.20)等价于单个矩阵方程
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于*k* = 1,
    2, … , *n*的*n*个方程(28.20)等价于单个矩阵方程  输出：'
  type: TYPE_NORMAL
  zh: 对于`k` = 1, 2, … , `n`的`n`个方程(28.20)等价于单个矩阵方程
- answer: '-   `(*Ac* - y)^T *A* = 0`'
  en: (*Ac* − *y*)^T *A* = 0
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   (*Ac* − *y*)^T *A*
    = 0  输出：'
  type: TYPE_NORMAL
  zh: '`(*Ac* - y)^T *A* = 0`'
- answer: '-   或者等价地(使用第 `1219` 页的练习 `D.1-2`)，为了'
  en: 或者等价地(使用第 1219 页的练习 D.1-2)，为了
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   或者等价地(使用第 1219
    页的练习 D.1-2)，为了  输出：'
  type: TYPE_NORMAL
  zh: 或者等价地(使用第 `1219` 页的练习 `D.1-2`)，为了
- answer: '-   `A^T(Ac - y) = 0`, '
  en: '*A*^T(*Ac* − *y*) = 0,'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *A*^T(*Ac*
    − *y*) = 0,  输出：'
  type: TYPE_NORMAL
  zh: '`A^T(Ac - y) = 0`, '
- answer: '---

    -   这意味着'
  en: 这意味着
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   这意味着  输出：'
  type: TYPE_NORMAL
  zh: 这意味着
- answer: '---

    -   ![art](img/Art_P959.jpg)'
  en: '![art](img/Art_P959.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P959.jpg)  输出：'
  type: TYPE_IMG
  zh: '![art](img/Art_P959.jpg)'
- answer: '-   在统计学中，方程`(28.21)`被称为***正规方程***。矩阵`A^T*A`通过练习 D.1-2 是对称的，如果`A`具有完整的列秩，那么根据第
    1222 页的定理 D.6，`A^T*A`也是正定的。因此，`(A^T*A)^(-1)`存在，方程`(28.21)`的解是'
  en: 在统计学中，方程(28.21)被称为***正规方程***。矩阵*A*^T*A*通过练习 D.1-2 是对称的，如果*A*具有完整的列秩，那么根据第 1222
    页的定理 D.6，*A*^T*A*也是正定的。因此，(*A*^T*A*)^(−1)存在，方程(28.21)的解是
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   在统计学中，方程(28.21)被称为***正规方程***。矩阵*A*^T*A*通过练习
    D.1-2 是对称的，如果*A*具有完整的列秩，那么根据第 1222 页的定理 D.6，*A*^T*A*也是正定的。因此，(*A*^T*A*)^(−1)存在，方程(28.21)的解是  输出：'
  type: TYPE_NORMAL
  zh: 在统计学中，方程`(28.21)`被称为***正规方程***。矩阵`A^T*A`通过练习 D.1-2 是对称的，如果`A`具有完整的列秩，那么根据第 1222
    页的定理 D.6，`A^T*A`也是正定的。因此，`(A^T*A)^(-1)`存在，方程`(28.21)`的解是
- answer: '---

    -   ![art](img/Art_P960.jpg)  '
  en: '![art](img/Art_P960.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P960.jpg)  输出：'
  type: TYPE_IMG
  zh: '![art](img/Art_P960.jpg)  '
- answer: '-   其中矩阵`A^+ = ((A^T*A)^(-1)*A^T)`是矩阵`A`的***伪逆***。伪逆自然地将矩阵逆的概念推广到`A`不是方阵的情况。(将方程(28.22)作为`Ac
    = y`的近似解与将解`A^(-1)b`作为`Ax = b`的精确解进行比较。)'
  en: 其中矩阵*A*^+ = ((*A*^T*A*)^(−1)*A*^T)是矩阵*A*的***伪逆***。伪逆自然地将矩阵逆的概念推广到*A*不是方阵的情况。(将方程(28.22)作为*Ac*
    = *y*的近似解与将解*A*^(−1)*b*作为*Ax* = *b*的精确解进行比较。)
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   其中矩阵*A*^+ =
    ((*A*^T*A*)^(−1)*A*^T)是矩阵*A*的***伪逆***。伪逆自然地将矩阵逆的概念推广到*A*不是方阵的情况。(将方程(28.22)作为*Ac*
    = *y*的近似解与将解*A*^(−1)*b*作为*Ax* = *b*的精确解进行比较。)  输出：'
  type: TYPE_NORMAL
  zh: 其中矩阵`A^+ = ((A^T*A)^(-1)*A^T)`是矩阵`A`的***伪逆***。伪逆自然地将矩阵逆的概念推广到`A`不是方阵的情况。(将方程(28.22)作为`Ac
    = y`的近似解与将解`A^(-1)b`作为`Ax = b`的精确解进行比较。)
- answer: '-   作为产生最小二乘拟合的一个例子，假设您有五个数据点'
  en: 作为产生最小二乘拟合的一个例子，假设您有五个数据点
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   作为产生最小二乘拟合的一个例子，假设您有五个数据点  输出：'
  type: TYPE_NORMAL
  zh: 作为产生最小二乘拟合的一个例子，假设您有五个数据点
- answer: '---

    -   | `(*x*[1], *y*[1])` | = | `(−1, 2),` |'
  en: '| (*x*[1], *y*[1]) | = | (−1, 2), |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | (*x*[1],
    *y*[1]) | = | (−1, 2), |  输出：'
  type: TYPE_TB
  zh: '| `(*x*[1], *y*[1])` | = | `(−1, 2),` |'
- answer: '```

    -   | --- | --- | --- |

    ```'
  en: '| --- | --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | --- | ---
    | --- |  输出：'
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- answer: '```

    -   | `x[2]`, `y[2]` | = | `(1, 1),` |

    ```'
  en: '| (*x*[2], *y*[2]) | = | (1, 1), |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | (*x*[2],
    *y*[2]) | = | (1, 1), |  输出：'
  type: TYPE_TB
  zh: '| `x[2]`, `y[2]` | = | `(1, 1),` |'
- answer: '-   | (`x[3]`, `y[3]`) | = | (2, 1), |'
  en: '| (*x*[3], *y*[3]) | = | (2, 1), |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | (*x*[3],
    *y*[3]) | = | (2, 1), |  输出：'
  type: TYPE_TB
  zh: '| (`x[3]`, `y[3]`) | = | (2, 1), |'
- answer: '-   | (`x[4]`, `y[4]`) | = | (3, 0), |'
  en: '| (*x*[4], *y*[4]) | = | (3, 0), |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | (*x*[4],
    *y*[4]) | = | (3, 0), |  输出：'
  type: TYPE_TB
  zh: '| (`x[4]`, `y[4]`) | = | (3, 0), |'
- answer: '-   | `x[5], y[5]` | = | `(5, 3),` |  '
  en: '| (*x*[5], *y*[5]) | = | (5, 3), |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | (*x*[5],
    *y*[5]) | = | (5, 3), |  输出：'
  type: TYPE_TB
  zh: '| `x[5], y[5]` | = | `(5, 3),` |  '
- answer: '-   在图 28.3 中显示为橙色点，您希望用二次多项式拟合这些点'
  en: 在图 28.3 中显示为橙色点，您希望用二次多项式拟合这些点
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   在图 28.3 中显示为橙色点，您希望用二次多项式拟合这些点  输出：'
  type: TYPE_NORMAL
  zh: 在图 28.3 中显示为橙色点，您希望用二次多项式拟合这些点
- answer: '-   `F(x) = c[1] + c[2]x + c[3]x²`。'
  en: '*F*(*x*) = *c*[1] + *c*[2]*x* + *c*[3]*x*²。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *F*(*x*) =
    *c*[1] + *c*[2]*x* + *c*[3]*x*²。  输出：'
  type: TYPE_NORMAL
  zh: '`F(x) = c[1] + c[2]x + c[3]x²`。'
- answer: '-   从基函数值矩阵开始'
  en: 从基函数值矩阵开始
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   从基函数值矩阵开始  输出：'
  type: TYPE_NORMAL
  zh: 从基函数值矩阵开始
- answer: '-   `![art](img/Art_P961.jpg)`'
  en: '![art](img/Art_P961.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P961.jpg)  输出：'
  type: TYPE_IMG
  zh: '`![art](img/Art_P961.jpg)`'
- answer: '---

    -   其伪逆是 '
  en: 其伪逆是
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   其伪逆是  输出：'
  type: TYPE_NORMAL
  zh: '其伪逆是 '
- answer: '---

    -   ![art](img/Art_P962.jpg)'
  en: '![art](img/Art_P962.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P962.jpg)  输出：'
  type: TYPE_IMG
  zh: '![art](img/Art_P962.jpg)'
- answer: '-   **图 28.3** 二次多项式对五个数据点集合{(−1, 2), (1, 1), (2, 1), (3, 0), (5, 3)}的最小二乘拟合。橙色点是数据点，蓝色点是由多项式`F(x)
    = 1.2 - 0.757x + 0.214x²`预测的它们的估计值，最小化平方误差的二次多项式，用蓝色绘制。每个橙色线显示了一个数据点的误差。'
  en: '**图 28.3** 二次多项式对五个数据点集合{(−1, 2), (1, 1), (2, 1), (3, 0), (5, 3)}的最小二乘拟合。橙色点是数据点，蓝色点是由多项式*F*(*x*)
    = 1.2 − 0.757*x* + 0.214*x*²预测的它们的估计值，最小化平方误差的二次多项式，用蓝色绘制。每个橙色线显示了一个数据点的误差。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **图 28.3**
    二次多项式对五个数据点集合{(−1, 2), (1, 1), (2, 1), (3, 0), (5, 3)}的最小二乘拟合。橙色点是数据点，蓝色点是由多项式*F*(*x*)
    = 1.2 − 0.757*x* + 0.214*x*²预测的它们的估计值，最小化平方误差的二次多项式，用蓝色绘制。每个橙色线显示了一个数据点的误差。  输出：'
  type: TYPE_NORMAL
  zh: '**图 28.3** 二次多项式对五个数据点集合{(−1, 2), (1, 1), (2, 1), (3, 0), (5, 3)}的最小二乘拟合。橙色点是数据点，蓝色点是由多项式`F(x)
    = 1.2 - 0.757x + 0.214x²`预测的它们的估计值，最小化平方误差的二次多项式，用蓝色绘制。每个橙色线显示了一个数据点的误差。'
- answer: '-   ![art](img/Art_P963.jpg)'
  en: '![art](img/Art_P963.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P963.jpg)  输出：'
  type: TYPE_IMG
  zh: '![art](img/Art_P963.jpg)'
- answer: '-   将`y`乘以`A`^+得到系数向量'
  en: 将*y*乘以*A*^+得到系数向量
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   将*y*乘以*A*^+得到系数向量  输出：'
  type: TYPE_NORMAL
  zh: 将`y`乘以`A`^+得到系数向量
- answer: '-   ![art](img/Art_P964.jpg)'
  en: '![art](img/Art_P964.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P964.jpg)  输出：'
  type: TYPE_IMG
  zh: '![art](img/Art_P964.jpg)'
- answer: '-   对应于二次多项式'
  en: 对应于二次多项式
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对应于二次多项式  输出：'
  type: TYPE_NORMAL
  zh: 对应于二次多项式
- answer: '-   `F(x) = 1.200 - 0.757x + 0.214x²`'
  en: '*F*(*x*) = 1.200 − 0.757*x* + 0.214*x*²'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *F*(*x*) =
    1.200 − 0.757*x* + 0.214*x*²  输出：'
  type: TYPE_NORMAL
  zh: '`F(x) = 1.200 - 0.757x + 0.214x²`'
- answer: '-   作为对给定数据的最接近的二次拟合，从最小二乘意义上讲。'
  en: 作为对给定数据的最接近的二次拟合，从最小二乘意义上讲。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   作为对给定数据的最接近的二次拟合，从最小二乘意义上讲。  输出：'
  type: TYPE_NORMAL
  zh: 作为对给定数据的最接近的二次拟合，从最小二乘意义上讲。
- answer: '-   作为一个实际问题，您通常会通过将`y`乘以`A`^T 来解决正规方程(28.21)，然后找到`A`^T`A`的 LU 分解。如果`A`具有满秩，那么矩阵`A`^T`A`是非奇异的，因为它是对称的且正定的。(参见练习
    D.1-2 和定理 D.6。)'
  en: 作为一个实际问题，您通常会通过将*y*乘以*A*^T 来解决正规方程(28.21)，然后找到*A*^T*A*的 LU 分解。如果*A*具有满秩，那么矩阵*A*^T*A*是非奇异的，因为它是对称的且正定的。(参见练习
    D.1-2 和定理 D.6。)
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   作为一个实际问题，您通常会通过将*y*乘以*A*^T
    来解决正规方程(28.21)，然后找到*A*^T*A*的 LU 分解。如果*A*具有满秩，那么矩阵*A*^T*A*是非奇异的，因为它是对称的且正定的。(参见练习
    D.1-2 和定理 D.6。)  输出：'
  type: TYPE_NORMAL
  zh: 作为一个实际问题，您通常会通过将`y`乘以`A`^T 来解决正规方程(28.21)，然后找到`A`^T`A`的 LU 分解。如果`A`具有满秩，那么矩阵`A`^T`A`是非奇异的，因为它是对称的且正定的。(参见练习
    D.1-2 和定理 D.6。)
- answer: '```

    -   ![art](img/Art_P965.jpg)

    ```'
  en: '![art](img/Art_P965.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![art](img/Art_P965.jpg)  输出：'
  type: TYPE_IMG
  zh: '![art](img/Art_P965.jpg)'
- answer: '```

    -   **图 28.4** 一个形式为的最小二乘拟合

    ```'
  en: '**图 28.4** 一个形式为的最小二乘拟合'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **图 28.4**
    一个形式为的最小二乘拟合  输出：'
  type: TYPE_NORMAL
  zh: '**图 28.4** 一个形式为的最小二乘拟合'
- answer: '-   `c[1]` + `c[2]*x` + `c[3]*x²` + `c[4] sin(2*πx)` + `c[5] cos(2*πx)`'
  en: '*c*[1] + *c*[2]*x* + *c*[3]*x*² + *c*[4] sin(2*πx*) + *c*[5] cos(2*πx*)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *c*[1] + *c*[2]*x*
    + *c*[3]*x*² + *c*[4] sin(2*πx*) + *c*[5] cos(2*πx*)  输出：'
  type: TYPE_NORMAL
  zh: '`c[1]` + `c[2]*x` + `c[3]*x²` + `c[4] sin(2*πx)` + `c[5] cos(2*πx)`'
- answer: '-   对于从 1990¹到 2019 年在夏威夷马瓦诺亚测得的二氧化碳浓度，其中`x`是自 1990 年以来经过的年数。这条曲线是著名的“基林曲线”，展示了对非多项式公式的曲线拟合。正弦和余弦项允许对
    CO[2] 浓度的季节性变化进行建模。红色曲线显示了测得的 CO[2] 浓度。最佳拟合曲线，显示为黑色，具有形式'
  en: 对于从 1990¹到 2019 年在夏威夷马瓦诺亚测得的二氧化碳浓度，其中*x*是自 1990 年以来经过的年数。这条曲线是著名的“基林曲线”，展示了对非多项式公式的曲线拟合。正弦和余弦项允许对
    CO[2]浓度的季节性变化进行建模。红色曲线显示了测得的 CO[2]浓度。最佳拟合曲线，显示为黑色，具有形式
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于从 1990¹到
    2019 年在夏威夷马瓦诺亚测得的二氧化碳浓度，其中*x*是自 1990 年以来经过的年数。这条曲线是著名的“基林曲线”，展示了对非多项式公式的曲线拟合。正弦和余弦项允许对
    CO[2]浓度的季节性变化进行建模。红色曲线显示了测得的 CO[2]浓度。最佳拟合曲线，显示为黑色，具有形式  输出：'
  type: TYPE_NORMAL
  zh: 对于从 1990¹到 2019 年在夏威夷马瓦诺亚测得的二氧化碳浓度，其中`x`是自 1990 年以来经过的年数。这条曲线是著名的“基林曲线”，展示了对非多项式公式的曲线拟合。正弦和余弦项允许对
    CO[2] 浓度的季节性变化进行建模。红色曲线显示了测得的 CO[2] 浓度。最佳拟合曲线，显示为黑色，具有形式
- answer: '-   `352.83 + 1.39*x* + 0.02*x*² + 2.83 sin(2*πx*) − 0.94 cos(2*πx*)`。'
  en: 352.83 + 1.39*x* + 0.02*x*² + 2.83 sin(2*πx*) − 0.94 cos(2*πx*)。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   352.83 + 1.39*x*
    + 0.02*x*² + 2.83 sin(2*πx*) − 0.94 cos(2*πx*)。  输出：'
  type: TYPE_NORMAL
  zh: '`352.83 + 1.39*x* + 0.02*x*² + 2.83 sin(2*πx*) − 0.94 cos(2*πx*)`。'
- answer: '-   我们在图 28.4 中以一个示例结束本节，说明曲线也可以拟合非多项式函数。该曲线证实了气候变化的一个方面：二氧化碳（`CO[2]`）浓度在
    29 年的时间内稳步增加。线性和二次项模拟了年度增长，正弦和余弦项模拟了季节性变化。'
  en: 我们在图 28.4 中以一个示例结束本节，说明曲线也可以拟合非多项式函数。该曲线证实了气候变化的一个方面：二氧化碳（CO[2]）浓度在 29 年的时间内稳步增加。线性和二次项模拟了年度增长，正弦和余弦项模拟了季节性变化。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   我们在图 28.4 中以一个示例结束本节，说明曲线也可以拟合非多项式函数。该曲线证实了气候变化的一个方面：二氧化碳（CO[2]）浓度在
    29 年的时间内稳步增加。线性和二次项模拟了年度增长，正弦和余弦项模拟了季节性变化。  输出：'
  type: TYPE_NORMAL
  zh: 我们在图 28.4 中以一个示例结束本节，说明曲线也可以拟合非多项式函数。该曲线证实了气候变化的一个方面：二氧化碳（`CO[2]`）浓度在 29 年的时间内稳步增加。线性和二次项模拟了年度增长，正弦和余弦项模拟了季节性变化。
- answer: '-   **`练习`**'
  en: '**练习**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **练习**  输出：'
  type: TYPE_NORMAL
  zh: '**`练习`**'
- answer: '-   ***28.3-1***'
  en: '***28.3-1***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28.3-1***  输出：'
  type: TYPE_NORMAL
  zh: '***28.3-1***'
- answer: '-   证明对称正定矩阵的每个对角元素都是正的。'
  en: 证明对称正定矩阵的每个对角元素都是正的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   证明对称正定矩阵的每个对角元素都是正的。  输出：'
  type: TYPE_NORMAL
  zh: 证明对称正定矩阵的每个对角元素都是正的。
- answer: '-   `28.3-2`'
  en: '***28.3-2***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28.3-2***  输出：'
  type: TYPE_NORMAL
  zh: '`28.3-2`'
- answer: '-   让`![art](img/Art_P966.jpg)`是一个 2×2 对称正定矩阵。通过“完成平方”证明其行列式`ac - b²`是正的，类似于引理
    28.5 的证明中使用的方法。'
  en: 让![art](img/Art_P966.jpg)是一个 2×2 对称正定矩阵。通过“完成平方”证明其行列式*ac* − *b*²是正的，类似于引理 28.5
    的证明中使用的方法。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   让![art](img/Art_P966.jpg)是一个
    2×2 对称正定矩阵。通过“完成平方”证明其行列式*ac* − *b*²是正的，类似于引理 28.5 的证明中使用的方法。  输出：'
  type: TYPE_NORMAL
  zh: 让`![art](img/Art_P966.jpg)`是一个 2×2 对称正定矩阵。通过“完成平方”证明其行列式`ac - b²`是正的，类似于引理 28.5
    的证明中使用的方法。
- answer: '-   ***28.3-3***'
  en: '***28.3-3***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28.3-3***  输出：'
  type: TYPE_NORMAL
  zh: '***28.3-3***'
- answer: '-   证明对称正定矩阵中的最大元素位于对角线上。'
  en: 证明对称正定矩阵中的最大元素位于对角线上。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   证明对称正定矩阵中的最大元素位于对角线上。  输出：'
  type: TYPE_NORMAL
  zh: 证明对称正定矩阵中的最大元素位于对角线上。
- answer: '-   `28.3-4`'
  en: '***28.3-4***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28.3-4***  输出：'
  type: TYPE_NORMAL
  zh: '`28.3-4`'
- answer: '-   证明对称正定矩阵的每个主导子矩阵的行列式都是正的。'
  en: 证明对称正定矩阵的每个主导子矩阵的行列式都是正的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   证明对称正定矩阵的每个主导子矩阵的行列式都是正的。  输出：'
  type: TYPE_NORMAL
  zh: 证明对称正定矩阵的每个主导子矩阵的行列式都是正的。
- answer: '-   `28.3-5`'
  en: '***28.3-5***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28.3-5***  输出：'
  type: TYPE_NORMAL
  zh: '`28.3-5`'
- answer: '-   让`A[k]`表示对称正定矩阵`A`的第`k`个主导子矩阵。证明 `det(A[k])/det(A[k−1])` 是 LU 分解过程中的第`k`个主元，按照惯例，`det(A[0])
    = 1`。'
  en: 让*A[k]*表示对称正定矩阵*A*的第*k*个主导子矩阵。证明 det(*A[k]*)/det(*A*[*k*−1])是 LU 分解过程中的第*k*个主元，按照惯例，det(*A*[0])
    = 1。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   让*A[k]*表示对称正定矩阵*A*的第*k*个主导子矩阵。证明
    det(*A[k]*)/det(*A*[*k*−1])是 LU 分解过程中的第*k*个主元，按照惯例，det(*A*[0]) = 1。  输出：'
  type: TYPE_NORMAL
  zh: 让`A[k]`表示对称正定矩阵`A`的第`k`个主导子矩阵。证明 `det(A[k])/det(A[k−1])` 是 LU 分解过程中的第`k`个主元，按照惯例，`det(A[0])
    = 1`。
- answer: '---

    -   ***28.3-6***

    ---'
  en: '***28.3-6***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28.3-6***  输出：'
  type: TYPE_NORMAL
  zh: '***28.3-6***'
- answer: '-   找到形式为'
  en: 找到形式为
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   找到形式为  输出：'
  type: TYPE_NORMAL
  zh: 找到形式为
- answer: '```

    -   `F(x) = c[1] + c[2]*x* lg x + c[3]*e^x`

    ```'
  en: '*F*(*x*) = *c*[1] + *c*[2]*x* lg *x* + *c*[3]*e^x*'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *F*(*x*) =
    *c*[1] + *c*[2]*x* lg *x* + *c*[3]*e^x*  输出：'
  type: TYPE_NORMAL
  zh: '`F(x) = c[1] + c[2]*x* lg x + c[3]*e^x`'
- answer: '-   这是对数据点的最佳最小二乘拟合'
  en: 这是对数据点的最佳最小二乘拟合
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   这是对数据点的最佳最小二乘拟合  输出：'
  type: TYPE_NORMAL
  zh: 这是对数据点的最佳最小二乘拟合
- answer: '-   `(1, 1), (2, 1), (3, 3), (4, 8)`。'
  en: (1, 1), (2, 1), (3, 3), (4, 8)。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   (1, 1), (2,
    1), (3, 3), (4, 8)。  输出：'
  type: TYPE_NORMAL
  zh: '`(1, 1), (2, 1), (3, 3), (4, 8)`。'
- answer: '-   `28.3-7`'
  en: '***28.3-7***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28.3-7***  输出：'
  type: TYPE_NORMAL
  zh: '`28.3-7`'
- answer: '---

    -   展示伪逆 `A^+` 满足以下四个方程：'
  en: 展示伪逆 *A*^+ 满足以下四个方���：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   展示伪逆 *A*^+
    满足以下四个方���：  输出：'
  type: TYPE_NORMAL
  zh: 展示伪逆 `A^+` 满足以下四个方程：
- answer: '-   | `AA`^+`A` | = | `A`, |  '
  en: '| *AA*^+*A* | = | *A*, |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *AA*^+*A*
    | = | *A*, |  输出：'
  type: TYPE_TB
  zh: '| `AA`^+`A` | = | `A`, |  '
- answer: '-   | --- | --- | --- |'
  en: '| --- | --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | --- | ---
    | --- |  输出：'
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- answer: '-   `| A^+AA^+ | = | A^+, |`'
  en: '| *A*^+*AA*^+ | = | *A*^+, |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *A*^+*AA*^+
    | = | *A*^+, |  输出：'
  type: TYPE_TB
  zh: '`| A^+AA^+ | = | A^+, |`'
- answer: '-   | `(*AA*^+)^T` | = | *AA*^+, |  '
  en: '| (*AA*^+)^T | = | *AA*^+, |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | (*AA*^+)^T
    | = | *AA*^+, |  输出：'
  type: TYPE_TB
  zh: '| `(*AA*^+)^T` | = | *AA*^+, |  '
- answer: '-   | `(*A*^+*A*)^T` | = | `*A*^+*A*`. |'
  en: '| (*A*^+*A*)^T | = | *A*^+*A*. |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | (*A*^+*A*)^T
    | = | *A*^+*A*. |  输出：'
  type: TYPE_TB
  zh: '| `(*A*^+*A*)^T` | = | `*A*^+*A*`. |'
- answer: '---

    -   **问题**

    ---'
  en: '**问题**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **问题**  输出：'
  type: TYPE_NORMAL
  zh: '**问题**'
- answer: '-   ***28-1     三对角线性方程组***  '
  en: '***28-1     三对角线性方程组***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28-1     三对角线性方程组***  输出：'
  type: TYPE_NORMAL
  zh: '***28-1     三对角线性方程组***  '
- answer: '-   考虑三对角矩阵'
  en: 考虑三对角矩阵
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   考虑三对角矩阵  输出：'
  type: TYPE_NORMAL
  zh: 考虑三对角矩阵
- answer: '---

    -   ![艺术](img/Art_P967.jpg)'
  en: '![艺术](img/Art_P967.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P967.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P967.jpg)'
- answer: '-   ***`a.`*** 找到 `A` 的 LU 分解。'
  en: '***a.*** 找到 *A* 的 LU 分解。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***a.*** 找到
    *A* 的 LU 分解。  输出：'
  type: TYPE_NORMAL
  zh: '***`a.`*** 找到 `A` 的 LU 分解。'
- answer: '-   ***b.*** 通过使用前向和后向替换解方程 `Ax = ( 1 1 1 1 1 )^T`。'
  en: '***b.*** 通过使用前向和后向替换解方程 *Ax* = ( 1 1 1 1 1 )^T。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***b.*** 通过使用前向和后向替换解方程
    *Ax* = ( 1 1 1 1 1 )^T。  输出：'
  type: TYPE_NORMAL
  zh: '***b.*** 通过使用前向和后向替换解方程 `Ax = ( 1 1 1 1 1 )^T`。'
- answer: '-   ***c.*** 找到 `A` 的逆。'
  en: '***c.*** 找到 *A* 的逆。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***c.*** 找到
    *A* 的逆。  输出：'
  type: TYPE_NORMAL
  zh: '***c.*** 找到 `A` 的逆。'
- answer: '-   ***d.*** 展示如何通过进行 LU 分解在 `O(n)` 时间内解方程 `Ax = b`，其中 `A` 是任意 `n` × `n`
    对称正定的三对角矩阵，`b` 是任意 `n` 维向量。论证基于形成 `A^(-1)` 的任何方法在最坏情况下都更昂贵。'
  en: '***d.*** 展示如何通过进行 LU 分解在 *O*(*n*) 时间内解方程 *Ax* = *b*，其中 *A* 是任意 *n* × *n* 对称正定的三对角矩阵，*b*
    是任意 *n* 维向量。论证基于形成 *A*^(−1) 的任何方法在最坏情况下都更昂贵。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***d.*** 展示如何通过进行
    LU 分解在 *O*(*n*) 时间内解方程 *Ax* = *b*，其中 *A* 是任意 *n* × *n* 对称正定的三对角矩阵，*b* 是任意 *n*
    维向量。论证基于形成 *A*^(−1) 的任何方法在最坏情况下都更昂贵。  输出：'
  type: TYPE_NORMAL
  zh: '***d.*** 展示如何通过进行 LU 分解在 `O(n)` 时间内解方程 `Ax = b`，其中 `A` 是任意 `n` × `n` 对称正定的三对角矩阵，`b`
    是任意 `n` 维向量。论证基于形成 `A^(-1)` 的任何方法在最坏情况下都更昂贵。'
- answer: '-   ***e.*** 展示如何通过进行 LUP 分解在 `O(n)` 时间内解方程 `Ax = b`，其中 `A` 是任意 `n` × `n`
    非奇异的三对角矩阵，`b` 是任意 `n` 维向量。'
  en: '***e.*** 展示如何通过进行 LUP 分解在 *O*(*n*) 时间内解方程 *Ax* = *b*，其中 *A* 是任意 *n* × *n* 非奇异的三对角矩阵，*b*
    是任意 *n* 维向量。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***e.*** 展示如何通过进行
    LUP 分解在 *O*(*n*) 时间内解方程 *Ax* = *b*，其中 *A* 是任意 *n* × *n* 非奇异的三对角矩阵，*b* 是任意 *n*
    维向量。  输出：'
  type: TYPE_NORMAL
  zh: '***e.*** 展示如何通过进行 LUP 分解在 `O(n)` 时间内解方程 `Ax = b`，其中 `A` 是任意 `n` × `n` 非奇异的三对角矩阵，`b`
    是任意 `n` 维向量。'
- answer: '---

    -   ***28-2     样条***


    ---'
  en: '***28-2     样条***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***28-2     样条***  输出：'
  type: TYPE_NORMAL
  zh: '***28-2     样条***'
- answer: '-   用`***三次样条***`插值一组点的实用方法是使用。给定一组点值对 `{(x[i], y[i]) : i = 0, 1, … , n}`，其中
    `x[0] < x[1] < ⋯ < x[n]`。你的目标是拟合一条分段三次曲线（样条）`f(x)`到这些点。也就是说，曲线 `f(x)` 由 `n` 个三次多项式
    `f[i](x) = a[i] + b[i]x + c[i]x² + d[i]x³` 组成，其中如果 `x` 落在 `x[i] ≤ x ≤ x[i+1]`
    的范围内，则曲线的值由 `f(x) = f[i](x − x[i])` 给出。将三次多项式“粘合”在一起的点 `x[i]` 称为**`结点`**。为简单起见，假设
    `x[i] = i` 对于 `i = 0, 1, … , n`。'
  en: '用***三次样条***插值一组点的实用方法是使用。给定一组点值对 {(*x[i]*, *y[i]*) : *i* = 0, 1, … , *n*}，其中
    *x*[0] < *x*[1] < ⋯ < *x[n]*。你的目标是拟合一条分段三次曲线（样条）*f*(*x*)到这些点。也就是说，曲线 *f*(*x*)
    由 *n* 个三次多项式 *f[i]*(*x*) = *a[i]* + *b[i]x* + *c*[*i*]*x*² + *d*[*i*]*x*³ 组成，其中如果
    *x* 落在 *x[i]* ≤ *x* ≤ *x*[*i*+1] 的范围内，则曲线的值由 *f*(*x*) = *f[i]*(*x* − *x[i]*) 给出。将三次多项式“粘合”在一起的点
    *x[i]* 称为***结点***。为简单起见，假设 *x[i]* = *i* 对于 *i* = 0, 1, … , *n*。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   用***三次样条***插值一组点的实用方法是使用。给定一组点值对
    {(*x[i]*, *y[i]*) : *i* = 0, 1, … , *n*}，其中 *x*[0] < *x*[1] < ⋯ < *x[n]*。你的目标是拟合一条分段三次曲线（样条）*f*(*x*)到这些点。也就是说，曲线
    *f*(*x*) 由 *n* 个三次多项式 *f[i]*(*x*) = *a[i]* + *b[i]x* + *c*[*i*]*x*² + *d*[*i*]*x*³
    组成，其中如果 *x* 落在 *x[i]* ≤ *x* ≤ *x*[*i*+1] 的范围内，则曲线的值由 *f*(*x*) = *f[i]*(*x* − *x[i]*)
    给出。将三次多项式“粘合”在一起的点 *x[i]* 称为***结点***。为简单起见，假设 *x[i]* = *i* 对于 *i* = 0, 1, … ,
    *n*。  输出：'
  type: TYPE_NORMAL
  zh: '用`***三次样条***`插值一组点的实用方法是使用。给定一组点值对 `{(x[i], y[i]) : i = 0, 1, … , n}`，其中 `x[0]
    < x[1] < ⋯ < x[n]`。你的目标是拟合一条分段三次曲线（样条）`f(x)`到这些点。也就是说，曲线 `f(x)` 由 `n` 个三次多项式 `f[i](x)
    = a[i] + b[i]x + c[i]x² + d[i]x³` 组成，其中如果 `x` 落在 `x[i] ≤ x ≤ x[i+1]` 的范围内，则曲线的值由
    `f(x) = f[i](x − x[i])` 给出。将三次多项式“粘合”在一起的点 `x[i]` 称为**`结点`**。为简单起见，假设 `x[i] =
    i` 对于 `i = 0, 1, … , n`。'
- answer: '-   为了确保 `f(x)` 的连续性，要求'
  en: 为了确保 *f*(*x*) 的连续性，要求
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   为了确保 *f*(*x*)
    的连续性，要求  输出：'
  type: TYPE_NORMAL
  zh: 为了确保 `f(x)` 的连续性，要求
- answer: '-   | `f(x[i])` | = | `f[i](0 | = | `y[i]`, |  '
  en: '| *f*(*x[i]*) | = | *f[i]*(0) | = | *y[i]*, |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *f*(*x[i]*)
    | = | *f[i]*(0) | = | *y[i]*, |  输出：'
  type: TYPE_TB
  zh: '| `f(x[i])` | = | `f[i](0 | = | `y[i]`, |  '
- answer: '-   | --- | --- | --- | --- | --- |'
  en: '| --- | --- | --- | --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。


    ## 要求


    +   将公式使用内联代码符号（`...`）包围，其它文本原样输出

    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分

    +   输入可能有多行，不要遗漏其中任何一行

    +   输出的每一行前面需要有分隔符（-   ），不然我无法处理



    ## 示例


    输入：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。



    输出：


    -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆
    V`，使得如果`(u, v)`是`G`的一条边，则`u ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。

    -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。

    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。


    ## 需要排版的段落


    输入：


    -   | --- | --- | --- | --- | --- |


    输出：

    '
  type: TYPE_TB
  zh: '| --- | --- | --- | --- | --- |'
- answer: '-   | `f(x[i+1])` | = | `f[i](1 | = | `y[i+1]` |  '
  en: '| *f*(*x*[*i*+1]) | = | *f[i]*(1) | = | *y*[*i*+1] |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *f*(*x*[*i*+1])
    | = | *f[i]*(1) | = | *y*[*i*+1] |  输出：'
  type: TYPE_TB
  zh: '| `f(x[i+1])` | = | `f[i](1 | = | `y[i+1]` |  '
- answer: '-   对于 `i = 0, 1, … , n - 1`. 为了确保 `f(x)` 充分平滑，还要求一阶导数在每个结点处连续：'
  en: 对于 *i* = 0, 1, … , *n* − 1\. 为了确保 *f*(*x*) 充分平滑，还要求一阶导数在每个结点处连续：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于 *i* = 0,
    1, … , *n* − 1\. 为了确保 *f*(*x*) 充分平滑，还要求一阶导数在每个结点处连续：  输出：'
  type: TYPE_NORMAL
  zh: 对于 `i = 0, 1, … , n - 1`. 为了确保 `f(x)` 充分平滑，还要求一阶导数在每个结点处连续：
- answer: '```

    -   ![艺术](img/Art_P968.jpg)

    ```'
  en: '![艺术](img/Art_P968.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P968.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P968.jpg)'
- answer: '-   对于 `i = 0, 1, … , n - 2`。'
  en: 对于 *i* = 0, 1, … , *n* − 2。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于 *i* = 0,
    1, … , *n* − 2。  输出：'
  type: TYPE_NORMAL
  zh: 对于 `i = 0, 1, … , n - 2`。
- answer: '-   ***a.*** 假设对于 `i` = 0, 1, … , `n`，除了点值对 {(`x[i]`, `y[i]`)} 外，还给出了每个结点处的一阶导数
    `D[i]` = `f′(x[i])`。用 `y[i]`、`y[i+1]`、`D[i]` 和 `D[i+1]` 的值表示每个系数 `a[i]`、`b[i]`、`c[i]`
    和 `d[i]`。你能多快地从点值对和一阶导数计算出 4*n* 个系数？'
  en: '***a.*** 假设对于 *i* = 0, 1, … , *n*，除了点值对 {(*x[i]*, *y[i]*)} 外，还给出了每个结点处的一阶导数
    *D[i]* = *f*′(*x[i]*)。用 *y[i]*、*y*[*i*+1]、*D[i]* 和 *D*[*i*+1] 的值表示每个系数 *a[i]*、*b[i]*、*c[i]*
    和 *d[i]*。你能多快地从点值对和一阶导数计算出 4*n* 个系数？'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***a.*** 假设对于
    *i* = 0, 1, … , *n*，除了点值对 {(*x[i]*, *y[i]*)} 外，还给出了每个结点处的一阶导数 *D[i]* = *f*′(*x[i]*)。用
    *y[i]*、*y*[*i*+1]、*D[i]* 和 *D*[*i*+1] 的值表示每个系数 *a[i]*、*b[i]*、*c[i]* 和 *d[i]*。你能多快地从点值对和一阶导数计算出
    4*n* 个系数？  输出：'
  type: TYPE_NORMAL
  zh: '***a.*** 假设对于 `i` = 0, 1, … , `n`，除了点值对 {(`x[i]`, `y[i]`)} 外，还给出了每个结点处的一阶导数
    `D[i]` = `f′(x[i])`。用 `y[i]`、`y[i+1]`、`D[i]` 和 `D[i+1]` 的值表示每个系数 `a[i]`、`b[i]`、`c[i]`
    和 `d[i]`。你能多快地从点值对和一阶导数计算出 4*n* 个系数？'
- answer: '```

    -   问题在于如何选择结点处 `f(x)` 的一阶导数。一种方法是要求结点处的二阶导数连续：

    ```'
  en: 问题在于如何选择结点处 *f*(*x*) 的一阶导数。一种方法是要求结点处的二阶导数连续：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   问题在于如何选择结点处
    *f*(*x*) 的一阶导数。一种方法是要求结点处的二阶导数连续：  输出：'
  type: TYPE_NORMAL
  zh: 问题在于如何选择结点处 `f(x)` 的一阶导数。一种方法是要求结点处的二阶导数连续：
- answer: '```

    -   ![艺术](img/Art_P969.jpg)

    ```'
  en: '![艺术](img/Art_P969.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P969.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P969.jpg)'
- answer: '-   对于 `i = 0, 1, … , n−2`. 在第一个和最后一个结点处，假设 ![艺术](img/Art_P970.jpg) 和 ![艺术](img/Art_P971.jpg)。这些假设使得
    `f(x)` 成为一个***自然***三次样条。'
  en: 对于 *i* = 0, 1, … , *n*−2\. 在第一个和最后一个结点处，假设 ![艺术](img/Art_P970.jpg) 和 ![艺术](img/Art_P971.jpg)。这些假设使得
    *f*(*x*) 成为一个***自然***三次样条。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于 *i* = 0,
    1, … , *n*−2\. 在第一个和最后一个结点处，假设 ![艺术](img/Art_P970.jpg) 和 ![艺术](img/Art_P971.jpg)。这些假设使得
    *f*(*x*) 成为一个***自然***三次样条。  输出：'
  type: TYPE_NORMAL
  zh: 对于 `i = 0, 1, … , n−2`. 在第一个和最后一个结点处，假设 ![艺术](img/Art_P970.jpg) 和 ![艺术](img/Art_P971.jpg)。这些假设使得
    `f(x)` 成为一个***自然***三次样条。
- answer: '-   ***b.*** 利用二阶导数的连续性约束，证明对于 `i = 1, 2, … , n - 1`，'
  en: '***b.*** 利用二阶导数的连续性约束，证明对于 *i* = 1, 2, … , *n* − 1，'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***b.*** 利用二阶导数的连续性约束，证明对于
    *i* = 1, 2, … , *n* − 1，  输出：'
  type: TYPE_NORMAL
  zh: '***b.*** 利用二阶导数的连续性约束，证明对于 `i = 1, 2, … , n - 1`，'
- answer: '---

    -   ![艺术](img/Art_P972.jpg)'
  en: '![艺术](img/Art_P972.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P972.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P972.jpg)'
- answer: '---

    -   ***c.*** 展示'
  en: '***c.*** 展示'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***c.*** 展示  输出：'
  type: TYPE_NORMAL
  zh: '***c.*** 展示'
- answer: '---

    -   `![艺术](img/Art_P973.jpg)`'
  en: '![艺术](img/Art_P973.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P973.jpg)  输出：'
  type: TYPE_IMG
  zh: '`![艺术](img/Art_P973.jpg)`'
- answer: '-   ***d.*** 将方程`（28.23）`–`（28.25）`重写为涉及未知向量 `D = (D[0] D[1] D[2] ⋯ D[n])^T`
    的矩阵方程。你的方程中的矩阵具有什么属性？'
  en: '***d.*** 将方程（28.23）–（28.25）重写为涉及未知向量 *D* = (*D*[0] *D*[1] *D*[2] ⋯ *D[n]*)^T
    的矩阵方程。你的方程中的矩阵具有什么属性？'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***d.*** 将方程（28.23）–（28.25）重写为涉及未知向量
    *D* = (*D*[0] *D*[1] *D*[2] ⋯ *D[n]*)^T 的矩阵方程。你的方程中的矩阵具有什么属性？  输出：'
  type: TYPE_NORMAL
  zh: '***d.*** 将方程`（28.23）`–`（28.25）`重写为涉及未知向量 `D = (D[0] D[1] D[2] ⋯ D[n])^T` 的矩阵方程。你的方程中的矩阵具有什么属性？'
- answer: '---

    -   ***e.*** 论证自然三次样条可以在 `O(n)` 时间内插值一组 `n` + 1 点值对（参见问题 28-1）。'
  en: '***e.*** 论证自然三次样条可以在 *O*(*n*) 时间内插值一组 *n* + 1 点值对（参见问题 28-1）。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***e.*** 论证自然三次样条可以在
    *O*(*n*) 时间内插值一组 *n* + 1 点值对（参见问题 28-1）。  输出：'
  type: TYPE_NORMAL
  zh: '***e.*** 论证自然三次样条可以在 `O(n)` 时间内插值一组 `n` + 1 点值对（参见问题 28-1）。'
- answer: '-   ***f.*** 展示如何确定一个自然三次样条，插值一组满足 `x[0] < x[1] < ⋯ < x[n]` 的 `n` + 1 点
    `(x[i], y[i])`，即使 `x[i]` 不一定等于 `i`。你的方法必须解决什么矩阵方程，你的算法运行多快？  '
  en: '***f.*** 展示如何确定一个自然三次样条，插值一组满足 *x*[0] < *x*[1] < ⋯ < *x[n]* 的 *n* + 1 点 (*x[i]*,
    *y[i]*)，即使 *x[i]* 不一定等于 *i*。你的方法必须解决什么矩阵方程，你的算法运行多快？'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***f.*** 展示如何确定一个自然三次样条，插值一组满足
    *x*[0] < *x*[1] < ⋯ < *x[n]* 的 *n* + 1 点 (*x[i]*, *y[i]*)，即使 *x[i]* 不一定等于 *i*。你的方法必须解决什么矩阵方程，你的算法运行多快？  输出：'
  type: TYPE_NORMAL
  zh: '***f.*** 展示如何确定一个自然三次样条，插值一组满足 `x[0] < x[1] < ⋯ < x[n]` 的 `n` + 1 点 `(x[i],
    y[i])`，即使 `x[i]` 不一定等于 `i`。你的方法必须解决什么矩阵方程，你的算法运行多快？  '
- answer: '-   `章节注释`'
  en: '**章节注释**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **章节注释**  输出：'
  type: TYPE_NORMAL
  zh: '`章节注释`'
- answer: '-   许多优秀的文本详细描述了数值和科学计算，比我们在这里有空间描述的要多得多。特别易读的有：George 和 Liu `180`, Golub
    和 Van Loan `192`, Press, Teukolsky, Vetterling, 和 Flannery `365, 366`, 以及 Strang
    `422, 423`。'
  en: 许多优秀的文本详细描述了数值和科学计算，比我们在这里有空间描述的要多得多。特别易读的有：George 和 Liu [180], Golub 和 Van
    Loan [192], Press, Teukolsky, Vetterling, 和 Flannery [365, 366], 以及 Strang [422,
    423]。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   许多优秀的文本详细描述了数值和科学计算，比我们在这里有空间描述的要多得多。特别易读的有：George
    和 Liu [180], Golub 和 Van Loan [192], Press, Teukolsky, Vetterling, 和 Flannery
    [365, 366], 以及 Strang [422, 423]。  输出：'
  type: TYPE_NORMAL
  zh: 许多优秀的文本详细描述了数值和科学计算，比我们在这里有空间描述的要多得多。特别易读的有：George 和 Liu `180`, Golub 和 Van
    Loan `192`, Press, Teukolsky, Vetterling, 和 Flannery `365, 366`, 以及 Strang `422,
    423`。
- answer: '-   Golub 和 Van Loan [192] 讨论了数值稳定性。他们解释了为什么 det(`A`) 不一定是矩阵 `A` 稳定性的好指标，而建议使用
    ∥`A`∥[∞] ∥`A`^(−1)∥[∞]，其中 ![art](img/Art_P974.jpg)。他们还讨论了如何计算这个值而不实际计算 `A`^(−1)。'
  en: Golub 和 Van Loan [192] 讨论了数值稳定性。他们解释了为什么 det(*A*) 不一定是矩阵 *A* 稳定性的好指标，而建议使用 ∥*A*∥[∞]
    ∥*A*^(−1)∥[∞]，其中 ![art](img/Art_P974.jpg)。他们还讨论了如何计算这个值而不实际计算 *A*^(−1)。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   Golub 和 Van
    Loan [192] 讨论了数值稳定性。他们解释了为什么 det(*A*) 不一定是矩阵 *A* 稳定性的好指标，而建议使用 ∥*A*∥[∞] ∥*A*^(−1)∥[∞]，其中
    ![art](img/Art_P974.jpg)。他们还讨论了如何计算这个值而不实际计算 *A*^(−1)。  输出：'
  type: TYPE_NORMAL
  zh: Golub 和 Van Loan [192] 讨论了数值稳定性。他们解释了为什么 det(`A`) 不一定是矩阵 `A` 稳定性的好指标，而建议使用 ∥`A`∥[∞]
    ∥`A`^(−1)∥[∞]，其中 ![art](img/Art_P974.jpg)。他们还讨论了如何计算这个值而不实际计算 `A`^(−1)。
- answer: '-   高斯消元法是 LU 和 LUP 分解的基础，是解线性方程组的第一个系统方法。它也是最早的数值算法之一。尽管它早在此前就已知晓，但其发现通常归功于
    C. F. Gauss (1777–1855)。在他著名的论文 [424] 中，Strassen 表明一个 `n`×`n` 矩阵可以在 `O(n^(lg 7))`
    的时间内求逆。Winograd [460] 最初证明矩阵乘法不比矩阵求逆更困难，而 Aho, Hopcroft, 和 Ullman [5] 则证明了反之。  '
  en: 高斯消元法是 LU 和 LUP 分解的基础，是解线性方程组的第一个系统方法。它也是最早的数值算法之一。尽管它早在此前就已知晓，但其发现通常归功于 C.
    F. Gauss (1777–1855)。在他著名的论文 [424] 中，Strassen 表明一个 *n*×*n* 矩阵可以在 *O*(*n*^(lg 7))
    的时间内求逆。Winograd [460] 最初证明矩阵乘法不比矩阵求逆更困难，而 Aho, Hopcroft, 和 Ullman [5] 则证明了反之。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   高斯消元法是 LU 和
    LUP 分解的基础，是解线性方程组的第一个系统方法。它也是最早的数值算法之一。尽管它早在此前就已知晓，但其发现通常归功于 C. F. Gauss (1777–1855)。在他著名的论文
    [424] 中，Strassen 表明一个 *n*×*n* 矩阵可以在 *O*(*n*^(lg 7)) 的时间内求逆。Winograd [460] 最初证明矩阵乘法不比矩阵求逆更困难，而
    Aho, Hopcroft, 和 Ullman [5] 则证明了反之。  输出：'
  type: TYPE_NORMAL
  zh: '高斯消元法是 LU 和 LUP 分解的基础，是解线性方程组的第一个系统方法。它也是最早的数值算法之一。尽管它早在此前就已知晓，但其发现通常归功于 C.
    F. Gauss (1777–1855)。在他著名的论文 [424] 中，Strassen 表明一个 `n`×`n` 矩阵可以在 `O(n^(lg 7))`
    的时间内求逆。Winograd [460] 最初证明矩阵乘法不比矩阵求逆更困难，而 Aho, Hopcroft, 和 Ullman [5] 则证明了反之。  '
- answer: '-   另一个重要的矩阵分解是`奇异值分解`，或`SVD`。SVD 将一个 *m* × *n* 矩阵 *A* 分解为 `![art](img/Art_P975.jpg)`，其中
    Σ 是一个只在对角线上有非零值的 *m*×*n* 矩阵，`Q[1]` 是 *m*×*m*，具有相互正交列的矩阵，`Q[2]` 是 *n* × *n*，同样具有相互正交列。如果两个向量的内积为
    0，且每个向量的范数为 1，则这两个向量是`正交归一`的。Strang [422, 423] 和 Golub 和 Van Loan [192] 的书中都有关于
    SVD 的良好讨论。'
  en: 另一个重要的矩阵分解是***奇异值分解***，或***SVD***。SVD 将一个 *m* × *n* 矩阵 *A* 分解为 ![art](img/Art_P975.jpg)，其中
    Σ 是一个只在对角线上有非零值的 *m*×*n* 矩阵，*Q*[1] 是 *m*×*m*，具有相互正交列的矩阵，*Q*[2] 是 *n* × *n*，同样具有相互正交列。如果两个向量的内积为
    0，且每个向量的范数为 1，则这两个向量是***正交归一***的。Strang [422, 423] 和 Golub 和 Van Loan [192] 的书中都有关于
    SVD 的良好讨论。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   另一个重要的矩阵分解是***奇异值分解***，或***SVD***。SVD
    将一个 *m* × *n* 矩阵 *A* 分解为 ![art](img/Art_P975.jpg)，其中 Σ 是一个只在对角线上有非零值的 *m*×*n*
    矩阵，*Q*[1] 是 *m*×*m*，具有相互正交列的矩阵，*Q*[2] 是 *n* × *n*，同样具有相互正交列。如果两个向量的内积为 0，且每个向量的范数为
    1，则这两个向量是***正交归一***的。Strang [422, 423] 和 Golub 和 Van Loan [192] 的书中都有关于 SVD 的良好讨论。  输出：'
  type: TYPE_NORMAL
  zh: 另一个重要的矩阵分解是`奇异值分解`，或`SVD`。SVD 将一个 *m* × *n* 矩阵 *A* 分解为 `![art](img/Art_P975.jpg)`，其中
    Σ 是一个只在对角线上有非零值的 *m*×*n* 矩阵，`Q[1]` 是 *m*×*m*，具有相互正交列的矩阵，`Q[2]` 是 *n* × *n*，同样具有相互正交列。如果两个向量的内积为
    0，且每个向量的范数为 1，则这两个向量是`正交归一`的。Strang [422, 423] 和 Golub 和 Van Loan [192] 的书中都有关于
    SVD 的良好讨论。
- answer: '-   Strang [423] 对对称正定矩阵和线性代数有出色的介绍。'
  en: Strang [423] 对对称正定矩阵和线性代数有出色的介绍。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   Strang [423]
    对对称正定矩阵和线性代数有出色的介绍。  输出：'
  type: TYPE_NORMAL
  zh: Strang [423] 对对称正定矩阵和线性代数有出色的介绍。
- answer: '-   ¹ *算法导论* 首次出版的年份。'
  en: ¹ *算法导论* 首次出版的年份。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ¹ *算法导论* 首次出版的年份。  输出：'
  type: TYPE_NORMAL
  zh: ¹ *算法导论* 首次出版的年份。
