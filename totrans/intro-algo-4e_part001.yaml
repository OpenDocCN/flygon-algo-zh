- en: '[***Part I    Foundations***](toc.xhtml#part-1)'
  prefs: []
  type: TYPE_NORMAL
- en: '[**Introduction**](toc.xhtml#Rh1-1)'
  prefs: []
  type: TYPE_NORMAL
- en: When you design and analyze algorithms, you need to be able to describe how
    they operate and how to design them. You also need some mathematical tools to
    show that your algorithms do the right thing and do it efficiently. This part
    will get you started. Later parts of this book will build upon this base.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1](chapter001.xhtml) provides an overview of algorithms and their
    place in modern computing systems. This chapter defines what an algorithm is and
    lists some examples. It also makes a case for considering algorithms as a technology,
    alongside technologies such as fast hardware, graphical user interfaces, object-oriented
    systems, and networks.'
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](chapter002.xhtml), we see our first algorithms, which solve the
    problem of sorting a sequence of *n* numbers. They are written in a pseudocode
    which, although not directly translatable to any conventional programming language,
    conveys the structure of the algorithm clearly enough that you should be able
    to implement it in the language of your choice. The sorting algorithms we examine
    are insertion sort, which uses an incremental approach, and merge sort, which
    uses a recursive technique known as “divide-and-conquer.” Although the time each
    requires increases with the value of *n*, the rate of increase differs between
    the two algorithms. We determine these running times in [Chapter 2](chapter002.xhtml),
    and we develop a useful “asymptotic” notation to express them.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 3](chapter003.xhtml) precisely defines asymptotic notation. We’ll
    use asymptotic notation to bound the growth of functions—most often, functions
    that describe the running time of algorithms—from above and below. The chapter
    starts by informally defining the most commonly used asymptotic notations and
    giving an example of how to apply them. It then formally defines five asymptotic
    notations and presents conventions for how to put them together. The rest of [Chapter
    3](chapter003.xhtml) is primarily a presentation of mathematical notation, more
    to ensure that your use of notation matches that in this book than to teach you
    new mathematical concepts.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 4](chapter004.xhtml) delves further into the divide-and-conquer method
    introduced in [Chapter 2](chapter002.xhtml). It provides two additional examples
    of divide-and-conquer algorithms for multiplying square matrices, including Strassen’s
    surprising method. [Chapter 4](chapter004.xhtml) contains methods for solving
    recurrences, which are useful for describing the running times of recursive algorithms.
    In the substitution method, you guess an answer and prove it correct. Recursion
    trees provide one way to generate a guess. [Chapter 4](chapter004.xhtml) also
    presents the powerful technique of the “master method,” which you can often use
    to solve recurrences that arise from divide-and-conquer algorithms. Although the
    chapter provides a proof of a foundational theorem on which the master theorem
    depends, you should feel free to employ the master method without delving into
    the proof. [Chapter 4](chapter004.xhtml) concludes with some advanced topics.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 5](chapter005.xhtml) introduces probabilistic analysis and randomized
    algorithms. You typically use probabilistic analysis to determine the running
    time of an algorithm in cases in which, due to the presence of an inherent probability
    distribution, the running time may differ on different inputs of the same size.
    In some cases, you might assume that the inputs conform to a known probability
    distribution, so that you are averaging the running time over all possible inputs.
    In other cases, the probability distribution comes not from the inputs but from
    random choices made during the course of the algorithm. An algorithm whose behavior
    is determined not only by its input but by the values produced by a random-number
    generator is a randomized algorithm. You can use randomized algorithms to enforce
    a probability distribution on the inputs—thereby ensuring that no particular input
    always causes poor performance—or even to bound the error rate of algorithms that
    are allowed to produce incorrect results on a limited basis.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Appendices A](appendix001.xhtml)–[D](appendix004.xhtml) contain other mathematical
    material that you will find helpful as you read this book. You might have seen
    much of the material in the appendix chapters before having read this book (although
    the specific definitions and notational conventions we use may differ in some
    cases from what you have seen in the past), and so you should think of the appendices
    as reference material. On the other hand, you probably have not already seen most
    of the material in Part I. All the chapters in Part I and the appendices are written
    with a tutorial flavor.'
  prefs: []
  type: TYPE_NORMAL
