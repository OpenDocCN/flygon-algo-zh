- en: '[***Part II    Sorting and Order Statistics***](toc.xhtml#part-2)'
  prefs: []
  type: TYPE_NORMAL
- en: '[**Introduction**](toc.xhtml#Rh1-31)'
  prefs: []
  type: TYPE_NORMAL
- en: 'This part presents several algorithms that solve the following ***sorting problem***:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Input:** A sequence of *n* numbers 〈*a*[1], *a*[2], … , *a[n]*〉.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Output:** A permutation (reordering) ![art](images/Art_P297a.jpg) of the
    input sequence such that ![art](images/Art_P297b.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: The input sequence is usually an *n*-element array, although it may be represented
    in some other fashion, such as a linked list.
  prefs: []
  type: TYPE_NORMAL
- en: '**The structure of the data**'
  prefs: []
  type: TYPE_NORMAL
- en: In practice, the numbers to be sorted are rarely isolated values. Each is usually
    part of a collection of data called a ***record***. Each record contains a ***key***,
    which is the value to be sorted. The remainder of the record consists of ***satellite
    data***, which are usually carried around with the key. In practice, when a sorting
    algorithm permutes the keys, it must permute the satellite data as well. If each
    record includes a large amount of satellite data, it often pays to permute an
    array of pointers to the records rather than the records themselves in order to
    minimize data movement.
  prefs: []
  type: TYPE_NORMAL
- en: In a sense, it is these implementation details that distinguish an algorithm
    from a full-blown program. A sorting algorithm describes the *method* to determine
    the sorted order, regardless of whether what’s being sorted are individual numbers
    or large records containing many bytes of satellite data. Thus, when focusing
    on the problem of sorting, we typically assume that the input consists only of
    numbers. Translating an algorithm for sorting numbers into a program for sorting
    records is conceptually straightforward, although in a given engineering situation
    other subtleties may make the actual programming task a challenge.
  prefs: []
  type: TYPE_NORMAL
- en: '**Why sorting?**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Many computer scientists consider sorting to be the most fundamental problem
    in the study of algorithms. There are several reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes an application inherently needs to sort information. For example,
    in order to prepare customer statements, banks need to sort checks by check number.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Algorithms often use sorting as a key subroutine. For example, a program that
    renders graphical objects which are layered on top of each other might have to
    sort the objects according to an “above” relation so that it can draw these objects
    from bottom to top. We will see numerous algorithms in this text that use sorting
    as a subroutine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can draw from among a wide variety of sorting algorithms, and they employ
    a rich set of techniques. In fact, many important techniques used throughout algorithm
    design appear in sorting algorithms that have been developed over the years. In
    this way, sorting is also a problem of historical interest.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can prove a nontrivial lower bound for sorting (as we’ll do in [Chapter 8](chapter008.xhtml)).
    Since the best upper bounds match the lower bound asymptotically, we can conclude
    that certain of our sorting algorithms are asymptotically optimal. Moreover, we
    can use the lower bound for sorting to prove lower bounds for various other problems.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Many engineering issues come to the fore when implementing sorting algorithms.
    The fastest sorting program for a particular situation may depend on many factors,
    such as prior knowledge about the keys and satellite data, the memory hierarchy
    (caches and virtual memory) of the host computer, and the software environment.
    Many of these issues are best dealt with at the algorithmic level, rather than
    by “tweaking” the code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sorting algorithms**'
  prefs: []
  type: TYPE_NORMAL
- en: We introduced two algorithms that sort *n* real numbers in [Chapter 2](chapter002.xhtml).
    Insertion sort takes Θ(*n*²) time in the worst case. Because its inner loops are
    tight, however, it is a fast sorting algorithm for small input sizes. Moreover,
    unlike merge sort, it sorts ***in place***, meaning that at most a constant number
    of elements of the input array are ever stored outside the array, which can be
    advantageous for space efficiency. Merge sort has a better asymptotic running
    time, Θ(*n* lg *n*), but the MERGE procedure it uses does not operate in place.
    (We’ll see a parallelized version of merge sort in [Section 26.3](chapter026.xhtml#Sec_26.3).)
  prefs: []
  type: TYPE_NORMAL
- en: This part introduces two more algorithms that sort arbitrary real numbers. Heapsort,
    presented in [Chapter 6](chapter006.xhtml), sorts *n* numbers in place in *O*(*n*
    lg *n*) time. It uses an important data structure, called a heap, which can also
    implement a priority queue.
  prefs: []
  type: TYPE_NORMAL
- en: Quicksort, in [Chapter 7](chapter007.xhtml), also sorts *n* numbers in place,
    but its worst-case running time is Θ(*n*²). Its expected running time is Θ(*n*
    lg *n*), however, and it generally outperforms heapsort in practice. Like insertion
    sort, quicksort has tight code, and so the hidden constant factor in its running
    time is small. It is a popular algorithm for sorting large arrays.
  prefs: []
  type: TYPE_NORMAL
- en: 'Insertion sort, merge sort, heapsort, and quicksort are all comparison sorts:
    they determine the sorted order of an input array by comparing elements. [Chapter
    8](chapter008.xhtml) begins by introducing the decision-tree model in order to
    study the performance limitations of comparison sorts. Using this model, we prove
    a lower bound of Ω(*n* lg *n*) on the worst-case running time of any comparison
    sort on *n* inputs, thus showing that heapsort and merge sort are asymptotically
    optimal comparison sorts.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 8](chapter008.xhtml) then goes on to show that we might be able to
    beat this lower bound of Ω(*n* lg *n*) if an algorithm can gather information
    about the sorted order of the input by means other than comparing elements. The
    counting sort algorithm, for example, assumes that the input numbers belong to
    the set {0, 1, … , *k*}. By using array indexing as a tool for determining relative
    order, counting sort can sort *n* numbers in Θ(*k* + *n*) time. Thus, when *k*
    = *O*(*n*), counting sort runs in time that is linear in the size of the input
    array. A related algorithm, radix sort, can be used to extend the range of counting
    sort. If there are *n* integers to sort, each integer has *d* digits, and each
    digit can take on up to *k* possible values, then radix sort can sort the numbers
    in Θ(*d*(*n* + *k*)) time. When *d* is a constant and *k* is *O*(*n*), radix sort
    runs in linear time. A third algorithm, bucket sort, requires knowledge of the
    probabilistic distribution of numbers in the input array. It can sort *n* real
    numbers uniformly distributed in the half-open interval [0, 1) in average-case
    *O*(*n*) time.'
  prefs: []
  type: TYPE_NORMAL
- en: The table on the following page summarizes the running times of the sorting
    algorithms from [Chapters 2](chapter002.xhtml) and [6](chapter006.xhtml)–[8](chapter008.xhtml).
    As usual, *n* denotes the number of items to sort. For counting sort, the items
    to sort are integers in the set {0, 1, … , *k*}. For radix sort, each item is
    a *d*-digit number, where each digit takes on *k* possible values. For bucket
    sort, we assume that the keys are real numbers uniformly distributed in the half-open
    interval [0, 1). The rightmost column gives the average-case or expected running
    time, indicating which one it gives when it differs from the worst-case running
    time. We omit the average-case running time of heapsort because we do not analyze
    it in this book.
  prefs: []
  type: TYPE_NORMAL
- en: '| Algorithm | Worst-case running time | Average-case/expected running time
    |'
  prefs: []
  type: TYPE_TB
- en: '| Insertion sort | Θ(*n*²) | Θ(*n*²) |'
  prefs: []
  type: TYPE_TB
- en: '| Merge sort | Θ(*n* lg *n*) | Θ(*n* lg *n*) |'
  prefs: []
  type: TYPE_TB
- en: '| Heapsort | *O*(*n* lg *n*) | — |'
  prefs: []
  type: TYPE_TB
- en: '| Quicksort | Θ(*n*²) | Θ(*n* lg *n*) (expected) |'
  prefs: []
  type: TYPE_TB
- en: '| Counting sort | Θ(*k* + *n*) | Θ(*k* + *n*) |'
  prefs: []
  type: TYPE_TB
- en: '| Radix sort | Θ(*d*(*n* + *k*)) | Θ(*d*(*n* + *k*)) |'
  prefs: []
  type: TYPE_TB
- en: '| Bucket sort | Θ(*n*²) | Θ(*n*) (average-case) |'
  prefs: []
  type: TYPE_TB
- en: '**Order statistics**'
  prefs: []
  type: TYPE_NORMAL
- en: The *i*th order statistic of a set of *n* numbers is the *i*th smallest number
    in the set. You can, of course, select the *i*th order statistic by sorting the
    input and indexing the *i*th element of the output. With no assumptions about
    the input distribution, this method runs in Ω(*n* lg *n*) time, as the lower bound
    proved in [Chapter 8](chapter008.xhtml) shows.
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 9](chapter009.xhtml) shows how to find the *i*th smallest element
    in *O*(*n*) time, even when the elements are arbitrary real numbers. We present
    a randomized algorithm with tight pseudocode that runs in Θ(*n*²) time in the
    worst case, but whose expected running time is *O*(*n*). We also give a more complicated
    algorithm that runs in *O*(*n*) worst-case time.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Background**'
  prefs: []
  type: TYPE_NORMAL
- en: Although most of this part does not rely on difficult mathematics, some sections
    do require mathematical sophistication. In particular, analyses of quicksort,
    bucket sort, and the order-statistic algorithm use probability, which is reviewed
    in [Appendix C](appendix003.xhtml), and the material on probabilistic analysis
    and randomized algorithms in [Chapter 5](chapter005.xhtml).
  prefs: []
  type: TYPE_NORMAL
