- answer: '-   **第七部分    精选主题**'
  en: '***第七部分    精选主题***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***第七部分    精选主题***  输出：'
  type: TYPE_NORMAL
  zh: '**第七部分    精选主题**'
- answer: '---

    -   **介绍**


    ---'
  en: '**介绍**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **介绍**  输出：'
  type: TYPE_NORMAL
  zh: '**介绍**'
- answer: '-   这部分包含了一些算法主题，扩展和补充了本书中较早的材料。一些章节介绍了新的计算模型，如电路或并行计算机。其他章节涵盖了专业领域，如矩阵或数论。最后两章讨论了设计高效算法的已知限制，并介绍了应对这些限制的技术。'
  en: 这部分包含了一些算法主题，扩展和补充了本书中较早的材料。一些章节介绍了新的计算模型，如电路或并行计算机。其他章节涵盖了专业领域，如矩阵或数论。最后两章讨论了设计高效算法的已知限制，并介绍了应对这些限制的技术。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   这部分包含了一些算法主题，扩展和补充了本书中较早的材料。一些章节介绍了新的计算模型，如电路或并行计算机。其他章节涵盖了专业领域，如矩阵或数论。最后两章讨论了设计高效算法的已知限制，并介绍了应对这些限制的技术。  输出：'
  type: TYPE_NORMAL
  zh: 这部分包含了一些算法主题，扩展和补充了本书中较早的材料。一些章节介绍了新的计算模型，如电路或并行计算机。其他章节涵盖了专业领域，如矩阵或数论。最后两章讨论了设计高效算法的已知限制，并介绍了应对这些限制的技术。
- answer: '-   第二十六章 提出了一个基于任务并行计算的并行计算算法模型，更具体地说，是分叉-加入并行性。该章介绍了该模型的基础知识，展示了如何以工作量和跨度的度量来量化并行性。然后研究了几个有趣的分叉-加入算法，包括矩阵乘法和合并排序的算法。'
  en: 第二十六章 提出了一个基于任务并行计算的并行计算算法模型，更具体地说，是分叉-加入并行性。该章介绍了该模型的基础知识，展示了如何以工作量和跨度的度量来量化并行性。然后研究了几个有趣的分叉-加入算法，包括矩阵乘法和合并排序的算法。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   第二十六章 提出了一个基于任务并行计算的并行计算算法模型，更具体地说，是分叉-加入并行性。该章介绍了该模型的基础知识，展示了如何以工作量和跨度的度量来量化并行性。然后研究了几个有趣的分叉-加入算法，包括矩阵乘法和合并排序的算法。  输出：'
  type: TYPE_NORMAL
  zh: 第二十六章 提出了一个基于任务并行计算的并行计算算法模型，更具体地说，是分叉-加入并行性。该章介绍了该模型的基础知识，展示了如何以工作量和跨度的度量来量化并行性。然后研究了几个有趣的分叉-加入算法，包括矩阵乘法和合并排序的算法。
- answer: '-      一个接收输入的算法随时间推移，而不是在开始时拥有整个输入，被称为“在线”算法。第二十七章研究了在线算法中使用的技术，从“玩具”问题开始，即在乘坐电梯前等待多长时间。然后研究了维护链表的“移至前端”启发式方法，并以我们在第
    15.4 节中看到的缓存问题的在线版本结束。这些在线算法的分析令人瞩目，因为它们证明了这些算法，它们不知道未来的输入，执行与知道未来输入入的最优算法相差一个常数因子。'
  en: 一个接收输入的算法随时间推移，而不是在开始时拥有整个输入，被称为“在线”算法。第二十七章 研究了在线算法中使用的技术，从“玩具”问题开始，即在乘坐电梯前等待多长时间。然后研究了维护链表的“移至前端”启发式方法，并以我们在第
    15.4 节中看到的缓存问题的在线版本结束。这些在线算法的分析令人瞩目，因为它们证明了这些算法，它们不知道未来的输入，执行与知道未来输入的最优算法相差一个常数因子。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   一个接收输入的算法随时间推移，而不是在开始时拥有整个输入，被称为“在线”算法。第二十七章
    研究了在线算法中使用的技术，从“玩具”问题开始，即在乘坐电梯前等待多长时间。然后研究了维护链表的“移至前端”启发式方法，并以我们在第 15.4 节中看到的缓存问题的在线版本结束。这些在线算法的分析令人瞩目，因为它们证明了这些算法，它们不知道未来的输入，执行与知道未来输入的最优算法相差一个常数因子。  输出：'
  type: TYPE_NORMAL
  zh: '   一个接收输入的算法随时间推移，而不是在开始时拥有整个输入，被称为“在线”算法。第二十七章研究了在线算法中使用的技术，从“玩具”问题开始，即在乘坐电梯前等待多长时间。然后研究了维护链表的“移至前端”启发式方法，并以我们在第
    15.4 节中看到的缓存问题的在线版本结束。这些在线算法的分析令人瞩目，因为它们证明了这些算法，它们不知道未来的输入，执行与知道未来输入入的最优算法相差一个常数因子。'
- answer: '-   第二十八章 研究了在矩阵上操作的高效算法。它提出了两种通用方法——LU 分解和 LUP 分解——通过高斯消元法在`O(n³)`时间内解线性方程。它还表明矩阵求逆和矩阵乘法可以同样快速地执行。该章最后展示了如何在一组线性方程没有精确解时计算最小二乘近似解。'
  en: 第二十八章 研究了在矩阵上操作的高效算法。它提出了两种通用方法——LU 分解和 LUP 分解——通过高斯消元法在*O*(*n*³)时间内解线性方程。它还表明矩阵求逆和矩阵乘法可以同样快速地执行。该章最后展示了如何在一组线性方程没有精确解时计算最小二乘近似解。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   第二十八章 研究了在矩阵上操作的高效算法。它提出了两种通用方法——LU
    分解和 LUP 分解——通过高斯消元法在*O*(*n*³)时间内解线性方程。它还表明矩阵求逆和矩阵乘法可以同样快速地执行。该章最后展示了如何在一组线性方程没有精确解时计算最小二乘近似解。  输出：'
  type: TYPE_NORMAL
  zh: 第二十八章 研究了在矩阵上操作的高效算法。它提出了两种通用方法——LU 分解和 LUP 分解——通过高斯消元法在`O(n³)`时间内解线性方程。它还表明矩阵求逆和矩阵乘法可以同样快速地执行。该章最后展示了如何在一组线性方程没有精确解时计算最小二乘近似解。
- answer: '-   第二十九章 研究了如何将问题建模为线性规划，目标是在有限资源和竞争约束的情况下最大化或最小化目标。线性规划在各种实际应用领域中出现。该章还涉及“对偶性”的概念，通过建立最大化问题和最小化问题具有相同目标值，有助于表明每个问题的解决方案都是最优的。  '
  en: 第二十九章 研究了如何将问题建模为线性规划，目标是在有限资源和竞争约束的情况下最大化或最小化目标。线性规划在各种实际应用领域中出现。该章还涉及“对偶性”的概念，通过建立最大化问题和最小化问题具有相同目标值，有助于表明每个问题的解决方案都是最优的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   第二十九章 研究了如何将问题建模为线性规划，目标是在有限资源和竞争约束的情况下最大化或最小化目标。线性规划在各种实际应用领域中出现。该章还涉及“对偶性”的概念，通过建立最大化问题和最小化问题具有相同目标值，有助于表明每个问题的解决方案都是最优的。  输出：'
  type: TYPE_NORMAL
  zh: '第二十九章 研究了如何将问题建模为线性规划，目标是在有限资源和竞争约束的情况下最大化或最小化目标。线性规划在各种实际应用领域中出现。该章还涉及“对偶性”的概念，通过建立最大化问题和最小化问题具有相同目标值，有助于表明每个问题的解决方案都是最优的。  '
- answer: '-   第三十章 研究了多项式的运算，并展示了如何使用一种著名的信号处理技术——快速傅里叶变换（FFT）在`O(n lg n)`时间内相乘两个`n`次多项式。它还推导出一个并行电路来计算
    FFT。'
  en: 第三十章 研究了多项式的运算，并展示了如何使用一种著名的信号处理技术——快速傅里叶变换（FFT）在*O*(*n* lg *n*)时间内相乘两个*n*次多项式。它还推导出一个并行电路来计算
    FFT。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   第三十章 研究了多项式的运算，并展示了如何使用一种著名的信号处理技术——快速傅里叶变换（FFT）在*O*(*n*
    lg *n*)时间内相乘两个*n*次多项式。它还推导出一个并行电路来计算 FFT。  输出：'
  type: TYPE_NORMAL
  zh: 第三十章 研究了多项式的运算，并展示了如何使用一种著名的信号处理技术——快速傅里叶变换（FFT）在`O(n lg n)`时间内相乘两个`n`次多项式。它还推导出一个并行电路来计算
    FFT。
- answer: '-   第三十一章 展示了数论算法。在回顾基本数论之后，它介绍了欧几里德算法用于计算最大公约数。接下来，它研究了解决模线性方程和对一个数取模另一个数的幂的算法。然后，它探讨了数论算法的一个重要应用：RSA
    公钥加密系统。这个加密系统不仅可以用于加密消息，使对手无法�读，还可以提供数字签名。该章以米勒-拉宾随机素性测试结束，该测试能够高效地找到大素数——RSA
    系统的一个基本要求。'
  en: 第三十一章 展示了数论算法。在回顾基本数论之后，它介绍了欧几里德算法用于计算最大公约数。接下来，它研究了解决模线性方程和对一个数取模另一个数的幂的算法。然后，它探讨了数论算法的一个重要应用：RSA
    公钥加密系统。这个加密系统不仅可以用于加密消息，使对手无法��读，还可以提供数字签名。该章以米勒-拉宾随机素性测试结束，该测试能够高效地找到大素数——RSA
    系统的一个基本要求。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   第三十一章 展示了数论算法。在回顾基本数论之后，它介绍了欧几里德算法用于计算最大公约数。接下来，它研究了解决模线性方程和对一个数取模另一个数的幂的算法。然后，它探讨了数论算法的一个重要应用：RSA
    公钥加密系统。这个加密系统不仅可以用于加密消息，使对手无法��读，还可以提供数字签名。该章以米勒-拉宾随机素性测试结束，该测试能够高效地找到大素数——RSA
    系统的一个基本要求。  输出：'
  type: TYPE_NORMAL
  zh: 第三十一章 展示了数论算法。在回顾基本数论之后，它介绍了欧几里德算法用于计算最大公约数。接下来，它研究了解决模线性方程和对一个数取模另一个数的幂的算法。然后，它探讨了数论算法的一个重要应用：RSA
    公钥加密系统。这个加密系统不仅可以用于加密消息，使对手无法�读，还可以提供数字签名。该章以米勒-拉宾随机素性测试结束，该测试能够高效地找到大素数——RSA
    系统的一个基本要求。
- answer: '-   第三十二章 研究了在给定文本字符串中找到给定模式字符串的所有出现的问题，这个问题在文本编辑程序中经常出现。在检查了朴素方法之后，本章介绍了由拉宾和卡普提出的优雅方法。然后，在展示了基于有限自动机的高效解决方案之后，本章介绍了
    Knuth-Morris-Pratt 算法，该算法修改了基于自动机的算法，通过巧妙地预处理模式来节省空间。本章最后研究了后缀数组，它不仅可以在文本字符串中找到模式，还可以做更多的事情，比如在文本中找到最长重复的子字符串，以及在两个文本中找到出现的最长公共子字符串。  '
  en: 第三十二章 研究了在给定文本字符串中找到给定模式字符串的所有出现的问题，这个问题在文本编辑程序中经常出现。在检查了朴素方法之后，本章介绍了由拉宾和卡普提出的优雅方法。然后，在展示了基于有限自动机的高效解决方案之后，本章介绍了
    Knuth-Morris-Pratt 算法，该算法修改了基于自动机的算法，通过巧妙地预处理模式来节省空间。本章最后研究了后缀数组，它不仅可以在文本字符串中找到模式，还可以做更多的事情，比如在文本中找到最长重复的子字符串，以及在两个文本中找到出现的最长公共子字符串。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   第三十二章 研究了在给定文本字符串中找到给定模式字符串的所有出现的问题，这个问题在文本编辑程序中经常出现。在检查了朴素方法之后，本章介绍了由拉宾和卡普提出的优雅方法。然后，在展示了基于有限自动机的高效解决方案之后，本章介绍了
    Knuth-Morris-Pratt 算法，该算法修改了基于自动机的算法，通过巧妙地预处理模式来节省空间。本章最后研究了后缀数组，它不仅可以在文本字符串中找到模式，还可以做更多的事情，比如在文本中找到最长重复的子字符串，以及在两个文本中找到出现的最长公共子字符串。  输出：'
  type: TYPE_NORMAL
  zh: '第三十二章 研究了在给定文本字符串中找到给定模式字符串的所有出现的问题，这个问题在文本编辑程序中经常出现。在检查了朴素方法之后，本章介绍了由拉宾和卡普提出的优雅方法。然后，在展示了基于有限自动机的高效解决方案之后，本章介绍了
    Knuth-Morris-Pratt 算法，该算法修改了基于自动机的算法，通过巧妙地预处理模式来节省空间。本章最后研究了后缀数组，它不仅可以在文本字符串中找到模式，还可以做更多的事情，比如在文本中找到最长重复的子字符串，以及在两个文本中找到出现的最长公共子字符串。  '
- answer: '-   第三十三章 探讨了机器学习领域中的三种算法。机器学习算法旨在接收大量数据，提出关于数据模式的假设，并测试这些假设。本章从`k`-means
    聚类开始，该算法根据数据元素之间的相似性将数据分组为`k`类。然后展示了如何使用乘法权重技术根据一组质量不同的“专家”准确预测。也许令人惊讶的是，即使不知道哪些专家可靠，哪些不可靠，你也可以几乎和最可靠的专家一样准确地预测。本章最后介绍了梯度下降，一种找到函数局部最小值的优化技术。梯度下降有许多应用，包括为许多机器学习模型找到参数设置。'
  en: 第三十三章 探讨了机器学习领域中的三种算法。机器学习算法旨在接收大量数据，提出关于数据模式的假设，并测试这些假设。本章从*k*-means 聚类开始，该算法根据数据元素之间的相似性将数据分组为*k*类。然后展示了如何使用乘法权重技术根据一组质量不同的“专家”准确预测。也许令人惊讶的是，即使不知道哪些专家可靠，哪些不可靠，你也可以几乎和最可靠的专家一样准确地预测。本章最后介绍了梯度下降，一种找到函数局部最小值的优化技术。梯度下降有许多应用，包括为许多机器学习模型找到参数设置。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   第三十三章 探讨了机器学习领域中的三种算法。机器学习算法旨在接收大量数据，提出关于数据模式的假设，并测试这些假设。本章从*k*-means
    聚类开始，该算法根据数据元素之间的相似性将数据分组为*k*类。然后展示了如何使用乘法权重技术根据一组质量不同的“专家”准确预测。也许令人惊讶的是，即使不知道哪些专家可靠，哪些不可靠，你也可以几乎和最可靠的专家一样准确地预测。本章最后介绍了梯度下降，一种找到函数局部最小值的优化技术。梯度下降有许多应用，包括为许多机器学习模型找到参数设置。  输出：'
  type: TYPE_NORMAL
  zh: 第三十三章 探讨了机器学习领域中的三种算法。机器学习算法旨在接收大量数据，提出关于数据模式的假设，并测试这些假设。本章从`k`-means 聚类开始，该算法根据数据元素之间的相似性将数据分组为`k`类。然后展示了如何使用乘法权重技术根据一组质量不同的“专家”准确预测。也许令人惊讶的是，即使不知道哪些专家可靠，哪些不可靠，你也可以几乎和最可靠的专家一样准确地预测。本章最后介绍了梯度下降，一种找到函数局部最小值的优化技术。梯度下降有许多应用，包括为许多机器学习模型找到参数设置。
- answer: '-   第三十四章 关注 NP 完全问题。许多有趣的计算问题都是 NP 完全的，但目前尚不知道任何多项式时间算法来解决它们。本章介绍了确定问题是否为
    NP 完全的技术，并使用这些技术证明了几个经典问题是 NP 完全的：确定图是否有哈密顿循环（包括每个顶点的循环），确定布尔公式是否可满足（是否存在一组布尔值的赋值使得公式求值为
    TRUE），以及确定给定数字集合是否有一个子集的和等于给定目标值。本章还证明了著名的旅行推销员问题（找到一条从同一位置出发并结束的最短路径，访问每个位置一次）是
    NP 完全的。'
  en: 第三十四章 关注 NP 完全问题。许多有趣的计算问题都是 NP 完全的，但目前尚不知道任何多项式时间算法来解决它们。本章介绍了确定问题是否为 NP 完全的技术，并使用这些技术证明了几个经典问题是
    NP 完全的：确定图是否有哈密顿循环（包括每个顶点的循环），确定布尔公式是否可满足（是否存在一组布尔值的赋值使得公式求值为 TRUE），以及确定给定数字集合是否有一个子集的和等于给定目标值。本章还证明了著名的旅行推销员问题（找到一条从同一位置出发并结束的最短路径，访问每个位置一次）是
    NP 完全的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   第三十四章 关注 NP
    完全问题。许多有趣的计算问题都是 NP 完全的，但目前尚不知道任何多项式时间算法来解决它们。本章介绍了确定问题是否为 NP 完全的技术，并使用这些技术证明了几个经典问题是
    NP 完全的：确定图是否有哈密顿循环（包括每个顶点的循环），确定布尔公式是否可满足（是否存在一组布尔值的赋值使得公式求值为 TRUE），以及确定给定数字集合是否有一个子集的和等于给定目标值。本章还证明了著名的旅行推销员问题（找到一条从同一位置出发并结束的最短路径，访问每个位置一次）是
    NP 完全的。  输出：'
  type: TYPE_NORMAL
  zh: 第三十四章 关注 NP 完全问题。许多有趣的计算问题都是 NP 完全的，但目前尚不知道任何多项式时间算法来解决它们。本章介绍了确定问题是否为 NP 完全的技术，并使用这些技术证明了几个经典问题是
    NP 完全的：确定图是否有哈密顿循环（包括每个顶点的循环），确定布尔公式是否可满足（是否存在一组布尔值的赋值使得公式求值为 TRUE），以及确定给定数字集合是否有一个子集的和等于给定目标值。本章还证明了著名的旅行推销员问题（找到一条从同一位置出发并结束的最短路径，访问每个位置一次）是
    NP 完全的。
- answer: '-   第三十五章 展示了如何通过使用近似算法有效地找到 NP 完全问题的近似解。对于一些 NP 完全问题，产生接近最优解的近似解相当容易，但对于其他问题，即使是已知的最佳近似算法随着问题规模的增加而逐渐变得更糟。然后，有一些问题，投入越来越多的计算时间会产生越来越好的近似解。本章通过顶点覆盖问题（无权重和有权重版本）、3-CNF
    可满足性的优化版本、旅行推销员问题、集合覆盖问题和子集和问题来说明这些可能性。'
  en: 第三十五章 展示了如何通过使用近似算法有效地找到 NP 完全问题的近似解。对于一些 NP 完全问题，产生接近最优解的近似解相当容易，但对于其他问题，即使是已知的最佳近似算法随着问题规模的增加而逐渐变得更糟。然后，有一些问题，投入越来越多的计算时间会产生越来越好的近似解。本章通过顶点覆盖问题（无权重和有权重版本）、3-CNF
    可满足性的优化版本、旅行推销员问题、集合覆盖问题和子集和问题来说明这些可能性。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   第三十五章 展示了如何通过使用近似算法有效地找到
    NP 完全问题的近似解。对于一些 NP 完全问题，产生接近最优解的近似解相当容易，但对于其他问题，即使是已知的最佳近似算法随着问题规模的增加而逐渐变得更糟。然后，有一些问题，投入越来越多的计算时间会产生越来越好的近似解。本章通过顶点覆盖问题（无权重和有权重版本）、3-CNF
    可满足性的优化版本、旅行推销员问题、集合覆盖问题和子集和问题来说明这些可能性。  输出：'
  type: TYPE_NORMAL
  zh: 第三十五章 展示了如何通过使用近似算法有效地找到 NP 完全问题的近似解。对于一些 NP 完全问题，产生接近最优解的近似解相当容易，但对于其他问题，即使是已知的最佳近似算法随着问题规模的增加而逐渐变得更糟。然后，有一些问题，投入越来越多的计算时间会产生越来越好的近似解。本章通过顶点覆盖问题（无权重和有权重版本）、3-CNF
    可满足性的优化版本、旅行推销员问题、集合覆盖问题和子集和问题来说明这些可能性。
