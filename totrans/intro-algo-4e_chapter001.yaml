- en: '**1          计算中的算法角色**'
  prefs: []
  type: TYPE_NORMAL
- en: 什么是算法？为什么研究算法是值得的？算法在计算机中的其他技术中的作用是什么？本章将回答这些问题。
  prefs: []
  type: TYPE_NORMAL
- en: '**1.1      算法**'
  prefs: []
  type: TYPE_NORMAL
- en: 非正式地说，一个***算法***是任何明确定义的计算过程，它将一些值或一组值作为***输入***，并在有限时间内产生一些值或一组值作为***输出***。因此，算法是一系列将输入转换为输出的计算步骤。
  prefs: []
  type: TYPE_NORMAL
- en: 您还可以将算法视为解决一个明确定义的***计算问题***的工具。问题的陈述以一般术语指定了问题实例的所需输入/输出关系，通常是任意大的尺寸。算法描述了实现所有问题实例的输入/输出关系的特定计算过程。
  prefs: []
  type: TYPE_NORMAL
- en: 举个例子，假设您需要将一系列数字按单调递增顺序排序。这个问题在实践中经常出现，并为引入许多标准设计技术和分析工具提供了肥沃的土壤。以下是我们如何正式定义***排序问题***：
  prefs: []
  type: TYPE_NORMAL
- en: '**输入:** 一个包含*n*个数字的序列 〈*a*[1], *a*[2], … , *a[n]*〉。'
  prefs: []
  type: TYPE_NORMAL
- en: '**输出:** 输入序列的一个排列（重新排序）![art](img/Art_P1.jpg)，使得![art](img/Art_P2.jpg)。'
  prefs: []
  type: TYPE_NORMAL
- en: 因此，给定输入序列 〈31, 41, 59, 26, 41, 58〉，一个正确的排序算法将输出序列 〈26, 31, 41, 41, 58, 59〉。这样的输入序列被称为排序问题的一个***实例***。一般来说，一个***问题的实例***¹包括计算问题解所需的输入（满足问题陈述中施加的任何约束）。
  prefs: []
  type: TYPE_NORMAL
- en: 由于许多程序将其用作中间步骤，排序在计算机科学中是一个基本操作。因此，您可以使用大量优秀的排序算法。对于给定应用程序来说，哪种算法最好取决于—除其他因素外—要排序的项目数量，项目已经有多少程度上排序，项目值可能的限制，计算机的架构，以及要使用的存储设备类型：主存储器、磁盘，甚至—古老的—磁带。
  prefs: []
  type: TYPE_NORMAL
- en: 对于作为输入提供的每个问题实例，计算问题的算法如果***终止***—在有限时间内完成计算—并输出问题实例的正确解，则算法是***正确***的。一个正确的算法***解决***了给定的计算问题。一个不正确的算法在某些输入实例上可能根本不会终止，或者在错误答案下终止。与您可能期望的相反，如果您可以控制其错误率，不正确的算法有时可能是有用的。当我们研究用于查找大素数的算法时，我们将在第三十一章看到一个具有可控错误率的算法示例。然而，通常情况下，我们只关注正确的算法。
  prefs: []
  type: TYPE_NORMAL
- en: 一个算法可以用英语、计算机程序，甚至硬件设计来指定。唯一的要求是规范必须提供一个精确描述要遵循的计算过程。
  prefs: []
  type: TYPE_NORMAL
- en: '**算法解决哪些问题？**'
  prefs: []
  type: TYPE_NORMAL
- en: 排序绝不是唯一一个为其开发算法的计算问题。（当您看到本书的大小时，您可能已经怀疑到了。）算法的实际应用是无处不在的，包括以下示例：
  prefs: []
  type: TYPE_NORMAL
- en: 人类基因组计划在确定人类 DNA 中大约 30,000 个基因、确定构成人类 DNA 的大约 30 亿个化学碱基对的序列、将这些信息存储在数据库中以及开发数据分析工具方面取得了巨大进展。每个步骤都需要复杂的算法。虽然这些问题的解决方案超出了本书的范围，但许多解决这些生物问题的方法使用了本书中���绍的思想，使科学家能够在使用资源高效的同时完成任务。动态规划，如第十四章中所述，是解决这些生物问题的重要技术，特别是涉及确定
    DNA 序列之间相似性的问题。节省的时间（包括人类和机器的时间）和金钱，因为实验室技术可以提取更多信息。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 互联网使全世界的人们能够快速访问和检索大量信息。在巧妙算法的帮助下，互联网上的网站能够管理和操纵这些大量数据。需要算法的问题的例子包括寻找数据传输的良好路线（解决这类问题的技术出现在第二十二章中），以及使用搜索引擎快速找到包含特定信息的页面（相关技术在第十一章和
    32 章中）。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 电子商务使商品和服务能够通过电子方式进行协商和交换，并且依赖于个人信息的隐私，如信用卡号码、密码和银行对账单。电子商务中使用的核心技术包括公钥加密和数字签名（在第三十一章中介绍），这些技术基于数值算法和数论。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 制造业和其他商业企业经常需要以最有利的方式分配稀缺资源。一家石油公司可能希望知道在哪里放置其油井以最大化预期利润。政治候选人可能想确定在哪里花钱购买竞选广告以最大化赢得选举的机会。航空公司可能希望以最经济的方式为航班分配机组人员，确保每个航班都有人员配备，并满足政府关于机组排班的规定。互联网服务提供商可能希望确定在哪里增加资源以更有效地为客户提供服务。所有这些都是可以通过将其建模为线性规划来解决的问题的示例，第二十九章对此进行了探讨。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 尽管这些示例的一些细节超出了本书的范围，但我们提供了适用于这些问题和问题领域的基本技术。我们还展示了如何解决许多具体问题，包括以下内容：
  prefs: []
  type: TYPE_NORMAL
- en: 你有一张道路地图，上面标有相邻交叉口之间的距离，并且希望确定从一个交叉口到另一个交叉口的最短路径。即使不允许跨越自身的路径，可能的路径数量也可能非常庞大。你如何选择所有可能路径中最短的路径？你可以通过将道路地图（本身就是实际道路的模型）建模为图（我们将在第六部分和附录
    B 中介绍），在这个图中，你希望找到从一个顶点到另一个顶点的最短路径。第二十二章展示了如何高效解决这个问题。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 给定一个机械设计，其中包含一个零件库，每个零件可能包含其他零件的实例，列出零件的顺序，使得每个零件都出现在使用它的任何零件之前。如果设计包括*n*个零件，那么可能有*n*!种可能的顺序，其中*n*!表示阶乘函数。因为阶乘函数增长速度甚至比指数函数还快，你不可能生成每个可能的顺序，然后验证在该顺序中，每个零件都出现在使用它的零件之前（除非你只有很少的零件）。这个问题是拓扑排序的一个实例，第二十章展示了如何高效解决这个问题。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 一位医生需要确定一幅图像是否代表一个恶性肿瘤还是良性肿瘤。医生可以使用许多其他肿瘤的图像，其中一些已知是恶性的，一些已知是良性的。恶性肿瘤更可能与其他恶性肿瘤相似，而良性肿瘤更可能与其他良性肿瘤相似。通过使用聚类算法，如第三十三章，医生可以确定哪种结果更有可能。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 你需要压缩一个包含文本的大文件，以便占用更少的空间。已知有许多压缩方法，包括“LZW 压缩”，它寻找重复的字符序列。第十五章研究了一种不同的方法，“赫夫曼编码”，它通过不同长度的比特序列对字符进行编码，出现频率更高的字符用较短的比特序列编码。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 这些列表远非详尽（正如你可能从本书的厚度中推测出来的那样），但它们展示了许多有趣的算法问题共有的两个特征：
  prefs: []
  type: TYPE_NORMAL
- en: 它们有许多候选解决方案，其中绝大多数都不能解决手头的问题。找到一个解决方案，或者一个“最佳”解决方案，而不是明确检查每个可能的解决方案，可能会带来相当大的挑战。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 它们具有实际应用。在上述列表中的问题中，寻找最短路径提供了最简单的例子。像卡车公司或铁路公司这样的运输公司有兴趣通过道路或铁路网络找到最短路径，因为走更短的路径会导致更低的劳动力和燃料成本。或者互联网上的路由节点可能需要通过网络找到最短路径以快速路由消息。或者一个想要从纽约开车到波士顿的人可能想要使用导航应用找到驾驶路线。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 并非每个由算法解决的问题都有���个易于识别的候选解决方案集。例如，给定一组表示在规则时间间隔内取样的信号样本的数值值，离散傅立叶变换将时间域转换为频率域。也就是说，它将信号近似为一组正弦波的加权和，产生各种频率的强度，这些频率的总和近似于取样信号。除了在信号处理中起着核心作用外，离散傅立叶变换还在数据压缩和乘法大多项式和整数方面有应用。第三十章提供了一个高效的算法，快速傅立叶变换（通常称为
    FFT），用于解决这个问题。该章还概述了硬件 FFT 电路的设计。
  prefs: []
  type: TYPE_NORMAL
- en: '**数据结构**'
  prefs: []
  type: TYPE_NORMAL
- en: 本书还介绍了几种数据结构。***数据结构***是一种存储和组织数据以便于访问和修改的方式。使用适当的数据结构或结构是算法设计的重要部分。没有一种单一的数据结构适用于所有目的，因此你应该了解其中几种的优势和局限性。
  prefs: []
  type: TYPE_NORMAL
- en: '**技术**'
  prefs: []
  type: TYPE_NORMAL
- en: 虽然你可以将本书当作算法的“食谱”，但你可能会在某一天遇到一个问题，你无法立即找到已发表的算法（例如本书中的许多练习和问题）。本书将教会你算法设计和分析技巧，以便你可以自己开发算法，展示它们给出正确答案，并分析它们的效率。不同章节涉及算法问题解决的不同方面。一些章节涉及特定问题，比如在第九章中找到中位数和顺序统计量，在第二十一章中计算最小生成树，在第二十四章中确定网络中的最大流。其他章节介绍技术，比如在第二章和第四章中的分治法，第十四章中的动态规划，以及第十六章中的摊销分析。
  prefs: []
  type: TYPE_NORMAL
- en: '**困难问题**'
  prefs: []
  type: TYPE_NORMAL
- en: 大部分本书讨论的是高效算法。我们通常衡量效率的标准是速度：算法产生结果需要多长时间？然而，有一些问题，我们却不知道有没有算法能在合理的时间内运行。第三十四章研究了这些问题的一个有趣子集，被称为
    NP 完全问题。
  prefs: []
  type: TYPE_NORMAL
- en: 为什么 NP 完全问题很有趣？首先，尽管从未找到 NP 完全问题的高效算法，但也从未有人证明不存在高效算法。换句话说，没有人知道是否存在 NP 完全问题的高效算法。其次，NP
    完全问题集合具有一个引人注目的特性，即���果存在任何一个 NP 完全问题的高效算法，那么所有 NP 完全问题都存在高效算法。NP 完全问题之间的这种关系使得缺乏高效解决方案更加诱人。第三，几个
    NP 完全问题与我们已知的高效算法类似，但并非相同。计算机科学家对问题陈述的微小变化如何导致最佳已知算法效率的巨大变化感到着迷。
  prefs: []
  type: TYPE_NORMAL
- en: 你应该了解 NP 完全问题，因为它们在实际应用中出现得令人惊讶地频繁。如果你被要求为一个 NP 完全问题设计���效算法，你可能会花费很多时间进行无果的搜索。相反，如果你能证明问题是
    NP 完全的，你可以花时间开发一个高效的近似算法，即一个给出良好但不一定是最佳解决方案的算法。
  prefs: []
  type: TYPE_NORMAL
- en: 举个具体例子，考虑一个有中央仓库的快递公司。每天，它在仓库装载交付卡车，并将它们派送到几个地址。一天结束时，每辆卡车必须回到仓库，以便为第二天装载做好准备。为了降低成本，公司希望选择一个交付站点顺序，使每辆卡车的总行驶距离最小。这个问题就是著名的“旅行推销员问题”，它是
    NP 完全的。² 它没有已知的高效算法。然而，在某些假设下，我们知道可以计算接近最小可能总距离的高效算法。第三十五章讨论了这样的“近似算法”。
  prefs: []
  type: TYPE_NORMAL
- en: '**替代计算模型**'
  prefs: []
  type: TYPE_NORMAL
- en: 多年来，我们一直可以依靠处理器时钟速度稳定增长。然而，物理限制对不断增加的时钟速度构成了根本障碍：因为功率密度随着时钟速度的增加呈超线性增长，一旦时钟速度足够高，芯片就有融化的风险。因此，为了每秒执行更多计算，芯片被设计为不仅包含一个而是多个处理“核心”。我们可以将这些多核计算机比作单个芯片上的几台顺序计算机。换句话说，它们是一种“并行计算机”。为了从多核计算机中获得最佳性能，我们需要设计考虑并行性的算法。第二十六章提出了一种“任务并行”算法模型，利用了多个处理核心。这种模型在理论和实践上都有优势，许多现代并行编程平台都采用了类似于这种并行性模型。
  prefs: []
  type: TYPE_NORMAL
- en: 本书中的大多数示例假设算法开始运行时所有输入数据都可用。然而，算法设计中的许多重要真实世界示例实际上是随时间到达输入数据，算法必须在不知道未来将到达哪些数据的情况下决定如何继续。在数据中心，作业不断到达和离开，调度算法必须决定何时何地运行作业，而不知道未来将到达哪些作业。基于当前状态，在互联网中必须路由流量，而不知道未来流量将到达何处。医院急诊室在不知道未来将到达哪些患者和他们将需要什么治疗的情况下，对哪些患者优先治疗做出分类决策。接收输入数据随时间而来的算法，而不是在开始时就有所有输入的算法，是***在线算法***，第二十七章对此进行了探讨。
  prefs: []
  type: TYPE_NORMAL
- en: '**练习**'
  prefs: []
  type: TYPE_NORMAL
- en: '***1.1-1***'
  prefs: []
  type: TYPE_NORMAL
- en: 描述一个需要排序的真实世界示例。描述一个需要找到两点之间最短距离的示例。
  prefs: []
  type: TYPE_NORMAL
- en: '***1.1-2***'
  prefs: []
  type: TYPE_NORMAL
- en: 除了速度之外，在真实世界环境中，您可能需要考虑哪些其他效率指标？
  prefs: []
  type: TYPE_NORMAL
- en: '***1.1-3***'
  prefs: []
  type: TYPE_NORMAL
- en: ���择一个您见过的数据结构，并讨论其优势和局限性。
  prefs: []
  type: TYPE_NORMAL
- en: '***1.1-4***'
  prefs: []
  type: TYPE_NORMAL
- en: 上述最短路径和旅行推销员问题有何相似之处？它们又有何不同？
  prefs: []
  type: TYPE_NORMAL
- en: '***1.1-5***'
  prefs: []
  type: TYPE_NORMAL
- en: 提出一个只有最佳解决方案才行的真实世界问题。然后想出一个“近似”最佳解决方案就足够的问题。
  prefs: []
  type: TYPE_NORMAL
- en: '***1.1-6***'
  prefs: []
  type: TYPE_NORMAL
- en: 描述一个真实世界问题，有时在需要解决问题之前整个输入可用，但其他时候输入并非完全提前可用，而是随时间到达。
  prefs: []
  type: TYPE_NORMAL
- en: '**1.2      算法作为一种技术**'
  prefs: []
  type: TYPE_NORMAL
- en: 如果计算机速度无限快，计算机内存是免费的，您是否有理由学习算法？答案是肯定的，即使出于其他原因，您仍希望确保您的解决方法终止并且得到正确答案。
  prefs: []
  type: TYPE_NORMAL
- en: 如果计算机速度无限快，解决问题的任何正确方法都可以。您可能希望您的实现在良好的软件工程实践范围内（例如，您的实现应设计良好并有文档），但您通常会使用最容易实现的方法。
  prefs: []
  type: TYPE_NORMAL
- en: 当然，计算机可能很快，但它们并不是无限快的。计算时间是一种有限的资源，因此它是宝贵的。尽管有句谚语说：“时间就是金钱”，但时间比金钱更宝贵：花掉金钱后你可以再赚回来，但一旦时间花掉了，你就再也无法拿回来。内存可能便宜，但它既不是无限的，也不是免费的。你应该选择能够高效利用���间和空间资源的算法。
  prefs: []
  type: TYPE_NORMAL
- en: '**效率**'
  prefs: []
  type: TYPE_NORMAL
- en: 为解决同一问题而设计的不同算法在效率上往往有显著差异。这些差异可能比硬件和软件造成的差异更为显著。
  prefs: []
  type: TYPE_NORMAL
- en: 举例来说，第二章介绍了两种排序算法。第一种被称为***插入排序***，排序*n*个项目大约需要时间*c*[1]*n*²，其中*c*[1]是一个不依赖于*n*的常数。也就是说，它的时间大约与*n*²成正比。第二种***归并排序***，排序*n*个项目大约需要时间*c*[2]*n*
    lg *n*，其中 lg *n*代表 log[2] *n*，*c*[2]是另一个不依赖于*n*的常数。插入排序通常比归并排序有更小的常数因子，因此*c*[1]
    < *c*[2]。我们将看到常数因子对运行时间的影响远不及对输入大小*n*的依赖。我们将插入排序的运行时间写为*c*[1]*n* · *n*，归并排序的运行时间写为*c*[2]*n*
    · lg *n*。然后我们看到插入排序在其运行时间中有一个*n*的因子，而归并排序有一个 lg *n*的因子，后者要小得多。例如，当*n*为 1000 时，lg
    *n*大约为 10，当*n*为 1,000,000 时，lg *n*大约只有 20。尽管插入排序通常在小输入大小时运行得比归并排序快，但一旦输入大小*n*足够大，归并排序的
    lg *n*优势远远超过常数因子的差异。无论*c*[1]比*c*[2]小多少，总会有一个交叉点，超过这个点，归并排序就更快了。
  prefs: []
  type: TYPE_NORMAL
- en: 举个具体的例子，让我们让一个更快的计算机（计算机 A）运行插入排序与一个更慢的计算机（计算机 B）运行归并排序进行比较。它们各自必须对一个包含 1000
    万个数字的数组进行排序。（虽然 1000 万个数字可能看起来很多，但如果这些数字是 8 字节整数，那么输入大约占用 80 兆字节的内存，这适用于即使是价格便宜的笔记本电脑的内存多次。）假设计算机
    A 每秒执行 100 亿条指令（比目前任何单个顺序计算机都要快），计算机 B 每秒只执行 1000 万条指令（比大多数当代计算机要慢得多），因此计算机 A
    在原始计算能力上比计算机 B 快 1000 倍。为了使差异更加明显，假设世界上最狡猾的程序员为计算机 A 用机器语言编写插入排序，结果代码需要 2*n*²条指令来对*n*个数字进行排序。进一步假设只是一个普通程序员使用效率低下的编译器用高级语言实现归并排序，结果代码需要
    50 *n* lg *n*条指令。对于排序 1000 万个数字，计算机 A 需要
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 当计算机 B 执行时
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 通过使用一个运行时间增长较慢的算法，即使使用一个较差的编译器，计算机 B 的运行速度比计算机 A 快了 17 倍以上！当对 1 亿个数字进行排序时，归并排序的优势更加明显：插入排序需要超过
    23 天，而归并排序只需要不到 4 小时。虽然 1 亿可能看起来是一个很大的数字，但每半小时有超过 1 亿次网络搜索，每分钟发送超过 1 亿封电子邮件，一些最小的星系（被称为超紧凑矮星系）包含大约
    1 亿颗星星。一般来说，随着问题规模的增加，归并排序的相对优势也会增加。
  prefs: []
  type: TYPE_NORMAL
- en: '**算法和其他技术**'
  prefs: []
  type: TYPE_NORMAL
- en: 上面的例子表明，你应该将算法视为***技术***，就像计算机硬件一样。整个系统的性能取决于选择高效的算法，就像选择快速硬件一样重要。就像其他计算机技术正在快速发展一样，算法也在快速发展。
  prefs: []
  type: TYPE_NORMAL
- en: 你可能会想知道在其他先进技术（如
  prefs: []
  type: TYPE_NORMAL
- en: 先进的计算机架构和制造技术，
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 易于使用、直观的图形用户界面（GUI），
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 面向对象的系统，
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 集成的网络技术，
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 快速的有线和无线网络，
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 机器学习，
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 和移动设备。
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 答案是肯定的。尽管一些应用程序在应用程序级别不明确需要算法内容（例如一些简单的基于 Web 的应用程序），但许多应用程序需要。例如，考虑一个确定如何从一个位置到另一个位置旅行的基于
    Web 的服务。其实现将依赖于快速硬件、图形用户界面、广域网和可能还依赖于面向对象。它还需要算法来执行诸如查找路线（可能使用最短路径算法）、渲染地图和插值地址等操作。
  prefs: []
  type: TYPE_NORMAL
- en: 此外，即使一个应用程序在应用程序级别不需要算法内容，也严重依赖算法。应用程序依赖快速硬件吗？硬件设计使用了算法。应用程序依赖图形用户界面吗？任何 GUI
    的设计都依赖于算法。应用程序依赖网络吗？网络中的路由非常依赖算法。应用程序是用机器码之外的语言编写的吗？那么它经过了编译器、解释器或汇编器的处理，所有这些都广泛使用算法。算法是当代计算机中使用的大多数技术的核心。
  prefs: []
  type: TYPE_NORMAL
- en: 机器学习可以被认为是一种执行算法任务的方法，而不是明确设计算法，而是从数据中推断模式，从而自动学习解决方案。乍一看，自动化算法设计的机器学习似乎使学习算法变得过时。然而，事实恰恰相反。机器学习本身就是一系列算法，只是用了一个不同的名字。此外，目前似乎机器学习的成功主要是针对我们作为人类不真正理解正确算法的问题。著名的例子包括计算机视觉和自动语言翻译。对于人类理解良好的算法问题，例如本书中的大多数问题，通常比机器学习方法更成功地设计出解决特定问题的高效算法。
  prefs: []
  type: TYPE_NORMAL
- en: 数据科学是一个跨学科领域，其目标是从结构化和非结构化数据中提取知识和见解。数据科学使用统计学、计算机科学和优化方法。算法的设计和分析对该领域至关重要。数据科学的核心技术与机器学习中的技术有很大重叠，包括本书中的许多算法。
  prefs: []
  type: TYPE_NORMAL
- en: 此外，随着计算机容量的不断增加，我们使用它们来解决比以往更大的问题。正如我们在上面插入排序和归并排序之间的比较中看到的，算法之间的效率差异在更大的问题规模下变得尤为显著。
  prefs: []
  type: TYPE_NORMAL
- en: 拥有扎实的算法知识和技巧是定义真正熟练程序员的一个特征。借助现代计算技术，你可以完成一些任务而不需要了解太多算法，但是有了良好的算法基础，你可以做更多、更多的事情。
  prefs: []
  type: TYPE_NORMAL
- en: '**练习**'
  prefs: []
  type: TYPE_NORMAL
- en: '***1.2-1***'
  prefs: []
  type: TYPE_NORMAL
- en: 给出一个需要应用级别算法内容的应用示例，并讨论所涉及算法的功能。
  prefs: []
  type: TYPE_NORMAL
- en: '***1.2-2***'
  prefs: []
  type: TYPE_NORMAL
- en: 假设在特定计算机上，对于大小为*n*的输入，插入排序需要 8*n*²步，而归并排序需要 64 *n* lg *n*步。对于哪些*n*值，插入排序胜过归并排序？
  prefs: []
  type: TYPE_NORMAL
- en: '***1.2-3***'
  prefs: []
  type: TYPE_NORMAL
- en: 什么是*n*的最小值，使得运行时间为 100*n*²的算法在同一台机器上比运行时间为 2*^n*的算法更快？
  prefs: []
  type: TYPE_NORMAL
- en: '**问题**'
  prefs: []
  type: TYPE_NORMAL
- en: '***1-1     运行时间的比较***'
  prefs: []
  type: TYPE_NORMAL
- en: 对于每个函数*f*(*n*)和时间*t*在下表中，确定在时间*t*内可以解决的问题的最大规模*n*，假设解决问题的算法需要*f*(*n*)微秒。
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**章节注释**'
  prefs: []
  type: TYPE_NORMAL
- en: 有许多关于算法这一一般主题的优秀文本，包括 Aho，Hopcroft 和 Ullman 的文本[5, 6]，Dasgupta，Papadimitriou
    和 Vazirani 的文本[107]，Edmonds 的文本[133]，Erickson 的文本[135]，Goodrich 和 Tamassia 的文本[195,
    196]，Kleinberg 和 Tardos 的文本[257]，Knuth 的文本[259, 260, 261, 262, 263]，Levitin 的文本[298]，Louridas
    的文本[305]，Mehlhorn 和 Sanders 的文本[325]，Mitzenmacher 和 Upfal 的文本[331]，Neapolitan
    的文本[342]，Roughgarden 的文本[385, 386, 387, 388]，Sanders，Mehlhorn，Dietzfelbinger 和
    Dementiev 的文本[393]，Sedgewick 和 Wayne 的文本[402]，Skiena 的文本[414]，Soltys-Kulinicz
    的文本[419]，Wilf 的文本[455]，以及 Williamson 和 Shmoys 的文本[459]。有关算法设计更实际方面的讨论可以参考 Bentley
    的文本[49, 50, 51]，Bhargava 的文本[54]，Kochenderfer 和 Wheeler 的文本[268]，以及 McGeoch 的文本[321]。算法领域的概述也可以在
    Atallah 和 Blanton 的书中找到[27, 28]，以及 Mehta 和 Sahhi 的书中[326]。对于较少技术性的材料，请参阅 Christian
    和 Griffiths 的书籍[92]，Cormen 的书籍[104]，Erwig 的书籍[136]，MacCormick 的书籍[307]，以及 Vöcking
    等人的书籍[448]。计算生物学中使用的算法概述可以在 Jones 和 Pevzner 的书籍中找到[240]，Elloumi 和 Zomaya 的书籍中找到[134]，以及
    Marchisio 的书籍中找到[315]。
  prefs: []
  type: TYPE_NORMAL
- en: ¹ 有时，当问题背景已知时，问题实例本身简称为“问题”。
  prefs: []
  type: TYPE_NORMAL
- en: ² 更确切地说，只有决策问题——即具有“是/否”答案的问题——才能是 NP 完全的。旅行推销员问题的决策版本询问是否存在一种顺序的停靠点，其距离总和最多为给定数量。
  prefs: []
  type: TYPE_NORMAL
