- answer: '-   **`17        扩充数据结构`**'
  en: '**17        扩充数据结构**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **17        扩充数据结构**  输出：'
  type: TYPE_NORMAL
- answer: '-   有些解决方案只需要一个“教科书”数据结构——比如双向链表、哈希表或二叉搜索树——但许多其他解决方案需要一点创造力。很少需要创建全新类型的数据结构，更常见的是在其中存储额外信息来扩充教科书数据结构。然后，你可以为数据结构编写新的操作以支持你的应用程序。然而，扩充数据结构并不总是直截了当的，因为添加信息必须由数据结构上的普通操作更新和维护。'
  en: 有些解决方案只需要一个“教科书”数据结构——比如双向链表、哈希表或二叉搜索树——但许多其他解决方案需要一点创造力。很少需要创建全新类型的数据结构，更常见的是在其中存储额外信息来扩充教科书数据结构。然后，你可以为数据结构编写新的操作以支持你的应用程序。然而，扩充数据结构并不总是直截了当的，因为添加��信息必须由数据结构上的普通操作更新和维护。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   有些解决方案只需要一个“教科书”数据结构——比如双向链表、哈希表或二叉搜索树——但许多其他解决方案需要一点创造力。很少需要创建全新类型的数据结构，更常见的是在其中存储额外信息来扩充教科书数据结构。然后，你可以为数据结构编写新的操作以支持你的应用程序。然而，扩充数据结构并不总是直截了当的，因为添加��信息必须由数据结构上的普通操作更新和维护。  输出：'
  type: TYPE_NORMAL
- answer: '-   本章讨论了基于红黑树的两种附加信息的数据结构。第 17.1 节描述了一个支持动态集合上的一般顺序统计操作的数据结构：快速找到第 `i`
    小的数字或给定元素的秩。第 17.2 节抽象了附加数据结构的过程，并提供了一个定理，当附加红黑树时可以使用。第 17.3 节使用这个定理来帮助设计一个用于维护动态区间集合（如时间区间）的数据结构。你可以使用这个数据结构快速找到与给定查询区间重叠的区间。'
  en: 本章讨论了基于红黑树的两种附加信息的数据结构。第 17.1 节描述了一个支持动态集合上的一般顺序统计操作的数据结构：快速找到第 *i* 小的数字或给定元素的秩。第
    17.2 节抽象了附加数据结构的过程，并提供了一个定理，当附加红黑树时可以使用。第 17.3 节使用这个定理来帮助设计一个用于维护动态区间集合（如时间区间）的数据结构。你可以使用这个数据结构快速找到与给定查询区间重叠的区间。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   本章讨论了基于红黑树的两种附加信息的数据结构。第
    17.1 节描述了一个支持动态集合上的一般顺序统计操作的数据结构：快速找到第 *i* 小的数字或给定元素的秩。第 17.2 节抽象了附加数据结构的过程，并提供了一个定理，当附加红黑树时可以使用。第
    17.3 节使用这个定理来帮助设计一个用于维护动态区间集合（如时间区间）的数据结构。你可以使用这个数据结构快速找到与给定查询区间重叠的区间。  输出：'
  type: TYPE_NORMAL
- answer: ''
  en: '**17.1    动态顺序统计**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **17.1    动态顺序统计**  输出：'
  type: TYPE_NORMAL
- answer: '-   第九章介绍了顺序统计的概念。具体来说，对于一个包含 `n` 个元素的集合，第 `i` 个顺序统计，其中 `i` ∈ {1, 2, …
    , `n`}，就是集合中第 `i` 小的键对应的元素。在第九章中，你看到了如何从无序集合中在 `O(n)` 的时间内确定任意顺序统计。本节展示了如何修改红黑树，以便你可以在
    `O(lg n)` 的时间内确定动态集合中的任意顺序统计，并在 `O(lg n)` 的时间内计算元素的***秩***—即其在集合的线性顺序中的位置。'
  en: 第九章介绍了顺序统计的概念。具体来说，对于一个包含 *n* 个元素的集合，第 *i* 个顺序统计，其中 *i* ∈ {1, 2, … , *n*}，就是集合中第
    *i* 小的键对应的元素。在第九章中，你看到了如何从无序集合中在 *O*(*n*) 的时间内确定任意顺序统计。本节展示了如何修改红黑树，以便你可以在 *O*(lg
    *n*) 的时间内确定动态集合中的任意顺序统计，并在 *O*(lg *n*) 的时间内计算元素的***秩***—即其在集合的线性顺序中的位置。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   第九章介绍了顺序统计的概念。具体来说，对于一个包含
    *n* 个元素的集合，第 *i* 个顺序统计，其中 *i* ∈ {1, 2, … , *n*}，就是集合中第 *i* 小的键对应的元素。在第九章中，你看到了如何从无序集合中在
    *O*(*n*) 的时间内确定任意顺序统计。本节展示了如何修改红黑树，以便你可以在 *O*(lg *n*) 的时间内确定动态集合中的任意顺序统计，并在 *O*(lg
    *n*) 的时间内计算元素的***秩***—即其在集合的线性顺序中的位置。  输出：'
  type: TYPE_NORMAL
- answer: ''
  en: '![艺术](img/Art_P533.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P533.jpg)  输出：'
  type: TYPE_IMG
- answer: '-   **图 17.1** 一个顺序统计树，即一个附加信息的红黑树。除了通常的属性外，每个节点 `x` 还有一个属性 `x.size`，表示除哨兵外以
    `x` 为根的子树中的节点数。'
  en: '**图 17.1** 一个顺序统计树，即一个附加信息的红黑树。除了通常的属性外，每个节点 *x* 还有一个属性 *x*.*size*，表示除哨兵外以
    *x* 为根的子树中的节点数。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **图 17.1**
    一个顺序统计树，即一个附加信息的红黑树。除了通常的属性外，每个节点 *x* 还有一个属性 *x*.*size*，表示除哨兵外以 *x* 为根的子树中的节点数。  输出：'
  type: TYPE_NORMAL
- answer: '-   图 17.1 展示了一个可以支持快速顺序统计操作的数据结构。一个`***顺序统计树***` `T` 简单地是一个红黑树，每个节点中存储有额外的信息。每个节点
    `x` 包含了通常的红黑树属性 `x.key`、`x.color`、`x.p`、`x.left` 和 `x.right`，以及一个新属性 `x.size`。这个属性包含了以
    `x` 为根的子树中的内部节点数（包括 `x` 本身，但不包括任何哨兵节点），也就是子树的大小。如果我们定义哨兵的大小为 0——也就是说，我们将 `T.nil.size`
    设为 0——那么我们有以下等式'
  en: 图 17.1 展示了一个可以支持快速顺序统计操作的数据结构。一个***顺序统计树*** *T* 简单地是一个红黑树，每个节点中存储有额外的信息。每个节点
    *x* 包含了通常的红黑树属性 *x*.*key*、*x*.*color*、*x*.*p*、*x*.*left* 和 *x*.*right*，以及一个新属性
    *x*.*size*。这个属性包含了以 *x* 为根的子树中的内部节点数（包括 *x* 本身，但不包括任何哨兵节点），也就是子树的大小。如果我们定义哨兵的大小为
    0——也就是说，我们将 *T*.*nil*.*size* 设为 0——那么我们有以下等式
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   图 17.1 展示了一个可以支持快速顺序统计操作的数据结构。一个***顺序统计树***
    *T* 简单地是一个红黑树，每个节点中存储有额外的信息。每个节点 *x* 包含了通常的红黑树属性 *x*.*key*、*x*.*color*、*x*.*p*、*x*.*left*
    和 *x*.*right*，以及一个新属性 *x*.*size*。这个属性包含了以 *x* 为根的子树中的内部节点数（包括 *x* 本身，但不包括任何哨兵节点），也就是子树的大小。如果我们定义哨兵的大小为
    0——也就是说，我们将 *T*.*nil*.*size* 设为 0——那么我们有以下等式  输出：'
  type: TYPE_NORMAL
- answer: ''
  en: '*x*.*size* = *x*.*left*.*size* + *x*.*right*.*size* + 1.'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *x*.*size*
    = *x*.*left*.*size* + *x*.*right*.*size* + 1.  输出：'
  type: TYPE_NORMAL
- answer: '-   在顺序统计树中，键值不必是唯一的。例如，图 17.1 中的树有两个值为 `14` 的键和两个值为 `21` 的键。当存在相等的键时，上述秩的概念就不明确了。我们通过定义元素的秩为其在树的中序遍历中打印的位置来消除这种模糊性。例如，在图
    17.1 中，存储在黑色节点中的键 `14` 的秩为 `5`，存储在红色节点中的键 `14` 的秩为 `6`。'
  en: 在顺序统计树中，键值不必是唯一的。例如，图 17.1 中的树有两个值为 14 的键和两个值为 21 的键。当存在相等的键时，上述秩的概念就不明确了。我们通过定义元素的秩为其在树的中序遍历中打印的位置来消除这种模糊性。例如，在图
    17.1 中，存储在黑色节点中的键 14 的秩为 5，存储在红色节点中的键 14 的秩为 6。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   在顺序统计树中，键值不必是唯一的。例如，图
    17.1 中的树有两个值为 14 的键和两个值为 21 的键。当存在相等的键时，上述秩的概念就不明确了。我们通过定义元素的秩为其在树的中序遍历中打印的位置来消除这种模糊性。例如，在图
    17.1 中，存储在黑色节点中的键 14 的秩为 5，存储在红色节点中的键 14 的秩为 6。  输出：'
  type: TYPE_NORMAL
- answer: '-   `**检索具有给定秩的元素**`'
  en: '**检索具有给定秩的元素**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **检索具有给定秩的元素**  输出：'
  type: TYPE_NORMAL
- answer: '-   在展示如何在插入和删除过程中维护大小信息之前，让我们看看如何实现使用此额外信息的两个有序统计查询。我们从检索具有给定排名的元素的操作开始。下一页的
    OS-SELECT(`x`, `i`) 过程返回指向包含以 `x` 为根的子树中第 `i` 小键的节点的指针。要找到有序统计树 `T` 中第 `i` 小键的节点，调用
    OS-SELECT(`T`.`root`, `i`)。'
  en: 在展示如何在插入和删除过程中维护大小信息之前，让我们看看如何实现使用此额外信息的两个有序统计查询。我们从检索具有给定排名的元素的操作开始。下一页的 OS-SELECT(*x*,
    *i*) 过程返回指向包含以 *x* 为根的子树中第 *i* 小键的节点的指针。要找到有序统计树 *T* 中第 *i* 小键的节点，调用 OS-SELECT(*T*.*root*,
    *i*)。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   在展示如何在插入和删除过程中维护大小信息之前，让我们看看如何实现使用此额外信息的两个有序统计查询。我们从检索具有给定排名的元素的操作开始。下一页的
    OS-SELECT(*x*, *i*) 过程返回指向包含以 *x* 为根的子树中第 *i* 小键的节点的指针。要找到有序统计树 *T* 中第 *i* 小键的节点，调用
    OS-SELECT(*T*.*root*, *i*)。  输出：'
  type: TYPE_NORMAL
- answer: '-   这里是 OS-SELECT 的工作原理。第 1 行计算 `r`，即节点 `x` 在以 `x` 为根的子树中的排名。`x.left.size`
    的值是在以 `x` 为根的子树的中序遍历中在 `x` 之前的节点数。因此，`x.left.size + 1` 就是 `x` 在以 `x` 为根的子树中的排名。如果
    `i` = `r`，那么节点 `x` 就是第 `i` 小的元素，因此第 3 行返回 `x`。如果 `i < r`，那么第 `i` 小的元素位于 `x` 的左子树中，因此，第
    5 行递归调用 `x.left`。如果 `i > r`，那么第 `i` 小的元素位于 `x` 的右子树中。由于以 `x` 为根的子树中有 `r` 个元素在
    `x` 的右子树之前，因此以 `x` 为根的子树中的第 `i` 小元素就是以 `x.right` 为根的子树中的第 (`i` − `r`) 小元素。第 6
    行通过递归确定这个元素。'
  en: 这里是 OS-SELECT 的工作原理。第 1 行计算 *r*，即节点 *x* 在以 *x* 为根的子树中的排名。*x*.*left*.*size* 的值是在以
    *x* 为根的子树的中序遍历中在 *x* 之前的节点数。因此，*x*.*left*.*size* + 1 就是 *x* 在以 *x* 为根的子树中的排名。如果
    *i* = *r*，那么节点 *x* 就是第 *i* 小的元素，因此第 3 行返回 *x*。如果 *i < r*，那么第 *i* 小的元素位于 *x* 的左子树中，因此，第
    5 行递归调用 *x*.*left*。如果 *i > r*，那么第 *i* 小的元素位于 *x* 的右子树中。由于以 *x* 为根的子树中有 *r* 个元素在
    *x* 的右子树之前，因此以 *x* 为根的子树中的第 *i* 小元素就是以 *x*.*right* 为根的子树中的第 (*i* − *r*) 小元素。第
    6 行通过递归确定这个元素。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   这里是 OS-SELECT
    的工作原理。第 1 行计算 *r*，即节点 *x* 在以 *x* 为根的子树中的排名。*x*.*left*.*size* 的值是在以 *x* 为根的子树的中序遍历中在
    *x* 之前的节点数。因此，*x*.*left*.*size* + 1 就是 *x* 在以 *x* 为根的子树中的排名。如果 *i* = *r*，那么节点
    *x* 就是第 *i* 小的元素，因此第 3 行返回 *x*。如果 *i < r*，那么第 *i* 小的元素位于 *x* 的左子树中，因此，第 5 行递归调用
    *x*.*left*。如果 *i > r*，那么第 *i* 小的元素位于 *x* 的右子树中。由于以 *x* 为根的子树中有 *r* 个元素在 *x* 的右子树之前，因此以
    *x* 为根的子树中的第 *i* 小元素就是以 *x*.*right* 为根的子树中的第 (*i* − *r*) 小元素。第 6 行通过递归确定这个元素。  输出：'
  type: TYPE_NORMAL
- answer: '-   `OS-SELECT(x, i)`'
  en: OS-SELECT(*x*, *i*)
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   OS-SELECT(*x*,
    *i*)  输出：'
  type: TYPE_NORMAL
- answer: '-   | 1 | `r = x.left.size + 1` | **//** `x` 在以 `x` 为根的子树中的排名 |  '
  en: '| 1 | *r* = *x*.*left*.*size* + 1 | **//** *x* 在以 *x* 为根的子树中的排名 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 1 | *r* =
    *x*.*left*.*size* + 1 | **//** *x* 在以 *x* 为根的子树中的排名 |  输出：'
  type: TYPE_TB
- answer: '-   | --- | --- | --- |'
  en: '| --- | --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | --- | ---
    | --- |  输出：'
  type: TYPE_TB
- answer: '-   | `2` | **如果** *i* == *r* | '
  en: '| 2 | **如果** *i* == *r* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 2 | **如果**
    *i* == *r* |  输出：'
  type: TYPE_TB
- answer: '-   | `3` | **返回** *x* |  '
  en: '| 3 | **返回** *x* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 3 | **返回**
    *x* |  输出：'
  type: TYPE_TB
- answer: '-   `| 4 |` **否则如果** `i < r` |  '
  en: '| 4 | **否则如果** *i* < *r* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 4 | **否则如果**
    *i* < *r* |  输出：'
  type: TYPE_TB
- answer: '-   | `5` | **返回** `OS-SELECT(x.left, i)` |  '
  en: '| 5 | **返回** OS-SELECT(*x*.*left*, *i*) |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 5 | **返回**
    OS-SELECT(*x*.*left*, *i*) |  输出：'
  type: TYPE_TB
- answer: '---

    | 6 | **否则返回** OS-SELECT(`x.right`, `i` - `r`) |

    ---'
  en: '| 6 | **否则返回** OS-SELECT(*x*.*right*, *i* − *r*) |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 6 | **否则返回**
    OS-SELECT(*x*.*right*, *i* − *r*) |  输出：'
  type: TYPE_TB
- answer: '-   以 OS-SELECT 如何运作为例，考虑在图 17.1 的有序统计树中搜索第 17 小的元素。搜索从根 `x` 开始，其键为 26，`i`
    = 17。由于 26 的左子树大小为 12，其排名为 13。因此，排名为 17 的节点是 26 的右子树中的第 17 − 13 = 4 小元素。在递归调用中，`x`
    是键为 41 的节点，`i` = 4。由于 41 的左子树大小为 5，其在子树中的排名为 6。因此，排名为 4 的节点是 41 的左子树中的第 4 小元素。在递归调用中，`x`
    是键为 30 的节点，其在子树中的排名为 2。过程再次递归以找到根为键为 38 的节点子树中的第 4 − 2 = 2 小元素。其左子树大小为 1，这意味着它是第二小的元素。因此，过程返回键为
    38 的节点的指针。'
  en: 以 OS-SELECT 如何运作为例，考虑在图 17.1 的有序统计树中搜索第 17 小的元素。搜索从根 *x* 开始，其键为 26，*i* = 17。由于
    26 的左子树大小为 12，其排名为 13。因此，排名为 17 的节点是 26 的右子树中的第 17 − 13 = 4 小元素。在递归调用中，*x* 是键为
    41 的节点，*i* = 4。由于 41 的左子树大小为 5，其在子树中的排名为 6。因此，排名为 4 的节点是 41 的左子树中的第 4 小元素。在递归调用中，*x*
    是键为 30 的节点，其在子树中的排名为 2。过程再次递归以找到根为键为 38 的节点子树中的第 4 − 2 = 2 小元素。其左子树大小为 1，这意味着它是第二小的元素。因此，过程返回键为
    38 的节点的指针。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   以 OS-SELECT
    如何运作为例，考虑在图 17.1 的有序统计树中搜索第 17 小的元素。搜索从根 *x* 开始，其键为 26，*i* = 17。由于 26 的左子树大小为
    12，其排名为 13。因此，排名为 17 的节点是 26 的右子树中的第 17 − 13 = 4 小元素。在递归调用中，*x* 是键为 41 的节点，*i*
    = 4。由于 41 的左子树大小为 5，其在子树中的排名为 6。因此，排名为 4 的节点是 41 的左子树中的第 4 小元素。在递归调用中，*x* 是键为
    30 的节点，其在子树中的排名为 2。过程再次递归以找到根为键为 38 的节点子树中的第 4 − 2 = 2 小元素。其左子树大小为 1，这意味着它是第二小的元素。因此，过程返回键为
    38 的节点的指针。  输出：'
  type: TYPE_NORMAL
- answer: '-   因为每次递归调用都会在有序统计树中下降一层，所以 `OS-SELECT` 的总时间最坏情况下与树的高度成比例。由于树是红黑树，其高度为
    `O(lg n)`，其中 `n` 是节点数。因此，`OS-SELECT` 的运行时间为 `O(lg n)`，对于包含 `n` 个元素的动态集合。'
  en: 因为每次递归调用都会在有序统计树中下降一层，所以 OS-SELECT 的总时间最坏情况下与树的高度成比例。由于树是红黑树，其高度为 *O*(lg *n*)，其中
    *n* 是节点数。因此，OS-SELECT 的运行时间为 *O*(lg *n*)，对于包含 *n* 个元素的动态集合。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   因为每次递归调用都会在有序统计树中下降一层，所以
    OS-SELECT 的总时间最坏情况下与树的高度成比例。由于树是红黑树，其高度为 *O*(lg *n*)，其中 *n* 是节点数。因此，OS-SELECT
    的运行时间为 *O*(lg *n*)，对于包含 *n* 个元素的动态集合。  输出：'
  type: TYPE_NORMAL
- answer: '-   **确定元素的排名**'
  en: '**确定元素的排名**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **确定元素的排名**  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   给定有序统计树 `T` 中节点 `x` 的指针，面向页面的 OS-RANK 过程返回 `x` 在由 `T` 的中序遍历确定的线性顺序中的位置。'
  en: 给定有序统计树 *T* 中节点 *x* 的指针，面向页面的 OS-RANK 过程返回 *x* 在由 *T* 的中序遍历确定的线性顺序中的位置。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   给定有序统计树 *T*
    中节点 *x* 的指针，面向页面的 OS-RANK 过程返回 *x* 在由 *T* 的中序遍历确定的线性顺序中的位置。  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   OS-RANK(`T`, `x`)

    ---'
  en: OS-RANK(*T*, *x*)
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   OS-RANK(*T*,
    *x*)  输出：'
  type: TYPE_NORMAL
- answer: '-   | 1 | *r* = `x.left.size` + 1 | **//** *x* 在以 *x* 为根的子树中的排名 |  '
  en: '| 1 | *r* = *x*.*left*.*size* + 1 | **//** *x* 在以 *x* 为根的子树中的排名 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 1 | *r* =
    *x*.*left*.*size* + 1 | **//** *x* 在以 *x* 为根的子树中的排名 |  输出：'
  type: TYPE_TB
- answer: '-   | --- | --- | --- |

    -   | --- | --- | --- |'
  en: '| --- | --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | --- | ---
    | --- |  输出：'
  type: TYPE_TB
- answer: '-   | `2` | *y* = *x* | **//** 正在检查的子树的根 |'
  en: '| 2 | *y* = *x* | **//** 正在检查的子树的根 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 2 | *y* =
    *x* | **//** 正在检查的子树的根 |  输出：'
  type: TYPE_TB
- answer: '-   \|   | `3` | **当** *y* ≠ ≠ `T.root` **时** \|  '
  en: '| 3 | **当** *y* ≠ *T*.*root* **时** |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 3 | **当**
    *y* ≠ *T*.*root* **时** |  输出：'
  type: TYPE_TB
- answer: '-   | `4` | **如果** `y` == `y.p.right` |  | **//** 如果是右子树的根 … |'
  en: '| 4 | **如果** *y* == *y*.*p*.*right* |  | **//** 如果是右子树的根 … |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 4 | **如果**
    *y* == *y*.*p*.*right* |  | **//** 如果是右子树的根 … |  输出：'
  type: TYPE_TB
- answer: '---

    -   | `5` | `r = r + y.p.left.size + 1` |  | **//** … 加上父节点及其左子树 | '
  en: '| 5 | *r* = *r* + *y*.*p*.*left*.*size* + 1 |  | **//** … 加上父节点及其左子树 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 5 | *r* =
    *r* + *y*.*p*.*left*.*size* + 1 |  | **//** … 加上父节点及其左子树 |  输出：'
  type: TYPE_TB
- answer: '-   | 6 | `y = y.p` |  | **//** 向根移动 y | '
  en: '| 6 | *y* = *y*.*p* |  | **//** 向根移动 *y* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 6 | *y* =
    *y*.*p* |  | **//** 向根移动 *y* |  输出：'
  type: TYPE_TB
- answer: '-   | 7 | **返回** `r` |  '
  en: '| 7 | **返回** *r* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 7 | **返回**
    *r* |  输出：'
  type: TYPE_TB
- answer: '-   OS-RANK 过程的工作原理如下。你可以将节点 `x` 的排名看作是在中序遍历中 `x` 之前的节点数加上 `x` 本身的数量。OS-RANK
    保持以下循环不变性：'
  en: OS-RANK 过程的工作原理如下。你可以将节点 *x* 的排名看作是在中序遍历中 *x* 之前的节点数加上 *x* 本身的数量。OS-RANK 保持以下循环不变性：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   OS-RANK 过程的工作原理如下。你可以将节点
    *x* 的排名看作是在中序遍历中 *x* 之前的节点数加上 *x* 本身的数量。OS-RANK 保持以下循环不变性：  输出：'
  type: TYPE_NORMAL
- answer: '-   在第 3-6 行的 **`while`** 循环的每次迭代开始时，`r` 是 `y` 节点根的子树中 `x.key` 的排名。'
  en: 在第 3-6 行的 **while** 循环的每次迭代开始时，*r* 是 *y* 节点根的子树中 *x*.*key* 的排名。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   在第 3-6 行的 **while**
    循环的每次迭代开始时，*r* 是 *y* 节点根的子树中 *x*.*key* 的排名。  输出：'
  type: TYPE_NORMAL
- answer: '---

    我们使用这个循环不变式来展示 OS-RANK 的正确性如下：

    ---'
  en: 我们使用这个循环不变式来展示 OS-RANK 的正确性如下：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   我们使用这个循环不变式来展示
    OS-RANK 的正确性如下：  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   **初始化：** 在第一次迭代之前，第 1 行将 `r` 设置为 `x.key` 在以 `x` 为根的子树中的排名。在第 2 行中将 `y` = `x`
    使得第 3 行的测试第一次执行时不变式成立。'
  en: '**初始化：** 在第一次迭代之前，第 1 行将 *r* 设置为 *x*.*key* 在以 *x* 为根的子树中的排名。在第 2 行中将 *y* =
    *x* 使得第 3 行的测试第一次执行时不变式成立。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **初始化：** 在第一次迭代之前，第
    1 行将 *r* 设置为 *x*.*key* 在以 *x* 为根的子树中的排名。在第 2 行中将 *y* = *x* 使得第 3 行的测试第一次执行时不变式成立。  输出：'
  type: TYPE_NORMAL
- answer: '-   **维护：** 在 **while** 循环的每次迭代结束时，第 6 行将 `y = y.p`。因此，我们必须证明如果 *r* 是循环体开始时
    *y* 为根的子树中 *x*.`key` 的排名，那么循环体结束时 *r* 是 `y.p` 为根的子树中 *x*.`key` 的排名。在 **while**
    循环的每次迭代中，考虑以 `y.p` 为根的子树。*r* 的值已经包括了在中序遍历中在节点 *y* 之前的节点数，因此过程必须添加在 *y* 的兄弟节点中在中序遍历中在
    *x* 之前的节点数，再加上 1 个 `y.p` 如果它也在 *x* 之前。如果 *y* 是左子节点，则 `y.p` 或 `y.p` 的右子树中的任何节点都不在
    *x* 之前，因此 OS-RANK 不会改变 *r*。否则，*y* 是右子节点，`y.p` 的左子树中的所有节点都在 *x* 之前，`y.p` 本身也在 *x*
    之前。在这种情况下，第 5 行将 `y.p.left.size + 1` 添加到 *r* 的当前值。'
  en: '**维护：** 在 **while** 循环的每次迭代结束时，第 6 行将 *y* = *y*.*p*。因此，我们必须证明如果 *r* 是循环体开始时
    *y* 为根的子树中 *x*.*key* 的排名，那么循环体结束时 *r* 是 *y*.*p* 为根的子树中 *x*.*key* 的排名。在 **while**
    循环的每次迭代中，考虑以 *y*.*p* 为根的子树。*r* 的值已经包括了在中序遍历中在节点 *y* 之前的节点数，因此过程必须添加在 *y* 的兄弟节点中在中序遍历中在
    *x* 之前的节点数，再加上 1 个 *y*.*p* 如果它也在 *x* 之前。如果 *y* 是左子节点，则 *y*.*p* 或 *y*.*p* 的右子树中的任何节点都不在
    *x* 之前，因此 OS-RANK 不会改变 *r*。否则，*y* 是右子节点，*y*.*p* 的左子树中的所有节点都在 *x* 之前，*y*.*p* 本身也在
    *x* 之前。在这种情况下，第 5 行将 *y*.*p*.*left*.*size* + 1 添加到 *r* 的当前值。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **维护：** 在 **while**
    循环的每次迭代结束时，第 6 行将 *y* = *y*.*p*。因此，我们必须证明如果 *r* 是循环体开始时 *y* 为根的子树中 *x*.*key* 的排名，那么循环体结束时
    *r* 是 *y*.*p* 为根的子树中 *x*.*key* 的排名。在 **while** 循环的每次迭代中，考虑以 *y*.*p* 为根的子树。*r*
    的值已经包括了在中序遍历中在节点 *y* 之前的节点数，因此过程必须添加在 *y* 的兄弟节点中在中序遍历中在 *x* 之前的节点数，再加上 1 个 *y*.*p*
    如果它也在 *x* 之前。如果 *y* 是左子节点，则 *y*.*p* 或 *y*.*p* 的右子树中的任何节点都不在 *x* 之前，因此 OS-RANK
    不会改变 *r*。否则，*y* 是右子节点，*y*.*p* 的左子树中的所有节点都在 *x* 之前，*y*.*p* 本身也在 *x* 之前。在这种情况下，第
    5 行将 *y*.*p*.*left*.*size* + 1 添加到 *r* 的当前值。  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   **终止：** 因为循环的每次迭代都将 `y` 向根移动，当 `y` = `T.root` 时循环终止。此外，以 `y` 为根的子树就是整棵树。因此，`r`
    的值就是 `x.key` 在整棵树中的排名。'
  en: '**终止：** 因为循环的每次迭代都将 *y* 向根移动，当 *y* = *T*.*root* 时循环终止。此外，以 *y* 为根的子树就是整棵树。因此，*r*
    的值就是 *x*.*key* 在整棵树中的排名。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **终止：** 因为循环的每次迭代都将
    *y* 向根移动，当 *y* = *T*.*root* 时循环终止。此外，以 *y* 为根的子树就是整棵树。因此，*r* 的值就是 *x*.*key* 在整棵树中的排名。  输出：'
  type: TYPE_NORMAL
- answer: '-   举个例子，当 OS-RANK 在 图 17.1 的顺序统计树上运行以找到关键字为 38 的节点的排名时，在 **`while`** 循环的顶部发生以下
    `y.key` 和 `r` 值的序列：'
  en: 举个例子，当 OS-RANK 在 图 17.1 的顺序统计树上运行以找到关键字为 38 的节点的排名时，在 **while** 循环的顶部发生以下 *y*.*key*
    和 *r* 值的序列：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   举个例子，当 OS-RANK
    在 图 17.1 的顺序统计树上运行以找到关键字为 38 的节点的排名时，在 **while** 循环的顶部发生以下 *y*.*key* 和 *r* 值的序列：  输出：'
  type: TYPE_NORMAL
- answer: '-   | 迭代 | `y.key` | `r` |  '
  en: '| 迭代 | *y*.*key* | *r* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 迭代 | *y*.*key*
    | *r* |  输出：'
  type: TYPE_TB
- answer: '```

    | --- | --- | --- |

    ```'
  en: '| --- | --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | --- | ---
    | --- |  输出：'
  type: TYPE_TB
- answer: '```

    -   | 1 | 38 | 2 |

    ```'
  en: '| 1 | 38 | 2 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 1 | 38 |
    2 |  输出：'
  type: TYPE_TB
- answer: '-   | `2` | `30` | `4` |  '
  en: '| 2 | 30 | 4 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 2 | 30 |
    4 |  输出：'
  type: TYPE_TB
- answer: '-   | `3` | `41` | `4` |  '
  en: '| 3 | 41 | 4 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 3 | 41 |
    4 |  输出：'
  type: TYPE_TB
- answer: '```

    -   | `4` | `26` | `17` |

    ```'
  en: '| 4 | 26 | 17 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 4 | 26 |
    17 |  输出：'
  type: TYPE_TB
- answer: '-   过程返回排名 `17`。'
  en: 过程返回排名 17。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   过程返回排名 17。  输出：'
  type: TYPE_NORMAL
- en: 由于 **while** 循环的每次迭代都需要 *O*(1) 时间，并且 *y* 每次迭代在树中上升一级，因此 OS-RANK 的运行时间最坏情况下与树的高度成正比：在一个
    *n* 个节点的顺序统计树上为 *O*(lg *n*)。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   由于 **while**
    循环的每次迭代都需要 *O*(1) 时间，并且 *y* 每次迭代在树中上升一级，因此 OS-RANK 的运行时间最坏情况下与树的高度成正比：在一个 *n*
    个节点的顺序统计树上为 *O*(lg *n*)。  输出：'
  type: TYPE_NORMAL
- answer: '-   **`维护子树大小`**'
  en: '**维护子树大小**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **维护子树大小**  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   给定每个节点中的 `size` 属性，OS-SELECT 和 OS-RANK 可以快速计算顺序统计信息。但是，如果红黑树上的基本修改操作不能有效地维护
    `size` 属性，那么我们的工作将毫无意义。让我们看看如何在不影响这两个操作的渐近运行时间的情况下维护插入和删除的子树大小。'
  en: 给定每个节点中的 *size* 属性，OS-SELECT 和 OS-RANK 可以快速计算顺序统计信息。但是，如果红黑树上的基本修改操作不能有效地维护
    *size* 属性，那么我们的工作将毫无意义。让我们看看如何在不影响这两个操作的渐近运行时间的情况下维护插入和删除的子树大小。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   给定每个节点中的 *size*
    属性，OS-SELECT 和 OS-RANK 可以快速计算顺序统计信息。但是，如果红黑树上的基本修改操作不能有效地维护 *size* 属性，那么我们的工作将毫无意义。让我们看看如何在不影响这两个操作的渐近运行时间的情况下维护插入和删除的子树大小。  输出：'
  type: TYPE_NORMAL
- answer: '-   从 第 13.3 节 回顾插入到红黑树中的过程包括两个阶段。第一阶段从根节点向下遍历树，将新节点插入为现有节点的子节点。第二阶段向上遍历树，改变颜色并执行旋转以保持红黑属性。  '
  en: 从 第 13.3 节 回顾插入到红黑树中的过程包括两个阶段。第一阶段从根节点向下遍历树，将新节点插入为现有节点的子节点。第二阶段向上遍历树，改变颜色并执行旋转以保持红黑属性。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   从 第 13.3 节
    回顾插入到红黑树中的过程包括两个阶段。第一阶段从根节点向下遍历树，将新节点插入为现有节点的子节点。第二阶段向上遍历树，改变颜色并执行旋转以保持红黑属性。  输出：'
  type: TYPE_NORMAL
- answer: '-   在第一阶段中为了维护子树大小，只需对从根向叶子遍历的简单路径上的每个节点 `x` 递增 `x.size`。新添加的节点得到一个 `size`
    为 1。由于在遍历路径上有 `O(lg n)` 个节点，因此维护 `size` 属性的额外成本为 `O(lg n)`。'
  en: 在第一阶段中为了维护子树大小，只需对从根向叶子遍历的简单路径上的每个节点 *x* 递增 *x*.*size*。新添加的节点得到一个 *size* 为 1。由于在遍历路径上有
    *O*(lg *n*) 个节点，因此维护 *size* 属性的额外成本为 *O*(lg *n*)。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   在第一阶段中为了维护子树大小，只需对从根向叶子遍历的简单路径上的每个节点
    *x* 递增 *x*.*size*。新添加的节点得到一个 *size* 为 1。由于在遍历路径上有 *O*(lg *n*) 个节点，因此维护 *size*
    属性的额外成本为 *O*(lg *n*)。  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   在第二阶段中，底层红黑树的唯一结构更改是由旋转引起的，最多有两次旋转。此外，旋转是一个局部操作：只有两个节点的 `size` 属性会失效。旋转围绕的链接作用于这两个节点。参考第
    336 页的 LEFT-ROTATE(`T`, `x`) 代码，添加以下行：'
  en: 在第二阶段中，底层红黑树的唯一结构更改是由旋转引起的，最多有两次旋转。此外，旋转是一个局部操作：只有两个节点的 *size* 属性会失效。旋转围绕的链接作用于这两个节点。参考第
    336 页的 LEFT-ROTATE(*T*, *x*) 代码，添加以下行：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   在第二阶段中，底层红黑树的唯一结构更改是由旋转引起的，最多有两次旋转。此外，旋转是一个局部操作：只有两个节点的
    *size* 属性会失效。旋转围绕的链接作用于这两个节点。参考第 336 页的 LEFT-ROTATE(*T*, *x*) 代码，添加以下行：  输出：'
  type: TYPE_NORMAL
- answer: '-   `| 13 | y.size = x.size |`  '
  en: '| 13 | *y*.*size* = *x*.*size* |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 13 | *y*.*size*
    = *x*.*size* |  输出：'
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | --- | ---
    |  输出：'
  type: TYPE_TB
- answer: '---

    -   | 14 | `x.size = x.left.size + x.right.size + 1` | '
  en: '| 14 | *x*.*size* = *x*.*left*.*size* + *x*.*right*.*size* + 1 |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | 14 | *x*.*size*
    = *x*.*left*.*size* + *x*.*right*.*size* + 1 |  输出：'
  type: TYPE_TB
- answer: '-   图 17.2 展示了属性如何更新。对`RIGHT-ROTATE`的更改是对称的。'
  en: 图 17.2 展示了属性如何更新。对 RIGHT-ROTATE 的更改是对称的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   图 17.2 展示了属性如何更新。对
    RIGHT-ROTATE 的更改是对称的。  输出：'
  type: TYPE_NORMAL
- answer: '-   由于插入红黑树最多需要两次旋转，第二阶段中更新`size`属性只需额外`O(1)`的时间。因此，插入到`n`节点顺序统计树的总时间为`O(lg
    n)`，这在渐近意义上与普通红黑树相同。'
  en: 由于插入红黑树最多需要两次旋转，第二阶段中更新*size*属性只需额外*O*(1)的时间。因此，插入到*n*节点顺序统计树的总时间为*O*(lg *n*)，这在渐近意义上与普通红黑树相同。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   由于插入红黑树最多需要两次旋转，第二阶段中更新*size*属性只需额外*O*(1)的时间。因此，插入到*n*节点顺序统计树的总时间为*O*(lg
    *n*)，这在渐近意义上与普通红黑树相同。  输出：'
  type: TYPE_NORMAL
- answer: '---

    输入：

    -   ![艺术](img/Art_P534.jpg)


    输出：'
  en: '![艺术](img/Art_P534.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P534.jpg)  输出：'
  type: TYPE_IMG
- answer: '---

    -   **图 17.2** 旋转期间更新子树大小。更新是局部的，只需要`x`、`y`和三角形表示的子树根中存储的`size`信息。'
  en: '**图 17.2** 旋转期间更新子树大小。更新是局部的，只需要*x*、*y*和三角形表示的子树根中存储的*size*信息。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **图 17.2**
    旋转期间更新子树大小。更新是局部的，只需要*x*、*y*和三角形表示的子树根中存储的*size*信息。  输出：'
  type: TYPE_NORMAL
- en: 从红黑树中删除也包括两个阶段：第一个在基础搜索树上操作，第二个最多进行三次旋转，否则不进行结构更改。（参见第 13.4 节。）第一阶段从树中移除一个节点*z*，最多可能将其他两个节点移动到树中（图
    12.4 中的节点*y*和*x*）。要更新子树大小，只需沿着从移动的最低节点（从其原始位置开始）到根的简单路径遍历，递减路径上每个节点的*size*属性。由于在*n*节点红黑树中，这条路径的长度为*O*(lg
    *n*)，在第一阶段中花费的额外时间维护*size*属性为*O*(lg *n*)。对于删除的第二阶段中的*O*(1)次旋转，处理方式与插入相同。因此，对于*n*节点顺序统计树，包括维护*size*属性，插入和删除都需要*O*(lg
    *n*)的时间。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   从红黑树中删除也包括两个阶段：第一个在基础搜索树上操作，第二个最多进行三次旋转，否则不进行结构更改。（参见第
    13.4 节。）第一阶段从树中移除一个节点*z*，最多可能将其他两个节点移动到树中（图 12.4 中的节点*y*和*x*）。要更新子树大小，只需沿着从移动的最低节点（从其原始位置开始）到根的简单路径遍历，递减路径上每个节点的*size*属性。由于在*n*节点红黑树中，这条路径的长度为*O*(lg
    *n*)，在第一阶段中花费的额外时间维护*size*属性为*O*(lg *n*)。对于删除的第二阶段中的*O*(1)次旋转，处理方式与插入相同。因此，对于*n*节点顺序统计树，包括维护*size*属性，插入和删除都需要*O*(lg
    *n*)的时间。  输出：'
  type: TYPE_NORMAL
- en: '**练习**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **练习**  输出：'
  type: TYPE_NORMAL
- answer: '-   ***17.1-1***'
  en: '***17.1-1***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***17.1-1***  输出：'
  type: TYPE_NORMAL
- en: 展示 OS-SELECT(*T*.*root*, 10)如何在红黑树*T*（见图 17.1）上操作。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   展示 OS-SELECT(*T*.*root*,
    10)如何在红黑树*T*（见图 17.1）上操作。  输出：'
  type: TYPE_NORMAL
- answer: '-   `17.1-2`'
  en: '***17.1-2***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***17.1-2***  输出：'
  type: TYPE_NORMAL
- en: 展示 OS-RANK(*T*, *x*)如何在红黑树*T*（见图 17.1）和节点*x*（*x*.*key* = 35）上操作。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   展示 OS-RANK(*T*,
    *x*)如何在红黑树*T*（见图 17.1）和节点*x*（*x*.*key* = 35）上操作。  输出：'
  type: TYPE_NORMAL
- en: '***17.1-3***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***17.1-3***  输出：'
  type: TYPE_NORMAL
- en: 编写 OS-SELECT 的非递归版本。
  prefs: []
  type: TYPE_NORMAL
- en: '***17.1-4***'
  prefs: []
  type: TYPE_NORMAL
- en: 编写一个过程 OS-KEY-RANK(*T*, *k*)，接受一个顺序统计树*T*和一个关键字*k*，返回*T*表示的动态集合中*k*的秩。假设*T*的关键字是不同的。
  prefs: []
  type: TYPE_NORMAL
- en: '***17.1-5***'
  prefs: []
  type: TYPE_NORMAL
- en: 给定*n*节点顺序统计树中的元素*x*和自然数*i*，展示如何在树的线性顺序中以*O*(lg *n*)时间确定*x*的第*i*个后继。
  prefs: []
  type: TYPE_NORMAL
- en: '***17.1-6***'
  prefs: []
  type: TYPE_NORMAL
- en: 过程 OS-SELECT 和 OS-RANK 仅使用节点的*size*属性来计算秩。假设在每个节点中存储其在其为根的子树中的秩，而不是*size*属性。展示如何在插入和删除期间维护此信息。（请记住这两个操作可能会导致旋转。）
  prefs: []
  type: TYPE_NORMAL
- en: '***17.1-7***'
  prefs: []
  type: TYPE_NORMAL
- en: 展示如何使用顺序统计树在*O*(*n* lg *n*)时间内计算数组中*n*个不同元素的逆序对数（参见第 47 页的问题 2-4）。
  prefs: []
  type: TYPE_NORMAL
- en: ★ ***17.1-8***
  prefs: []
  type: TYPE_NORMAL
- en: 在圆上考虑*n*条弦，每条弦由其端点定义。描述一个*O*(*n* lg *n*)时间复杂度的算法，用于确定圆内相交的弦对数。（例如，如果*n*条弦都是直径，相交于中心，则答案是![艺术](img/Art_P535.jpg)。）假设没有两条弦共享一个端点。
  prefs: []
  type: TYPE_NORMAL
- en: '**17.2    如何增强数据结构**'
  prefs: []
  type: TYPE_NORMAL
- en: 增强基本数据结构以支持额外功能的过程在算法设计中经常发生。我们将在下一节中再次使用它来设计支持区间操作的数据结构。本节探讨了这种增强所涉及的步骤。它包括一个有用的定理，允许您在许多情况下轻松增强红黑树。
  prefs: []
  type: TYPE_NORMAL
- en: 你可以将增强数据结构的过程分为四个步骤：
  prefs: []
  type: TYPE_NORMAL
- en: 选择一个基础数据结构。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 确定要在基础数据结构中维护的额外信息。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 验证您可以在基础数据结构的基本修改操作中维护额外信息。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 开发新操作。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 与任何规范性设计方法一样，您很少能够按照给定顺序精确地遵循这些步骤。大多数设计工作都包含试验和错误的元素，通常所有步骤的进展都是并行的。例如，如果您无法有效地维护��外信息，那么确定额外信息和开发新操作（步骤
    2 和 4）就没有意义。尽管如此，这四步方法为您在增强数据结构方面的努力提供了一个很好的焦点，也是记录增强数据结构的良好框架。
  prefs: []
  type: TYPE_NORMAL
- en: 我们在第 17.1 节中遵循了这四个步骤来设计顺序统计树。在第 1 步中，我们选择红黑树作为基础数据结构。红黑树似乎是一个很好的起点，因为它们有效地支持总序上的其他动态集合操作，如
    MINIMUM、MAXIMUM、SUCCESSOR 和 PREDECESSOR。
  prefs: []
  type: TYPE_NORMAL
- en: 在第 2 步中，我们添加了*size*属性，这样每个节点*x*都存储以*x*为根的子树的大小。通常，额外信息使操作更有效率。例如，可以仅使用树中存储的键来实现
    OS-SELECT 和 OS-RANK，但这样它们不会在*O*(lg *n*)时间内运行。有时，额外信息是指针信息而不是数据，就像在练习 17.2-1 中一样。
  prefs: []
  type: TYPE_NORMAL
- en: 对于第 3 步，我们确保插入和删除可以在仍然在*O*(lg *n*)时间内维护*size*属性。理想情况下，您希望仅更新数据结构的少数元素以维护额外信息。例如，如果每个节点仅存储其在树中的排名，那么
    OS-SELECT 和 OS-RANK 过程将快速运行，但插入一个新的最小元素可能会导致树中每个节点的信息发生变化。因为我们选择存储子树大小，插入新元素只会导致*O*(lg
    *n*)个节点的信息发生变化。
  prefs: []
  type: TYPE_NORMAL
- en: 在第 4 步中，我们开发了操作 OS-SELECT 和 OS-RANK。毕竟，需要新操作是任何人首先考虑增强数据结构的原因。有时，而不是开发新操作，您可以使用额外信息来加快现有操作，就像在练习
    17.2-1 中一样。
  prefs: []
  type: TYPE_NORMAL
- en: '**增强红黑树**'
  prefs: []
  type: TYPE_NORMAL
- en: 当红黑树作为增强数据结构的基础时，我们可以证明插入和删除总是可以有效地维护某些额外信息，从而简化第 3 步。以下定理的证明类似于第 17.1 节中的论证，我们可以为顺序统计树维护*size*属性。
  prefs: []
  type: TYPE_NORMAL
- en: '***定理 17.1（增强红黑树）***'
  prefs: []
  type: TYPE_NORMAL
- en: 设*f*是增强了一个包含*n*个节点的红黑树*T*的属性，假设每个节点*x*的*f*值仅取决于节点*x*、*x*.*left*和*x*.*right*中的信息（可能包括*x*.*left*.*f*和*x*.*right*.*f*），并且*x*.*f*的值可以在*O*(1)时间内从这些信息中计算出来。那么，插入和删除操作可以在不影响这些操作的*O*(lg
    *n*)运行时间的情况下，维护*T*中所有节点的*f*值。
  prefs: []
  type: TYPE_NORMAL
- en: '***证明*** 主要思想是，对节点*x*中的*f*属性的更改仅传播到树中*x*的祖先。也就是说，更改*x*.*f*可能需要更新*x*.*p*.*f*，但不需要更新其他任何内容；更新*x*.*p*.*f*可能需要更新*x*.*p*.*p*.*f*，但不需要更新其他任何内容；依此类推直至树的顶部。在更新*T*.*root*.*f*后，没有其他节点依赖于新值，因此过程终止。由于红黑树的高度为*O*(lg
    *n*)，在更新所有依赖于更改的节点时，更改节点中的*f*属性的成本为*O*(lg *n*)时间。'
  prefs: []
  type: TYPE_NORMAL
- en: 正如我们在第 13.3 节中看到的，将节点*x*插入红黑树*T*包括两个阶段。如果树*T*为空，则第一阶段只需使*x*成为*T*的根。如果*T*不为空，则第一阶段将*x*插入为现有节点的子节点。因为我们假设*x*.*f*的值仅取决于*x*本身的其他属性和*x*的子节点中的信息，并且因为*x*的子节点都是哨兵*T*.*nil*，所以计算*x*.*f*的值仅需*O*(1)时间。计算完*x*.*f*后，更改向上传播到树中。因此，插入的第一阶段的总时间为*O*(lg
    *n*)。在第二阶段，树的结构更改仅来自旋转。由于旋转只更改两个节点，但更改属性可能需要向上传播到根，因此每次旋转更新*f*属性的总时间为*O*(lg *n*)。由于插入期间旋转的次数最多为两次，因此插入的总时间为*O*(lg
    *n*)。
  prefs: []
  type: TYPE_NORMAL
- en: 与插入类似，删除有两个阶段，如第 13.4 节所述。在第一阶段，当删除节点时，树发生更改，最多有两个其他节点可能在树中移动。由于这些更改沿着从最低更改节点到根的简单路径在树中局部修改树，因此由于这些更改导致的*f*的更新最多花费*O*(lg
    *n*)。在第二阶段修复红黑树时，最多需要三次旋转，每次旋转最多需要*O*(lg *n*)时间来传播*f*的更新。因此，与插入类似，删除的总时间为*O*(lg
    *n*)。
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: 在许多情况下，例如在顺序统计树中维护*size*属性时，旋转后的更新成本为*O*(1)，而不是定理 17.1 证明中推导的*O*(lg *n*)。练习
    17.2-3 给出了一个例子。
  prefs: []
  type: TYPE_NORMAL
- en: 另一方面，当旋转后的更新需要遍历一直到根时，插入和删除红黑树需要恒定数量的旋转是很重要的。第十三章的章节注释列出了其他平衡搜索树的方案，这些方案不通过常数限制每次插入或删除的旋转次数。如果每个操作可能需要Θ(lg
    *n*)次旋转，并且每次旋转都遍历一条路径到根，那么单个操作可能需要Θ(lg²*n*)时间，而不是定理 17.1 给出的*O*(lg *n*)时间界限。
  prefs: []
  type: TYPE_NORMAL
- en: '**练习**'
  prefs: []
  type: TYPE_NORMAL
- en: '***17.2-1***'
  prefs: []
  type: TYPE_NORMAL
- en: 通过向节点添加指针，展示如何在增强的顺序统计树上以*O*(1)的最坏情况时间支持每个动态集查询 MINIMUM、MAXIMUM、SUCCESSOR 和
    PREDECESSOR。顺序统计树上其他操作的渐近性能不应受影响。
  prefs: []
  type: TYPE_NORMAL
- en: '***17.2-2***'
  prefs: []
  type: TYPE_NORMAL
- en: 你能否在红黑树中将节点的黑高度作为节点的属性而不影响任何红黑树操作的渐近性能？展示如何做到，或者为什么不能。那么维护节点的深度呢？
  prefs: []
  type: TYPE_NORMAL
- en: '***17.2-3***'
  prefs: []
  type: TYPE_NORMAL
- en: 让⊗是一个可结合的二元运算符，*a*是红黑树每个节点中维护的一个属性。假设你想在每个节点*x*中包含一个额外属性*f*，使得*x*.*f* = *x*[1].*a*
    ⊗ *x*[2].*a* ⊗ … ⊗ *x[m]*.*a*，其中*x*[1]，*x*[2]，…，*x[m]*是以*x*为根的子树中节点的中序列表。展示如何在旋转后在*O*(1)时间内更新*f*属性。稍微修改你的论点，以将其应用于有序统计树中的*size*属性。
  prefs: []
  type: TYPE_NORMAL
- en: '**17.3    区间树**'
  prefs: []
  type: TYPE_NORMAL
- en: 本节展示了如何扩展红黑树以支持动态区间集合上的操作。在本节中，我们将假设区间是闭合的。将结果扩展到开放和半开放区间在概念上是直接的。（有关闭合、开放和半开放区间的定义，请参见第
    1157 页。）
  prefs: []
  type: TYPE_NORMAL
- en: 区间方便地表示每个占据连续时间段的事件。例如，您可以查询时间间隔数据库，以查找在给定时间间隔内发生了哪些事件。本节中的数据结构提供了一种维护这种区间数据库的有效方法。
  prefs: []
  type: TYPE_NORMAL
- en: 表示一个区间[*t*[1], *t*[2]]的简单方法是将其表示为一个对象*i*，其属性为*i*.*low* = *t*[1]（***低端点***）和*i*.*high*
    = *t*[2]（***高端点***）。我们说区间*i*和*i*′***重叠***，如果*i* ∩*i*′ ≠ ∅，即，如果*i*.*low* ≤ *i*′.*high*且*i*′.*low*
    ≤ *i*.*high*。
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P536.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**图 17.3** 两个闭区间*i*和*i*′的区间三歧性。**(a)** 如果*i*和*i*′重叠，有四种情况，在每种情况中，*i*.*low*
    ≤ *i*′.*high*且*i*′.*low* ≤ *i*.*high*。**(b)** 区间不重叠，且*i*.*high < i*′.*low*。**(c)**
    区间不重叠，且*i*′.*high < i*.*low*。'
  prefs: []
  type: TYPE_NORMAL
- en: 如图 17.3 所示，任意两个区间*i*和*i*′满足***区间三歧性***，即，以下三种属性中恰好有一种成立：
  prefs: []
  type: TYPE_NORMAL
- en: a. *i*和*i*′重叠，
  prefs: []
  type: TYPE_NORMAL
- en: b. *i*在*i*′的左侧（即，*i*.*high* < *i*′.*low*），
  prefs: []
  type: TYPE_NORMAL
- en: c. *i*在*i*′的右侧（即，*i*′.*high* < *i*.*low*）。
  prefs: []
  type: TYPE_NORMAL
- en: 一个***区间树***是一棵红黑树，用于维护一个动态元素集合，其中每个元素*x*包含一个区间*x*.*int*。区间树支持以下操作：
  prefs: []
  type: TYPE_NORMAL
- en: INTERVAL-INSERT(*T*, *x*)将元素*x*（假定其*int*属性包含一个区间）添加到区间树*T*中。
  prefs: []
  type: TYPE_NORMAL
- en: INTERVAL-DELETE(*T*, *x*)从区间树*T*中移除元素*x*。
  prefs: []
  type: TYPE_NORMAL
- en: INTERVAL-SEARCH(*T*, *i*)返回指向区间树*T*中元素*x*的指针，使得*x*.*int*与区间*i*重叠，或者如果没有这样的元素属于集合，则返回指向哨兵*T*.*nil*的指针。
  prefs: []
  type: TYPE_NORMAL
- en: 图 17.4 展示了区间树如何表示一组区间。来自第 17.2 节的四步方法将指导我们设计区间树及其上运行的操作。
  prefs: []
  type: TYPE_NORMAL
- en: '**步骤 1：基础数据结构**'
  prefs: []
  type: TYPE_NORMAL
- en: 红黑树作为基础数据结构。每个节点*x*包含一个区间*x*.*int*。*x*的关键是区间的低端点*x*.*int*.*low*。因此，数据结构的中序树遍历按低端点的顺序列出区间。
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P537.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**图 17.4** 一个区间树。**(a)** 一组 10 个区间，按左端点从底部到顶部排序显示。**(b)** 代表它们的区间树。每个节点*x*包含一个区间，显示在虚线上方，并且在以*x*为根的子树中任何区间端点的最大值，显示在虚线下方。树的中序遍历按左端点的顺序列出节点。'
  prefs: []
  type: TYPE_NORMAL
- en: '**步骤 2：额外信息**'
  prefs: []
  type: TYPE_NORMAL
- en: 除了区间本身，每个节点 *x* 还包含一个值 *x*.*max*，它是存储在以 *x* 为根的子树中任何区间端点的最大值。
  prefs: []
  type: TYPE_NORMAL
- en: '**第 3 步：维护信息**'
  prefs: []
  type: TYPE_NORMAL
- en: 我们必须验证在 *n* 个节点的区间树上插入和删除需要 *O*(lg *n*) 的时间。很容易确定 *x*.*max*，只需在 *O*(1) 的时间内给定区间
    *x*.*int* 和节点 *x* 的子节点的 *max* 值：
  prefs: []
  type: TYPE_NORMAL
- en: '*x*.*max* = max {*x*.*int*.*high*, *x*.*left*.*max*, *x*.*right*.*max*}.'
  prefs: []
  type: TYPE_NORMAL
- en: 因此，根据定理 17.1，插入和删除在 *O*(lg *n*) 的时间内运行。实际上，您可以使用练习 17.2-3 或 17.3-1 来展示如何在旋转后仅用
    *O*(1) 的时间更新所有更改的 *max* 属性。
  prefs: []
  type: TYPE_NORMAL
- en: '**第 4 步：开发新操作**'
  prefs: []
  type: TYPE_NORMAL
- en: 唯一的新操作是 INTERVAL-SEARCH(*T*, *i*)，它在树 *T* 中找到与区间 *i* 重叠的节点。如果树中没有与 *i* 重叠的区间，则该过程返回指向哨兵
    *T*.*nil* 的指针。
  prefs: []
  type: TYPE_NORMAL
- en: INTERVAL-SEARCH(*T*, *i*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | *x* = *T*.*root* |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | **while** *x* ≠ *T*.*nil* and *i* does not overlap *x*.*int* |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | **if** *x*.*left* ≠ *T*.*nil* and *x*.*left*.*max* ≥ *i*.*low* |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | *x* = *x*.*left* | **//** 左子树中有重叠或右子树中没有重叠 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | **else** *x* = *x*.*right* | **//** 左子树中没有重叠 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | **return** *x* |'
  prefs: []
  type: TYPE_TB
- en: 寻找与 *i* 重叠的区间从树的根开始并向下进行。当找到重叠区间或到达哨兵 *T*.*nil* 时终止。由于基本循环的每次迭代都需要 *O*(1) 的时间，并且由于
    *n* 个节点的红黑树的高度为 *O*(lg *n*)，因此 INTERVAL-SEARCH 过程需要 *O*(lg *n*) 的时间。
  prefs: []
  type: TYPE_NORMAL
- en: 在我们看到 INTERVAL-SEARCH 为什么正确之前，让我们看看它在 图 17.4 中的区间树上是如何工作的。让我们寻找一个与区间 *i* = [22,
    25] 重叠的区间。从 *x* 作为根开始，其中包含 [16, 21]，不与 *i* 重叠。由于 *x*.*left*.*max* = 23 大于 *i*.*low*
    = 22，循环继续，*x* 作为根的左子节点——包含 [8, 9] 的节点，也不与 *i* 重叠。这次，*x*.*left*.*max* = 10 小于 *i*.*low*
    = 22，所以循环继续，将 *x* 的右子节点作为新的 *x*。因为这个节点中存储的区间 [15, 23] 与 *i* 重叠，所以该过程返回这个节点。
  prefs: []
  type: TYPE_NORMAL
- en: 现在让我们尝试一个不成功的搜索，寻找在 图 17.4 的区间树中与 *i* = [11, 14] 重叠的区间。同样，从 *x* 作为根开始。由于根的区间
    [16, 21] 不与 *i* 重叠，并且 *x*.*left*.*max* = 23 大于 *i*.*low* = 11，向左移动到包含 [8, 9] 的节点。区间
    [8, 9] 不与 *i* 重叠，*x*.*left*.*max* = 10 小于 *i*.*low* = 11，所以搜索向右移动。（左子树中没有区间与 *i*
    重叠。）区间 [15, 23] 不与 *i* 重叠，其左子节点为 *T*.*nil*，所以搜索再次向右移动，循环终止，INTERVAL-SEARCH 返回哨兵
    *T*.*nil*。
  prefs: []
  type: TYPE_NORMAL
- en: 要了解 INTERVAL-SEARCH 为什么正确，我们必须理解为什么只需检查从根到单个路径就足够了。基本思想是，在任何节点 *x* 处，如果 *x*.*int*
    不与 *i* 重叠，则搜索总是朝着安全方向进行：如果树中包含重叠区间，则搜索一定会找到重叠区间。以下定理更准确地陈述了这一属性。
  prefs: []
  type: TYPE_NORMAL
- en: '***定理 17.2***'
  prefs: []
  type: TYPE_NORMAL
- en: 任何执行 INTERVAL-SEARCH(*T*, *i*) 要么返回一个与 *i* 重叠的节点，要么返回 *T*.*nil*，表示树 *T* 不包含与
    *i* 重叠的节点。
  prefs: []
  type: TYPE_NORMAL
- en: '***证明*** **while** 循环在第 2-5 行终止，当*x* = *T*.*nil*或*i*与*x*.*int*重叠时。在后一种情况下，返回*x*当然是正确的。因此，我们关注前一种情况，即**while**循环终止于*x*
    = *T*.*nil*，即 INTERVAL-SEARCH 返回的节点。'
  prefs: []
  type: TYPE_NORMAL
- en: 我们将证明，如果过程返回*T*.*nil*，则它没有错过与*i*重叠的*T*中的任何区间。思路是表明无论搜索在第 4 行向左还是在第 5 行向右，它总是朝向包含与*i*重叠的区间的节点前进，如果存在这样的区间。特别地，我们将证明
  prefs: []
  type: TYPE_NORMAL
- en: 如果搜索在第 4 行向左进行，那么节点*x*的左子树包含一个与*i*重叠的区间，或者*x*的右子树不包含与*i*重叠的区间。因此，即使*x*的左子树不包含与*i*重叠的区间，但搜索向左进行也不会出错，因为*x*的右子树也不包含与*i*重叠的区间。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 如果搜索在第 5 行正确进行，那么*x*的左子树不包含与*i*重叠的区间。因此，如果搜索向右进行，就不会出错。
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 对于这两种情况，我们依赖于区间三歧性。让我们从搜索向右的情况开始，其证明更简单。通过第 3 行的测试，我们知道*x*.*left* = *T*.*nil*或*x*.*left*.*max
    < i*.*low*。如果*x*.*left* = *T*.*nil*，那么*x*的左子树不包含与*i*重叠的区间，因为它根本不包含任何区间。现在假设*x*.*left*
    ≠ *T*.*nil*，因此我们必须有*x*.*left*.*max < i*.*low*。考虑*x*的左子树中的任何区间*i*′。因为*x*.*left*.*max*是*x*的左子树中的最大端点，我们有*i*′.*high*
    ≤ *x*.*left*.*max*。因此，正如图 17.5(a)所示，
  prefs: []
  type: TYPE_NORMAL
- en: '| *i*′.*high* | ≤ | *x*.*left*.*max* |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|  | < | *i*.*low*. |'
  prefs: []
  type: TYPE_TB
- en: 因此，根据区间三歧性，区间*i*和*i*′不重叠，因此*x*的左子树不包含与*i*重叠的区间。
  prefs: []
  type: TYPE_NORMAL
- en: '![艺术](img/Art_P538.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**图 17.5** 定理 17.2 证明中的区间。每种情况下*x*.*left*.*max*的值都显示为虚线。**(a)** 搜索向右。*x*的左子树中没有区间*i*′可以与*i*重叠。**(b)**
    搜索向左。*x*的左子树包含一个与*i*重叠的区间（未显示的情况），或者*x*的左子树包含一个区间*i*′，使得*i*′.*high* = *x*.*left*.*max*。由于*i*不与*i*′重叠，它也不与*x*的右子树中的任何区间*i*″重叠，因为*i*′.*low*
    ≤ *i*″.*low*。'
  prefs: []
  type: TYPE_NORMAL
- en: 现在我们来看搜索向左的情况。如果节点*x*的左子树包含一个与*i*重叠的区间，那么我们完成了，因此假设*x*的左子树中没有节点与*i*重叠。我们需要证明在这种情况下，*x*的右子树中没有节点与*i*重叠，因此向左不会错过*x*的右子树中的任何重叠。通过第
    3 行的测试，*x*的左子树不为空且*x*.*left*.*max* ≥ *i*.*low*。根据*max*属性的定义，*x*的左子树包含一些区间*i*′，使得
  prefs: []
  type: TYPE_NORMAL
- en: '| *i*′.*high* | = | *x*.*left*.*max* |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|  | ≥ | *i*.*low*, |'
  prefs: []
  type: TYPE_TB
- en: 如图 17.5(b)所示。由于*i*′在*x*的左子树中，它不与*i*重叠，且由于*i*′.*high* ≥ *i*.*low*，区间三歧性告诉我们*i*.*high
    < i*′.*low*。现在我们引入区间树以低端点为键的属性。因为*i*′在*x*的左子树中，我们有*i*′.*low* ≤ *x*.*int*.*low*。现在考虑*x*的右子树中的任何区间*i*″，使得*x*.*int*.*low*
    ≤ *i*″.*low*。将不等式放在一起，我们得到
  prefs: []
  type: TYPE_NORMAL
- en: '| *i*.*high* | < | *i*′.*low* |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '|  | ≤ | *x*.*int*.*low* |'
  prefs: []
  type: TYPE_TB
- en: '|  | ≤ | *i*″.*low*. |'
  prefs: []
  type: TYPE_TB
- en: 因为*i*.*high < i*″.*low*，区间三分法告诉我们*i*和*i*″不重叠。由于我们选择*i*″作为*x*右子树中的任意区间，所以*x*右子树中的任何节点都不会与*i*重叠。
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: 因此，INTERVAL-SEARCH 过程运行正确。
  prefs: []
  type: TYPE_NORMAL
- en: '**练习**'
  prefs: []
  type: TYPE_NORMAL
- en: '***17.3-1***'
  prefs: []
  type: TYPE_NORMAL
- en: 编写一个在区间树中操作并在*O*(1)时间内更新所有更改的*max*属性的 LEFT-ROTATE 的伪代码。
  prefs: []
  type: TYPE_NORMAL
- en: '***17.3-2***'
  prefs: []
  type: TYPE_NORMAL
- en: 描述一个有效的算法，给定一个区间*i*，返回与*i*重叠且具有最小低端点的区间，如果不存在这样的区间，则返回*T*.*nil*。
  prefs: []
  type: TYPE_NORMAL
- en: '***17.3-3***'
  prefs: []
  type: TYPE_NORMAL
- en: 给定一个区间树*T*和一个区间*i*，描述如何在*O*(min {*n*, *k* lg *n*})时间内列出*T*中与*i*重叠的所有区间，其中*k*是输出列表中的区间数。(*提示*：一种简单的方法在查询之间进行修改，修改树。稍微复杂一点的方法不修改树。)
  prefs: []
  type: TYPE_NORMAL
- en: '***17.3-4***'
  prefs: []
  type: TYPE_NORMAL
- en: 建议修改区间树程序以支持新操作 INTERVAL-SEARCH-EXACTLY(*T*, *i*)，其中*T*是一个区间树，*i*是一个区间。该操作应返回*T*中满足*x*.*int*.*low*
    = *i*.*low*和*x*.*int*.*high* = *i*.*high*的节点*x*的指针，如果*T*不包含这样的节点，则返回*T*.*nil*。所有操作，包括
    INTERVAL-SEARCH-EXACTLY，应在*n*个节点的区间树上以*O*(lg *n*)时间运行。
  prefs: []
  type: TYPE_NORMAL
- en: '***17.3-5***'
  prefs: []
  type: TYPE_NORMAL
- en: 展示如何维护一个支持 MIN-GAP 操作的数字动态集合*Q*，该操作返回*Q*中两个最接近数字的绝对值差。例如，如果我们有*Q* = {1, 5, 9,
    15, 18, 22}，那么 MIN-GAP(*Q*)返回 3，因为 15 和 18 是*Q*中最接近的两个数字。使 INSERT、DELETE、SEARCH
    和 MIN-GAP 操作尽可能高效，并分析它们的运行时间。
  prefs: []
  type: TYPE_NORMAL
- en: ★ ***17.3-6***
  prefs: []
  type: TYPE_NORMAL
- en: VLSI 数据库通常将集成电路表示为矩形列表。假设每个矩形都是直角方向（边平行于*x*和*y*轴），因此每个矩形由四个值表示：其最小和最大*x*和*y*坐标。给出一个*O*(*n*
    lg *n*)时间算法，以确定以这种方式表示的一组*n*个矩形是否包含重叠的两个矩形。你的算法不需要报告所有相交的对，但如果一个矩形完全覆盖另一个矩形，即使边界线不相交，也必须报告存在重叠。(*提示*：在矩形集合上移动“扫描”线。)
  prefs: []
  type: TYPE_NORMAL
- en: '**问题**'
  prefs: []
  type: TYPE_NORMAL
- en: '***17-1     最大重叠点***'
  prefs: []
  type: TYPE_NORMAL
- en: 你希望跟踪一组区间中的***最大重叠点***—一个集合中与之重叠的区间数最多的点。
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** 展示总是存在一个作为区间端点的最大重叠点。'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** 设计一个数据结构，有效支持 INTERVAL-INSERT、INTERVAL-DELETE 和 FIND-POM 操作，返回最大重叠点。(*提示*：保持所有端点的红黑树。将每个左端点关联值+1，将每个右端点关联值-1。增加树的每个节点的一些额外信息以维护最大重叠点。)'
  prefs: []
  type: TYPE_NORMAL
- en: '***17-2     Josephus 排列***'
  prefs: []
  type: TYPE_NORMAL
- en: 我们将***Josephus 问题***定义如下。一组*n*个人围成一个圆圈，给定一个正整数*m* ≤ *n*。从指定的第一个人开始，沿着圆圈继续，每隔*m*个人移除一个人。每次移除一个人后，继续计数剩下的圆圈。这个过程一直持续，直到圆圈中没有人。从圆圈中移除人的顺序定义了整数
    1, 2, … , *n*的**(*n*, *m*)-Josephus 排列**。例如，(7, 3)-Josephus 排列是〈3, 6, 2, 7, 5,
    1, 4〉。
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** 假设*m*是一个常数。描述一个*O*(*n*)时间复杂度的算法，给定一个整数*n*，输出(*n*, *m*)-Josephus 排列。'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** 假设*m*不一定是一个常数。描述一个*O*(*n* lg *n*)时间复杂度的算法，给定整数*n*和*m*，输出(*n*, *m*)-Josephus
    排列。'
  prefs: []
  type: TYPE_NORMAL
- en: '**章节注释**'
  prefs: []
  type: TYPE_NORMAL
- en: 在他们的书中，Preparata 和 Shamos [364] 描述了文献中出现的几种区间树，引用了 H. Edelsbrunner（1980）和 E.
    M. McCreight（1981）的工作。该书详细介绍了一种区间树，给定一个静态数据库的*n*个区间，允许我们在*O*(*k* + lg *n*)时间内枚举所有与给定查询区间重叠的*k*个区间。
  prefs: []
  type: TYPE_NORMAL
