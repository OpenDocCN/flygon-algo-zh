- en: '[**2          Getting Started**](toc.xhtml#chap-2)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[**2          入门**](toc.xhtml#chap-2)'
- en: This chapter will familiarize you with the framework we’ll use throughout the
    book to think about the design and analysis of algorithms. It is self-contained,
    but it does include several references to material that will be introduced in
    [Chapters 3](chapter003.xhtml) and [4](chapter004.xhtml). (It also contains several
    summations, which [Appendix A](appendix001.xhtml) shows how to solve.)
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将使您熟悉我们将在整本书中使用的框架，以思考算法的设计和分析。它是独立的，但包含了对将在[第3章](chapter003.xhtml)和[第4章](chapter004.xhtml)中介绍的材料的几个引用。（它还包含几个求和，[附录A](appendix001.xhtml)展示了如何解决。）
- en: We’ll begin by examining the insertion sort algorithm to solve the sorting problem
    introduced in [Chapter 1](chapter001.xhtml). We’ll specify algorithms using a
    pseudocode that should be understandable to you if you have done computer programming.
    We’ll see why insertion sort correctly sorts and analyze its running time. The
    analysis introduces a notation that describes how running time increases with
    the number of items to be sorted. Following a discussion of insertion sort, we’ll
    use a method called divide-and-conquer to develop a sorting algorithm called merge
    sort. We’ll end with an analysis of merge sort’s running time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从检查插入排序算法开始，以解决[第1章](chapter001.xhtml)中介绍的排序问题。我们将使用伪代码指定算法，如果您有计算机编程经验，应该能够理解。我们将看到为什么插入排序能够正确排序并分析其运行时间。分析引入了一种描述运行时间随要排序的项目数量增加而增加的符号。在讨论插入排序之后，我们将使用一种称为分而治之的方法来开发一个名为归并排序的排序算法。最后，我们将分析归并排序的运行时间。
- en: '[**2.1      Insertion sort**](toc.xhtml#Rh1-6)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[**2.1      插入排序**](toc.xhtml#Rh1-6)'
- en: 'Our first algorithm, insertion sort, solves the ***sorting problem*** introduced
    in [Chapter 1](chapter001.xhtml):'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我��的第一个算法，插入排序，解决了[第1章](chapter001.xhtml)中介绍的***排序问题***：
- en: '**Input:** A sequence of *n* numbers 〈*a*[1], *a*[2], … , *a[n]*〉.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入:** 一个包含*n*个数字〈*a*[1], *a*[2], … , *a[n]*〉的序列。'
- en: '**Output:** A permutation (reordering) ![art](images/Art_P6.jpg) of the input
    sequence such that ![art](images/Art_P7.jpg).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出:** 输入序列的一个排列（重新排序）![art](images/Art_P6.jpg)，使得![art](images/Art_P7.jpg)。'
- en: The numbers to be sorted are also known as the ***keys***. Although the problem
    is conceptually about sorting a sequence, the input comes in the form of an array
    with *n* elements. When we want to sort numbers, it’s often because they are the
    keys associated with other data, which we call ***satellite data***. Together,
    a key and satellite data form a ***record***. For example, consider a spreadsheet
    containing student records with many associated pieces of data such as age, grade-point
    average, and number of courses taken. Any one of these quantities could be a key,
    but when the spreadsheet sorts, it moves the associated record (the satellite
    data) with the key. When describing a sorting algorithm, we focus on the keys,
    but it is important to remember that there usually is associated satellite data.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 要排序的数字也被称为***键***。虽然问题概念上是关于对序列进行排序，但输入以包含*n*个元素的数组形式呈现。当我们想要对数字进行排序时，通常是因为它们是与其他数据相关联的键，我们称之为***卫星数据***。一起，键和卫星数据形成一个***记录***。例如，考虑一个包含许多相关数据的学生记录的电子表格，如年龄、平均绩点和所修课程数。这些数量中的任何一个都可以是一个键，但当电子表格进行排序时，它会将与键相关联的记录（卫星数据）一起移动。在描述排序算法时，我们关注键，但重要的是要记住通常会有相关的卫星数据。
- en: In this book, we’ll typically describe algorithms as procedures written in a
    ***pseudocode*** that is similar in many respects to C, C++, Java, Python,^([1](#footnote_1))
    or JavaScript. (Apologies if we’ve omitted your favorite programming language.
    We can’t list them all.) If you have been introduced to any of these languages,
    you should have little trouble understanding algorithms “coded” in pseudocode.
    What separates pseudocode from real code is that in pseudocode, we employ whatever
    expressive method is most clear and concise to specify a given algorithm. Sometimes
    the clearest method is English, so do not be surprised if you come across an English
    phrase or sentence embedded within a section that looks more like real code. Another
    difference between pseudocode and real code is that pseudocode often ignores aspects
    of software engineering—such as data abstraction, modularity, and error handling—in
    order to convey the essence of the algorithm more concisely.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书中，我们通常将算法描述为以类似于C、C++、Java、Python^([1](#footnote_1))或JavaScript的***伪代码***编写的过程。如果您已经接触过这些语言中的任何一种，那么应该很容易理解以伪代码“编码”的算法。伪代码与真实代码的区别在于，在伪代码中，我们使用最清晰简洁的表达方法来指定给定算法。有时最清晰的方法是英语，因此如果您在看起来更像真实代码的部分中遇到嵌入的英语短语或句子，不要感到惊讶。伪代码与真实代码的另一个区别是，为了更简洁地传达算法的本质，伪代码通常忽略软件工程的方面，如数据抽象、模块化和错误处理。
- en: We start with ***insertion sort***, which is an efficient algorithm for sorting
    a small number of elements. Insertion sort works the way you might sort a hand
    of playing cards. Start with an empty left hand and the cards in a pile on the
    table. Pick up the first card in the pile and hold it with your left hand. Then,
    with your right hand, remove one card at a time from the pile, and insert it into
    the correct position in your left hand. As [Figure 2.1](chapter002.xhtml#Fig_2-1)
    illustrates, you find the correct position for a card by comparing it with each
    of the cards already in your left hand, starting at the right and moving left.
    As soon as you see a card in your left hand whose value is less than or equal
    to the card you’re holding in your right hand, insert the card that you’re holding
    in your right hand just to the right of this card in your left hand. If all the
    cards in your left hand have values greater than the card in your right hand,
    then place this card as the leftmost card in your left hand. At all times, the
    cards held in your left hand are sorted, and these cards were originally the top
    cards of the pile on the table.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从***插入排序***开始，这是一种对少量元素进行排序的高效算法。插入排序的工作方式类似于整理一手扑克牌。从一个空的左手开始，桌上有一摞牌。拿起桌上的第一张牌，用左手拿住。然后，用右手，从牌堆中逐张拿出一张牌，并将其插入左手的正确位置。正如[图
    2.1](chapter002.xhtml#Fig_2-1)所示，通过将右手中的卡片与左手中已有的每张卡片进行比较，从右向左开始，找到卡片的正确位置。一旦看到左手中有一张值小于或等于右手中的卡片，就将右手中的卡片插入到左手中这张卡片的右侧。如果左手中的所有卡片的值都大于右手中的卡片，则将这张卡片放在左手中最左边。始终保持左手中的卡片排序，这些卡片最初是桌上牌堆的顶部卡片。
- en: 'The pseudocode for insertion sort is given as the procedure INSERTION-SORT
    on the facing page. It takes two parameters: an array *A* containing the values
    to be sorted and the number *n* of values of sort. The values occupy positions
    *A*[1] through *A*[*n*] of the array, which we denote by *A*[1 : *n*]. When the
    INSERTION-SORT procedure is finished, array *A*[1 : *n*] contains the original
    values, but in sorted order.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '插入排序的伪代码如下所示，称为 INSERTION-SORT 过程。它接受两个参数：包含要排序的值的数组 *A* 和要排序的值的数量 *n*。 这些值占据数组的位置
    *A*[1] 到 *A*[*n*]，我们用 *A*[1 : *n*] 表示。当 INSERTION-SORT 过程完成时，数组 *A*[1 : *n*] 包含原始值，但按排序顺序排列。'
- en: '![art](images/Art_P8.jpg)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P8.jpg)'
- en: '**Figure 2.1** Sorting a hand of cards using insertion sort.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2.1** 使用插入排序整理一手牌。'
- en: INSERTION-SORT(*A, n*)
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: INSERTION-SORT(*A, n*)
- en: '| 1 | **for** *i* = 2 **to** *n* |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **for** *i* = 2 **to** *n* |'
- en: '| 2 | *key* = *A*[*i*] |'
  id: totrans-15
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *key* = *A*[*i*] |'
- en: '| 3 | **//** Insert *A*[*i*] into the sorted subarray *A*[1 : *i* – 1]. |'
  id: totrans-16
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **//** 将 *A*[*i*] 插入已排序的子数组 *A*[1 : *i* – 1]。 |'
- en: '| 4 | *j* = *i* – 1 |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *j* = *i* – 1 |'
- en: '| 5 | **while** *j* > 0 and *A*[*j*] > *key* |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **while** *j* > 0 and *A*[*j*] > *key* |'
- en: '| 6 | *A*[*j* + 1] = *A*[*j*] |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 6 | *A*[*j* + 1] = *A*[*j*] |'
- en: '| 7 | *j* = *j* – 1 |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 7 | *j* = *j* – 1 |'
- en: '| 8 | *A*[*j* + 1] = *key* |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 8 | *A*[*j* + 1] = *key* |'
- en: '**Loop invariants and the correctness of insertion sort**'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**循环不变式和插入排序的正确性**'
- en: '[Figure 2.2](chapter002.xhtml#Fig_2-2) shows how this algorithm works for an
    array *A* that starts out with the sequence 〈5, 2, 4, 6, 1, 3〉. The index *i*
    indicates the “current card” being inserted into the hand. At the beginning of
    each iteration of the **for** loop, which is indexed by *i*, the ***subarray***
    (a contiguous portion of the array) consisting of elements *A*[1 : *i* – 1] (that
    is, *A*[1] through *A*[*i* – 1]) constitutes the currently sorted hand, and the
    remaining subarray *A*[*i* + 1 : *n*] (elements *A*[*i* + 1] through *A*[*n*])
    corresponds to the pile of cards still on the table. In fact, elements *A*[1 :
    *i* – 1] are the elements *originally* in positions 1 through *i* – 1, but now
    in sorted order. We state these properties of *A*[1 : *i* – 1] formally as a ***loop
    invariant***:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.2](chapter002.xhtml#Fig_2-2) 展示了这个算法如何处理一个以序列 〈5, 2, 4, 6, 1, 3〉 开始的数组
    *A*。索引 *i* 表示正在插入手中的“当前卡片”。在由 *i* 索引的 **for** 循环的每次迭代开始时，由元素 *A*[1 : *i* – 1]（即
    *A*[1] 到 *A*[*i* – 1]）组成的***子数组***（数组的连续部分）构成当前排序好的手，而剩余的子数组 *A*[*i* + 1 : *n*]（元素
    *A*[*i* + 1] 到 *A*[*n*]）对应于桌上仍留着的牌堆。实际上，元素 *A*[1 : *i* – 1] 是最初在位置 1 到 *i* – 1
    的元素，但现在按排序顺序排列。我们正式陈述 *A*[1 : *i* – 1] 的这些属性作为一个***循环不变式***：'
- en: '![art](images/Art_P9.jpg)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P9.jpg)'
- en: '**Figure 2.2** The operation of INSERTION-SORT(*A, n*), where *A* initially
    contains the sequence 〈5, 2, 4, 6, 1, 3〉 and *n* = 6\. Array indices appear above
    the rectangles, and values stored in the array positions appear within the rectangles.
    **(a)–(e)** The iterations of the **for** loop of lines 1–8\. In each iteration,
    the blue rectangle holds the key taken from *A*[*i*], which is compared with the
    values in tan rectangles to its left in the test of line 5\. Orange arrows show
    array values moved one position to the right in line 6, and blue arrows indicate
    where the key moves to in line 8\. **(f)** The final sorted array.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2.2** INSERTION-SORT(*A, n*) 的操作，其中 *A* 最初包含序列 〈5, 2, 4, 6, 1, 3〉，*n* =
    6\. 数组索引出现在矩形上方，数组位置中存储的值出现在矩形内部。**(a)–(e)** 行 1–8 的 **for** 循环的迭代。在每次迭代中，蓝色矩形中存放着从
    *A*[*i*] 中取出的关键字，该关键字与左侧的棕色矩形中的值进行比较，从右向左开始。一旦看到左手中有一张值小于或等于右手中的卡片，就将右手中的卡片插入到左手中这张卡片的右侧。如果左手中的所有卡片的值都大于右手中的卡片，则将这张卡片放在左手中最左边。始终保持左手中的卡片排序，这些卡片最初是桌上牌堆的顶部卡片。'
- en: 'At the start of each iteration of the **for** loop of lines 1–8, the subarray
    *A*[1 : *i* – 1] consists of the elements originally in *A*[1 : *i* – 1], but
    in sorted order.'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '在行 1–8 的 **for** 循环的每次迭代开始���，子数组 *A*[1 : *i* – 1] 包含最初在 *A*[1 : *i* – 1] 中的元素，但按排序顺序排列。'
- en: 'Loop invariants help us understand why an algorithm is correct. When you’re
    using a loop invariant, you need to show three things:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 循环不变式帮助我们理解算法为什么是正确的。当使用循环不变式时，需要展示三点：
- en: '**Initialization:** It is true prior to the first iteration of the loop.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化：** 在循环的第一次迭代之前为真。'
- en: '**Maintenance:** If it is true before an iteration of the loop, it remains
    true before the next iteration.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**维护：** 如果在循环的一次迭代之前为真，则在下一次迭代之前仍为真。'
- en: '**Termination:** The loop terminates, and when it terminates, the invariant—usually
    along with the reason that the loop terminated—gives us a useful property that
    helps show that the algorithm is correct.'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: '**终止：** 循环终止时，循环不变式——通常连同循环终止的原因——给我们提供了一个有用的属性，有助于展示算法的正确性。'
- en: When the first two properties hold, the loop invariant is true prior to every
    iteration of the loop. (Of course, you are free to use established facts other
    than the loop invariant itself to prove that the loop invariant remains true before
    each iteration.) A loop-invariant proof is a form of mathematical induction, where
    to prove that a property holds, you prove a base case and an inductive step. Here,
    showing that the invariant holds before the first iteration corresponds to the
    base case, and showing that the invariant holds from iteration to iteration corresponds
    to the inductive step.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 当前两个属性成立时，循环不变式在每次循环迭代之前都是真实的。（当然，您可以使用除了循环不变式本身之外的已知事实来证明在每次迭代之前循环不变式仍然成立。）循环不变式证明是数学归纳的一种形式，其中为了证明一个属性成立，您需要证明一个基本情况和一个归纳步骤。在这里，展示在第一次迭代之前不变式成立对应于基本情况，展示在迭代之间不变式保持对应于归纳步骤。
- en: The third property is perhaps the most important one, since you are using the
    loop invariant to show correctness. Typically, you use the loop invariant along
    with the condition that caused the loop to terminate. Mathematical induction typically
    applies the inductive step infinitely, but in a loop invariant the “induction”
    stops when the loop terminates.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个属性可能是最重要的，因为您使用循环不变式来展示正确性。通常，您会将循环不变式与导致循环终止的条件一起使用。数学归纳通常会无限地应用归纳步骤，但在循环不变式中，“归纳”在循环终止时停止。
- en: Let’s see how these properties hold for insertion sort.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这些属性如何适用于插入排序。
- en: '**Initialization:** We start by showing that the loop invariant holds before
    the first loop iteration, when *i* = 2.^([2](#footnote_2)) The subarray *A*[1
    : *i* – 1] consists of just the single element *A*[1], which is in fact the original
    element in *A*[1]. Moreover, this subarray is sorted (after all, how could a subarray
    with just one value not be sorted?), which shows that the loop invariant holds
    prior to the first iteration of the loop.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化：** 我们首先展示循环不变式在第一次循环迭代之前，即*i* = 2时成立。子数组*A*[1 : *i* – 1]只包含单个元素*A*[1]，实际上就是*A*[1]中的原始元素。此外，这个子数组是排序的（毕竟，只有一个值的子数组怎么可能不是排序的？），这表明循环不变式在循环的第一次迭代之前是成立的。'
- en: '**Maintenance:** Next, we tackle the second property: showing that each iteration
    maintains the loop invariant. Informally, the body of the **for** loop works by
    moving the values in *A*[*i* – 1], *A*[*i* – 2], *A*[*i* – 3], and so on by one
    position to the right until it finds the proper position for *A*[*i*] (lines 4–7),
    at which point it inserts the value of *A*[*i*] (line 8). The subarray *A*[1 :
    *i*] then consists of the elements originally in *A*[1 : *i*], but in sorted order.
    ***Incrementing*** *i* (increasing its value by 1) for the next iteration of the
    **for** loop then preserves the loop invariant.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '**维护：** 接下来，我们解决第二个属性：展示每次迭代如何保持循环不变式。非正式地说，**for**循环的主体通过将*A*[*i* – 1]、*A*[*i*
    – 2]、*A*[*i* – 3]等值向右移动一个位置，直到找到*A*[*i*]的正确位置（第4至7行），然后插入*A*[*i*]的值（第8行）来工作。然后，子数组*A*[1
    : *i*]包含的是原始的*A*[1 : *i*]中的元素，但是按排序顺序排列。**递增** *i*（将其值增加1）以供**for**循环的下一次迭代保持循环不变式。'
- en: A more formal treatment of the second property would require us to state and
    show a loop invariant for the **while** loop of lines 5–7\. Let’s not get bogged
    down in such formalism just yet. Instead, we’ll rely on our informal analysis
    to show that the second property holds for the outer loop.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对第二个属性的更正式处理需要我们为第5至7行的**while**循环陈述并展示一个循环不变式。让我们暂时不要陷入这种形式主义。相反，我们将依赖我们的非正式分析来展示第二个属性对外部循环是成立的。
- en: '**Termination:** Finally, we examine loop termination. The loop variable *i*
    starts at 2 and increases by 1 in each iteration. Once *i*’s value exceeds *n*
    in line 1, the loop terminates. That is, the loop terminates once *i* equals *n*
    + 1\. Substituting *n* + 1 for *i* in the wording of the loop invariant yields
    that the subarray *A*[1 : *n*] consists of the elements originally in *A*[1 :
    *n*], but in sorted order. Hence, the algorithm is correct.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '**终止：** 最后，我们检查循环终止。循环变量*i*从2开始，并在每次迭代中增加1。一旦*i*的值在第1行超过*n*，循环就终止。也就是说，一旦*i*等于*n*
    + 1时，循环终止。将*n* + 1代入循环不变式的措辞中，得出子数组*A*[1 : *n*]包含的是原始的*A*[1 : *n*]中的元素，但按排序顺序排列。因此，算法是正确的。'
- en: This method of loop invariants is used to show correctness in various places
    throughout this book.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这种循环不变式的方法用于展示本书中各处的正确性。
- en: '**Pseudocode conventions**'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**伪代码约定**'
- en: We use the following conventions in our pseudocode.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在伪代码中使用以下约定。
- en: Indentation indicates block structure. For example, the body of the **for**
    loop that begins on line 1 consists of lines 2–8, and the body of the **while**
    loop that begins on line 5 contains lines 6–7 but not line 8\. Our indentation
    style applies to **if-else** statements^([3](#footnote_3)) as well. Using indentation
    instead of textual indicators of block structure, such as **begin** and **end**
    statements or curly braces, reduces clutter while preserving, or even enhancing,
    clarity.^([4](#footnote_4))
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩进表示块结构。例如，从第1行开始的**for**循环的主体包括第2至8行，而从第5行开始的**while**循环的主体包括第6至7行，但不包括第8行。我们的缩进风格也适用于**if-else**语句。使用缩进而不是文本指示块结构的方法，如**begin**和**end**语句或花括号，可以减少混乱，同时保持甚至增强清晰度。
- en: The looping constructs **while**, **for**, and **repeat-until** and the **if-else**
    conditional construct have interpretations similar to those in C, C++, Java, Python,
    and JavaScript.^([5](#footnote_5)) In this book, the loop counter retains its
    value after the loop is exited, unlike some situations that arise in C++ and Java.
    Thus, immediately after a **for** loop, the loop counter’s value is the value
    that first exceeded the **for** loop bound.^([6](#footnote_6)) We used this property
    in our correctness argument for insertion sort. The **for** loop header in line
    1 is **for** *i* = 2 **to** *n*, and so when this loop terminates, *i* equals
    *n* + 1\. We use the keyword **to** when a **for** loop increments its loop counter
    in each iteration, and we use the keyword **downto** when a **for** loop ***decrements***
    its loop counter (reduces its value by 1 in each iteration). When the loop counter
    changes by an amount greater than 1, the amount of change follows the optional
    keyword **by**.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 循环结构**while**、**for**和**repeat-until**以及**if-else**条件结构的解释与C、C++、Java、Python和JavaScript中的类似。[^5](#footnote_5)
    在本书中，循环计数器在退出循环后保留其值，不像在C++和Java中出现的某些情况。因此，在**for**循环后，循环计数器的值是首次超过**for**循环边界的值。[^6](#footnote_6)
    我们在插入排序的正确性论证中使用了这个属性。第1行中的**for**循环头是**for** *i* = 2 **to** *n*，因此当这个循环终止时，*i*等于*n*
    + 1。当**for**循环在每次迭代中递增其循环计数器时，我们使用关键字**to**，当**for**循环***递减***其循环计数器（每次迭代减少1）时，我们使用关键字**downto**。当循环计数器的变化量大于1时，变化量遵循可选关键字**by**。
- en: The symbol “**//**” indicates that the remainder of the line is a comment.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 符号“**//**”表示该行剩余部分是注释。
- en: Variables (such as *i*, *j*, and *key*) are local to the given procedure. We
    won’t use global variables without explicit indication.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 变量（如*i*、*j*和*key*）是局部于给定过程的。我们不会在没有明确指示的情况下使用全局变量。
- en: We access array elements by specifying the array name followed by the index
    in square brackets. For example, *A*[*i*] indicates the *i*th element of the array
    *A*.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过指定数组名称后跟方括号中的索引��访问数组元素。例如，*A*[*i*]表示数组*A*的第*i*个元素。
- en: Although many programming languages enforce 0-origin indexing for arrays (0
    is the smallest valid index), we choose whichever indexing scheme is clearest
    for human readers to understand. Because people usually start counting at 1, not
    0, most—but not all—of the arrays in this book use 1-origin indexing. To be clear
    about whether a particular algorithm assumes 0-origin or 1-origin indexing, we’ll
    specify the bounds of the arrays explicitly. If you are implementing an algorithm
    that we specify using 1-origin indexing, but you’re writing in a programming language
    that enforces 0-origin indexing (such as C, C++, Java, Python, or JavaScript),
    then give yourself credit for being able to adjust. You can either always subtract
    1 from each index or allocate each array with one extra position and just ignore
    position 0.
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管许多编程语言对数组实施从0开始的索引（0是最小有效索引），但我们选择最清晰的索引方案供人类读者理解。因为人们通常从1开始计数，而不是从0开始，本书中的大多数数组使用1起始索引。为了明确某个算法是否假定从0开始或从1开始索引，我们将明确指定数组的边界。如果您正在实现我们用1起始索引指定的算法，但您使用的编程语言强制从0开始索引（如C、C++、Java、Python或JavaScript），那么您可以自行调整。您可以从每个索引中减去1，或者为每个数组分配一个额外位置，然后忽略位置0。
- en: 'The notation “:” denotes a subarray. Thus, *A*[*i* : *j*] indicates the subarray
    of *A* consisting of the elements *A*[*i*], *A*[*i* + 1], … , *A*[*j*].^([7](#footnote_7))
    We also use this notation to indicate the bounds of an array, as we did earlier
    when discussing the array *A*[1 : *n*].'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '符号“:”表示子数组。因此，*A*[*i* : *j*]表示由元素*A*[*i*]、*A*[*i* + 1]、…、*A*[*j*]组成的*A*的子数组。[^7](#footnote_7)
    我们在讨论数组*A*[1 : *n*]时也使用了这种表示法来指示数组的边界。'
- en: 'We typically organize compound data into ***objects***, which are composed
    of ***attributes***. We access a particular attribute using the syntax found in
    many object-oriented programming languages: the object name, followed by a dot,
    followed by the attribute name. For example, if an object *x* has attribute *f*,
    we denote this attribute by *x.f*.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通常将复合数据组织成***对象***，这些对象由***属性***组成。我们使用许多面向对象编程语言中的语法来访问特定属性：对象名称，后跟一个点，再后跟属性名称。例如，如果一个对象*x*有属性*f*，我们用*x.f*表示这个属性。
- en: We treat a variable representing an array or object as a pointer (known as a
    reference in some programming languages) to the data representing the array or
    object. For all attributes *f* of an object *x*, setting *y* = *x* causes *y.f*
    to equal *x.f*. Moreover, if we now set *x.f* = 3, then afterward not only does
    *x.f* equal 3, but *y.f* equals 3 as well. In other words, *x* and *y* point to
    the same object after the assignment *y* = *x*. This way of treating arrays and
    objects is consistent with most contemporary programming languages.
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将表示数组或对象的变量视为指针（在一些编程语言中称为引用），指向表示数组或对象的数据。对于对象*x*的所有属性*f*，设置*y* = *x*会导致*y.f*等于*x.f*。此外，如果我们现在设置*x.f*
    = 3，那么之后不仅*x.f*等于3，而且*y.f*也等于3。换句话说，在赋值*y* = *x*后，*x*和*y*指向同一个对象。这种处理数组和对象的方式与大多数当代编程语言一致。
- en: Our attribute notation can “cascade.” For example, suppose that the attribute
    *f* is itself a pointer to some type of object that has an attribute *g*. Then
    the notation *x.f.g* is implicitly parenthesized as (*x.f*).*g*. In other words,
    if we had assigned *y* = *x.f*, then *x.f.g* is the same as *y.g*.
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们的属性表示法可以“级联”。例如，假设属性*f*本身是指向某种具有属性*g*的对象的指针。那么表示法*x.f.g*隐含地被括号化为（*x.f*）.*g*。换句话说，如果我们已经赋值*y*
    = *x.f*，那么*x.f.g*就等同于*y.g*。
- en: Sometimes a pointer refers to no object at all. In this case, we give it the
    special value NIL.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时指针可能不指向任何对象。在这种情况下，我们给它赋予特殊值NIL。
- en: 'We pass parameters to a procedure ***by value***: the called procedure receives
    its own copy of the parameters, and if it assigns a value to a parameter, the
    change is *not* seen by the calling procedure. When objects are passed, the pointer
    to the data representing the object is copied, but the object’s attributes are
    not. For example, if *x* is a parameter of a called procedure, the assignment
    *x* = *y* within the called procedure is not visible to the calling procedure.
    The assignment *x.f* = 3, however, is visible if the calling procedure has a pointer
    to the same object as *x*. Similarly, arrays are passed by pointer, so that a
    pointer to the array is passed, rather than the entire array, and changes to individual
    array elements are visible to the calling procedure. Again, most contemporary
    programming languages work this way.'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过***按值***向过程传递参数：被调用的过程接收参数的自己副本，如果它给参数赋值，那么调用过程看不到这个改变。当对象被传递时，表示对象的数据指针被复制，但对象的属性不会被复制。例如，如果*x*是被调用过程的参数，那么在被调用过程内部的赋值*x*
    = *y*对调用过程是不可见的。然而，如果调用过程有指向与*x*相同对象的指针，那么赋值*x.f* = 3是可见的。同样，数组是通过指针传递的，因此传递的是数组的指针，而不是整个数组，对单个数组元素的更改对调用过程是可见的。再次强调，大多数当代编程语言都是这样工作的。
- en: A **return** statement immediately transfers control back to the point of call
    in the calling procedure. Most **return** statements also take a value to pass
    back to the caller. Our pseudocode differs from many programming languages in
    that we allow multiple values to be returned in a single **return** statement
    without having to create objects to package them together.^([8](#footnote_8))
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**return**语句立即将控制权传回调用过程的调用点。大多数**return**语句还会带有一个值传回给调用者。我们的伪代码与许多编程语言不同之处在于，我们允许在单个**return**语句中返回多个值，而无需创建对象将它们打包在一起。^([8](#footnote_8))'
- en: The boolean operators “and” and “or” are ***short circuiting***. That is, evaluate
    the expression “*x* and *y*” by first evaluating *x*. If *x* evaluates to FALSE,
    then the entire expression cannot evaluate to TRUE, and therefore *y* is not evaluated.
    If, on the other hand, *x* evaluates to TRUE, *y* must be evaluated to determine
    the value of the entire expression. Similarly, in the expression “*x* or *y*”
    the expression *y* is evaluated only if *x* evaluates to FALSE. Short-circuiting
    operators allow us to write boolean expressions such as “*x* ≠ NIL and *x.f* =
    *y*” without worrying about what happens upon evaluating *x.f* when *x* is NIL.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 布尔运算符“and”和“or”是***短路运算***的。也就是说，通过首先评估*x*来评估表达式“*x* and *y*”。如果*x*评估为FALSE，那么整个表达式不能评估为TRUE，因此*y*不会被评估。另一方面，如果*x*评估为TRUE，则必须评估*y*以确定整个表达式的值。类似地，在表达式“*x*
    or *y*”中，只有当*x*评估为FALSE时才评估表达式*y*。短路运算符允许我们编写布尔表达式，如“*x* ≠ NIL and *x.f* = *y*”，而不用担心在*x*为NIL时评估*x.f*会发生什么。
- en: The keyword **error** indicates that an error occurred because conditions were
    wrong for the procedure to have been called, and the procedure immediately terminates.
    The calling procedure is responsible for handling the error, and so we do not
    specify what action to take.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关键字**error**表示发生错误，因为调用过程的条件不正确，所以过程立即终止。调用过程负责处理错误，因此我们不指定要采取的操作。
- en: '**Exercises**'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***2.1-1***'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '***2.1-1***'
- en: Using [Figure 2.2](chapter002.xhtml#Fig_2-2) as a model, illustrate the operation
    of INSERTION-SORT on an array initially containing the sequence 〈31, 41, 59, 26,
    41, 58〉.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[图2.2](chapter002.xhtml#Fig_2-2)作为模型，说明在初始包含序列〈31, 41, 59, 26, 41, 58〉的数组上执行INSERTION-SORT的操作。
- en: '***2.1-2***'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '***2.1-2***'
- en: 'Consider the procedure SUM-ARRAY on the facing page. It computes the sum of
    the *n* numbers in array *A*[1 : *n*]. State a loop invariant for this procedure,
    and use its initialization, maintenance, and termination properties to show that
    the SUM-ARRAY procedure returns the sum of the numbers in *A*[1 : *n*].'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑面向页面的SUM-ARRAY过程。它计算数组*A*[1 : *n*]中*n*个数字的和。为该过程陈述一个循环不变式，并使用其初始化、维护和终止属性来展示SUM-ARRAY过程返回*A*[1
    : *n*]中数字的和。'
- en: SUM-ARRAY(*A, n*)
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: SUM-ARRAY(*A, n*)
- en: '| 1 | *sum* = 0 |'
  id: totrans-62
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *sum* = 0 |'
- en: '| 2 | **for** *i* = 1 **to** *n* |'
  id: totrans-63
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **for** *i* = 1 **to** *n* |'
- en: '| 3 | *sum* = *sum* + *A*[*i*] |'
  id: totrans-64
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *sum* = *sum* + *A*[*i*] |'
- en: '| 4 | **return** *sum* |'
  id: totrans-65
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **return** *sum* |'
- en: '***2.1-3***'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: '***2.1-3***'
- en: Rewrite the INSERTION-SORT procedure to sort into monotonically decreasing instead
    of monotonically increasing order.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 重写INSERTION-SORT过程，以按单调递减顺序排序而不是单调递增顺序。
- en: '***2.1-4***'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '***2.1-4***'
- en: 'Consider the ***searching problem***:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑***搜索问题***：
- en: '**Input:** A sequence of *n* numbers 〈*a*[1], *a*[2], … , *a[n]*〉 stored in
    array *A*[1 : *n*] and a value *x*.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入:** 存储在数组*A*[1 : *n*]中的*n*个数字序列〈*a*[1], *a*[2], … , *a[n]*〉和一个值*x*。'
- en: '**Output:** An index *i* such that *x* equals *A*[*i*] or the special value
    NIL if *x* does not appear in *A*.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**输出:** 一个索引*i*，使得*x*等于*A*[*i*]，或者特殊值NIL，如果*x*不出现在*A*中。'
- en: Write pseudocode for ***linear search***, which scans through the array from
    beginning to end, looking for *x*. Using a loop invariant, prove that your algorithm
    is correct. Make sure that your loop invariant fulfills the three necessary properties.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 编写***线性搜索***的伪代码，该算法从头到尾扫描数组，寻找*x*。使用循环不变式证明你的算法是正确的。确保你的循环不变式满足三个必要属性。
- en: '***2.1-5***'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '***2.1-5***'
- en: 'Consider the problem of adding two *n*-bit binary integers *a* and *b*, stored
    in two *n*-element arrays *A*[0 : *n* – 1] and *B*[0 : *n* – 1], where each element
    is either 0 or 1, ![art](images/Art_P10.jpg), and ![art](images/Art_P11.jpg).
    The sum *c* = *a* + *b* of the two integers should be stored in binary form in
    an (*n* + 1)-element array *C* [0 : *n*], where ![art](images/Art_P12.jpg). Write
    a procedure ADD-BINARY-INTEGERS that takes as input arrays *A* and *B*, along
    with the length *n*, and returns array *C* holding the sum.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑将两个*n*位二进制整数*a*和*b*相加的问题，它们分别存储在两个*n*元素数组*A*[0 : *n* – 1]和*B*[0 : *n* – 1]中，其中每个元素都是0或1，![art](images/Art_P10.jpg)，以及![art](images/Art_P11.jpg)。两个整数的和*c*
    = *a* + *b*应以二进制形式存储在一个(*n* + 1)元素数组*C*[0 : *n*]中，其中![art](images/Art_P12.jpg)。编写一个名为ADD-BINARY-INTEGERS的过程，该过程接受数组*A*和*B*以及长度*n*作为输入，并返回存储和的数组*C*。'
- en: '[**2.2      Analyzing algorithms**](toc.xhtml#Rh1-7)'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '[**2.2      分析算法**](toc.xhtml#Rh1-7)'
- en: '***Analyzing*** an algorithm has come to mean predicting the resources that
    the algorithm requires. You might consider resources such as memory, communication
    bandwidth, or energy consumption. Most often, however, you’ll want to measure
    computational time. If you analyze several candidate algorithms for a problem,
    you can identify the most efficient one. There might be more than just one viable
    candidate, but you can often rule out several inferior algorithms in the process.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '***分析***算法已经意味着预测算法所需的资源。您可能考虑资源，如内存、通信带宽或能源消耗。然而，最常见的情况是您希望测量计算时间。如果为一个问题分析了几个候选算法，您可以确定最有效的算法。可能不止一个可行的候选算法，但在这个过程中通常可以排除几个较差的算法。'
- en: Before you can analyze an algorithm, you need a model of the technology that
    it runs on, including the resources of that technology and a way to express their
    costs. Most of this book assumes a generic one-processor, ***random-access machine
    (RAM)*** model of computation as the implementation technology, with the understanding
    that algorithms are implemented as computer programs. In the RAM model, instructions
    execute one after another, with no concurrent operations. The RAM model assumes
    that each instruction takes the same amount of time as any other instruction and
    that each data access—using the value of a variable or storing into a variable—takes
    the same amount of time as any other data access. In other words, in the RAM model
    each instruction or data access takes a constant amount of time—even indexing
    into an array.^([9](#footnote_9))
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在分析算法之前，您需要一个运行该算法的技术模型，包括该技术的资源以及表达它们成本的方式。本书的大部分内容假定一种通用的单处理器、***随机访问机器（RAM）***计算模型作为实现技术，理解算法是作为计算机程序实现的。在RAM模型中，指令依次执行，没有并发操作。RAM模型假设每条指令的执行时间与任何其他指令相同，并且每次数据访问——使用变量的值或存储到变量中——所需的时间与任何其他数据访问相同。换句话说，在RAM模型中，每条指令或数据访问都需要固定的时间——甚至是对数组进行索引。^([9](#footnote_9))
- en: 'Strictly speaking, we should precisely define the instructions of the RAM model
    and their costs. To do so, however, would be tedious and yield little insight
    into algorithm design and analysis. Yet we must be careful not to abuse the RAM
    model. For example, what if a RAM had an instruction that sorts? Then you could
    sort in just one step. Such a RAM would be unrealistic, since such instructions
    do not appear in real computers. Our guide, therefore, is how real computers are
    designed. The RAM model contains instructions commonly found in real computers:
    arithmetic (such as add, subtract, multiply, divide, remainder, floor, ceiling),
    data movement (load, store, copy), and control (conditional and unconditional
    branch, subroutine call and return).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 严格来说，我们应该精确定义RAM模型的指令及其成本。然而，这样做将是乏味的，并且对算法设计和分析没有太多见解。但我们必须小心不要滥用RAM模型。例如，如果RAM有一个排序指令会怎么样？那么你可以在一步中完成排序。这样的RAM是不现实的，因为真实计算机中不存在这样的指令。因此，我们的指导是真实计算机的设计方式。RAM模型包含在真实计算机中常见的指令：算术（如加、减、乘、除、余数、向下取整、向上取整）、数据移动（加载、存储、复制）和控制（条件和无条件分支、子程序调用和返回）。
- en: The data types in the RAM model are integer, floating point (for storing real-number
    approximations), and character. Real computers do not usually have a separate
    data type for the boolean values TRUE and FALSE. Instead, they often test whether
    an integer value is 0 (FALSE) or nonzero (TRUE), as in C. Although we typically
    do not concern ourselves with precision for floating-point values in this book
    (many numbers cannot be represented exactly in floating point), precision is crucial
    for most applications. We also assume that each word of data has a limit on the
    number of bits. For example, when working with inputs of size *n*, we typically
    assume that integers are represented by *c* log[2] *n* bits for some constant
    *c* ≥ 1\. We require *c* ≥ 1 so that each word can hold the value of *n*, enabling
    us to index the individual input elements, and we restrict *c* to be a constant
    so that the word size does not grow arbitrarily. (If the word size could grow
    arbitrarily, we could store huge amounts of data in one word and operate on it
    all in constant time—an unrealistic scenario.)
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: RAM模型中的数据类型包括整数、浮点数（用于存储实数近似值）和字符。真实计算机通常没有单独的数据类型来表示布尔值TRUE和FALSE。相反，它们通常测试一个整数值是否为0（FALSE）或非零（TRUE），就像在C语言中一样。尽管在本书中我们通常不关心浮点值的精度（许多数字在浮点数中无法精确表示），但对于大多数应用程序来说，精度至关重要。我们还假设每个数据字的位数有一个限制。例如���在处理大小为*n*的输入时，我们通常假设整数由*c*
    log[2] *n*位表示，其中*c* ≥ 1是一个常数。我们要求*c* ≥ 1，以便每个字可以保存*n*的值，从而使我们能够索引各个输入元素，并且我们限制*c*为常数，以便字长不会任意增长。（如果字长可以任意增长，我们可以在一个字中存储大量数据并在常数时间内操作所有数据——这是一个不现实的场景。）
- en: 'Real computers contain instructions not listed above, and such instructions
    represent a gray area in the RAM model. For example, is exponentiation a constant-time
    instruction? In the general case, no: to compute *x^n* when *x* and *n* are general
    integers typically takes time logarithmic in *n* (see equation (31.34) on page
    934), and you must worry about whether the result fits into a computer word. If
    *n* is an exact power of 2, however, exponentiation can usually be viewed as a
    constant-time operation. Many computers have a “shift left” instruction, which
    in constant time shifts the bits of an integer by *n* positions to the left. In
    most computers, shifting the bits of an integer by 1 position to the left is equivalent
    to multiplying by 2, so that shifting the bits by *n* positions to the left is
    equivalent to multiplying by 2*^n*. Therefore, such computers can compute 2*^n*
    in 1 constant-time instruction by shifting the integer 1 by *n* positions to the
    left, as long as *n* is no more than the number of bits in a computer word. We’ll
    try to avoid such gray areas in the RAM model and treat computing 2*^n* and multiplying
    by 2*^n* as constant-time operations when the result is small enough to fit in
    a computer word.'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 真实计算机包含上述未列出的指令，这些指令在 RAM 模型中代表一个灰色区域。例如，幂运算是否是一个常数时间指令？一般情况下，不是：计算*x^n*当*x*和*n*是一般整数时，通常需要对*n*进行对数时间的计算（见第934页的方程（31.34）），并且您必须担心结果是否适合计算机字。然而，如果*n*是一个确切的2的幂，幂运算通常可以视为常数时间操作。许多计算机有一个“左移”指令，它在常数时间内将整数的位向左移动*n*个位置。在大多数计算机中，将整数的位向左移动1个位置等效于乘以2，因此将整数的位向左移动*n*个位置等效于乘以2*^n*。因此，这样的计算机可以通过将整数左移1个位置来在1个常数时间指令中计算2*^n*，只要*n*不超过计算机字中的位数。我们将尽量避免
    RAM 模型中的这种灰色区域，并在结果小到适合计算机字时将计算2*^n*和乘以2*^n*视为常数时间操作。
- en: The RAM model does not account for the memory hierarchy that is common in contemporary
    computers. It models neither caches nor virtual memory. Several other computational
    models attempt to account for memory-hierarchy effects, which are sometimes significant
    in real programs on real machines. [Section 11.5](chapter011.xhtml#Sec_11.5) and
    a handful of problems in this book examine memory-hierarchy effects, but for the
    most part, the analyses in this book do not consider them. Models that include
    the memory hierarchy are quite a bit more complex than the RAM model, and so they
    can be difficult to work with. Moreover, RAM-model analyses are usually excellent
    predictors of performance on actual machines.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: RAM 模型不考虑当代计算机中常见的存储器层次结构。它既不模拟缓存，也不模拟虚拟内存。几种其他计算模型试图考虑存储器层次结构的影响，这在实际机器上的真实程序中有时很重要。本书的[第11.5节](chapter011.xhtml#Sec_11.5)和一些问题探讨了存储器层次结构的影响，但在大部分情况下，本书的分析并未考虑它们。包含存储器层次结构的模型比
    RAM 模型复杂得多，因此可能难以处理。此外，RAM 模型的分析通常是实际机器性能的出色预测器。
- en: Although it is often straightforward to analyze an algorithm in the RAM model,
    sometimes it can be quite a challenge. You might need to employ mathematical tools
    such as combinatorics, probability theory, algebraic dexterity, and the ability
    to identify the most significant terms in a formula. Because an algorithm might
    behave differently for each possible input, we need a means for summarizing that
    behavior in simple, easily understood formulas.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在 RAM 模型中分析算法通常很直接，但有时可能会很具挑战性。您可能需要运用诸如组合数学、概率论、代数灵活性以及识别公式中最重要项的能力等数学工具。由于算法可能对每个可能的输入表现不同，我们需要一种方法来用简单易懂的公式总结其行为。
- en: '**Analysis of insertion sort**'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '**插入排序的分析**'
- en: How long does the INSERTION-SORT procedure take? One way to tell would be for
    you to run it on your computer and time how long it takes to run. Of course, you’d
    first have to implement it in a real programming language, since you cannot run
    our pseudocode directly. What would such a timing test tell you? You would find
    out how long insertion sort takes to run on your particular computer, on that
    particular input, under the particular implementation that you created, with the
    particular compiler or interpreter that you ran, with the particular libraries
    that you linked in, and with the particular background tasks that were running
    on your computer concurrently with your timing test (such as checking for incoming
    information over a network). If you run insertion sort again on your computer
    with the same input, you might even get a different timing result. From running
    just one implementation of insertion sort on just one computer and on just one
    input, what would you be able to determine about insertion sort’s running time
    if you were to give it a different input, if you were to run it on a different
    computer, or if you were to implement it in a different programming language?
    Not much. We need a way to predict, given a new input, how long insertion sort
    will take.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: INSERTION-SORT 程序需要多长时间？一种方法是在您的计算机上运行它并计算运行时间。当然，您首先必须在真实编程语言中实现它，因为您无法直接运行我们的伪代码。这样的定时测试会告诉您什么？您将了解插入排序在您特定的计算机上运行所需的时间，对于特定的输入，在您创建的特定实现下，在您运行的特定编译器或解释器下，在您链接的特定库下，以及在您计算机上与您的定时测��同时运行的特定后台任务（例如检查网络上的传入信息）。如果您再次在您的计算机上使用相同的输入运行插入排序，您甚至可能得到不同的定时结果。仅通过在一个计算机上运行一个插入排序实现并在一个输入上运行，如果您给它不同的输入，如果您在不同的计算机上运行它，或者如果您在不同的编程语言中实现它，您将能够确定插入排序的运行时间吗？不多。我们需要一种方法来预测，给定一个新输入，插入排序将需要多长时间。
- en: Instead of timing a run, or even several runs, of insertion sort, we can determine
    how long it takes by analyzing the algorithm itself. We’ll examine how many times
    it executes each line of pseudocode and how long each line of pseudocode takes
    to run. We’ll first come up with a precise but complicated formula for the running
    time. Then, we’ll distill the important part of the formula using a convenient
    notation that can help us compare the running times of different algorithms for
    the same problem.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过分析算法本身来确定插入排序需要多长时间，而不是计时一次运行，甚至多次运行。我们将检查伪代码的每一行执行多少次以及每一行伪代码运行多长时间。我们首先为运行时间制定一个精确但复杂的公式。然后，我们将使用方便的符号提炼出公式的重要部分，这可以帮助我们比较相同问题的不同算法的运行时间。
- en: How do we analyze insertion sort? First, let’s acknowledge that the running
    time depends on the input. You shouldn’t be terribly surprised that sorting a
    thousand numbers takes longer than sorting three numbers. Moreover, insertion
    sort can take different amounts of time to sort two input arrays of the same size,
    depending on how nearly sorted they already are. Even though the running time
    can depend on many features of the input, we’ll focus on the one that has been
    shown to have the greatest effect, namely the size of the input, and describe
    the running time of a program as a function of the size of its input. To do so,
    we need to define the terms “running time” and “input size” more carefully. We
    also need to be clear about whether we are discussing the running time for an
    input that elicits the worst-case behavior, the best-case behavior, or some other
    case.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何分析插入排序？首先，让我们承认运行时间取决于输入。排序一千个数字所需的时间比排序三个数字所需的时间长并不奇怪。此外，插入排序对于排序两个大小相同的输入数组可能需要不同的时间，这取决于它们已经排序得有多接近。即使运行时间可能取决于输入的许多特征，我们将专注于已被证明具有最大影响的特征，即输入大小，并将程序的运行时间描述为其输入大小的函数。为此，我们需要更仔细地定义“运行时间”和“输入大小”的术语。我们还需要明确我们是否讨论引发最坏情况行为、最佳情况行为或其他情况的输入的运行时间。
- en: The best notion for ***input size*** depends on the problem being studied. For
    many problems, such as sorting or computing discrete Fourier transforms, the most
    natural measure is the *number of items in the input*—for example, the number
    *n* of items being sorted. For many other problems, such as multiplying two integers,
    the best measure of input size is the *total number of bits* needed to represent
    the input in ordinary binary notation. Sometimes it is more appropriate to describe
    the size of the input with more than just one number. For example, if the input
    to an algorithm is a graph, we usually characterize the input size by both the
    number of vertices and the number of edges in the graph. We’ll indicate which
    input size measure is being used with each problem we study.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '***输入大小*** 的最佳概念取决于所研究的问题。对于许多问题，例如排序或计算离散傅立叶变换，最自然的度量是输入中的项目数量，例如，正在排序的项目数量*n*。对于许多其他问题，例如两个整数相乘，输入大小的最佳度量是表示输入所需的总位数，以普通二进制表示法表示。有时，用不止一个数字描述输入大小更合适。例如，如果算法的输入是一个图，我们通常通过图中的顶点数和边数来表征输入大小。我们将在研究每个问题时指出使用的输入大小度量。'
- en: The ***running time*** of an algorithm on a particular input is the number of
    instructions and data accesses executed. How we account for these costs should
    be independent of any particular computer, but within the framework of the RAM
    model. For the moment, let us adopt the following view. A constant amount of time
    is required to execute each line of our pseudocode. One line might take more or
    less time than another line, but we’ll assume that each execution of the *k*th
    line takes *c[k]* time, where *c[k]* is a constant. This viewpoint is in keeping
    with the RAM model, and it also reflects how the pseudocode would be implemented
    on most actual computers.^([10](#footnote_10))
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 算法在特定输入上的***运行时间*** 是执行的指令和数据访问次数。我们如何计算这些成本应该独立于任何特定计算机，但在RAM模型的框架内。暂时，让我们采用以下观点。执行伪代码的每一行都需要恒定的时间。一行可能比另一行花费更多或更少的时间，但我们假设第*k*行的每次执行都需要*c[k]*时间，其中*c[k]*是一个常数。这个观点符合RAM模型，并反映了伪代码在大多数实际计算机上的实现方式。
- en: Let’s analyze the INSERTION-SORT procedure. As promised, we’ll start by devising
    a precise formula that uses the input size and all the statement costs *c[k]*.
    This formula turns out to be messy, however. We’ll then switch to a simpler notation
    that is more concise and easier to use. This simpler notation makes clear how
    to compare the running times of algorithms, especially as the size of the input
    increases.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分析**插入排序**过程。正如承诺的那样，我们将首先设计一个精确的公式，该公式使用输入大小和所有语句成本*c[k]*。然而，这个公式变得混乱。然后，我们将转换为更简洁、更易于使用的简单符号。这种简单符号清楚地说明了如何比较算法的运行时间，特别是随着输入大小的增加。
- en: To analyze the INSERTION-SORT procedure, let’s view it on the following page
    with the time cost of each statement and the number of times each statement is
    executed. For each *i* = 2, 3, … , *n*, let *t[i]* denote the number of times
    the **while** loop test in line 5 is executed for that value of *i*. When a **for**
    or **while** loop exits in the usual way—because the test in the loop header comes
    up FALSE—the test is executed one time more than the loop body. Because comments
    are not executable statements, assume that they take no time.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要分析**插入排序**过程，让我们在下一页上查看每个语句的时间成本以及每个语句执行的次数。对于每个*i* = 2, 3, … , *n*，让*t[i]*表示第5行中**while**循环测试对于该*i*值执行的次数。当**for**或**while**循环以通常方式退出——因为循环头中的测试为FALSE时，测试执行的次数比循环体多一次。由于注释不是可执行语句，假设它们不需要时间。
- en: The running time of the algorithm is the sum of running times for each statement
    executed. A statement that takes *c[k]* steps to execute and executes *m* times
    contributes *c[k]m* to the total running time.^([11](#footnote_11)) We usually
    denote the running time of an algorithm on an input of size *n* by *T* (*n*).
    To compute *T* (*n*), the running time of INSERTION-SORT on an input of *n* values,
    we sum the products of the *cost* and *times* columns, obtaining
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 算法的运行时间是执行每条语句的运行时间之和。执行一条需要*c[k]*步的语句*m*次会为总运行时间贡献*c[k]m*。我们通常用*T*(*n*)表示算法在大小为*n*的输入上的运行时间。为了计算*T*(*n*)，即在*n*个值的输入上的INSERTION-SORT的运行时间，我们求和*cost*和*times*列的乘积，得到
- en: '| INSERTION-SORT(*A, n*) | *cost* | *times* |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| INSERTION-SORT(*A, n*) | *cost* | *times* |'
- en: '| 1 | **for** *i* = 2 **to** *n* | *c*[1] | *n* |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **for** *i* = 2 **to** *n* | *c*[1] | *n* |'
- en: '| 2 | *key* = *A*[*i*] | *c*[2] | *n* – 1 |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *key* = *A*[*i*] | *c*[2] | *n* – 1 |'
- en: '| 3 | **//** Insert *A*[*i*] into the sorted subarray *A*[1 : *i* – 1]. | 0
    | *n* – 1 |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **//** 将*A*[*i*]插入已排序的子数组*A*[1 : *i* – 1]。 | 0 | *n* – 1 |'
- en: '| 4 | *j* = *i* – 1 | *c*[4] | *n* – 1 |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *j* = *i* – 1 | *c*[4] | *n* – 1 |'
- en: '| 5 | **while** *j* > 0 and *A*[*j*] > *key* | *c*[5] | ![art](images/Art_P13.jpg)
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 5 | **while** *j* > 0 and *A*[*j*] > *key* | *c*[5] | ![art](images/Art_P13.jpg)
    |'
- en: '| 6 | *A*[*j* + 1] = *A*[*j*] | *c*[6] | ![art](images/Art_P14.jpg) |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 6 | *A*[*j* + 1] = *A*[*j*] | *c*[6] | ![art](images/Art_P14.jpg) |'
- en: '| 7 | *j* = *j* – 1 | *c*[7] | ![art](images/Art_P15.jpg) |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 7 | *j* = *j* – 1 | *c*[7] | ![art](images/Art_P15.jpg) |'
- en: '| 8 | *A*[*j* + 1] = *key* | *c*[8] | *n* – 1 |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| 8 | *A*[*j* + 1] = *key* | *c*[8] | *n* – 1 |'
- en: '![art](images/Art_P16.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P16.jpg)'
- en: 'Even for inputs of a given size, an algorithm’s running time may depend on
    *which* input of that size is given. For example, in INSERTION-SORT, the best
    case occurs when the array is already sorted. In this case, each time that line
    5 executes, the value of *key*—the value originally in *A*[*i*]—is already greater
    than or equal to all values in *A*[1 : *i* – 1], so that the **while** loop of
    lines 5–7 always exits upon the first test in line 5\. Therefore, we have that
    *t[i]* = 1 for *i* = 2, 3, … , *n*, and the best-case running time is given by'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '即使对于给定大小的输入，算法的运行时间也可能取决于给定大小的*哪个*输入。例如，在INSERTION-SORT中，最佳情况发生在数组已经排序的情况下。在这种情况下，每当第5行执行时，*key*的值（最初在*A*[*i*]中的值）已经大于或等于*A*[1
    : *i* – 1]中的所有值，因此第5-7行的**while**循环总是在第5行的���一次测试时退出。因此，我们有*t[i]* = 1，对于*i* =
    2, 3, … , *n*，最佳情况的运行时间由此给出'
- en: '![art](images/Art_P17.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P17.jpg)'
- en: We can express this running time as *an* + *b* for *constants a* and *b* that
    depend on the statement costs *c[k]* (where *a* = *c*[1] + *c*[2] + *c*[4] + *c*[5]
    + *c*[8] and *b* = *c*[2] + *c*[4] + *c*[5] + *c*[8]). The running time is thus
    a ***linear function*** of *n*.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个运行时间表示为*an* + *b*，其中*常数a*和*b*取决于语句成本*c[k]*（其中*a* = *c*[1] + *c*[2] +
    *c*[4] + *c*[5] + *c*[8]，*b* = *c*[2] + *c*[4] + *c*[5] + *c*[8]）。因此，运行时间是*n*的一个***线性函数***。
- en: 'The worst case arises when the array is in reverse sorted order—that is, it
    starts out in decreasing order. The procedure must compare each element *A*[*i*]
    with each element in the entire sorted subarray *A*[1 : *i* – 1], and so *t[i]*
    = *i* for *i* = 2, 3, … , *n*. (The procedure finds that *A*[*j*] > *key* every
    time in line 5, and the **while** loop exits only when *j* reaches 0.) Noting
    that'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '最坏情况出现在数组是逆序排序的情况下，即它起始于降序。该过程必须将每个元素*A*[*i*]与整个已排序子数组*A*[1 : *i* – 1]中的每个元素进行比较，因此*t[i]*
    = *i*，对于*i* = 2, 3, … , *n*。（该过程发现每次在第5行中*A*[*j*] > *key*，并且**while**循环仅在*j*达到0时退出。）注意到'
- en: '![art](images/Art_P18.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P18.jpg)'
- en: and
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 和
- en: '![art](images/Art_P19.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P19.jpg)'
- en: we find that in the worst case, the running time of INSERTION-SORT is
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们发现，在最坏情况下，INSERTION-SORT的运行时间是
- en: '![art](images/Art_P20.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P20.jpg)'
- en: We can express this worst-case running time as *an*² + *bn* + *c* for constants
    *a*, *b*, and *c* that again depend on the statement costs *c[k]* (now, *a* =
    *c*[5]/2 + *c*[6]/2 + *c*[7]/2, *b* = *c*[1] + *c*[2] + *c*[4] + *c*[5]/2 – *c*[6]/2
    – *c*[7]/2 + *c*[8], and *c* = –(*c*[2] + *c*[4] + *c*[5] + *c*[8])). The running
    time is thus a ***quadratic function*** of *n*.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将这个最坏情况运行时间表示为*an*² + *bn* + *c*，其中常数*a*、*b*和*c*再次取决于语句成本*c[k]*（现在，*a* =
    *c*[5]/2 + *c*[6]/2 + *c*[7]/2，*b* = *c*[1] + *c*[2] + *c*[4] + *c*[5]/2 – *c*[6]/2
    – *c*[7]/2 + *c*[8]，*c* = –(*c*[2] + *c*[4] + *c*[5] + *c*[8]）。因此，运行时间是*n*的一个***二次函数***。
- en: Typically, as in insertion sort, the running time of an algorithm is fixed for
    a given input, although we’ll also see some interesting “randomized” algorithms
    whose behavior can vary even for a fixed input.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，就像插入排序一样，算法的运行时间对于给定的输入是固定的，尽管我们也会看到一些有趣的“随机化”算法，它们的行为甚至对于固定输入也可能有所变化。
- en: '**Worst-case and average-case analysis**'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '**最坏情况和平均情况分析**'
- en: 'Our analysis of insertion sort looked at both the best case, in which the input
    array was already sorted, and the worst case, in which the input array was reverse
    sorted. For the remainder of this book, though, we’ll usually (but not always)
    concentrate on finding only the ***worst-case running time***, that is, the longest
    running time for *any* input of size *n*. Why? Here are three reasons:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对插入排序的分析考虑了最佳情况，即输入数组已经排序，以及最坏情况，即输入数组是逆序排序的。然而，在本书的其余部分，我们通常（但并非总是）集中于找到只有***最坏情况运行时间***，即对于大小为*n*的*任何*输入的最长运行时间。为什么？以下是三个原因：
- en: The worst-case running time of an algorithm gives an upper bound on the running
    time for *any* input. If you know it, then you have a guarantee that the algorithm
    never takes any longer. You need not make some educated guess about the running
    time and hope that it never gets much worse. This feature is especially important
    for real-time computing, in which operations must complete by a deadline.
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 算法的最坏情况运行时间给出了对*任何*输入的运行时间的上界。如果你知道它，那么你就有保证算法永远不会花费更长的时间。你不需要对运行时间做一些有根据的猜测，并希望它永远不会变得更糟。这个特性对于实时计算特别重要，其中操作必须在截止日期前完成。
- en: For some algorithms, the worst case occurs fairly often. For example, in searching
    a database for a particular piece of information, the searching algorithm’s worst
    case often occurs when the information is not present in the database. In some
    applications, searches for absent information may be frequent.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一些算法，最坏情况经常发生。例如，在搜索数据库中特定信息时，搜索算法的最坏情况经常发生在信息不在数据库中的情况下。在一些应用中，搜索缺失信息的情况可能很频繁。
- en: 'The “average case” is often roughly as bad as the worst case. Suppose that
    you run insertion sort on an array of *n* randomly chosen numbers. How long does
    it take to determine where in subarray *A*[1 : *i* – 1] to insert element *A*[*i*]?
    On average, half the elements in *A*[1 : *i* – 1] are less than *A*[*i*], and
    half the elements are greater. On average, therefore, *A*[*i*] is compared with
    just half of the subarray *A*[1 : *i* – 1], and so *t[i]* is about *i*/2\. The
    resulting average-case running time turns out to be a quadratic function of the
    input size, just like the worst-case running time.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '“平均情况”通常与最坏情况一样糟糕。假设你在一个包含*n*个随机选择数字的数组上运行插入排序算法。确定在子数组*A*[1 : *i* – 1]中插入元素*A*[*i*]需要多长时间？平均而言，子数组*A*[1
    : *i* – 1]中一半的元素小于*A*[*i*]，另一半大于*A*[*i*]。因此，平均而言，*A*[*i*]只与子数组*A*[1 : *i* – 1]的一半进行比较，因此*t[i]*约为*i*/2。结果得到的平均情况运行时间是输入规模的二次函数，就像最坏情况运行时间一样。'
- en: In some particular cases, we’ll be interested in the ***average-case*** running
    time of an algorithm. We’ll see the technique of ***probabilistic analysis***
    applied to various algorithms throughout this book. The scope of average-case
    analysis is limited, because it may not be apparent what constitutes an “average”
    input for a particular problem. Often, we’ll assume that all inputs of a given
    size are equally likely. In practice, this assumption may be violated, but we
    can sometimes use a ***randomized algorithm***, which makes random choices, to
    allow a probabilistic analysis and yield an ***expected*** running time. We explore
    randomized algorithms more in [Chapter 5](chapter005.xhtml) and in several other
    subsequent chapters.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在一些特定情况下，我们会对算法的***平均情况***运行时间感兴趣。我们将在本书中的各种算法中看到***概率分析***技术的应用。平均情况分析的范围有限，因为对于特定问题，什么构成“平均”输入可能并不明显。通常，我们会假设给定大小的所有输入是等概率的。在实践中，这种假设可能被违反，但我们有时可以使用***随机算法***，即进行随机选择，以允许概率分析并得出***期望***运行时间。我们将在[第5章](chapter005.xhtml)和随后的几章中更深入探讨随机算法。
- en: '**Order of growth**'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '**增长阶**'
- en: In order to ease our analysis of the INSERTION-SORT procedure, we used some
    simplifying abstractions. First, we ignored the actual cost of each statement,
    using the constants *c[k]* to represent these costs. Still, the best-case and
    worst-case running times in equations (2.1) and (2.2) are rather unwieldy. The
    constants in these expressions give us more detail than we really need. That’s
    why we also expressed the best-case running time as *an* + *b* for constants *a*
    and *b* that depend on the statement costs *c[k]* and why we expressed the worst-case
    running time as *an*² + *bn* + *c* for constants *a*, *b*, and *c* that depend
    on the statement costs. We thus ignored not only the actual statement costs, but
    also the abstract costs *c[k]*.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化我们对INSERTION-SORT过程的分析，我们使用了一些简化的抽象。首先���我们忽略了每个语句的实际成本，使用常数*c[k]*来表示这些成本。然而，在方程(2.1)和(2.2)中，最佳情况和最坏情况的运行时间相当复杂。这些表达式中的常数给了我们比我们实际需要的更多细节。这就是为什么我们将最佳情况的运行时间表示为*an*
    + *b*，其中常数*a*和*b*取决于语句成本*c[k]*，以及为什么我们将最坏情况的运行时间表示为*an*² + *bn* + *c*，其中常数*a*、*b*和*c*取决于语句成本。因此，我们不仅忽略了实际语句成本，还忽略了抽象成本*c[k]*。
- en: 'Let’s now make one more simplifying abstraction: it is the ***rate of growth***,
    or ***order of growth***, of the running time that really interests us. We therefore
    consider only the leading term of a formula (e.g., *an*²), since the lower-order
    terms are relatively insignificant for large values of *n*. We also ignore the
    leading term’s constant coefficient, since constant factors are less significant
    than the rate of growth in determining computational efficiency for large inputs.
    For insertion sort’s worst-case running time, when we ignore the lower-order terms
    and the leading term’s constant coefficient, only the factor of *n*² from the
    leading term remains. That factor, *n*², is by far the most important part of
    the running time. For example, suppose that an algorithm implemented on a particular
    machine takes *n*²/100 + 100*n* + 17 microseconds on an input of size *n*. Although
    the coefficients of 1/100 for the *n*² term and 100 for the *n* term differ by
    four orders of magnitude, the *n*²/100 term dominates the 100*n* term once *n*
    exceeds 10,000\. Although 10,000 might seem large, it is smaller than the population
    of an average town. Many real-world problems have much larger input sizes.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们再进行一个简化的抽象：真正让我们感兴趣的是运行时间的***增长率***或***增长阶***。因此，我们只考虑公式的主导项（例如，*an*²），因为对于较大的*n*值，低阶项相对不重要。我们还忽略主导项的常数系数，因为常数因子在决定大输入情况下的计算效率时不如增长率重要。对于插入排序的最坏情况运行时间，当我们忽略低阶项和主导项的常数系数时，只剩下主导项的*n*²因子。这个因子*n*²远比运行时间的其他部分重要。例如，假设在特定机器上实现的算法在大小为*n*的输入上需要*n*²/100
    + 100*n* + 17微秒。尽管*n*²项的系数1/100和*n*项的系数100相差四个数量级，但一旦*n*超过10,000，*n*²/100项就会主导100*n*项。尽管10,000可能看起来很大，但它比一个普通城镇的人口要小。许多现实世界的问题具有更大的输入规模。
- en: To highlight the order of growth of the running time, we have a special notation
    that uses the Greek letter Θ (theta). We write that insertion sort has a worst-case
    running time of Θ(*n*²) (pronounced “theta of *n*-squared” or just “theta *n*-squared”).
    We also write that insertion sort has a best-case running time of Θ(*n*) (“theta
    of *n*” or “theta *n*”). For now, think of Θ-notation as saying “roughly proportional
    when *n* is large,” so that Θ(*n*²) means “roughly proportional to *n*² when *n*
    is large” and Θ(*n*) means “roughly proportional to *n* when *n* is large” We’ll
    use Θ-notation informally in this chapter and define it precisely in [Chapter
    3](chapter003.xhtml).
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突出运行时间的增长阶，我们有一个使用希腊字母Θ（theta）的特殊符号。我们写道插入排序的最坏情况运行时间为Θ(*n*²)（读作“theta of
    *n*-squared”或只是“theta *n*-squared”）。我们还写道插入排序的最佳情况运行时间为Θ(*n*)（“theta of *n*”或“theta
    *n*”）。现在，将Θ-符号视为在*n*很大时“大致成比例”，因此Θ(*n*²)意味着“当*n*很大时大致成比例于*n*²”，Θ(*n*)意味着“当*n*很大时大致成比例于*n*”。我们将在本章中非正式地使用Θ-符号，并在[第3章](chapter003.xhtml)中精确定义它。
- en: We usually consider one algorithm to be more efficient than another if its worst-case
    running time has a lower order of growth. Due to constant factors and lower-order
    terms, an algorithm whose running time has a higher order of growth might take
    less time for small inputs than an algorithm whose running time has a lower order
    of growth. But on large enough inputs, an algorithm whose worst-case running time
    is Θ(*n*²), for example, takes less time in the worst case than an algorithm whose
    worst-case running time is Θ(*n*³). Regardless of the constants hidden by the
    Θ-notation, there is always some number, say *n*[0], such that for all input sizes
    *n* ≥ *n*[0], the Θ(*n*²) algorithm beats the Θ(*n*³) algorithm in the worst case.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通常认为一个算法比另一个算法更有效，如果其最坏情况运行时间具有更低的增长阶。由于常数因子和低阶项，一个运行时间具有更高增长阶的算法可能在小输入时花费的时间比一个运行时间具有更低增长阶的算法少。但是在足够大的输入上，例如，一个最坏情况运行时间为Θ(*n*²)的算法在最坏情况下花费的时间比一个最坏情况运行时间为Θ(*n*³)的算法少。无论Θ-符号隐藏的常数如何，总会有一个数字，比如*n*[0]，对于所有输入大小*n*
    ≥ *n*[0]，Θ(*n*²)算法在最坏情况下击败Θ(*n*³)算法。
- en: '**Exercises**'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***2.2-1***'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '***2.2-1***'
- en: Express the function *n*³/1000 + 100*n*² – 100*n* + 3 in terms of Θ-notation.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 将函数*n*³/1000 + 100*n*² - 100*n* + 3表示为Θ-符号。
- en: '***2.2-2***'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: '***2.2-2***'
- en: 'Consider sorting *n* numbers stored in array *A*[1 : *n*] by first finding
    the smallest element of *A*[1 : *n*] and exchanging it with the element in *A*[1].
    Then find the smallest element of *A*[2 : *n*], and exchange it with *A*[2]. Then
    find the smallest element of *A*[3 : *n*], and exchange it with *A*[3]. Continue
    in this manner for the first *n* – 1 elements of *A*. Write pseudocode for this
    algorithm, which is known as ***selection sort***. What loop invariant does this
    algorithm maintain? Why does it need to run for only the first *n* – 1 elements,
    rather than for all *n* elements? Give the worst-case running time of selection
    sort in Θ-notation. Is the best-case running time any better?'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑对存储在数组*A*[1：*n*]中的*n*个数字进行排序，首先找到*A*[1：*n*]中最小的元素并将其与*A*[1]中的元素交换。然后找到*A*[2：*n*]中最小的元素，并将其与*A*[2]交换。然后找到*A*[3：*n*]中最小的元素，并将其与*A*[3]交换。以此类推，对*A*的前*n*
    - 1个元素继续这样做。为这种算法编写伪代码，这种算法被称为***选择排序***。这个算法维护什么循环不变式？为什么它只需要运行前*n* - 1个元素，而不是所有*n*个元素？给出选择排序的最坏情况运行时间的Θ-符号。最佳情况的运行时间是否更好？
- en: '***2.2-3***'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '***2.2-3***'
- en: Consider linear search again (see Exercise 2.1-4). How many elements of the
    input array need to be checked on the average, assuming that the element being
    searched for is equally likely to be any element in the array? How about in the
    worst case? Using Θ-notation, give the average-case and worst-case running times
    of linear search. Justify your answers.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 再次考虑线性搜索（见练习2.1-4）。假设被搜索的元素等可能地是数组中的任何一个元素，平均需要检查输入数组的多少个元素？最坏情况呢？使用Θ-符号，给出线性搜索的平均情况和最坏情况的运行时间。证明你的答案。
- en: '***2.2-4***'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '***2.2-4***'
- en: How can you modify any sorting algorithm to have a good best-case running time?
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如何修改任何排序算法以获得良好的最佳情况运行时间？
- en: '[**2.3      Designing algorithms**](toc.xhtml#Rh1-8)'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '[**2.3      设计算法**](toc.xhtml#Rh1-8)'
- en: 'You can choose from a wide range of algorithm design techniques. Insertion
    sort uses the ***incremental*** method: for each element *A*[*i*], insert it into
    its proper place in the subarray *A*[1 : *i*], having already sorted the subarray
    *A*[1 : *i* – 1].'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以选择从各种算法设计技术中选择。插入排序使用***增量***方法：对于每个元素*A*[*i*]，将其插入到已经对子数组*A*[1：*i* – 1]进行排序的子数组*A*[1：*i*]中的适当位置。
- en: This section examines another design method, known as “divide-and-conquer,”
    which we explore in more detail in [Chapter 4](chapter004.xhtml). We’ll use divide-and-conquer
    to design a sorting algorithm whose worst-case running time is much less than
    that of insertion sort. One advantage of using an algorithm that follows the divide-and-conquer
    method is that analyzing its running time is often straightforward, using techniques
    that we’ll explore in [Chapter 4](chapter004.xhtml).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 本节将探讨另一种设计方法，称为“分治法”，我们将在[第4章](chapter004.xhtml)中更详细地探讨。我们将使用分治法设计一种排序算法，其最坏情况运行时间远远小于插入排序。使用遵循分治法的算法的一个优势是，分析其运行时间通常很简单，使用我们将在[第4章](chapter004.xhtml)中探讨的技术。
- en: '**2.3.1    The divide-and-conquer method**'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.3.1    分治法**'
- en: 'Many useful algorithms are ***recursive*** in structure: to solve a given problem,
    they ***recurse*** (call themselves) one or more times to handle closely related
    subproblems. These algorithms typically follow the ***divide-and-conquer*** method:
    they break the problem into several subproblems that are similar to the original
    problem but smaller in size, solve the subproblems recursively, and then combine
    these solutions to create a solution to the original problem.'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 许多有用的算法在结构上是***递归***的：为了解决给定问题，它们会***递归***（调用自身）一次或多次来处理紧密相关的子问题。这些算法通常遵循***分治法***：它们将问题分解为几个与原始问题相似但规模较小的子问题，递归地解决这些子问题，然后将这些解合并以创建原始问题的解。
- en: 'In the divide-and-conquer method, if the problem is small enough—the ***base
    case***—you just solve it directly without recursing. Otherwise—the ***recursive
    case***—you perform three characteristic steps:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在分治法中，如果问题足够小——***基本情况***——你可以直接解决它而不进行递归。否则——***递归情况***——你执行三个特征步骤：
- en: '**Divide** the problem into one or more subproblems that are smaller instances
    of the same problem.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '**划分**问题为一个或多个更小的相同问题的子问题。'
- en: '**Conquer** the subproblems by solving them recursively.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**征服**通过递归解决子问题。'
- en: '**Combine** the subproblem solutions to form a solution to the original problem.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**合并**子问题的解以形成原始问题的解。'
- en: 'The ***merge sort*** algorithm closely follows the divide-and-conquer method.
    In each step, it sorts a subarray *A*[*p* : *r*], starting with the entire array
    *A*[1 : *n*] and recursing down to smaller and smaller subarrays. Here is how
    merge sort operates:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '***归并排序***算法紧随分治法。在每一步中，它对一个子数组*A*[*p*:*r*]进行排序，从整个数组*A*[1:*n*]开始，并递归到越来越小的子数组。以下是归并排序的操作方式：'
- en: '**Divide** the subarray *A*[*p* : *r*] to be sorted into two adjacent subarrays,
    each of half the size. To do so, compute the midpoint *q* of *A*[*p* : *r*] (taking
    the average of *p* and *r*), and divide *A*[*p* : *r*] into subarrays *A*[*p*
    : *q*] and *A*[*q* + 1 : *r*].'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '**划分**要排序的子数组*A*[*p*:*r*]为两个相邻的子数组，每个大小为原来的一半。为此，计算*A*[*p*:*r*]的中点*q*（取*p*和*r*的平均值），并将*A*[*p*:*r*]划分为子数组*A*[*p*:*q*]和*A*[*q*+1:*r*]。'
- en: '**Conquer** by sorting each of the two subarrays *A*[*p* : *q*] and *A*[*q*
    + 1 : *r*] recursively using merge sort.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**征服**通过使用归并排序递归地对每个两个子数组*A*[*p*:*q*]和*A*[*q*+1:*r*]进行排序。'
- en: '**Combine** by merging the two sorted subarrays *A*[*p* : *q*] and *A*[*q*
    + 1 : *r*] back into *A*[*p* : *r*], producing the sorted answer.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '**合并**将两个排序好的子数组*A*[*p*:*q*]和*A*[*q*+1:*r*]合并回*A*[*p*:*r*]，得到排序好的答案。'
- en: 'The recursion “bottoms out”—it reaches the base case—when the subarray *A*[*p*
    : *r*] to be sorted has just 1 element, that is, when *p* equals *r*. As we noted
    in the initialization argument for INSERTION-SORT’s loop invariant, a subarray
    comprising just a single element is always sorted.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 递归“触底”——达到基本情况——当要排序的子数组*A*[*p*:*r*]只有1个元素时，也就是当*p*等于*r*时。正如我们在INSERTION-SORT的循环不变式初始化参数中指出的，由只有一个元素组成的子数组总是排序好的。
- en: 'The key operation of the merge sort algorithm occurs in the “combine” step,
    which merges two adjacent, sorted subarrays. The merge operation is performed
    by the auxiliary procedure MERGE(*A*, *p*, *q*, *r*) on the following page, where
    *A* is an array and *p*, *q*, and *r* are indices into the array such that *p*
    ≤ *q* < *r*. The procedure assumes that the adjacent subarrays *A*[*p* : *q*]
    and *A*[*q* + 1 : *r*] were already recursively sorted. It ***merges*** the two
    sorted subarrays to form a single sorted subarray that replaces the current subarray
    *A*[*p* : *r*].'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 归并排序算法的关键操作发生在“合并”步骤中，它合并两个相邻的排序好的子数组。合并操作由辅助过程MERGE(*A*, *p*, *q*, *r*)在下一页上执行，其中*A*是一个数组，*p*、*q*和*r*是数组中的索引，使得*p*
    ≤ *q* < *r*。该过程假定相邻的子数组*A*[*p*:*q*]和*A*[*q*+1:*r*]已经被递归排序好。它***合并***这两个排序好的子数组，形成一个替换当前子数组*A*[*p*:*r*]的单个排序好的子数组。
- en: To understand how the MERGE procedure works, let’s return to our card-playing
    motif. Suppose that you have two piles of cards face up on a table. Each pile
    is sorted, with the smallest-value cards on top. You wish to merge the two piles
    into a single sorted output pile, which is to be face down on the table. The basic
    step consists of choosing the smaller of the two cards on top of the face-up piles,
    removing it from its pile—which exposes a new top card—and placing this card face
    down onto the output pile. Repeat this step until one input pile is empty, at
    which time you can just take the remaining input pile and flip over the entire
    pile, placing it face down onto the output pile.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解MERGE过程的工作原理，让我们回到我们的打牌主题。假设你在桌子上有两堆卡片面朝上。每堆都是排序好的，最小值的卡片在顶部。你希望将这两堆合并成一个单独的排序好的输出堆，这个输出堆面朝下放在桌子上。基本步骤包括选择两堆面朝上的卡片中较小的那张，将其从堆中取出——这样会暴露一个新的顶部卡片——并将这张卡片面朝下放在输出堆上。重复这个步骤，直到一个输入堆为空，此时你可以直接取出剩余的输入堆并将整堆翻面，将其面朝下放在输出堆上。
- en: Let’s think about how long it takes to merge two sorted piles of cards. Each
    basic step takes constant time, since you are comparing just the two top cards.
    If the two sorted piles that you start with each have *n*/2 cards, then the number
    of basic steps is at least *n*/2 (since in whichever pile was emptied, every card
    was found to be smaller than some card from the other pile) and at most *n* (actually,
    at most *n* – 1, since after *n* – 1 basic steps, one of the piles must be empty).
    With each basic step taking constant time and the total number of basic steps
    being between *n*/2 and *n*, we can say that merging takes time roughly proportional
    to *n*. That is, merging takes Θ(*n*) time.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想一想合并两堆排序好的卡片需要多长时间。每个基本步骤都需要恒定的时间，因为你只是比较两张顶部的卡片。如果你开始的两堆排序好的卡片每堆有*n*/2张卡片，那么基本步骤的数量至少为*n*/2（因为无论哪一堆被清空，每张卡片都被发现比另一堆的某张卡片小）且最多为*n*（实际上，最多为*n*
    - 1，因为经过*n* - 1个基本步骤后，其中一堆必须为空）。每个基本步骤花费恒定时间，总基本步骤数量在*n*/2和*n*之间，我们可以说合并大约需要与*n*成比例的时间。也就是说，合并需要Θ(*n*)时间。
- en: 'In detail, the MERGE procedure works as follows. It copies the two subarrays
    *A*[*p* : *q*] and *A*[*q* + 1 : *r*] into temporary arrays *L* and *R* (“left”
    and “right”), and then it merges the values in *L* and *R* back into *A*[*p* :
    *r*]. Lines 1 and 2 compute the lengths *n[L]* and *n[R]* of the subarrays *A*[*p*
    : *q*] and *A*[*q* + 1 : *r*], respectively. Then line 3 creates arrays *L*[0
    : *n[L]* – 1] and *R*[0 : *n[R]* – 1] with respective lengths *n[L]* and *n[R]*.^([12](#footnote_12))
    The **for** loop of lines 4–5 copies the subarray *A*[*p* : *q*] into *L*, and
    the **for** loop of lines 6–7 copies the subarray *A*[*q* + 1 : *r*] into *R*.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 'MERGE 过程的详细步骤如下。它将两个子数组 *A*[*p* : *q*] 和 *A*[*q* + 1 : *r*] 复制到临时数组 *L* 和 *R*（“左”和“右”），然后将
    *L* 和 *R* 中的值合并回 *A*[*p* : *r*]。第 1 和 2 行计算子数组 *A*[*p* : *q*] 和 *A*[*q* + 1 :
    *r*] 的长度 *n[L]* 和 *n[R]*。然后第 3 行创建具有相应长度 *n[L]* 和 *n[R]* 的数组 *L*[0 : *n[L]* –
    1] 和 *R*[0 : *n[R]* – 1]。第 4–5 行的 **for** 循环将子数组 *A*[*p* : *q*] 复制到 *L* 中，第 6–7
    行的 **for** 循环将子数组 *A*[*q* + 1 : *r*] 复制到 *R* 中。'
- en: MERGE(*A*, *p*, *q*, *r*)
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: MERGE(*A*, *p*, *q*, *r*)
- en: '|   1 | *n[L]* = *q* – *p* + 1 | **//** length of *A*[*p* : *q*] |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|   1 | *n[L]* = *q* – *p* + 1 | **//** *A*[*p* : *q*] 的长度 |'
- en: '|   2 | *n[R]* = *r* – *q* | **//** length of *A*[*q* + 1 : *r*] |'
  id: totrans-153
  prefs: []
  type: TYPE_TB
  zh: '|   2 | *n[R]* = *r* – *q* | **//** *A*[*q* + 1 : *r*] 的长度 |'
- en: '|   3 | let *L*[0 : *n[L]* – 1] and *R*[0 : *n[R]* – 1] be new arrays |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '|   3 | 令 *L*[0 : *n[L]* – 1] 和 *R*[0 : *n[R]* – 1] 为新数组 |'
- en: '|   4 | **for** *i* = 0 **to** *n[L]* – 1 | **//** copy *A*[*p* : *q*] into
    *L*[0 : *n[L]* – 1] |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '|   4 | **for** *i* = 0 **to** *n[L]* – 1 | **//** 将 *A*[*p* : *q*] 复制到 *L*[0
    : *n[L]* – 1] |'
- en: '|   5 | *L*[*i*] = *A*[*p* + *i*] |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '|   5 | *L*[*i*] = *A*[*p* + *i*] |'
- en: '|   6 | **for** *j* = 0 **to** *n[R]* – 1 | **//** copy *A*[*q* + 1 : *r*]
    into *R*[0 : *n[R]* – 1] |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '|   6 | **for** *j* = 0 **to** *n[R]* – 1 | **//** 将 *A*[*q* + 1 : *r*] 复制到
    *R*[0 : *n[R]* – 1] |'
- en: '|   7 | *R*[*j*] = *A*[*q* + *j* + 1] |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '|   7 | *R*[*j*] = *A*[*q* + *j* + 1] |'
- en: '|   8 | *i* = 0 | **//** *i* indexes the smallest remaining element in *L*
    |'
  id: totrans-159
  prefs: []
  type: TYPE_TB
  zh: '|   8 | *i* = 0 | **//** *i* 索引 *L* 中剩余最小元素 |'
- en: '|   9 | *j* = 0 | **//** *j* indexes the smallest remaining element in *R*
    |'
  id: totrans-160
  prefs: []
  type: TYPE_TB
  zh: '|   9 | *j* = 0 | **//** *j* 索引 *R* 中剩余最小元素 |'
- en: '| 10 | *k* = *p* | **//** *k* indexes the location in *A* to fill |'
  id: totrans-161
  prefs: []
  type: TYPE_TB
  zh: '| 10 | *k* = *p* | **//** *k* 索引 *A* 中要填充的位置 |'
- en: '| 11 | **//** As long as each of the arrays *L* and *R* contains an unmerged
    element, **//**          copy the smallest unmerged element back into *A*[*p*
    : *r*]. |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| 11 | **//** 只要 *L* 和 *R* 中都还有未合并的元素，**//**          就将最小的未合并元素复制回 *A*[*p*
    : *r*]。 |'
- en: '| 12 | **while** *i* < *n[L]* and *j* < *n[R]* |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 12 | **while** *i* < *n[L]* and *j* < *n[R]* |'
- en: '| 13 | **if** *L*[*i*] ≤ *R*[*j*] |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| 13 | **if** *L*[*i*] ≤ *R*[*j*] |'
- en: '| 14 | *A*[*k*] = *L*[*i*] |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| 14 | *A*[*k*] = *L*[*i*] |'
- en: '| 15 | *i* = *i* + 1 |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| 15 | *i* = *i* + 1 |'
- en: '| 16 | **else** *A*[*k*] = *R*[*j*] |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| 16 | **else** *A*[*k*] = *R*[*j*] |'
- en: '| 17 | *j* = *j* + 1 |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| 17 | *j* = *j* + 1 |'
- en: '| 18 | *k* = *k* + 1 |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| 18 | *k* = *k* + 1 |'
- en: '| 19 | **//** Having gone through one of *L* and *R* entirely, copy the **//**          remainder
    of the other to the end of *A*[*p* : *r*]. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| 19 | **//** 完全经过 *L* 或 *R* 后，将另一个的剩余部分复制到 *A*[*p* : *r*] 的末尾。 |'
- en: '| 20 | **while** *i* < *n[L]* |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 20 | **while** *i* < *n[L]* |'
- en: '| 21 | *A*[*k*] = *L*[*i*] |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| 21 | *A*[*k*] = *L*[*i*] |'
- en: '| 22 | *i* = *i* + 1 |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| 22 | *i* = *i* + 1 |'
- en: '| 23 | *k* = *k* + 1 |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| 23 | *k* = *k* + 1 |'
- en: '| 24 | **while** *j* < *n[R]* |'
  id: totrans-175
  prefs: []
  type: TYPE_TB
  zh: '| 24 | **while** *j* < *n[R]* |'
- en: '| 25 | *A*[*k*] = *R*[*j*] |'
  id: totrans-176
  prefs: []
  type: TYPE_TB
  zh: '| 25 | *A*[*k*] = *R*[*j*] |'
- en: '| 26 | *j* = *j* + 1 |'
  id: totrans-177
  prefs: []
  type: TYPE_TB
  zh: '| 26 | *j* = *j* + 1 |'
- en: '| 27 | *k* = *k* + 1 |'
  id: totrans-178
  prefs: []
  type: TYPE_TB
  zh: '| 27 | *k* = *k* + 1 |'
- en: 'Lines 8–18, illustrated in [Figure 2.3](chapter002.xhtml#Fig_2-3), perform
    the basic steps. The **while** loop of lines 12–18 repeatedly identifies the smallest
    value in *L* and *R* that has yet to be copied back into *A*[*p* : *r*] and copies
    it back in. As the comments indicate, the index *k* gives the position of *A*
    that is being filled in, and the indices *i* and *j* give the positions in *L*
    and *R*, respectively, of the smallest remaining values. Eventually, either all
    of *L* or all of *R* is copied back into *A*[*p* : *r*], and this loop terminates.
    If the loop terminates because all of *R* has been copied back, that is, because
    *j* equals *n[R]*, then *i* is still less than *n[L]*, so that some of *L* has
    yet to be copied back, and these values are the greatest in both *L* and *R*.
    In this case, the **while** loop of lines 20–23 copies these remaining values
    of *L* into the last few positions of *A*[*p* : *r*]. Because *j* equals *n[R]*,
    the **while** loop of lines 24–27 iterates 0 times. If instead the **while** loop
    of lines 12–18 terminates because *i* equals *n[L]*, then all of *L* has already
    been copied back into *A*[*p* : *r*], and the **while** loop of lines 24–27 copies
    the remaining values of *R* back into the end of *A*[*p* : *r*].'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '第 8–18 行，在 [图 2.3](chapter002.xhtml#Fig_2-3) 中有详细说明，执行基本步骤。第 12–18 行的 **while**
    循环重复地识别 *L* 和 *R* 中尚未复制回 *A*[*p* : *r*] 的最小值，并将其复制回去。正如注释所示，索引 *k* 给出了正在填充的 *A*
    的位置，索引 *i* 和 *j* 分别给出了 *L* 和 *R* 中剩余最小值的位置。最终，要么 *L* 的所有值要么 *R* 的所有值被复制回 *A*[*p*
    : *r*]，这个循环就会终止。如果循环终止是因为 *R* 的所有值都已经复制回去，也就是因为 *j* 等于 *n[R]*，那么 *i* 仍然小于 *n[L]*，所以
    *L* 的一些值尚未复制回去，这些值是 *L* 和 *R* 中最大的值。在这种情况下，第 20–23 行的 **while** 循环将这些剩余的 *L* 的值复制到
    *A*[*p* : *r*] 的最后几个位置。因为 *j* 等于 *n[R]*，第 24–27 行的 **while** 循环迭代 0 次。如果相反，第 12–18
    行的 **while** 循环终止是因为 *i* 等于 *n[L]*，那么 *L* 的所有值已经被复制回 *A*[*p* : *r*]，第 24–27 行的
    **while** 循环将 *R* 的剩余值复制回 *A*[*p* : *r*] 的末尾。'
- en: '![art](images/Art_P21.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P21.jpg)'
- en: '**Figure 2.3** The operation of the **while** loop in lines 8–18 in the call
    MERGE(*A*, 9, 12, 16), when the subarray *A*[9 : 16] contains the values 〈2, 4,
    6, 7, 1, 2, 3, 5〉. After allocating and copying into the arrays *L* and *R*, the
    array *L* contains 〈2, 4, 6, 7〉, and the array *R* contains 〈1, 2, 3, 5〉. Tan
    positions in *A* contain their final values, and tan positions in *L* and *R*
    contain values that have yet to be copied back into *A*. Taken together, the tan
    positions always comprise the values originally in *A*[9 : 16]. Blue positions
    in *A* contain values that will be copied over, and dark positions in *L* and
    *R* contain values that have already been copied back into *A*. **(a)–(g)** The
    arrays *A*, *L*, and *R*, and their respective indices *k*, *i*, and *j* prior
    to each iteration of the loop of lines 12–18\. At the point in part (g), all values
    in *R* have been copied back into *A* (indicated by *j* equaling the length of
    *R*), and so the **while** loop in lines 12–18 terminates. **(h)** The arrays
    and indices at termination. The **while** loops of lines 20–23 and 24–27 copied
    back into *A* the remaining values in *L* and *R*, which are the largest values
    originally in *A*[9 : 16]. Here, lines 20–23 copied *L*[2 : 3] into *A*[15 : 16],
    and because all values in *R* had already been copied back into *A*, the **while**
    loop of lines 24–27 iterated 0 times. At this point, the subarray in *A*[9 : 16]
    is sorted.'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 2.3** 在调用 MERGE(*A*, 9, 12, 16) 中第 8–18 行的 **while** 循环的操作，当子数组 *A*[9 :
    16] 包含值 〈2, 4, 6, 7, 1, 2, 3, 5〉 时。在分配和复制到数组 *L* 和 *R* 后，数组 *L* 包含值 〈2, 4, 6,
    7〉，数组 *R* 包含值 〈1, 2, 3, 5〉。棕色位置在 *A* 中包含它们的最终值，在 *L* 和 *R* 中的棕色位置包含尚未复制回 *A* 的值。总体而言，棕色位置始终包含最初在
    *A*[9 : 16] 中的值。蓝色位置在 *A* 中包含将要复制的值，*L* 和 *R* 中的深色位置包含已经复制回 *A* 的值。**(a)–(g)**
    在循环的每次迭代之前，数组 *A*、*L* 和 *R* 及其相应的索引 *k*、*i* 和 *j*。在 (g) 部分，*R* 中的所有值都已经复制回 *A*（通过
    *j* 等于 *R* 的长度表示），因此第 12–18 行的 **while** 循环终止。**(h)** 终止时的数组和索引。第 20–23 行和 24–27
    行的 **while** 循环将 *L* 和 *R* 中剩余的值复制回 *A*，这些值是最初在 *A*[9 : 16] 中的最大值。在这里，第 20–23
    行将 *L*[2 : 3] 复制到 *A*[15 : 16]，因为 *R* 中的所有值都已经复制回 *A*，所以第 24–27 行的 **while** 循环迭代
    0 次。此时，*A*[9 : 16] 中的子数组已经排序。'
- en: To see that the MERGE procedure runs in Θ(*n*) time, where *n* = *r* – *p* +
    1,^([13](#footnote_13)) observe that each of lines 1–3 and 8–10 takes constant
    time, and the **for** loops of lines 4–7 take Θ(*n[L]* + *n[R]*) = Θ(*n*) time.^([14](#footnote_14))
    To account for the three **while** loops of lines 12–18, 20–23, and 24–27, observe
    that each iteration of these loops copies exactly one value from *L* or *R* back
    into *A* and that every value is copied back into *A* exactly once. Therefore,
    these three loops together make a total of *n* iterations. Since each iteration
    of each of the three loops takes constant time, the total time spent in these
    three loops is Θ(*n*).
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 要看出 MERGE 过程运行时间为 Θ(*n*)，其中 *n* = *r* – *p* + 1，观察到每行 1–3 和 8–10 都需要常数时间，而第
    4–7 行的 **for** 循环需要 Θ(*n[L]* + *n[R]*) = Θ(*n*) 的时间。要考虑第 12–18、20–23 和 24–27 行的三个
    **while** 循环，观察到这些循环的每次迭代都将 *L* 或 *R* 中的一个值复制回 *A*，并且每个值都只复制回 *A* 一次。因此，这三个循环总共进行了
    *n* 次迭代。由于这三个循环的每次迭代都需要常数时间，因此这三个循环的总时间为 Θ(*n*)。
- en: 'We can now use the MERGE procedure as a subroutine in the merge sort algorithm.
    The procedure MERGE-SORT(*A*, *p*, *r*) on the facing page sorts the elements
    in the subarray *A*[*p* : *r*]. If *p* equals *r*, the subarray has just 1 element
    and is therefore already sorted. Otherwise, we must have *p* < *r*, and MERGE-SORT
    runs the divide, conquer, and combine steps. The divide step simply computes an
    index *q* that partitions *A*[*p* : *r*] into two adjacent subarrays: *A*[*p*
    : *q*], containing ⌈*n*/2⌉ elements, and *A*[*q* + 1 : *r*], containing ⌊*n*/2⌋
    elements.^([15](#footnote_15)) The initial call MERGE-SORT(*A,* 1, *n*) sorts
    the entire array *A*[1 : *n*].'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们可以将 MERGE 过程作为合并排序算法中的子程序使用。在下一页上的 MERGE-SORT(*A*, *p*, *r*) 过程对子数组 *A*[*p*
    : *r*] 中的元素进行排序。如果 *p* 等于 *r*，则子数组只有 1 个元素，因此已经排序。否则，我们必须有 *p* < *r*，并且 MERGE-SORT
    运行分割、征服和合并步骤。分割步骤简单地计算一个索引 *q*，将 *A*[*p* : *r*] 分成两个相邻的子数组：*A*[*p* : *q*]，包含 ⌈*n*/2⌉
    个元素，和 *A*[*q* + 1 : *r*]，包含 ⌊*n*/2⌋ 个元素。初始调用 MERGE-SORT(*A,* 1, *n*) 对整个数组 *A*[1
    : *n*] 进行排序。'
- en: '[Figure 2.4](chapter002.xhtml#Fig_2-4) illustrates the operation of the procedure
    for *n* = 8, showing also the sequence of divide and merge steps. The algorithm
    recursively divides the array down to 1-element subarrays. The combine steps merge
    pairs of 1-element subarrays to form sorted subarrays of length 2, merges those
    to form sorted subarrays of length 4, and merges those to form the final sorted
    subarray of length 8\. If *n* is not an exact power of 2, then some divide steps
    create subarrays whose lengths differ by 1\. (For example, when dividing a subarray
    of length 7, one subarray has length 4 and the other has length 3.) Regardless
    of the lengths of the two subarrays being merged, the time to merge a total of
    *n* items is Θ(*n*).'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '[图 2.4](chapter002.xhtml#Fig_2-4) 展示了 *n* = 8 时该过程的操作，还显示了分割和合并步骤的顺序。该算法递归地将数组分解为
    1 元素子数组。合并步骤将 1 元素子数组的对成对合并以形成长度为 2 的排序子数组，将这些子数组合并以形成长度为 4 的排序子数组，然后将这些子数组合并以形成最终长度为
    8 的排序子数组。如果 *n* 不是 2 的幂，则一些分割步骤创建的子数组长度会相差 1（例如，当分割长度为 7 的子数组时，一个子数组长度为 4，另一个子数组长度为
    3）。无论要合并的两个子数组的长度如何，合并 *n* 个项的时间为 Θ(*n*)。'
- en: MERGE-SORT(*A*, *p*, *r*)
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: MERGE-SORT(*A*, *p*, *r*)
- en: '| 1 | **if** *p* ≥ *r* | **//** zero or one element? |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **如果** *p* ≥ *r* | **//** 零个或一个元素？ |'
- en: '| 2 | **return** |  |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **返回** |  |'
- en: '| 3 | *q* = ⌊(*p* + *r*)/2⌋ | **//** midpoint of *A*[*p* : *r*] |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *q* = ⌊(*p* + *r*)/2⌋ | **//** *A*[*p* : *r*] 的中点 |'
- en: '| 4 | MERGE-SORT(*A*, *p*, *q*) | **//** recursively sort *A*[*p* : *q*] |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| 4 | MERGE-SORT(*A*, *p*, *q*) | **//** 递归排序 *A*[*p* : *q*] |'
- en: '| 5 | MERGE-SORT(*A*, *q* + 1, *r*) | **//** recursively sort *A*[*q* + 1 :
    *r*] |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| 5 | MERGE-SORT(*A*, *q* + 1, *r*) | **//** 递归排序 *A*[*q* + 1 : *r*] |'
- en: '| 6 | **//** Merge *A*[*p* : *q*] and *A*[*q* + 1 : *r*] into *A*[*p* : *r*].
    |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| 6 | **//** 合并 *A*[*p* : *q*] 和 *A*[*q* + 1 : *r*] 到 *A*[*p* : *r*]。'
- en: '| 7 | MERGE(*A*, *p*, *q*, *r*) |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 7 | MERGE(*A*, *p*, *q*, *r*)'
- en: '**2.3.2    Analyzing divide-and-conquer algorithms**'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '**2.3.2 分析分治算法**'
- en: When an algorithm contains a recursive call, you can often describe its running
    time by a ***recurrence equation*** or ***recurrence***, which describes the overall
    running time on a problem of size *n* in terms of the running time of the same
    algorithm on smaller inputs. You can then use mathematical tools to solve the
    recurrence and provide bounds on the performance of the algorithm.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当算法包含递归调用时，通常可以通过***递归方程***或***递归***描述其运行时间，该方程描述了在较小输入上的相同算法的运行时间对于规模为*n*的问题。然后，您可以使用数学工具解决递归并为算法的性能提供界限。
- en: A recurrence for the running time of a divide-and-conquer algorithm falls out
    from the three steps of the basic method. As we did for insertion sort, let *T*
    (*n*) be the worst-case running time on a problem of size *n*. If the problem
    size is small enough, say *n* < *n*[0] for some constant *n*[0] > 0, the straightforward
    solution takes constant time, which we write as Θ(1).^([16](#footnote_16)) Suppose
    that the division of the problem yields *a* subproblems, each with size *n*/*b*,
    that is, 1/*b* the size of the original. For merge sort, both *a* and *b* are
    2, but we’ll see other divide-and-conquer algorithms in which *a* ≠ *b*. It takes
    *T* (*n*/*b*) time to solve one subproblem of size *n*/*b*, and so it takes *aT*
    (*n*/*b*) time to solve all *a* of them. If it takes *D*(*n*) time to divide the
    problem into subproblems and *C*(*n*) time to combine the solutions to the subproblems
    into the solution to the original problem, we get the recurrence
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从基本方法的三个步骤中可以得出分治算法的运行时间的递归。就像我们为插入排序所做的那样，让*T*(*n*)表示规模为*n*的问题的最坏情况运行时间。如果问题规模足够小，比如对于某个常数*n*[0]
    > 0，有*n* < *n*[0]，那么直接解决方案需要恒定时间，我们将其写为Θ(1)。^([16](#footnote_16)) 假设问题的划分产生了*a*个规模为*n*/*b*的子问题，即原始问题规模的1/*b*。对于归并排序，*a*和*b*都是2，但我们将看到其他分治算法中的*a*
    ≠ *b*。解决一个规模为*n*/*b*的子问题需要*T*(*n*/*b*)时间，因此解决所有*a*个子问题需要*aT*(*n*/*b*)时间。如果将问题划分为子问题需要*D*(*n*)时间，将子问题的解组合成原始问题的解需要*C*(*n*)时间，我们得到递归关系
- en: '![art](images/Art_P22.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P22.jpg)'
- en: '[Chapter 4](chapter004.xhtml) shows how to solve common recurrences of this
    form.'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](chapter004.xhtml)展示了如何解决这种形式的常见递归。'
- en: '![art](images/Art_P23.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P23.jpg)'
- en: '**Figure 2.4** The operation of merge sort on the array *A* with length 8 that
    initially contains the sequence 〈12, 3, 7, 9, 14, 6, 11, 2〉. The indices *p*,
    *q*, and *r* into each subarray appear above their values. Numbers in italics
    indicate the order in which the MERGE-SORT and MERGE procedures are called following
    the initial call of MERGE-SORT(*A,* 1, 8).'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.4** 归并排序在初始包含序列〈12, 3, 7, 9, 14, 6, 11, 2〉的长度为8的数组*A*上的操作。每个子数组的索引*p*、*q*和*r*出现在其值上方。斜体数字表示在初始调用MERGE-SORT(*A,*
    1, 8)后调用MERGE-SORT和MERGE过程的顺序。'
- en: Sometimes, the *n*/*b* size of the divide step isn’t an integer. For example,
    the MERGE-SORT procedure divides a problem of size *n* into subproblems of sizes
    ⌈*n*/2⌉ and ⌊*n*/2⌋. Since the difference between ⌈*n*/2⌉ and ⌊*n*/2⌋ is at most
    1, which for large *n* is much smaller than the effect of dividing *n* by 2, we’ll
    squint a little and just call them both size *n*/2\. As [Chapter 4](chapter004.xhtml)
    will discuss, this simplification of ignoring floors and ceilings does not generally
    affect the order of growth of a solution to a divide-and-conquer recurrence.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，分治步骤的*n*/*b*大小不是整数。例如，MERGE-SORT过程将大小为*n*的问题划分为大小为⌈*n*/2⌉和⌊*n*/2⌋的子问题。由于⌈*n*/2⌉和⌊*n*/2⌋之间的差异最多为1，对于较大的*n*，这比将*n*除以2的效果要小得多，我们会稍微忽略一下，将它们都称为大小为*n*/2。正如[第4章](chapter004.xhtml)将讨论的那样，忽略地板和天花板的这种简化通常不会影响解决分治递归的解的增长顺序。
- en: Another convention we’ll adopt is to omit a statement of the base cases of the
    recurrence, which we’ll also discuss in more detail in [Chapter 4](chapter004.xhtml).
    The reason is that the base cases are pretty much always *T* (*n*) = Θ(1) if *n*
    < *n*[0] for some constant *n*[0] > 0\. That’s because the running time of an
    algorithm on an input of constant size is constant. We save ourselves a lot of
    extra writing by adopting this convention.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采用的另一个约定是省略递归的基本情况陈述，我们将在[第4章](chapter004.xhtml)中更详细地讨论。原因是基本情况几乎总是*T*(*n*)
    = Θ(1)，如果对于某个常数*n*[0] > 0，有*n* < *n*[0]。这是因为算法在常数规模的输入上的运行时间是恒定的。通过采用这种约定，我们节省了大量额外的写作。
- en: '**Analysis of merge sort**'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**归并排序的分析**'
- en: Here’s how to set up the recurrence for *T* (*n*), the worst-case running time
    of merge sort on *n* numbers.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这是如何为*n*个数字上的归并排序设置递归*T*(*n*)，最坏情况运行时间的方法。
- en: '**Divide:** The divide step just computes the middle of the subarray, which
    takes constant time. Thus, *D*(*n*) = Θ(1).'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**划分：** 划分步骤只是计算子数组的中间值，需要恒定时间。因此，*D*(*n*) = Θ(1)。'
- en: '**Conquer:** Recursively solving two subproblems, each of size *n*/2, contributes
    2*T* (*n*/2) to the running time (ignoring the floors and ceilings, as we discussed).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**征服：** 递归解决两个规模为*n*/2的子问题，对运行时间贡献了2*T*(*n*/2)（忽略地板和天花板，正如我们讨论过的）。'
- en: '**Combine:** Since the MERGE procedure on an *n*-element subarray takes Θ(*n*)
    time, we have *C*(*n*) = Θ(*n*).'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**合并：** 由于MERGE过程在一个*n*元素子数组上需要Θ(*n*)时间，我们有*C*(*n*) = Θ(*n*)。'
- en: 'When we add the functions *D*(*n*) and *C*(*n*) for the merge sort analysis,
    we are adding a function that is Θ(*n*) and a function that is Θ(1). This sum
    is a linear function of *n*. That is, it is roughly proportional to *n* when *n*
    is large, and so merge sort’s dividing and combining times together are Θ(*n*).
    Adding Θ(*n*) to the 2*T* (*n*/2) term from the conquer step gives the recurrence
    for the worst-case running time *T* (*n*) of merge sort:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们为归并排序分析添加函数*D*(*n*)和*C*(*n*)时，我们添加了一个Θ(*n*)的函数和一个Θ(1)的函数。这个和是*n*的线性函数。也就是说，当*n*很大时，它大致与*n*成比例，因此归并排序的划分和合并时间一起为Θ(*n*)。将征服步骤中的2*T*(*n*/2)项加上Θ(*n*)得到归并排���最坏情况运行时间*T*(*n*)的递归：
- en: '![art](images/Art_P24.jpg)'
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P24.jpg)'
- en: '[Chapter 4](chapter004.xhtml) presents the “master theorem,” which shows that
    *T* (*n*) = Θ(*n* lg *n*).^([17](#footnote_17)) Compared with insertion sort,
    whose worst-case running time is Θ(*n*²), merge sort trades away a factor of *n*
    for a factor of lg *n*. Because the logarithm function grows more slowly than
    any linear function, that’s a good trade. For large enough inputs, merge sort,
    with its Θ(*n* lg *n*) worst-case running time, outperforms insertion sort, whose
    worst-case running time is Θ(*n*²).'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '[第4章](chapter004.xhtml)介绍了“主定理”，它表明*T*(*n*) = Θ(*n* lg *n*)。与插入排序相比，插入排序的最坏情况运行时间为Θ(*n*²)，归并排序则将一个*n*因子换成了一个lg
    *n*因子。由于对数函数增长速度比任何线性函数都慢，这是一个很好的交换。对于足够大的输入，具有Θ(*n* lg *n*)最坏情况运行时间的归并排序优于具有Θ(*n*²)最坏情况运行时间的插入排序。'
- en: We do not need the master theorem, however, to understand intuitively why the
    solution to recurrence (2.3) is *T* (*n*) = Θ(*n* lg *n*). For simplicity, assume
    that *n* is an exact power of 2 and that the implicit base case is *n* = 1\. Then
    recurrence (2.3) is essentially
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们不需要主定理来直观理解为什么递归（2.3）的解是*T*(*n*) = Θ(*n* lg *n*)。为简单起见，假设*n*是2的幂，并且隐含的基本情况是*n*
    = 1。那么递归（2.3）本质上是
- en: '![art](images/Art_P25.jpg)'
  id: totrans-211
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P25.jpg)'
- en: where the constant *c*[1] > 0 represents the time required to solve a problem
    of size 1, and *c*[2] > 0 is the time per array element of the divide and combine
    steps.^([18](#footnote_18))
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 其中常数*c*[1] > 0代表解决大小为1的问题所需的时间，*c*[2] > 0是分割和合并步骤的每个数组元素的时间。
- en: '[Figure 2.5](chapter002.xhtml#Fig_2-5) illustrates one way of figuring out
    the solution to recurrence (2.4). Part (a) of the figure shows *T* (*n*), which
    part (b) expands into an equivalent tree representing the recurrence. The *c*[2]*n*
    term denotes the cost of dividing and combining at the top level of recursion,
    and the two subtrees of the root are the two smaller recurrences *T* (*n*/2).
    Part (c) shows this process carried one step further by expanding *T* (*n*/2).
    The cost for dividing and combining at each of the two nodes at the second level
    of recursion is *c*[2]*n*/2\. Continue to expand each node in the tree by breaking
    it into its constituent parts as determined by the recurrence, until the problem
    sizes get down to 1, each with a cost of *c*[1]. Part (d) shows the resulting
    ***recursion tree***.'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '[图2.5](chapter002.xhtml#Fig_2-5)展示了解决递归（2.4）的一种方法。图的部分**(a)**显示了*T*(*n*)，部分**(b)**将其扩展为表示递归的等效树。*c*[2]*n*项表示在递归的顶层进行分割和合并的成本，而根节点的两个子树是两个更小的递归*T*(*n*/2)。部分**(c)**展示了将*T*(*n*/2)扩展一步的过程。在递归的第二层的每个节点进行分割和合并的成本为*c*[2]*n*/2。通过将树中的每个节点继续展开，按照递归确定的构成部分将其拆分，直到问题规模降至1，每个问题的成本为*c*[1]。部分**(d)**展示了结果的***递归树***。'
- en: 'Next, add the costs across each level of the tree. The top level has total
    cost *c*[2]*n*, the next level down has total cost *c*[2](*n*/2) + *c*[2](*n*/2)
    = *c*[2]*n*, the level after that has total cost *c*[2](*n*/4) + *c*[2](*n*/4)
    + *c*[2](*n*/4) + *c*[2](*n*/4) = *c*[2]*n*, and so on. Each level has twice as
    many nodes as the level above, but each node contributes only half the cost of
    a node from the level above. From one level to the next, doubling and halving
    cancel each other out, so that the cost across each level is the same: *c*[2]*n*.
    In general, the level that is *i* levels below the top has 2*^i* nodes, each contributing
    a cost of *c*[2](*n*/2*^i*), so that the *i*th level below the top has total cost
    2*^i* · *c*[2](*n*/2*^i*) = *c*[2]*n*. The bottom level has *n* nodes, each contributing
    a cost of *c*[1], for a total cost of *c*[1]*n*.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将每个层级的成本相加。顶层的总成本为*c*[2]*n*，下一层的总成本为*c*[2](*n*/2) + *c*[2](*n*/2) = *c*[2]*n*，再下一层的总成本为*c*[2](*n*/4)
    + *c*[2](*n*/4) + *c*[2](*n*/4) + *c*[2](*n*/4) = *c*[2]*n*，依此类推。每个层级的节点数是上一层级的两倍，但每个节点只贡献上一层级节点成本的一半。从一层到下一层，翻倍和减半相互抵消，因此每个层级的成本是相同的：*c*[2]*n*。一般来说，距离顶部*i*层的层级有2*^i*个节点，每个节点贡献*c*[2](*n*/2*^i*)的成本，因此距离顶部第*i*层的总成本为2*^i*
    · *c*[2](*n*/2*^i*) = *c*[2]*n*。底部层级有*n*个节点，每个节点贡献*c*[1]的成本，总成本为*c*[1]*n*。
- en: The total number of levels of the recursion tree in [Figure 2.5](chapter002.xhtml#Fig_2-5)
    is lg *n* + 1, where *n* is the number of leaves, corresponding to the input size.
    An informal inductive argument justifies this claim. The base case occurs when
    *n* = 1, in which case the tree has only 1 level. Since lg 1 = 0, we have that
    lg *n* + 1 gives the correct number of levels. Now assume as an inductive hypothesis
    that the number of levels of a recursion tree with 2*^i* leaves is lg 2*^i* +
    1 = *i* + 1 (since for any value of *i*, we have that lg 2*^i* = *i*). Because
    we assume that the input size is an exact power of 2, the next input size to consider
    is 2^(*i* + 1). A tree with *n* = 2^(*i* + 1) leaves has 1 more level than a tree
    with 2*^i* leaves, and so the total number of levels is (*i* + 1) + 1 = lg 2^(*i*
    + 1) + 1.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 递归树在[图2.5](chapter002.xhtml#Fig_2-5)中的总层数为lg *n* + 1，其中*n*是叶子节点的数量，对应于输入大小。一个非正式的归纳论证证明了这一点。基本情况发生在*n*
    = 1时，此时树只有1层。由于lg 1 = 0，我们有lg *n* + 1给出了正确的层数。现在假设归纳假设是，具有2*^i*个叶子节点的递归树的层数为lg
    2*^i* + 1 = *i* + 1（因为对于任何*i*的值，我们有lg 2*^i* = *i*）。因为我们假设输入大小是2的幂，所以下一个要考虑的输入大小是2^(*i*
    + 1)。具有*n* = 2^(*i* + 1)个叶子节点的树比具有2*^i*个叶子节点的树多1层，因此总层数为(*i* + 1) + 1 = lg 2^(*i*
    + 1) + 1。
- en: '![art](images/Art_P26.jpg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P26.jpg)'
- en: '**Figure 2.5** How to construct a recursion tree for the recurrence (2.4).
    Part **(a)** shows *T* (*n*), which progressively expands in **(b)–(d)** to form
    the recursion tree. The fully expanded tree in part (d) has lg *n* + 1 levels.
    Each level above the leaves contributes a total cost of *c*[2]*n*, and the leaf
    level contributes *c*[1]*n*. The total cost, therefore, is *c*[2]*n* lg *n* +
    *c*[1]*n* = Θ(*n* lg *n*).'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '**图2.5** 如何构建递归树以解决递归（2.4）。部分**(a)**显示了*T*(*n*)，在**(b)–(d)**中逐步扩展以形成递归树。在第**(d)**部分中完全展开的树有lg
    *n* + 1层。叶子节点以上的每一层都贡献了*c*[2]*n*的总成本，而叶子层贡献了*c*[1]*n*。因此，总成本为*c*[2]*n* lg *n*
    + *c*[1]*n* = Θ(*n* lg *n*)。'
- en: To compute the total cost represented by the recurrence (2.4), simply add up
    the costs of all the levels. The recursion tree has lg *n* + 1 levels. The levels
    above the leaves each cost *c*[2]*n*, and the leaf level costs *c*[1]*n*, for
    a total cost of *c*[2]*n* lg *n* + *c*[1]*n* = Θ(*n* lg *n*).
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算由递归式(2.4)表示的总成本，只需将所有级别的成本相加。递归树有lg *n* + 1个级别。叶子节点上面的级别每个成本为*c*[2]*n*，叶子级别成本为*c*[1]*n*，总成本为*c*[2]*n*
    lg *n* + *c*[1]*n* = Θ(*n* lg *n*)。
- en: '**Exercises**'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***2.3-1***'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '***2.3-1***'
- en: Using [Figure 2.4](chapter002.xhtml#Fig_2-4) as a model, illustrate the operation
    of merge sort on an array initially containing the sequence 〈3, 41, 52, 26, 38,
    57, 9, 49〉.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用[图2.4](chapter002.xhtml#Fig_2-4)作为模型，说明在初始包含序列〈3, 41, 52, 26, 38, 57, 9, 49〉的数组上的归并排序操作。
- en: '***2.3-2***'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: '***2.3-2***'
- en: 'The test in line 1 of the MERGE-SORT procedure reads “**if** *p* ≥ *r*” rather
    than “**if** *p* ≠ *r*.” If MERGE-SORT is called with *p* > *r*, then the subarray
    *A*[*p* : *r*] is empty. Argue that as long as the initial call of MERGE-SORT(*A,*
    1, *n*) has *n* ≥ 1, the test “**if** *p* ≠ *r*” suffices to ensure that no recursive
    call has *p* > *r*.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 'MERGE-SORT过程的第1行中的测试为“**if** *p* ≥ *r*”，而不是“**if** *p* ≠ *r*”。如果MERGE-SORT以*p*
    > *r*调用，则子数组*A*[*p* : *r*]为空。证明只要MERGE-SORT(*A,* 1, *n*)的初始调用具有*n* ≥ 1，测试“**if** *p*
    ≠ *r*”就足以确保没有递归调用具有*p* > *r*。'
- en: '***2.3-3***'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '***2.3-3***'
- en: State a loop invariant for the **while** loop of lines 12–18 of the MERGE procedure.
    Show how to use it, along with the **while** loops of lines 20–23 and 24–27, to
    prove that the MERGE procedure is correct.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 给出MERGE过程第12-18行的**while**循环的一个循环不变式。展示如何使用它，以及第20-23行和第24-27行的**while**循环，证明MERGE过程的正确性。
- en: '***2.3-4***'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '***2.3-4***'
- en: Use mathematical induction to show that when *n* ≥ 2 is an exact power of 2,
    the solution of the recurrence
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数学归纳法证明当*n* ≥ 2是2的幂时，递归的解决方案
- en: '![art](images/Art_P27.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P27.jpg)'
- en: is *T*(*n*) = *n* lg *n*.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 是*T*(*n*) = *n* lg *n*。
- en: '***2.3-5***'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '***2.3-5***'
- en: 'You can also think of insertion sort as a recursive algorithm. In order to
    sort *A*[1 : *n*], recursively sort the subarray *A*[1 : *n* – 1] and then insert
    *A*[*n*] into the sorted subarray *A*[1 : *n* – 1]. Write pseudocode for this
    recursive version of insertion sort. Give a recurrence for its worst-case running
    time.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '你也可以将插入排序看作是一个递归算法。为了对*A*[1 : *n*]进行排序，递归地对子数组*A*[1 : *n* – 1]进行排序，然后将*A*[*n*]插入到排序好的子数组*A*[1
    : *n* – 1]中。为这个递归版本的插入排序编写伪代码。给出其最坏情况运行时间的递归。'
- en: '***2.3-6***'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '***2.3-6***'
- en: Referring back to the searching problem (see Exercise 2.1-4), observe that if
    the subarray being searched is already sorted, the searching algorithm can check
    the midpoint of the subarray against *v* and eliminate half of the subarray from
    further consideration. The ***binary search*** algorithm repeats this procedure,
    halving the size of the remaining portion of the subarray each time. Write pseudocode,
    either iterative or recursive, for binary search. Argue that the worst-case running
    time of binary search is Θ(lg *n*).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: ��顾搜索问题（参见练习2.1-4），观察到如果正在搜索的子数组已经排序，则搜索算法可以将子数组的中点与*v*进行比较，并消除另一半子数组的进一步考虑。***二分搜索***算法重复这个过程，每次将剩余子数组的大小减半。为二分搜索编写伪代码，无论是迭代还是递归，证明二分搜索的最坏情况运行时间为Θ(lg
    *n*)。
- en: '***2.3-7***'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '***2.3-7***'
- en: 'The **while** loop of lines 5–7 of the INSERTION-SORT procedure in [Section
    2.1](chapter002.xhtml#Sec_2.1) uses a linear search to scan (backward) through
    the sorted subarray *A*[1 : *j* – 1]. What if insertion sort used a binary search
    (see Exercise 2.3-6) instead of a linear search? Would that improve the overall
    worst-case running time of insertion sort to Θ(*n* lg *n*)?'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 'INSERTION-SORT过程[第2.1节](chapter002.xhtml#Sec_2.1)中第5-7行的**while**循环使用线性搜索来扫描（向后）排序的子数组*A*[1
    : *j* – 1]。如果插入排序使用二分搜索（参见练习2.3-6）而不是线性搜索，那么这是否会改善插入排序的整体最坏情况运行时间为Θ(*n* lg *n*)？'
- en: '***2.3-8***'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '***2.3-8***'
- en: Describe an algorithm that, given a set *S* of *n* integers and another integer
    *x*, determines whether *S* contains two elements that sum to exactly *x*. Your
    algorithm should take Θ(*n* lg *n*) time in the worst case.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 描述一个算法，给定一个包含*n*个整数的集合*S*和另一个整数*x*，确定*S*是否包含两个元素，它们的和恰好为*x*。你的算法在最坏情况下应该花费Θ(*n*
    lg *n*)的时间。
- en: '**Problems**'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '***2-1     Insertion sort on small arrays in merge sort***'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '***2-1     在归并排序中对小数组使用插入排序***'
- en: Although merge sort runs in Θ(*n* lg *n*) worst-case time and insertion sort
    runs in Θ(*n*²) worst-case time, the constant factors in insertion sort can make
    it faster in practice for small problem sizes on many machines. Thus it makes
    sense to ***coarsen*** the leaves of the recursion by using insertion sort within
    merge sort when subproblems become sufficiently small. Consider a modification
    to merge sort in which *n*/*k* sublists of length *k* are sorted using insertion
    sort and then merged using the standard merging mechanism, where *k* is a value
    to be determined.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管归并排序的最坏情况运行时间为Θ(*n* lg *n*)，插入排序的最坏情况运行时间为Θ(*n*²)，但插入排序中的常数因子可能使其在许多机器上对小问题规模更快。因此，在子问题变得足够小的时候，通过在归并排序中使用插入排序来使递归的叶子节点变得更粗糙是有意义的。考虑一种修改后的归并排序，其中长度为*k*的*n*/*k*个子列表使用插入排序进行排序，然后使用标准的合并机制进行合并，其中*k*是一个待确定的值。
- en: '***a.*** Show that insertion sort can sort the *n*/*k* sublists, each of length
    *k*, in Θ(*nk*) worst-case time.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 证明插入排序可以在Θ(*nk*)的最坏情况时间内对长度为*k*的*n*/*k*个子列表进行排序。'
- en: '***b.*** Show how to merge the sublists in Θ(*n* lg(*n*/*k*)) worst-case time.'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 展示如何在Θ(*n* lg(*n*/*k*))的最坏情况时间内合并子列表。'
- en: '***c.*** Given that the modified algorithm runs in Θ(*nk* + *n* lg(*n*/*k*))
    worst-case time, what is the largest value of *k* as a function of *n* for which
    the modified algorithm has the same running time as standard merge sort, in terms
    of Θ-notation?'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 鉴于修改后的算法的最坏情况运行时间为Θ(*nk* + *n* lg(*n*/*k*))，对于哪个最大的*k*值作为*n*的函数，使得修改后的算法与标准的归并排序具有相同的运行时间，用Θ-符号表示？'
- en: '***d.*** How should you choose *k* in practice?'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 在实践中应该如何选择*k*？'
- en: '***2-2     Correctness of bubblesort***'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '***2-2     冒泡排序的正确性***'
- en: 'Bubblesort is a popular, but inefficient, sorting algorithm. It works by repeatedly
    swapping adjacent elements that are out of order. The procedure BUBBLESORT sorts
    array *A*[1 : *n*].'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '冒泡排序是一种流行但低效的排序算法。它通过重复交换相邻的逆序元素来工作。过程BUBBLESORT对数组*A*[1 : *n*]进行排序。'
- en: BUBBLESORT(*A*, *n*)
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: BUBBLESORT(*A*, *n*)
- en: '| 1 | **for** *i* = 1 **to** *n* – 1 |'
  id: totrans-248
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **对于** *i* = 1 **到** *n* – 1 |'
- en: '| 2 | **for** *j* = *n* **downto** *i* + 1 |'
  id: totrans-249
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **对于** *j* = *n* **向下到** *i* + 1 |'
- en: '| 3 | **if** *A*[*j*] < *A*[*j* – 1] |'
  id: totrans-250
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **如果** *A*[*j*] < *A*[*j* – 1] |'
- en: '| 4 | exchange *A*[*j*] with *A*[*j* – 1] |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 4 | 交换*A*[*j*]和*A*[*j* – 1] |'
- en: '***a.*** Let *A*^′ denote the array *A* after BUBBLESORT(*A*, *n*) is executed.
    To prove that'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 让*A*^′表示执行BUBBLESORT(*A*, *n*)后的数组*A*。为了证明'
- en: '![art](images/Art_P28.jpg)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P28.jpg)'
- en: In order to show that BUBBLESORT actually sorts, what else do you need to prove?
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了证明BUBBLESORT实际上是排序的，你还需要证明什么？
- en: The next two parts prove inequality (2.5).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两部分证明不等式(2.5)。
- en: '***b.*** State precisely a loop invariant for the **for** loop in lines 2–4,
    and prove that this loop invariant holds. Your proof should use the structure
    of the loop-invariant proof presented in this chapter.'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 准确陈述第2-4行的**for**循环的一个循环不变性，并证明这个循环不变性成立。你的证明应该使用本章中提出的循环不变性证明的结构。'
- en: '***c.*** Using the termination condition of the loop invariant proved in part
    (b), state a loop invariant for the **for** loop in lines 1–4 that allows you
    to prove inequality (2.5). Your proof should use the structure of the loop-invariant
    proof presented in this chapter.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 使用在(b)部分证明的循环不变性的终止条件，给出第1-4行的**for**循环的一个循环不变性，使你能够证明不等式(2.5)。你的证明应该使用本章中提出的循环不变性证明的结构。'
- en: '***d.*** What is the worst-case running time of BUBBLESORT? How does it compare
    with the running time of INSERTION-SORT?'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** BUBBLESORT的最坏情况运���时间是多少？它与INSERTION-SORT的运行时间相比如何？'
- en: '***2-3     Correctness of Horner’s rule***'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '***2-3     霍纳法则的正确性***'
- en: You are given the coefficents *a*[0], *a*[1], *a*[2], … , *a[n]* of a polynomial
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 给定多项式的系数*a*[0], *a*[1], *a*[2], … , *a[n]*
- en: '![art](images/Art_P29.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P29.jpg)'
- en: 'and you want to evaluate this polynomial for a given value of *x*. ***Horner’s
    rule*** says to evaluate the polynomial according to this parenthesization:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 你想要为给定的*x*值评估这个多项式。***霍纳法则***建议根据这种括号化评估多项式：
- en: '![art](images/Art_P30.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P30.jpg)'
- en: 'The procedure HORNER implements Horner’s rule to evaluate *P*(*x*), given the
    coefficients *a*[0], *a*[1], *a*[2], … , *a[n]* in an array *A*[0 : *n*] and the
    value of *x*.'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: '过程HORNER实现了霍纳法则来评估*P*(*x*)，给定数组*A*[0 : *n*]中的系数*a*[0], *a*[1], *a*[2], … ,
    *a[n]*和值*x*。'
- en: HORNER(*A, n, x*)
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: HORNER(*A, n, x*)
- en: '| 1 | *p* = 0 |'
  id: totrans-266
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *p* = 0 |'
- en: '| 2 | **for** *i* = *n* **downto** 0 |'
  id: totrans-267
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **对于** *i* = *n* **向下到** 0 |'
- en: '| 3 | *p* = *A*[*i*] + *x* · *p* |'
  id: totrans-268
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *p* = *A*[*i*] + *x* · *p* |'
- en: '| 4 | **return** *p* |'
  id: totrans-269
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **返回** *p* |'
- en: '***a.*** In terms of Θ-notation, what is the running time of this procedure?'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 用Θ-符号表示，这个过程的运行时间是多少？'
- en: '***b.*** Write pseudocode to implement the naive polynomial-evaluation algorithm
    that computes each term of the polynomial from scratch. What is the running time
    of this algorithm? How does it compare with HORNER?'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 编写伪代码来实现朴素的多项式求值算法，从头计算多项式的每一项。这个算法的运行时间是多少？它与HORNER相比如何？'
- en: '***c.*** Consider the following loop invariant for the procedure HORNER:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 考虑过程HORNER的以下循环不变性：'
- en: At the start of each iteration of the **for** loop of lines 2–3,
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在第2-3行的**for**循环的每次迭代开始时，
- en: '![art](images/Art_P31.jpg)'
  id: totrans-274
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P31.jpg)'
- en: Interpret a summation with no terms as equaling 0\. Following the structure
    of the loop-invariant proof presented in this chapter, use this loop invariant
    to show that, at termination, ![art](images/Art_P32.jpg).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 将没有项的求和解释为等于0。遵循本章中提出的循环不变性证明的结构，使用这个循环不变性来展示，在终止时，![艺术](images/Art_P32.jpg)。
- en: '***2-4     Inversions***'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: '***2-4     逆序***'
- en: 'Let *A*[1 : *n*] be an array of *n* distinct numbers. If *i* < *j* and *A*[*i*]
    > *A*[*j*], then the pair (*i, j*) is called an ***inversion*** of *A*.'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: '让*A*[1 : *n*]是一个包含*n*个不同数字的数组。如果*i* < *j*且*A*[*i*] > *A*[*j*]，那么这对(*i, j*)被称为*A*的一个***逆序***。'
- en: '***a.*** List the five inversions of the array 〈2, 3, 8, 6, 1〉.'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 列出数组〈2, 3, 8, 6, 1〉的五个逆序。'
- en: '***b.*** What array with elements from the set {1, 2, … , *n*} has the most
    inversions? How many does it have?'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 从集合{1, 2, … , *n*}中具有最多逆序的元素的数组是什么？它有多少个逆序？'
- en: '***c.*** What is the relationship between the running time of insertion sort
    and the number of inversions in the input array? Justify your answer.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 插入排序的运行时间与输入数组中逆序数之间的关系是什么？证明你的答案。'
- en: '***d.*** Give an algorithm that determines the number of inversions in any
    permutation on *n* elements in Θ(*n* lg *n*) worst-case time. (*Hint:* Modify
    merge sort.)'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 给出一个算法，确定Θ(*n* lg *n*)最坏情况时间内任意排列上的逆序数。(*提示:* 修改归并排序。)'
- en: '**Chapter notes**'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节注释**'
- en: In 1968, Knuth published the first of three volumes with the general title *The
    Art of Computer Programming* [[259](bibliography001.xhtml#endnote_259), [260](bibliography001.xhtml#endnote_260),
    [261](bibliography001.xhtml#endnote_261)]. The first volume ushered in the modern
    study of computer algorithms with a focus on the analysis of running time. The
    full series remains an engaging and worthwhile reference for many of the topics
    presented here. According to Knuth, the word “algorithm” is derived from the name
    “al-Khowârizmî,” a ninth-century Persian mathematician.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 1968年，Knuth出版了三卷的通用标题为*计算机编程艺术*[[259](bibliography001.xhtml#endnote_259), [260](bibliography001.xhtml#endnote_260),
    [261](bibliography001.xhtml#endnote_261)]。第一卷引领了现代计算机算法研究，重点是运行时间的分析。整个系列仍然是许多这里介绍的主题的引人入胜且有价值的参考资料。根据Knuth，单词“算法”源自于第九世纪波斯数学家“al-Khowârizmî”的名字。
- en: Aho, Hopcroft, and Ullman [[5](bibliography001.xhtml#endnote_5)] advocated the
    asymptotic analysis of algorithms—using notations that [Chapter 3](chapter003.xhtml)
    introduces, including Θ-notation—as a means of comparing relative performance.
    They also popularized the use of recurrence relations to describe the running
    times of recursive algorithms.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: Aho、Hopcroft和Ullman [[5](bibliography001.xhtml#endnote_5)] 提倡算法的渐近分析——使用[第3章](chapter003.xhtml)介绍的符号，包括Θ-符号——作为比较相对性能的手段。他们还推广了使用递归算法的运行时间的递归关系描述。
- en: Knuth [[261](bibliography001.xhtml#endnote_261)] provides an encyclopedic treatment
    of many sorting algorithms. His comparison of sorting algorithms (page 381) includes
    exact step-counting analyses, like the one we performed here for insertion sort.
    Knuth’s discussion of insertion sort encompasses several variations of the algorithm.
    The most important of these is Shell’s sort, introduced by D. L. Shell, which
    uses insertion sort on periodic subarrays of the input to produce a faster sorting
    algorithm.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: Knuth [[261](bibliography001.xhtml#endnote_261)] 对许多排序算法进行了百科全书式的处理。他对排序算法的比较（第381页）包括精确的步数分析，就像我们在这里为插入排序执行的那样。Knuth对插入排序的讨论涵盖了算法的几种变体。其中最重要的是由D.
    L. Shell引入的Shell排序，它使用插入排序在输入的周期子数组上产生更快的排序算法。
- en: Merge sort is also described by Knuth. He mentions that a mechanical collator
    capable of merging two decks of punched cards in a single pass was invented in
    1938\. J. von Neumann, one of the pioneers of computer science, apparently wrote
    a program for merge sort on the EDVAC computer in 1945.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: Knuth也描述了归并排序。他提到，1938年发明了一种能够在一次传递中合并两叠打孔卡片的机械整理机。计算机科学先驱之一J. von Neumann显然在1945年为EDVAC计算机编写了归并排序程序。
- en: The early history of proving programs correct is described by Gries [[200](bibliography001.xhtml#endnote_200)],
    who credits P. Naur with the first article in this field. Gries attributes loop
    invariants to R. W. Floyd. The textbook by Mitchell [[329](bibliography001.xhtml#endnote_329)]
    is a good reference on how to prove programs correct.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 早期证明程序正确性的历史由Gries [[200](bibliography001.xhtml#endnote_200)] 描述，他将第一篇关于这一领域的文章归功于P.
    Naur。Gries将循环不变式归因于R. W. Floyd。Mitchell的教科书[[329](bibliography001.xhtml#endnote_329)]是如何证明程序正确的良好参考资料。
- en: '[¹](#footnote_ref_1) If you’re familiar with only Python, you can think of
    arrays as similar to Python lists.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: '[¹](#footnote_ref_1) 如果您只熟悉Python，您可以将数组视为类似于Python列表。'
- en: '[²](#footnote_ref_2) When the loop is a **for** loop, the loop-invariant check
    just prior to the first iteration occurs immediately after the initial assignment
    to the loop-counter variable and just before the first test in the loop header.
    In the case of INSERTION-SORT, this time is after assigning 2 to the variable
    *i* but before the first test of whether *i* ≤ *n*.'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '[²](#footnote_ref_2) 当循环是**for**循环时，在第一次迭代之前的循环不变式检查立即在将循环计数器变量初始化赋值后和在循环头部的第一个测试之前发生。在INSERTION-SORT的情况下，这个时间是在将变量*i*赋值为2之后，但在第一次测试*i*
    ≤ *n*之前。'
- en: '[³](#footnote_ref_3) In an **if-else** statement, we indent **else** at the
    same level as its matching **if**. The first executable line of an **else** clause
    appears on the same line as the keyword **else**. For multiway tests, we use **elseif**
    for tests after the first one. When it is the first line in an **else** clause,
    an **if** statement appears on the line following **else** so that you do not
    misconstrue it as **elseif**.'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '[³](#footnote_ref_3) 在**if-else**语句中，我们将**else**缩进到与其匹配的**if**相同的级别。**else**子句的第一行出现在与关键字**else**相同的行上。对于多路测试，我们在第一个测试后使用**elseif**。当**if**语句是**else**子句中的第一行时，**if**语句出现在**else**的下一行，以免您将其误解为**elseif**。'
- en: '[⁴](#footnote_ref_4) Each pseudocode procedure in this book appears on one
    page so that you do not need to discern levels of indentation in pseudocode that
    is split across pages.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '[⁴](#footnote_ref_4) 本书中的每个伪代码过程都显示在一页上，因此您无需辨别跨页分割的伪代码中的缩进级别。'
- en: '[⁵](#footnote_ref_5) Most block-structured languages have equivalent constructs,
    though the exact syntax may differ. Python lacks **repeat-until** loops, and its
    **for** loops operate differently from the **for** loops in this book. Think of
    the pseudocode line “**for** *i* = 1 **to** *n*” as equivalent to “for i in range(1,
    n+1)” in Python.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: '[⁵](#footnote_ref_5) 大多数块结构化语言具有等效的结构，尽管确切的语法可能有所不同。Python缺少**repeat-until**循环，其**for**循环与本书中的**for**循环操作方式不同。将伪代码行“**for** *i*
    = 1 **to** *n*”视为Python中“for i in range(1, n+1)”的等效形式。'
- en: '[⁶](#footnote_ref_6) In Python, the loop counter retains its value after the
    loop is exited, but the value it retains is the value it had during the final
    iteration of the **for** loop, rather than the value that exceeded the loop bound.
    That is because a Python **for** loop iterates through a list, which may contain
    nonnumeric values.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '[⁶](#footnote_ref_6) 在Python中，循环计数器在退出循环后保留其值，但它保留的值是在**for**循环的最后一次迭代期间的值，而不是超过循环边界的值。这是因为Python的**for**循环遍历列表，该列表可能包含非数字值。'
- en: '[⁷](#footnote_ref_7) If you’re used to programming in Python, bear in mind
    that in this book, the subarray *A*[*i* : *j*] includes the element *A*[*j*].
    In Python, the last element of *A*[*i* : *j*] is *A*[*j* – 1]. Python allows negative
    indices, which count from the back end of the list. This book does not use negative
    array indices.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '[⁷](#footnote_ref_7) 如果您习惯于在Python中编程，请记住，在本书中，子数组*A*[*i* : *j*]包括元素*A*[*j*]。在Python中，*A*[*i*
    : *j*]的最后一个元素是*A*[*j* – 1]。Python允许负索引，从列表的末尾计数。本书不使用负数组索引。'
- en: '[⁸](#footnote_ref_8) Python’s tuple notation allows **return** statements to
    return multiple values without creating objects from a programmer-defined class.'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '[⁸](#footnote_ref_8) Python的元���表示允许**return**语句返回多个值，而无需从程序员定义的类创建对象。'
- en: '[⁹](#footnote_ref_9) We assume that each element of a given array occupies
    the same number of bytes and that the elements of a given array are stored in
    contiguous memory locations. For example, if array *A*[1 : *n*] starts at memory
    address 1000 and each element occupies four bytes, then element *A*[*i*] is at
    address 1000 + 4(*i* – 1). In general, computing the address in memory of a particular
    array element requires at most one subtraction (no subtraction for a 0-origin
    array), one multiplication (often implemented as a shift operation if the element
    size is an exact power of 2), and one addition. Furthermore, for code that iterates
    through the elements of an array in order, an optimizing compiler can generate
    the address of each element using just one addition, by adding the element size
    to the address of the preceding element.'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: '[⁹](#footnote_ref_9) 我们假设给定数组的每个元素占用相同数量的字节，并且给定数组的元素存储在连续的内存位置中。例如，如果数组*A*[1
    : *n*]从内存地址1000开始，每个元素占用四个字节，那么元素*A*[*i*]位于地址1000 + 4(*i* – 1)。通常，计算特定数组元素在内存中的地址最多需要一次减法（对于从0开始的数组不需要减法），一次乘法（如果元素大小是2的幂，则通常实现为移位操作）和一次加法。此外，对数组元素按顺序进行迭代的代码，优化编译器可以仅通过一次加法生成每个元素的地址，通过将元素大小添加到前一个元素的地址。'
- en: '[^(10)](#footnote_ref_10) There are some subtleties here. Computational steps
    that we specify in English are often variants of a procedure that requires more
    than just a constant amount of time. For example, in the RADIX-SORT procedure
    on page 213, one line reads “use a stable sort to sort array *A* on digit *i*,”
    which, as we shall see, takes more than a constant amount of time. Also, although
    a statement that calls a subroutine takes only constant time, the subroutine itself,
    once invoked, may take more. That is, we separate the process of ***calling***
    the subroutine—passing parameters to it, etc.—from the process of ***executing***
    the subroutine.'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '[^(10)](#footnote_ref_10) 这里有一些微妙之处。我们用英语指定的计算步骤通常是需要超过一个恒定时间的过程的变体。例如，在第213页的RADIX-SORT过程中，有一行写着“使用稳定排序对数组*A*上的第*i*位进行排序”，正如我们将看到的那样，这需要超过一个恒定时间。此外，尽管调用子程序的语句只需要恒定时间，但一旦调用了子程序，子程序本身可能需要更多时间。也就是说，我们将***调用***子程序的过程——传递参数等——与***执行***子程序的过程分开。'
- en: '[^(11)](#footnote_ref_11) This characteristic does not necessarily hold for
    a resource such as memory. A statement that references *m* words of memory and
    is executed *n* times does not necessarily reference *mn* distinct words of memory.'
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '[^(11)](#footnote_ref_11) 这种特性不一定适用于内存等资源。引用*m*个内存字并执行*n*次的语句不一定引用*mn*个不同的内存字。'
- en: '[^(12)](#footnote_ref_12) This procedure is the rare case that uses both 1-origin
    indexing (for array *A*) and 0-origin indexing (for arrays *L* and *R*). Using
    0-origin indexing for *L* and *R* makes for a simpler loop invariant in Exercise
    2.3-3.'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: '[^(12)](#footnote_ref_12) 这个过程是少见的同时使用1起始索引（对于数组*A*）和0起始索引（对于数组*L*和*R*）的情况。对*L*和*R*使用0起始索引使得练习2.3-3中的循环不变式更简单。'
- en: '[^(13)](#footnote_ref_13) If you’re wondering where the “+1” comes from, imagine
    that *r* = *p* + 1\. Then the subarray *A*[*p* : *r*] consists of two elements,
    and *r* – *p* + 1 = 2.'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: '[^(13)](#footnote_ref_13) 如果你想知道“+1”是从哪里来的，想象一下*r* = *p* + 1\. 那么子数组*A*[*p*
    : *r*]由两个元素组成，*r* – *p* + 1 = 2。'
- en: '[^(14)](#footnote_ref_14) [Chapter 3](chapter003.xhtml) shows how to formally
    interpret equations containing Θ-notation.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '[^(14)](#footnote_ref_14) [第3章](chapter003.xhtml)展示了如何正式解释包含Θ符号的方程。'
- en: '[^(15)](#footnote_ref_15) The expression ⌈*x*⌉ denotes the least integer greater
    than or equal to *x*, and ⌊*x*⌋ denotes the greatest integer less than or equal
    to *x*. These notations are defined in [Section 3.3](chapter003.xhtml#Sec_3.3).
    The easiest way to verify that setting *q* to ⌊(*p* + *r*)/2⌋ yields subarrays
    *A*[*p* : *q*] and *A*[*q* + 1 : *r*] of sizes ⌈*n*/2⌉ and ⌊*n*/2⌋, respectively,
    is to examine the four cases that arise depending on whether each of *p* and *r*
    is odd or even.'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: '[^(15)](#footnote_ref_15) 表达式⌈*x*⌉表示不小于*x*的最小整数，⌊*x*⌋表示不大于*x*的最大整数。这些符号在[第3.3节](chapter003.xhtml#Sec_3.3)中定义。验证将*q*设置为⌊(*p*
    + *r*)/2⌋会产生大小为⌈*n*/2⌉和⌊*n*/2⌋的子数组*A*[*p* : *q*]和*A*[*q* + 1 : *r*]的最简单方法是根据*p*和*r*是奇数还是偶数的四种情况进行检查。'
- en: '[^(16)](#footnote_ref_16) If you’re wondering where Θ(1) comes from, think
    of it this way. When we say that *n*²/100 is Θ(*n*²), we are ignoring the coefficient
    1/100 of the factor *n*². Likewise, when we say that a constant *c* is Θ(1), we
    are ignoring the coefficient *c* of the factor 1 (which you can also think of
    as *n*⁰).'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '[^(16)](#footnote_ref_16) 如果你想知道Θ(1)是从哪里来的，可以这样想。当我们说*n*²/100是Θ(*n*²)时，我们忽略了因子*n*²的系数1/100。同样，当我们说一个常数*c*是Θ(1)时，我们忽略了因子1的系数*c*（你也可以将其视为*n*⁰）。'
- en: '[^(17)](#footnote_ref_17) The notation lg *n* stands for log[2] *n*, although
    the base of the logarithm doesn’t matter here, but as computer scientists, we
    like logarithms base 2\. [Section 3.3](chapter003.xhtml#Sec_3.3) discusses other
    standard notation.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: '[^(17)](#footnote_ref_17) 符号lg *n*代表log[2] *n*，尽��对数的底在这里并不重要，但作为计算机科学家，我们喜欢以2为底的对数。[第3.3节](chapter003.xhtml#Sec_3.3)讨论了其他标准符号。'
- en: '[^(18)](#footnote_ref_18) It is unlikely that *c*[1] is exactly the time to
    solve problems of size 1 and that *c*[2]*n* is exactly the time of the divide
    and combine steps. We’ll look more closely at bounding recurrences in [Chapter
    4](chapter004.xhtml), where we’ll be more careful about this kind of detail.'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '[^(18)](#footnote_ref_18) *c*[1]恰好是解决规模为1的问题所需的时间，*c*[2]*n*也恰好是分割和合并步骤所需的时间是不太可能的。我们将在[第4章](chapter004.xhtml)更仔细地研究递归的界限，对这种细节我们会更加小心。'
