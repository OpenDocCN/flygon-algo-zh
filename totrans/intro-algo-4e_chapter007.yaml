- en: '[**7          Quicksort**](toc.xhtml#chap-7)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The quicksort algorithm has a worst-case running time of Θ(*n*²) on an input
    array of *n* numbers. Despite this slow worst-case running time, quicksort is
    often the best practical choice for sorting because it is remarkably efficient
    on average: its expected running time is Θ(*n* lg *n*) when all numbers are distinct,
    and the constant factors hidden in the Θ(*n* lg *n*) notation are small. Unlike
    merge sort, it also has the advantage of sorting in place (see page 158), and
    it works well even in virtual-memory environments.'
  prefs: []
  type: TYPE_NORMAL
- en: Our study of quicksort is broken into four sections. [Section 7.1](chapter007.xhtml#Sec_7.1)
    describes the algorithm and an important subroutine used by quicksort for partitioning.
    Because the behavior of quicksort is complex, we’ll start with an intuitive discussion
    of its performance in [Section 7.2](chapter007.xhtml#Sec_7.2) and analyze it precisely
    at the end of the chapter. [Section 7.3](chapter007.xhtml#Sec_7.3) presents a
    randomized version of quicksort. When all elements are distinct,^([1](#footnote_1))
    this randomized algorithm has a good expected running time and no particular input
    elicits its worst-case behavior. (See Problem 7-2 for the case in which elements
    may be equal.) [Section 7.4](chapter007.xhtml#Sec_7.4) analyzes the randomized
    algorithm, showing that it runs in Θ(*n*²) time in the worst case and, assuming
    distinct elements, in expected *O*(*n* lg *n*) time.
  prefs: []
  type: TYPE_NORMAL
- en: '[**7.1      Description of quicksort**](toc.xhtml#Rh1-39)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Quicksort, like merge sort, applies the divide-and-conquer method introduced
    in [Section 2.3.1](chapter002.xhtml#Sec_2.3.1). Here is the three-step divide-and-conquer
    process for sorting a subarray *A*[*p* : *r*]:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Divide** by partitioning (rearranging) the array *A*[*p* : *r*] into two
    (possibly empty) subarrays *A*[*p* : *q* – 1] (the ***low side***) and *A*[*q*
    + 1 : *r*] (the ***high side***) such that each element in the low side of the
    partition is less than or equal to the ***pivot*** *A*[*q*], which is, in turn,
    less than or equal to each element in the high side. Compute the index *q* of
    the pivot as part of this partitioning procedure.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Conquer** by calling quicksort recursively to sort each of the subarrays
    *A*[*p* : *q* – 1] and *A*[*q* + 1 : *r*].'
  prefs: []
  type: TYPE_NORMAL
- en: '**Combine** by doing nothing: because the two subarrays are already sorted,
    no work is needed to combine them. All elements in *A*[*p* : *q* – 1] are sorted
    and less than or equal to *A*[*q*], and all elements in *A*[*q* + 1 : *r*] are
    sorted and greater than or equal to the pivot *A*[*q*]. The entire subarray *A*[*p*
    : *r*] cannot help but be sorted!'
  prefs: []
  type: TYPE_NORMAL
- en: 'The QUICKSORT procedure implements quicksort. To sort an entire *n*-element
    array *A*[1 : *n*], the initial call is QUICKSORT (*A*, 1, *n*).'
  prefs: []
  type: TYPE_NORMAL
- en: QUICKSORT(*A*, *p*, *r*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | **if** *p* < *r* |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | **//** Partition the subarray around the pivot, which ends up in *A*[*q*].
    |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | *q* = PARTITION(*A*, *p*, *r*) |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | QUICKSORT(*A*, *p*, *q* – 1) | **//** recursively sort the low side |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | QUICKSORT(*A*, *q* + 1, *r*) | **//** recursively sort the high side
    |'
  prefs: []
  type: TYPE_TB
- en: '**Partitioning the array**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The key to the algorithm is the PARTITION procedure on the next page, which
    rearranges the subarray *A*[*p* : *r*] in place, returning the index of the dividing
    point between the two sides of the partition.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Figure 7.1](chapter007.xhtml#Fig_7-1) shows how PARTITION works on an 8-element
    array. PARTITION always selects the element *x* = *A*[*r*] as the pivot. As the
    procedure runs, each element falls into exactly one of four regions, some of which
    may be empty. At the start of each iteration of the **for** loop in lines 3–6,
    the regions satisfy certain properties, shown in [Figure 7.2](chapter007.xhtml#Fig_7-2).
    We state these properties as a loop invariant:'
  prefs: []
  type: TYPE_NORMAL
- en: PARTITION(*A*, *p*, *r*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | *x* = *A*[*r*] | **//** the pivot |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | *i* = *p* – 1 | **//** highest index into the low side |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | **for** *j* = *p* **to** *r* – 1 | **//** process each element other
    than the pivot |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | **if** *A*[*j*] ≤ *x* | **//** does this element belong on the low side?
    |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | *i* = *i* + 1 | **//** index of a new slot in the low side |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | exchange *A*[*i*] with *A*[*j*] | **//** put this element there |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | exchange *A*[*i* + 1] with *A*[*r*] | **//** pivot goes just to the right
    of the low side |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | **return** *i* + 1 | **//** new index of the pivot |'
  prefs: []
  type: TYPE_TB
- en: 'At the beginning of each iteration of the loop of lines 3–6, for any array
    index *k*, the following conditions hold:'
  prefs: []
  type: TYPE_NORMAL
- en: if *p* ≤ *k* ≤ *i*, then *A*[*k*] ≤ *x* (the tan region of [Figure 7.2](chapter007.xhtml#Fig_7-2));
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: if *i* + 1 ≤ *k* ≤ *j* – 1, then *A*[*k*] > *x* (the blue region);
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: if *k* = *r*, then *A*[*k*] = *x* (the yellow region).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to show that this loop invariant is true prior to the first iteration,
    that each iteration of the loop maintains the invariant, that the loop terminates,
    and that correctness follows from the invariant when the loop terminates.
  prefs: []
  type: TYPE_NORMAL
- en: '**Initialization:** Prior to the first iteration of the loop, we have *i* =
    *p* – 1 and *j* = *p*. Because no values lie between *p* and *i* and no values
    lie between *i* + 1 and *j* – 1, the first two conditions of the loop invariant
    are trivially satisfied. The assignment in line 1 satisfies the third condition.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Maintenance:** As [Figure 7.3](chapter007.xhtml#Fig_7-3) shows, we consider
    two cases, depending on the outcome of the test in line 4\. [Figure 7.3(a)](chapter007.xhtml#Fig_7-3)
    shows what happens when *A*[*j*] > *x*: the only action in the loop is to increment
    *j*. After *j* has been incremented, the second condition holds for *A*[*j* –
    1] and all other entries remain unchanged. [Figure 7.3(b)](chapter007.xhtml#Fig_7-3)
    shows what happens when *A*[*j*] ≤ *x*: the loop increments *i*, swaps *A*[*i*]
    and *A*[*j*], and then increments *j*. Because of the swap, we now have that *A*[*i*]
    ≤ *x*, and condition 1 is satisfied. Similarly, we also have that *A*[*j* – 1]
    > *x*, since the item that was swapped into *A*[*j* – 1] is, by the loop invariant,
    greater than *x*.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Termination:** Since the loop makes exactly *r* – *p* iterations, it terminates,
    whereupon *j* = *r*. At that point, the unexamined subarray *A*[*j* : *r* – 1]
    is empty, and every entry in the array belongs to one of the other three sets
    described by the invariant. Thus, the values in the array have been partitioned
    into three sets: those less than or equal to *x* (the low side), those greater
    than *x* (the high side), and a singleton set containing *x* (the pivot).'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P309.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.1** The operation of PARTITION on a sample array. Array entry *A*[*r*]
    becomes the pivot element *x*. Tan array elements all belong to the low side of
    the partition, with values at most *x*. Blue elements belong to the high side,
    with values greater than *x*. White elements have not yet been put into either
    side of the partition, and the yellow element is the pivot *x*. **(a)** The initial
    array and variable settings. None of the elements have been placed into either
    side of the partition. **(b)** The value 2 is “swapped with itself” and put into
    the low side. **(c)–(d)** The values 8 and 7 are placed into to high side. **(e)**
    The values 1 and 8 are swapped, and the low side grows. **(f)** The values 3 and
    7 are swapped, and the low side grows. **(g)–(h)** The high side of the partition
    grows to include 5 and 6, and the loop terminates. **(i)** Line 7 swaps the pivot
    element so that it lies between the two sides of the partition, and line 8 returns
    the pivot’s new index.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The final two lines of PARTITION finish up by swapping the pivot with the leftmost
    element greater than *x*, thereby moving the pivot into its correct place in the
    partitioned array, and then returning the pivot’s new index. The output of PARTITION
    now satisfies the specifications given for the divide step. In fact, it satisfies
    a slightly stronger condition: after line 3 of QUICKSORT, *A*[*q*] is strictly
    less than every element of *A*[*q* + 1 : *r*].'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P310.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.2** The four regions maintained by the procedure PARTITION on a
    subarray *A*[*p* : *r*]. The tan values in *A*[*p* : *i*] are all less than or
    equal to *x*, the blue values in *A*[*i* + 1 : *j* – 1] are all greater than *x*,
    the white values in *A*[*j* : *r* – 1] have unknown relationships to *x*, and
    *A*[*r*] = *x*.'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P311.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.3** The two cases for one iteration of procedure PARTITION. **(a)**
    If *A*[*j*] > *x*, the only action is to increment *j*, which maintains the loop
    invariant. **(b)** If *A*[*j*] ≤ *x*, index *i* is incremented, *A*[*i*] and *A*[*j*]
    are swapped, and then *j* is incremented. Again, the loop invariant is maintained.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 7.1-3 asks you to show that the running time of PARTITION on a subarray
    *A*[*p* : *r*] of *n* = *r* – *p* + 1 elements is Θ(*n*).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs: []
  type: TYPE_NORMAL
- en: '***7.1-1***'
  prefs: []
  type: TYPE_NORMAL
- en: Using [Figure 7.1](chapter007.xhtml#Fig_7-1) as a model, illustrate the operation
    of PARTITION on the array *A* = 〈13, 19, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11〉.
  prefs: []
  type: TYPE_NORMAL
- en: '***7.1-2***'
  prefs: []
  type: TYPE_NORMAL
- en: 'What value of *q* does PARTITION return when all elements in the subarray *A*[*p*
    : *r*] have the same value? Modify PARTITION so that *q* = ⌊(*p* + *r*)/2⌋ when
    all elements in the subarray *A*[*p* : *r*] have the same value.'
  prefs: []
  type: TYPE_NORMAL
- en: '***7.1-3***'
  prefs: []
  type: TYPE_NORMAL
- en: Give a brief argument that the running time of PARTITION on a subarray of size
    *n* is Θ(*n*).
  prefs: []
  type: TYPE_NORMAL
- en: '***7.1-4***'
  prefs: []
  type: TYPE_NORMAL
- en: Modify QUICKSORT to sort into monotonically decreasing order.
  prefs: []
  type: TYPE_NORMAL
- en: '[**7.2      Performance of quicksort**](toc.xhtml#Rh1-40)'
  prefs: []
  type: TYPE_NORMAL
- en: The running time of quicksort depends on how balanced each partitioning is,
    which in turn depends on which elements are used as pivots. If the two sides of
    a partition are about the same size—the partitioning is balanced—then the algorithm
    runs asymptotically as fast as merge sort. If the partitioning is unbalanced,
    however, it can run asymptotically as slowly as insertion sort. To allow you to
    gain some intuition before diving into a formal analysis, this section informally
    investigates how quicksort performs under the assumptions of balanced versus unbalanced
    partitioning.
  prefs: []
  type: TYPE_NORMAL
- en: But first, let’s briefly look at the maximum amount of memory that quicksort
    requires. Although quicksort sorts in place according to the definition on page
    158, the amount of memory it uses—aside from the array being sorted—is not constant.
    Since each recursive call requires a constant amount of space on the runtime stack,
    outside of the array being sorted, quicksort requires space proportional to the
    maximum depth of the recursion. As we’ll see now, that could be as bad as Θ(*n*)
    in the worst case.
  prefs: []
  type: TYPE_NORMAL
- en: '**Worst-case partitioning**'
  prefs: []
  type: TYPE_NORMAL
- en: The worst-case behavior for quicksort occurs when the partitioning produces
    one subproblem with *n* – 1 elements and one with 0 elements. (See [Section 7.4.1](chapter007.xhtml#Sec_7.4.1).)
    Let us assume that this unbalanced partitioning arises in each recursive call.
    The partitioning costs Θ(*n*) time. Since the recursive call on an array of size
    0 just returns without doing anything, *T* (0) = Θ(1), and the recurrence for
    the running time is
  prefs: []
  type: TYPE_NORMAL
- en: '| *T* (*n*) | = | *T* (*n* – 1) + *T* (0) + Θ(*n*) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | *T* (*n* – 1) + Θ(*n*). |'
  prefs: []
  type: TYPE_TB
- en: By summing the costs incurred at each level of the recursion, we obtain an arithmetic
    series (equation (A.3) on page 1141), which evaluates to Θ(*n*²). Indeed, the
    substitution method can be used to prove that the recurrence *T* (*n*) = *T* (*n*
    – 1) + Θ(*n*) has the solution *T* (*n*) = Θ(*n*²). (See Exercise 7.2-1.)
  prefs: []
  type: TYPE_NORMAL
- en: Thus, if the partitioning is maximally unbalanced at every recursive level of
    the algorithm, the running time is Θ(*n*²). The worst-case running time of quicksort
    is therefore no better than that of insertion sort. Moreover, the Θ(*n*²) running
    time occurs when the input array is already completely sorted—a situation in which
    insertion sort runs in *O*(*n*) time.
  prefs: []
  type: TYPE_NORMAL
- en: '**Best-case partitioning**'
  prefs: []
  type: TYPE_NORMAL
- en: In the most even possible split, PARTITION produces two subproblems, each of
    size no more than *n*/2, since one is of size ⌊(*n* – 1)/2⌋ ≤ *n*/2 and one of
    size ⌈(*n* – 1)/2⌉ – 1 ≤ *n*/2\. In this case, quicksort runs much faster. An
    upper bound on the running time can then be described by the recurrence
  prefs: []
  type: TYPE_NORMAL
- en: '*T* (*n*) = 2*T* (*n*/2) + Θ(*n*).'
  prefs: []
  type: TYPE_NORMAL
- en: By case 2 of the master theorem (Theorem 4.1 on page 102), this recurrence has
    the solution *T* (*n*) = Θ(*n* lg *n*). Thus, if the partitioning is equally balanced
    at every level of the recursion, an asymptotically faster algorithm results.
  prefs: []
  type: TYPE_NORMAL
- en: '**Balanced partitioning**'
  prefs: []
  type: TYPE_NORMAL
- en: As the analyses in [Section 7.4](chapter007.xhtml#Sec_7.4) will show, the average-case
    running time of quicksort is much closer to the best case than to the worst case.
    By appreciating how the balance of the partitioning affects the recurrence describing
    the running time, we can gain an understanding of why.
  prefs: []
  type: TYPE_NORMAL
- en: Suppose, for example, that the partitioning algorithm always produces a 9-to-1
    proportional split, which at first blush seems quite unbalanced. We then obtain
    the recurrence
  prefs: []
  type: TYPE_NORMAL
- en: '*T* (*n*) = *T* (9*n*/10) + *T* (*n*/10) + Θ(*n*),'
  prefs: []
  type: TYPE_NORMAL
- en: on the running time of quicksort. [Figure 7.4](chapter007.xhtml#Fig_7-4) shows
    the recursion tree for this recurrence, where for simplicity the Θ(*n*) driving
    function has been replaced by *n*, which won’t affect the asymptotic solution
    of the recurrence (as Exercise 4.7-1 on page 118 justifies). Every level of the
    tree has cost *n*, until the recursion bottoms out in a base case at depth log[10] *n*
    = Θ(lg *n*), and then the levels have cost at most *n*. The recursion terminates
    at depth log[10/9] *n* = Θ(lg *n*). Thus, with a 9-to-1 proportional split at
    every level of recursion, which intuitively seems highly unbalanced, quicksort
    runs in *O*(*n* lg *n*) time—asymptotically the same as if the split were right
    down the middle. Indeed, even a 99-to-1 split yields an *O*(*n* lg *n*) running
    time. In fact, any split of *constant* proportionality yields a recursion tree
    of depth Θ(lg *n*), where the cost at each level is *O*(*n*). The running time
    is therefore *O*(*n* lg *n*) whenever the split has constant proportionality.
    The ratio of the split affects only the constant hidden in the *O*-notation.
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P312.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.4** A recursion tree for QUICKSORT in which PARTITION always produces
    a 9-to-1 split, yielding a running time of *O*(*n* lg *n*). Nodes show subproblem
    sizes, with per-level costs on the right.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Intuition for the average case**'
  prefs: []
  type: TYPE_NORMAL
- en: To develop a clear notion of the expected behavior of quicksort, we must assume
    something about how its inputs are distributed. Because quicksort determines the
    sorted order using only comparisons between input elements, its behavior depends
    on the relative ordering of the values in the array elements given as the input,
    not on the particular values in the array. As in the probabilistic analysis of
    the hiring problem in [Section 5.2](chapter005.xhtml#Sec_5.2), assume that all
    permutations of the input numbers are equally likely and that the elements are
    distinct.
  prefs: []
  type: TYPE_NORMAL
- en: When quicksort runs on a random input array, the partitioning is highly unlikely
    to happen in the same way at every level, as our informal analysis has assumed.
    We expect that some of the splits will be reasonably well balanced and that some
    will be fairly unbalanced. For example, Exercise 7.2-6 asks you to show that about
    80% of the time PARTITION produces a split that is at least as balanced as 9 to
    1, and about 20% of the time it produces a split that is less balanced than 9
    to 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P313.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 7.5 (a)** Two levels of a recursion tree for quicksort. The partitioning
    at the root costs *n* and produces a “bad” split: two subarrays of sizes 0 and
    *n* – 1\. The partitioning of the subarray of size *n* – 1 costs *n* – 1 and produces
    a “good” split: subarrays of size (*n* – 1)/2 – 1 and (*n* – 1)/2\. **(b)** A
    single level of a recursion tree that is well balanced. In both parts, the partitioning
    cost for the subproblems shown with blue shading is Θ(*n*). Yet the subproblems
    remaining to be solved in (a), shown with tan shading, are no larger than the
    corresponding subproblems remaining to be solved in (b).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the average case, PARTITION produces a mix of “good” and “bad” splits. In
    a recursion tree for an average-case execution of PARTITION, the good and bad
    splits are distributed randomly throughout the tree. Suppose for the sake of intuition
    that the good and bad splits alternate levels in the tree, and that the good splits
    are best-case splits and the bad splits are worst-case splits. [Figure 7.5(a)](chapter007.xhtml#Fig_7-5)
    shows the splits at two consecutive levels in the recursion tree. At the root
    of the tree, the cost is *n* for partitioning, and the subarrays produced have
    sizes *n* – 1 and 0: the worst case. At the next level, the subarray of size *n*
    – 1 undergoes best-case partitioning into subarrays of size (*n* – 1)/2 – 1 and
    (*n* – 1)/2\. Let’s assume that the base-case cost is 1 for the subarray of size
    0.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The combination of the bad split followed by the good split produces three
    subarrays of sizes 0, (*n* – 1)/2 – 1, and (*n* – 1)/2 at a combined partitioning
    cost of Θ(*n*) + Θ(*n* – 1) = Θ(*n*). This situation is at most a constant factor
    worse than that in [Figure 7.5(b)](chapter007.xhtml#Fig_7-5), namely, where a
    single level of partitioning produces two subarrays of size (*n* – 1)/2, at a
    cost of Θ(*n*). Yet this latter situation is balanced! Intuitively, the Θ(*n*
    – 1) cost of the bad split in [Figure 7.5(a)](chapter007.xhtml#Fig_7-5) can be
    absorbed into the Θ(*n*) cost of the good split, and the resulting split is good.
    Thus, the running time of quicksort, when levels alternate between good and bad
    splits, is like the running time for good splits alone: still *O*(*n* lg *n*),
    but with a slightly larger constant hidden by the *O*-notation. We’ll analyze
    the expected running time of a randomized version of quicksort rigorously in [Section
    7.4.2](chapter007.xhtml#Sec_7.4.2).'
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs: []
  type: TYPE_NORMAL
- en: '***7.2-1***'
  prefs: []
  type: TYPE_NORMAL
- en: Use the substitution method to prove that the recurrence *T* (*n*) = *T* (*n*
    – 1) + Θ(*n*) has the solution *T* (*n*) = Θ(*n*²), as claimed at the beginning
    of [Section 7.2](chapter007.xhtml#Sec_7.2).
  prefs: []
  type: TYPE_NORMAL
- en: '***7.2-2***'
  prefs: []
  type: TYPE_NORMAL
- en: What is the running time of QUICKSORT when all elements of array *A* have the
    same value?
  prefs: []
  type: TYPE_NORMAL
- en: '***7.2-3***'
  prefs: []
  type: TYPE_NORMAL
- en: Show that the running time of QUICKSORT is Θ(*n*²) when the array *A* contains
    distinct elements and is sorted in decreasing order.
  prefs: []
  type: TYPE_NORMAL
- en: '***7.2-4***'
  prefs: []
  type: TYPE_NORMAL
- en: Banks often record transactions on an account in order of the times of the transactions,
    but many people like to receive their bank statements with checks listed in order
    by check number. People usually write checks in order by check number, and merchants
    usually cash them with reasonable dispatch. The problem of converting time-of-transaction
    ordering to check-number ordering is therefore the problem of sorting almost-sorted
    input. Explain persuasively why the procedure INSERTION-SORT might tend to beat
    the procedure QUICKSORT on this problem.
  prefs: []
  type: TYPE_NORMAL
- en: '***7.2-5***'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that the splits at every level of quicksort are in the constant proportion
    *α* to *β*, where *α* + *β* = 1 and 0 < *α* ≤ *β* < 1\. Show that the minimum
    depth of a leaf in the recursion tree is approximately log[1/*α*] *n* and that
    the maximum depth is approximately log[1/*β*] *n*. (Don’t worry about integer
    round-off.)
  prefs: []
  type: TYPE_NORMAL
- en: '***7.2-6***'
  prefs: []
  type: TYPE_NORMAL
- en: Consider an array with distinct elements and for which all permutations of the
    elements are equally likely. Argue that for any constant 0 < *α* ≤ 1/2, the probability
    is approximately 1 – 2*α* that PARTITION produces a split at least as balanced
    as 1 – *α* to *α*.
  prefs: []
  type: TYPE_NORMAL
- en: '[**7.3      A randomized version of quicksort**](toc.xhtml#Rh1-41)'
  prefs: []
  type: TYPE_NORMAL
- en: In exploring the average-case behavior of quicksort, we have assumed that all
    permutations of the input numbers are equally likely. This assumption does not
    always hold, however, as, for example, in the situation laid out in the premise
    for Exercise 7.2-4\. [Section 5.3](chapter005.xhtml#Sec_5.3) showed that judicious
    randomization can sometimes be added to an algorithm to obtain good expected performance
    over all inputs. For quicksort, randomization yields a fast and practical algorithm.
    Many software libraries provide a randomized version of quicksort as their algorithm
    of choice for sorting large data sets.
  prefs: []
  type: TYPE_NORMAL
- en: 'In [Section 5.3](chapter005.xhtml#Sec_5.3), the RANDOMIZED-HIRE-ASSISTANT procedure
    explicitly permutes its input and then runs the deterministic HIRE-ASSISTANT procedure.
    We could do the same for quicksort as well, but a different randomization technique
    yields a simpler analysis. Instead of always using *A*[*r*] as the pivot, a randomized
    version randomly chooses the pivot from the subarray *A*[*p* : *r*], where each
    element in *A*[*p* : *r*] has an equal probability of being chosen. It then exchanges
    that element with *A*[*r*] before partitioning. Because the pivot is chosen randomly,
    we expect the split of the input array to be reasonably well balanced on average.'
  prefs: []
  type: TYPE_NORMAL
- en: The changes to PARTITION and QUICKSORT are small. The new partitioning procedure,
    RANDOMIZED-PARTITION, simply swaps before performing the partitioning. The new
    quicksort procedure, RANDOMIZED-QUICKSORT, calls RANDOMIZED-PARTITION instead
    of PARTITION. We’ll analyze this algorithm in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: RANDOMIZED-PARTITION(*A*, *p*, *r*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | *i* = RANDOM(*p*, *r*) |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | exchange *A*[*r*] with *A*[*i*] |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | **return** PARTITION(*A*, *p*, *r*) |'
  prefs: []
  type: TYPE_TB
- en: RANDOMIZED-QUICKSORT(*A*, *p*, *r*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | **if** *p* < *r* |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | *q* = RANDOMIZED-PARTITION(*A*, *p*, *r*) |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | RANDOMIZED-QUICKSORT(*A*, *p*, *q* – 1) |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | RANDOMIZED-QUICKSORT(*A*, *q* + 1, *r*) |'
  prefs: []
  type: TYPE_TB
- en: '**Exercises**'
  prefs: []
  type: TYPE_NORMAL
- en: '***7.3-1***'
  prefs: []
  type: TYPE_NORMAL
- en: Why do we analyze the expected running time of a randomized algorithm and not
    its worst-case running time?
  prefs: []
  type: TYPE_NORMAL
- en: '***7.3-2***'
  prefs: []
  type: TYPE_NORMAL
- en: When RANDOMIZED-QUICKSORT runs, how many calls are made to the random-number
    generator RANDOM in the worst case? How about in the best case? Give your answer
    in terms of Θ-notation.
  prefs: []
  type: TYPE_NORMAL
- en: '[**7.4      Analysis of quicksort**](toc.xhtml#Rh1-42)'
  prefs: []
  type: TYPE_NORMAL
- en: '[Section 7.2](chapter007.xhtml#Sec_7.2) gave some intuition for the worst-case
    behavior of quicksort and for why we expect the algorithm to run quickly. This
    section analyzes the behavior of quicksort more rigorously. We begin with a worst-case
    analysis, which applies to either QUICKSORT or RANDOMIZED-QUICKSORT, and conclude
    with an analysis of the expected running time of RANDOMIZED-QUICKSORT.'
  prefs: []
  type: TYPE_NORMAL
- en: '**7.4.1    Worst-case analysis**'
  prefs: []
  type: TYPE_NORMAL
- en: We saw in [Section 7.2](chapter007.xhtml#Sec_7.2) that a worst-case split at
    every level of recursion in quicksort produces a Θ(*n*²) running time, which,
    intuitively, is the worst-case running time of the algorithm. We now prove this
    assertion.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the substitution method (see [Section 4.3](chapter004.xhtml#Sec_4.3))
    to show that the running time of quicksort is *O*(*n*²). Let *T* (*n*) be the
    worst-case time for the procedure QUICKSORT on an input of size *n*. Because the
    procedure PARTITION produces two subproblems with total size *n* – 1, we obtain
    the recurrence
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P314.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We guess that *T* (*n*) ≤ *cn*² for some constant *c* > 0\. Substituting this
    guess into recurrence (7.1) yields
  prefs: []
  type: TYPE_NORMAL
- en: '| *T* (*n*) | ≤ | max {*cq*² + *c*(*n* – 1 – *q*)² : 0 ≤ *q* ≤ *n* – 1} + Θ(*n*)
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | *c* · max {*q*² + (*n* – 1 – *q*)² : 0 ≤ *q* ≤ *n* – 1} + Θ(*n*).
    |'
  prefs: []
  type: TYPE_TB
- en: Let’s focus our attention on the maximization. For *q* = 0, 1, … , *n* – 1,
    we have
  prefs: []
  type: TYPE_NORMAL
- en: '| *q*² + (*n* – 1 – *q*)² | = | *q*² + (*n* – 1)² – 2*q*(*n* – 1) + *q*² |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | (*n* – 1)² + 2*q*(*q* – (*n* – 1)) |'
  prefs: []
  type: TYPE_TB
- en: '|  | ≤ | (*n* – 1)² |'
  prefs: []
  type: TYPE_TB
- en: because *q* ≤ *n* – 1 implies that 2*q*(*q* – (*n* – 1)) ≤ 0\. Thus every term
    in the maximization is bounded by (*n* – 1)².
  prefs: []
  type: TYPE_NORMAL
- en: Continuing with our analysis of *T* (*n*), we obtain
  prefs: []
  type: TYPE_NORMAL
- en: '| *T* (*n*) | ≤ | *c*(*n* – 1)² + Θ(*n*) |'
  prefs: []
  type: TYPE_TB
- en: '|  | ≤ | *cn*² – *c*(2*n* – 1) + Θ(*n*) |'
  prefs: []
  type: TYPE_TB
- en: '|  | ≤ | *cn*², |'
  prefs: []
  type: TYPE_TB
- en: 'by picking the constant *c* large enough that the *c*(2*n* – 1) term dominates
    the Θ(*n*) term. Thus *T* (*n*) = *O*(*n*²). [Section 7.2](chapter007.xhtml#Sec_7.2)
    showed a specific case where quicksort takes Ω(*n*²) time: when partitioning is
    maximally unbalanced. Thus, the worst-case running time of quicksort is Θ(*n*²).'
  prefs: []
  type: TYPE_NORMAL
- en: '**7.4.2    Expected running time**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen the intuition behind why the expected running time of
    RANDOMIZED-QUICKSORT is *O*(*n* lg *n*): if, in each level of recursion, the split
    induced by RANDOMIZED-PARTITION puts any constant fraction of the elements on
    one side of the partition, then the recursion tree has depth Θ(lg *n*) and *O*(*n*)
    work is performed at each level. Even if we add a few new levels with the most
    unbalanced split possible between these levels, the total time remains *O*(*n*
    lg *n*). We can analyze the expected running time of RANDOMIZED-QUICKSORT precisely
    by first understanding how the partitioning procedure operates and then using
    this understanding to derive an *O*(*n* lg *n*) bound on the expected running
    time. This upper bound on the expected running time, combined with the Θ(*n* lg
    *n*) best-case bound we saw in [Section 7.2](chapter007.xhtml#Sec_7.2), yields
    a Θ(*n* lg *n*) expected running time. We assume throughout that the values of
    the elements being sorted are distinct.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Running time and comparisons**'
  prefs: []
  type: TYPE_NORMAL
- en: The QUICKSORT and RANDOMIZED-QUICKSORT procedures differ only in how they select
    pivot elements. They are the same in all other respects. We can therefore analyze
    RANDOMIZED-QUICKSORT by considering the QUICKSORT and PARTITION procedures, but
    with the assumption that pivot elements are selected randomly from the subarray
    passed to RANDOMIZED-PARTITION. Let’s start by relating the asymptotic running
    time of QUICKSORT to the number of times elements are compared (all in line 4
    of PARTITION), understanding that this analysis also applies to RANDOMIZED-QUICKSORT.
    Note that we are counting the number of times that *array elements* are compared,
    not comparisons of indices.
  prefs: []
  type: TYPE_NORMAL
- en: '***Lemma 7.1***'
  prefs: []
  type: TYPE_NORMAL
- en: The running time of QUICKSORT on an *n*-element array is *O*(*n* + *X*), where
    *X* is the number of element comparisons performed.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   The running time of QUICKSORT is dominated by the time spent
    in the PARTITION procedure. Each time PARTITION is called, it selects a pivot
    element, which is never included in any future recursive calls to QUICKSORT and
    PARTITION. Thus, there can be at most *n* calls to PARTITION over the entire execution
    of the quicksort algorithm. Each time QUICKSORT calls PARTITION, it also recursively
    calls itself twice, so there are at most 2*n* calls to the QUICKSORT procedure
    itself.'
  prefs: []
  type: TYPE_NORMAL
- en: One call to PARTITION takes *O*(1) time plus an amount of time that is proportional
    to the number of iterations of the **for** loop in lines 3–6\. Each iteration
    of this **for** loop performs one comparison in line 4, comparing the pivot element
    to another element of the array *A*. Therefore, the total time spent in the **for**
    loop across all executions is proportional to *X*. Since there are at most *n*
    calls to PARTITION and the time spent outside the **for** loop is *O*(1) for each
    call, the total time spent in PARTITION outside of the **for** loop is *O*(*n*).
    Thus the total time for quicksort is *O*(*n* + *X*).
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: Our goal for analyzing RANDOMIZED-QUICKSORT, therefore, is to compute the expected
    value E [*X*] of the random variable *X* denoting the total number of comparisons
    performed in all calls to PARTITION. To do so, we must understand when the quicksort
    algorithm compares two elements of the array and when it does not. For ease of
    analysis, let’s index the elements of the array *A* by their position in the sorted
    output, rather than their position in the input. That is, although the elements
    in *A* may start out in any order, we’ll refer to them by *z*[1], *z*[2], … ,
    *z[n]*, where *z*[1] < *z*[2] < ⋯ < *z[n]*, with strict inequality because we
    assume that all elements are distinct. We denote the set {*z[i]*, *z*[*i* + 1],
    … , *z[j]*} by *Z[ij]*.
  prefs: []
  type: TYPE_NORMAL
- en: The next lemma characterizes when two elements are compared.
  prefs: []
  type: TYPE_NORMAL
- en: '***Lemma 7.2***'
  prefs: []
  type: TYPE_NORMAL
- en: During the execution of RANDOMIZED-QUICKSORT on an array of *n* distinct elements
    *z*[1] < *z*[2] < ⋯ < *z[n]*, an element *z[i]* is compared with an element *z[j]*,
    where *i* < *j*, if and only if one of them is chosen as a pivot before any other
    element in the set *Z[ij]*. Moreover, no two elements are ever compared twice.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   Let’s look at the first time that an element *x* ∈ *Z[ij]* is
    chosen as a pivot during the execution of the algorithm. There are three cases
    to consider. If *x* is neither *z[i]* nor *z[j]*—that is, *z[i]* < *x* < *z[j]*—then
    *z[i]* and *z[j]* are not compared at any subsequent time, because they fall into
    different sides of the partition around *x*. If *x* = *z[i]*, then PARTITION compares
    *z[i]* with every other item in *Z[ij]*. Similarly, if *x* = *z[j]*, then PARTITION
    compares *z[j]* with every other item in *Z[ij]*. Thus, *z[i]* and *z[j]* are
    compared if and only if the first element to be chosen as a pivot from *Z[ij]*
    is either *z[i]* or *z[j]*. In the latter two cases, where one of *z[i]* and *z[j]*
    is chosen as a pivot, since the pivot is removed from future comparisons, it is
    never compared again with the other element.'
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example of this lemma, consider an input to quicksort of the numbers
    1 through 10 in some arbitrary order. Suppose that the first pivot element is
    7\. Then the first call to PARTITION separates the numbers into two sets: {1,
    2, 3, 4, 5, 6} and {8, 9, 10}. In the process, the pivot element 7 is compared
    with all other elements, but no number from the first set (e.g., 2) is or ever
    will be compared with any number from the second set (e.g., 9). The values 7 and
    9 are compared because 7 is the first item from *Z*[7,9] to be chosen as a pivot.
    In contrast, 2 and 9 are never compared because the first pivot element chosen
    from *Z*[2,9] is 7.'
  prefs: []
  type: TYPE_NORMAL
- en: The next lemma gives the probability that two elements are compared.
  prefs: []
  type: TYPE_NORMAL
- en: '***Lemma 7.3***'
  prefs: []
  type: TYPE_NORMAL
- en: Consider an execution of the procedure RANDOMIZED-QUICKSORT on an array of *n*
    distinct elements *z*[1] < *z*[2] < ⋯ < *z[n]*. Given two arbitrary elements *z[i]*
    and *z[j]* where *i* < *j*, the probability that they are compared is 2/(*j* –
    *i* + 1).
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   Let’s look at the tree of recursive calls that RANDOMIZED-QUICKSORT
    makes, and consider the sets of elements provided as input to each call. Initially,
    the root set contains all the elements of *Z[ij]*, since the root set contains
    every element in *A*. The elements belonging to *Z[ij]* all stay together for
    each recursive call of RANDOMIZED-QUICKSORT until PARTITION chooses some element
    *x* ∈ *Z[ij]* as a pivot. From that point on, the pivot *x* appears in no subsequent
    input set. The first time that RANDOMIZED-SELECT chooses a pivot *x* ∈ *Z[ij]*
    from a set containing all the elements of *Z[ij]*, each element in *Z[ij]* is
    equally likely to be *x* because the pivot is chosen uniformly at random. Since
    |*Z[ij]*| = *j* – *i* + 1, the probability is 1/(*j* – *i* + 1) that any given
    element in *Z[ij]* is the first pivot chosen from *Z[ij]*. Thus, by Lemma 7.2,
    we have'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pr {*z[i]* is compared with *z[j]*} | = | Pr {*z[i]* or *z[j]* is the first
    pivot chosen from *Z[ij]*} |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | Pr {*z[i]* is the first pivot chosen from *Z[ij]*} |'
  prefs: []
  type: TYPE_TB
- en: '|  |  | + Pr {*z[j]* is the first pivot chosen from *Z[ij]*} |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | ![art](images/Art_P315.jpg), |'
  prefs: []
  type: TYPE_TB
- en: where the second line follows from the first because the two events are mutually
    exclusive.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: We can now complete the analysis of randomized quicksort.
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 7.4***'
  prefs: []
  type: TYPE_NORMAL
- en: The expected running time of RANDOMIZED-QUICKSORT on an input of *n* distinct
    elements is *O*(*n* lg *n*).
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   The analysis uses indicator random variables (see [Section 5.2](chapter005.xhtml#Sec_5.2)).
    Let the *n* distinct elements be *z*[1] < *z*[2] < ⋯ < *z[n]*, and for 1 ≤ *i*
    < *j* ≤ *n*, define the indicator random variable *X[ij]* = I {*z[i]* is compared
    with *z[j]*}. From Lemma 7.2, each pair is compared at most once, and so we can
    express *X* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P316.jpg)'
  prefs: []
  type: TYPE_IMG
- en: By taking expectations of both sides and using linearity of expectation (equation
    (C.24) on page 1192) and Lemma 5.1 on page 130, we obtain
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P317.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can evaluate this sum using a change of variables (*k* = *j* – *i*) and
    the bound on the harmonic series in equation (A.9) on page 1142:'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P318.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This bound and Lemma 7.1 allow us to conclude that the expected running time
    of RANDOMIZED-QUICKSORT is *O*(*n* lg *n*) (assuming that the element values are
    distinct).
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs: []
  type: TYPE_NORMAL
- en: '***7.4-1***'
  prefs: []
  type: TYPE_NORMAL
- en: Show that the recurrence
  prefs: []
  type: TYPE_NORMAL
- en: '*T* (*n*) = max {*T* (*q*) + *T* (*n* – *q* – 1) : 0 ≤ *q* ≤ *n* – 1} + Θ(*n*)'
  prefs: []
  type: TYPE_NORMAL
- en: has a lower bound of *T* (*n*) = Ω (*n*²).
  prefs: []
  type: TYPE_NORMAL
- en: '***7.4-2***'
  prefs: []
  type: TYPE_NORMAL
- en: Show that quicksort’s best-case running time is Ω(*n* lg *n*).
  prefs: []
  type: TYPE_NORMAL
- en: '***7.4-3***'
  prefs: []
  type: TYPE_NORMAL
- en: Show that the expression *q*² + (*n* – *q* – 1)² achieves its maximum value
    over *q* = 0, 1, … , *n* – 1 when *q* = 0 or *q* = *n* – 1.
  prefs: []
  type: TYPE_NORMAL
- en: '***7.4-4***'
  prefs: []
  type: TYPE_NORMAL
- en: Show that RANDOMIZED-QUICKSORT’s expected running time is Ω(*n* lg *n*).
  prefs: []
  type: TYPE_NORMAL
- en: '***7.4-5***'
  prefs: []
  type: TYPE_NORMAL
- en: Coarsening the recursion, as we did in Problem 2-1 for merge sort, is a common
    way to improve the running time of quicksort in practice. We modify the base case
    of the recursion so that if the array has fewer than *k* elements, the subarray
    is sorted by insertion sort, rather than by continued recursive calls to quicksort.
    Argue that the randomized version of this sorting algorithm runs in *O*(*nk* +
    *n* lg(*n*/*k*)) expected time. How should you pick *k*, both in theory and in
    practice?
  prefs: []
  type: TYPE_NORMAL
- en: ★ ***7.4-6***
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider modifying the PARTITION procedure by randomly picking three elements
    from subarray *A*[*p* : *r*] and partitioning about their median (the middle value
    of the three elements). Approximate the probability of getting worse than an *α*-to-(1–*α*)
    split, as a function of *α* in the range 0 < *α* < 1/2.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Problems**'
  prefs: []
  type: TYPE_NORMAL
- en: '***7-1     Hoare partition correctness***'
  prefs: []
  type: TYPE_NORMAL
- en: The version of PARTITION given in this chapter is not the original partitioning
    algorithm. Here is the original partitioning algorithm, which is due to C. A.
    R. Hoare.
  prefs: []
  type: TYPE_NORMAL
- en: HOARE-PARTITION(*A*, *p*, *r*)
  prefs: []
  type: TYPE_NORMAL
- en: '|   1 | *x* = *A*[*p*] |'
  prefs: []
  type: TYPE_TB
- en: '|   2 | *i* = *p* – 1 |'
  prefs: []
  type: TYPE_TB
- en: '|   3 | *j* = *r* + 1 |'
  prefs: []
  type: TYPE_TB
- en: '|   4 | **while** TRUE |'
  prefs: []
  type: TYPE_TB
- en: '|   5 | **repeat** |'
  prefs: []
  type: TYPE_TB
- en: '|   6 | *j* = *j* – 1 |'
  prefs: []
  type: TYPE_TB
- en: '|   7 | **until** *A*[*j*] ≤ *x* |'
  prefs: []
  type: TYPE_TB
- en: '|   8 | **repeat** |'
  prefs: []
  type: TYPE_TB
- en: '|   9 | *i* = *i* + 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 10 | **until** *A*[*i*] ≥ *x* |'
  prefs: []
  type: TYPE_TB
- en: '| 11 | **if** *i* < *j* |'
  prefs: []
  type: TYPE_TB
- en: '| 12 | exchange *A*[*i*] with *A*[*j*] |'
  prefs: []
  type: TYPE_TB
- en: '| 13 | **else return** *j* |'
  prefs: []
  type: TYPE_TB
- en: '***a.*** Demonstrate the operation of HOARE-PARTITION on the array *A* = 〈13,
    19, 9, 5, 12, 8, 7, 4, 11, 2, 6, 21〉, showing the values of the array and the
    indices *i* and *j* after each iteration of the **while** loop in lines 4–13.'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** Describe how the PARTITION procedure in [Section 7.1](chapter007.xhtml#Sec_7.1)
    differs from HOARE-PARTITION when all elements in *A*[*p* : *r*] are equal. Describe
    a practical advantage of HOARE-PARTITION over PARTITION for use in quicksort.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next three questions ask you to give a careful argument that the procedure
    HOARE-PARTITION is correct. Assuming that the subarray *A*[*p* : *r*] contains
    at least two elements, prove the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '***c.*** The indices *i* and *j* are such that the procedure never accesses
    an element of *A* outside the subarray *A*[*p* : *r*].'
  prefs: []
  type: TYPE_NORMAL
- en: '***d.*** When HOARE-PARTITION terminates, it returns a value *j* such that
    *p* ≤ *j* < *r*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***e.*** Every element of *A*[*p* : *j*] is less than or equal to every element
    of *A*[*j* + 1 : *r*] when HOARE-PARTITION terminates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The PARTITION procedure in [Section 7.1](chapter007.xhtml#Sec_7.1) separates
    the pivot value (originally in *A*[*r*]) from the two partitions it forms. The
    HOARE-PARTITION procedure, on the other hand, always places the pivot value (originally
    in *A*[*p*]) into one of the two partitions *A*[*p* : *j*] and *A*[*j* + 1 : *r*].
    Since *p* ≤ *j* < *r*, neither partition is empty.'
  prefs: []
  type: TYPE_NORMAL
- en: '***f.*** Rewrite the QUICKSORT procedure to use HOARE-PARTITION.'
  prefs: []
  type: TYPE_NORMAL
- en: '***7-2     Quicksort with equal element values***'
  prefs: []
  type: TYPE_NORMAL
- en: The analysis of the expected running time of randomized quicksort in [Section
    7.4.2](chapter007.xhtml#Sec_7.4.2) assumes that all element values are distinct.
    This problem examines what happens when they are not.
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** Suppose that all element values are equal. What is randomized quicksort’s
    running time in this case?'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** The PARTITION procedure returns an index *q* such that each element
    of *A*[*p* : *q* – 1] is less than or equal to *A*[*q*] and each element of *A*[*q*
    + 1 : *r*] is greater than *A*[*q*]. Modify the PARTITION procedure to produce
    a procedure PARTITION′ (*A*, *p*, *r*), which permutes the elements of *A*[*p*
    : *r*] and returns two indices *q* and *t*, where *p* ≤ *q* ≤ *t* ≤ *r*, such
    that'
  prefs: []
  type: TYPE_NORMAL
- en: 'all elements of *A*[*q* : *t*] are equal,'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'each element of *A*[*p* : *q* – 1] is less than *A*[*q*], and'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'each element of *A*[*t* + 1 : *r*] is greater than *A*[*q*].'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like PARTITION, your PARTITION′ procedure should take Θ(*r* – *p*) time.
  prefs: []
  type: TYPE_NORMAL
- en: '***c.*** Modify the RANDOMIZED-PARTITION procedure to call PARTITION′, and
    name the new procedure RANDOMIZED-PARTITION′. Then modify the QUICKSORT procedure
    to produce a procedure QUICKSORT′ (*A*, *p*, *r*) that calls RANDOMIZED-PARTITION′
    and recurses only on partitions where elements are not known to be equal to each
    other.'
  prefs: []
  type: TYPE_NORMAL
- en: '***d.*** Using QUICKSORT′, adjust the analysis in [Section 7.4.2](chapter007.xhtml#Sec_7.4.2)
    to avoid the assumption that all elements are distinct.'
  prefs: []
  type: TYPE_NORMAL
- en: '***7-3     Alternative quicksort analysis***'
  prefs: []
  type: TYPE_NORMAL
- en: An alternative analysis of the running time of randomized quicksort focuses
    on the expected running time of each individual recursive call to RANDOMIZED-QUICKSORT,
    rather than on the number of comparisons performed. As in the analysis of [Section
    7.4.2](chapter007.xhtml#Sec_7.4.2), assume that the values of the elements are
    distinct.
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** Argue that, given an array of size *n*, the probability that any particular
    element is chosen as the pivot is 1/*n*. Use this probability to define indicator
    random variables *X[i]* = I {*i*th smallest element is chosen as the pivot}. What
    is E [*X[i]*]?'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** Let *T* (*n*) be a random variable denoting the running time of quicksort
    on an array of size *n*. Argue that'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P319.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '***c.*** Show how to rewrite equation (7.2) as'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P320.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '***d.*** Show that'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P321.jpg)'
  prefs: []
  type: TYPE_IMG
- en: for *n* ≥ 2\. (*Hint:* Split the summation into two parts, one summation for
    *q* = 1, 2, … , ⌈*n*/2⌉ – 1 and one summation for *q* = ⌈*n*/2⌉ , … , *n* – 1.)
  prefs: []
  type: TYPE_NORMAL
- en: '***e.*** Using the bound from equation (7.4), show that the recurrence in equation
    (7.3) has the solution E [*T* (*n*)] = *O*(*n* lg *n*). (*Hint:* Show, by substitution,
    that E [*T* (*n*)] ≤ *an* lg *n* for sufficiently large *n* and for some positive
    constant *a*.)'
  prefs: []
  type: TYPE_NORMAL
- en: '***7-4     Stooge sort***'
  prefs: []
  type: TYPE_NORMAL
- en: Professors Howard, Fine, and Howard have proposed a deceptively simple sorting
    algorithm, named stooge sort in their honor, appearing on the following page.
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** Argue that the call STOOGE-SORT(*A*, 1, *n*) correctly sorts the array
    *A*[1 : *n*].'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** Give a recurrence for the worst-case running time of STOOGE-SORT and
    a tight asymptotic (Θ-notation) bound on the worst-case running time.'
  prefs: []
  type: TYPE_NORMAL
- en: '***c.*** Compare the worst-case running time of STOOGE-SORT with that of insertion
    sort, merge sort, heapsort, and quicksort. Do the professors deserve tenure?'
  prefs: []
  type: TYPE_NORMAL
- en: STOOGE-SORT(*A*, *p*, *r*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | **if** *A*[*p*] > *A*[*r*] |  |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | exchange *A*[*p*] with *A*[*r*] |  |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | **if** *p* + 1 < *r* |  |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | *k* = ⌊(*r* – *p* + 1)/3⌋ | **//** round down |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | STOOGE-SORT(*A*, *p*, *r* – *k*) | **//** first two-thirds |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | STOOGE-SORT(*A*, *p* + *k*, *r*) | **//** last two-thirds |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | STOOGE-SORT(*A*, *p*, *r* – *k*) | **//** first two-thirds again |'
  prefs: []
  type: TYPE_TB
- en: '***7-5 Stack depth for quicksort***'
  prefs: []
  type: TYPE_NORMAL
- en: The QUICKSORT procedure of [Section 7.1](chapter007.xhtml#Sec_7.1) makes two
    recursive calls to itself. After QUICKSORT calls PARTITION, it recursively sorts
    the low side of the partition and then it recursively sorts the high side of the
    partition. The second recursive call in QUICKSORT is not really necessary, because
    the procedure can instead use an iterative control structure. This transformation
    technique, called ***tail-recursion elimination***, is provided automatically
    by good compilers. Applying tail-recursion elimination transforms QUICKSORT into
    the TRE-QUICKSORT procedure.
  prefs: []
  type: TYPE_NORMAL
- en: TRE-QUICKSORT(*A*, *p*, *r*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | **while** *p* < *r* |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | **//** Partition and then sort the low side. |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | *q* = PARTITION(*A*, *p*, *r*) |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | TRE-QUICKSORT(*A*, *p*, *q* – 1) |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | *p* = *q* + 1 |'
  prefs: []
  type: TYPE_TB
- en: '***a.*** Argue that TRE-QUICKSORT(*A*, 1, *n*) correctly sorts the array *A*[1
    : *n*].'
  prefs: []
  type: TYPE_NORMAL
- en: Compilers usually execute recursive procedures by using a ***stack*** that contains
    pertinent information, including the parameter values, for each recursive call.
    The information for the most recent call is at the top of the stack, and the information
    for the initial call is at the bottom. When a procedure is called, its information
    is ***pushed*** onto the stack, and when it terminates, its information is ***popped***.
    Since we assume that array parameters are represented by pointers, the information
    for each procedure call on the stack requires *O*(1) stack space. The ***stack
    depth*** is the maximum amount of stack space used at any time during a computation.
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** Describe a scenario in which TRE-QUICKSORT’s stack depth is Θ(*n*)
    on an *n*-element input array.'
  prefs: []
  type: TYPE_NORMAL
- en: '***c.*** Modify TRE-QUICKSORT so that the worst-case stack depth is Θ(lg *n*).
    Maintain the *O*(*n* lg *n*) expected running time of the algorithm.'
  prefs: []
  type: TYPE_NORMAL
- en: '***7-6     Median-of-3 partition***'
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to improve the RANDOMIZED-QUICKSORT procedure is to partition around
    a pivot that is chosen more carefully than by picking a random element from the
    subarray. A common approach is the ***median-of-3*** method: choose the pivot
    as the median (middle element) of a set of 3 elements randomly selected from the
    subarray. (See Exercise 7.4-6.) For this problem, assume that the *n* elements
    in the input subarray *A*[*p* : *r*] are distinct and that *n* ≥ 3\. Denote the
    sorted version of *A*[*p* : *r*] by *z*[1], *z*[2], … , *z[n]*. Using the median-of-3
    method to choose the pivot element *x*, define *p[i]* = Pr {*x* = *z[i]*}.'
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** Give an exact formula for *p[i]* as a function of *n* and *i* for
    *i* = 2, 3, … , *n* – 1\. (Observe that *p*[1] = *p[n]* = 0.)'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** By what amount does the median-of-3 method increase the likelihood
    of choosing the pivot to be *x* = *z*[⌊(*n* + 1)/2⌋], the median of *A*[*p* :
    *r*], compared with the ordinary implementation? Assume that *n* → ∞, and give
    the limiting ratio of these probabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: '***c.*** Suppose that we define a “good” split to mean choosing the pivot as
    *x* = *z[i]*, where *n*/3 ≤ *i* ≤ 2*n*/3\. By what amount does the median-of-3
    method increase the likelihood of getting a good split compared with the ordinary
    implementation? (*Hint:* Approximate the sum by an integral.)'
  prefs: []
  type: TYPE_NORMAL
- en: '***d.*** Argue that in the Ω(*n* lg *n*) running time of quicksort, the median-of-3
    method affects only the constant factor.'
  prefs: []
  type: TYPE_NORMAL
- en: '***7-7     Fuzzy sorting of intervals***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a sorting problem in which you do not know the numbers exactly. Instead,
    for each number, you know an interval on the real line to which it belongs. That
    is, you are given *n* closed intervals of the form [*a[i]*, *b[i]*], where *a[i]*
    ≤ *b[i]*. The goal is to ***fuzzy-sort*** these intervals: to produce a permutation
    〈*i*[1], *i*[2], … , *i[n]*〉 of the intervals such that for *j* = 1, 2, … , *n*,
    there exist ![art](images/Art_P322.jpg) satisfying *c*[1] ≤ *c*[2] ≤ ⋯ ≤ *c[n]*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** Design a randomized algorithm for fuzzy-sorting *n* intervals. Your
    algorithm should have the general structure of an algorithm that quicksorts the
    left endpoints (the *a[i]* values), but it should take advantage of overlapping
    intervals to improve the running time. (As the intervals overlap more and more,
    the problem of fuzzy-sorting the intervals becomes progressively easier. Your
    algorithm should take advantage of such overlapping, to the extent that it exists.)'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** Argue that your algorithm runs in Θ(*n* lg *n*) expected time in general,
    but runs in Θ(*n*) expected time when all of the intervals overlap (i.e., when
    there exists a value *x* such that *x* ∈ [*a[i]*, *b[i]*] for all *i*). Your algorithm
    should not be checking for this case explicitly, but rather, its performance should
    naturally improve as the amount of overlap increases.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter notes**'
  prefs: []
  type: TYPE_NORMAL
- en: Quicksort was invented by Hoare [[219](bibliography001.xhtml#endnote_219)],
    and his version of PARTITION appears in Problem 7-1\. Bentley [[51](bibliography001.xhtml#endnote_51),
    p. 117] attributes the PARTITION procedure given in [Section 7.1](chapter007.xhtml#Sec_7.1)
    to N. Lomuto. The analysis in [Section 7.4](chapter007.xhtml#Sec_7.4) based on
    an analysis due to Motwani and Raghavan [[336](bibliography001.xhtml#endnote_336)].
    Sedgewick [[401](bibliography001.xhtml#endnote_401)] and Bentley [[51](bibliography001.xhtml#endnote_51)]
    provide good references on the details of implementation and how they matter.
  prefs: []
  type: TYPE_NORMAL
- en: McIlroy [[323](bibliography001.xhtml#endnote_323)] shows how to engineer a “killer
    adversary” that produces an array on which virtually any implementation of quicksort
    takes Θ(*n*²) time.
  prefs: []
  type: TYPE_NORMAL
- en: '[¹](#footnote_ref_1) You can enforce the assumption that the values in an array
    *A* are distinct at the cost of Θ(*n*) additional space and only constant overhead
    in running time by converting each input value *A*[*i*] to an ordered pair (*A*[*i*],
    *i*) with (*A*[*i*], *i*) < (*A*[*j*], *j*) if *A*[*i*] < *A*[*j*] or if *A*[*i*]
    = *A*[*j*] and *i* < *j*. There are also more practical variants of quicksort
    that work well when elements are not distinct.'
  prefs: []
  type: TYPE_NORMAL
