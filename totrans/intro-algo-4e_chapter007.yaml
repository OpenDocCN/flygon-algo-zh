- en: '[**7          Quicksort**](toc.xhtml#chap-7)'
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: '[**7          快速排序**](toc.xhtml#chap-7)'
- en: 'The quicksort algorithm has a worst-case running time of Θ(*n*²) on an input
    array of *n* numbers. Despite this slow worst-case running time, quicksort is
    often the best practical choice for sorting because it is remarkably efficient
    on average: its expected running time is Θ(*n* lg *n*) when all numbers are distinct,
    and the constant factors hidden in the Θ(*n* lg *n*) notation are small. Unlike
    merge sort, it also has the advantage of sorting in place (see page 158), and
    it works well even in virtual-memory environments.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序算法在*n*个数字的输入数组上具有Θ(*n*²)的最坏情况运行时间。尽管最坏情况下运行时间较慢，但快速排序通常是排序的最佳实际选择，因为其平均效率非常高：当所有数字都不同时，其期望运行时间为Θ(*n*
    lg *n*)，Θ(*n* lg *n*)符号中隐藏的常数因子很小。与归并排序不同，它还具有原地排序的优势（参见第158页），即使在虚拟内存环境中也能很好地工作。
- en: Our study of quicksort is broken into four sections. [Section 7.1](chapter007.xhtml#Sec_7.1)
    describes the algorithm and an important subroutine used by quicksort for partitioning.
    Because the behavior of quicksort is complex, we’ll start with an intuitive discussion
    of its performance in [Section 7.2](chapter007.xhtml#Sec_7.2) and analyze it precisely
    at the end of the chapter. [Section 7.3](chapter007.xhtml#Sec_7.3) presents a
    randomized version of quicksort. When all elements are distinct,^([1](#footnote_1))
    this randomized algorithm has a good expected running time and no particular input
    elicits its worst-case behavior. (See Problem 7-2 for the case in which elements
    may be equal.) [Section 7.4](chapter007.xhtml#Sec_7.4) analyzes the randomized
    algorithm, showing that it runs in Θ(*n*²) time in the worst case and, assuming
    distinct elements, in expected *O*(*n* lg *n*) time.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对快速排序的研究分为四个部分。[第7.1节](chapter007.xhtml#Sec_7.1)描述了算法以及快速排序用于分区的重要子例程。由于快速排序的行为复杂，我们将从直观讨论其性能开始，[第7.2节](chapter007.xhtml#Sec_7.2)在章节末尾精确分析。[第7.3节](chapter007.xhtml#Sec_7.3)介绍了快速排序的随机版本。当所有元素都不相同时，^([1](#footnote_1))
    这种随机算法具有良好的期望运行时间，并且没有特定输入会引发其最坏情况。 （查看问题7-2，了解元素可能相等的情况。）[第7.4节](chapter007.xhtml#Sec_7.4)分析了随机算法，表明在最坏情况下运行时间为Θ(*n*²)，假设元素不同，则期望运行时间为*O*(*n*
    lg *n*)。
- en: '[**7.1      Description of quicksort**](toc.xhtml#Rh1-39)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[**7.1      快速排序描述**](toc.xhtml#Rh1-39)'
- en: 'Quicksort, like merge sort, applies the divide-and-conquer method introduced
    in [Section 2.3.1](chapter002.xhtml#Sec_2.3.1). Here is the three-step divide-and-conquer
    process for sorting a subarray *A*[*p* : *r*]:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: '快速排序，类似于归并排序，应用了[第2.3.1节](chapter002.xhtml#Sec_2.3.1)介绍的分治方法。以下是对子数组*A*[*p*
    : *r*]进行排序的三步分治过程：'
- en: '**Divide** by partitioning (rearranging) the array *A*[*p* : *r*] into two
    (possibly empty) subarrays *A*[*p* : *q* – 1] (the ***low side***) and *A*[*q*
    + 1 : *r*] (the ***high side***) such that each element in the low side of the
    partition is less than or equal to the ***pivot*** *A*[*q*], which is, in turn,
    less than or equal to each element in the high side. Compute the index *q* of
    the pivot as part of this partitioning procedure.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: '**划分** 通过将数组*A*[*p* : *r*]分割（重新排列）为两个（可能为空）子数组*A*[*p* : *q* – 1]（***低侧***）和*A*[*q*
    + 1 : *r*]（***高侧***），使得分区的低侧中的每个元素都小于或等于中轴元素*A*[*q*]，中轴元素又小于或等于高侧中的每个元素。作为此划分过程的一部分计算中轴元素的索引*q*。'
- en: '**Conquer** by calling quicksort recursively to sort each of the subarrays
    *A*[*p* : *q* – 1] and *A*[*q* + 1 : *r*].'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**征服** 通过递归调用quicksort对子数组*A*[*p* : *q* – 1]和*A*[*q* + 1 : *r*]进行排序。'
- en: '**Combine** by doing nothing: because the two subarrays are already sorted,
    no work is needed to combine them. All elements in *A*[*p* : *q* – 1] are sorted
    and less than or equal to *A*[*q*], and all elements in *A*[*q* + 1 : *r*] are
    sorted and greater than or equal to the pivot *A*[*q*]. The entire subarray *A*[*p*
    : *r*] cannot help but be sorted!'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: '**合并** 什么也不做：因为两个子数组已经排序，不需要任何工作来合并它们。 *A*[*p* : *q* – 1]中的所有元素都已排序且小于或等于*A*[*q*]，*A*[*q*
    + 1 : *r*]中的所有元素都已排序且大于或等于中轴元素*A*[*q*]。整个子数组*A*[*p* : *r*]不可能不排序！'
- en: 'The QUICKSORT procedure implements quicksort. To sort an entire *n*-element
    array *A*[1 : *n*], the initial call is QUICKSORT (*A*, 1, *n*).'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 'QUICKSORT过程实现了快速排序。要对整个*n*元素数组*A*[1 : *n*]进行排序，初始调用是QUICKSORT (*A*, 1, *n*)。'
- en: QUICKSORT(*A*, *p*, *r*)
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: QUICKSORT(*A*, *p*, *r*)
- en: '| 1 | **if** *p* < *r* |'
  id: totrans-10
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **if** *p* < *r* |'
- en: '| 2 | **//** Partition the subarray around the pivot, which ends up in *A*[*q*].
    |'
  id: totrans-11
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **//** 围绕中轴元素对子数组进行分区，中轴元素最终位于*A*[*q*]处。 |'
- en: '| 3 | *q* = PARTITION(*A*, *p*, *r*) |'
  id: totrans-12
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *q* = PARTITION(*A*, *p*, *r*) |'
- en: '| 4 | QUICKSORT(*A*, *p*, *q* – 1) | **//** recursively sort the low side |'
  id: totrans-13
  prefs: []
  type: TYPE_TB
  zh: '| 4 | QUICKSORT(*A*, *p*, *q* – 1) | **//** 递归排序低侧 |'
- en: '| 5 | QUICKSORT(*A*, *q* + 1, *r*) | **//** recursively sort the high side
    |'
  id: totrans-14
  prefs: []
  type: TYPE_TB
  zh: '| 5 | QUICKSORT(*A*, *q* + 1, *r*) | **//** 递归排序高侧 |'
- en: '**Partitioning the array**'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '**数组的划分**'
- en: 'The key to the algorithm is the PARTITION procedure on the next page, which
    rearranges the subarray *A*[*p* : *r*] in place, returning the index of the dividing
    point between the two sides of the partition.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '算法的关键在于下一页的PARTITION过程，它在原地重新排列子数组*A*[*p* : *r*]，返回分区两侧之间的分界点的索引。'
- en: '[Figure 7.1](chapter007.xhtml#Fig_7-1) shows how PARTITION works on an 8-element
    array. PARTITION always selects the element *x* = *A*[*r*] as the pivot. As the
    procedure runs, each element falls into exactly one of four regions, some of which
    may be empty. At the start of each iteration of the **for** loop in lines 3–6,
    the regions satisfy certain properties, shown in [Figure 7.2](chapter007.xhtml#Fig_7-2).
    We state these properties as a loop invariant:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '[图7.1](chapter007.xhtml#Fig_7-1)展示了PARTITION在一个8元素数组上的工作方式。PARTITION总是选择元素*x*
    = *A*[*r*]作为中轴元素。随着过程的运行，每个元素都会落入四个区域中的一个，其中一些可能为空。在行3-6的**for**循环的每次迭代开始时，区域满足某些属性，如[图7.2](chapter007.xhtml#Fig_7-2)所示。我们将这些属性陈述为循环不变式：'
- en: PARTITION(*A*, *p*, *r*)
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: PARTITION(*A*, *p*, *r*)
- en: '| 1 | *x* = *A*[*r*] | **//** the pivot |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *x* = *A*[*r*] | **//** 中轴元素 |'
- en: '| 2 | *i* = *p* – 1 | **//** highest index into the low side |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *i* = *p* – 1 | **//** 低侧的最高索引 |'
- en: '| 3 | **for** *j* = *p* **to** *r* – 1 | **//** process each element other
    than the pivot |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **对于** *j* = *p* **到** *r* - 1 | **//** 处理除枢轴之外的每个元素 |'
- en: '| 4 | **if** *A*[*j*] ≤ *x* | **//** does this element belong on the low side?
    |'
  id: totrans-22
  prefs: []
  type: TYPE_TB
  zh: '| 4 | **如果** *A*[*j*] ≤ *x* | **//** 此元素应属于低侧吗？ |'
- en: '| 5 | *i* = *i* + 1 | **//** index of a new slot in the low side |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| 5 | *i* = *i* + 1 | **//** 低侧的新槽位索引 |'
- en: '| 6 | exchange *A*[*i*] with *A*[*j*] | **//** put this element there |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| 6 | 交换*A*[*i*]和*A*[*j*] | **//** 将此元素放在那里 |'
- en: '| 7 | exchange *A*[*i* + 1] with *A*[*r*] | **//** pivot goes just to the right
    of the low side |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| 7 | 交换*A*[*i* + 1]和*A*[*r*] | **//** 枢轴刚好在低侧右侧 |'
- en: '| 8 | **return** *i* + 1 | **//** new index of the pivot |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| 8 | **返回** *i* + 1 | **//** 枢轴的新索引 |'
- en: 'At the beginning of each iteration of the loop of lines 3–6, for any array
    index *k*, the following conditions hold:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环的第3-6行的每次迭代开始时，对于任意数组索引*k*，以下条件成立：
- en: if *p* ≤ *k* ≤ *i*, then *A*[*k*] ≤ *x* (the tan region of [Figure 7.2](chapter007.xhtml#Fig_7-2));
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*p* ≤ *k* ≤ *i*，则*A*[*k*] ≤ *x*（[图7.2](chapter007.xhtml#Fig_7-2)的棕色区域）；
- en: if *i* + 1 ≤ *k* ≤ *j* – 1, then *A*[*k*] > *x* (the blue region);
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*i* + 1 ≤ *k* ≤ *j* - 1，则*A*[*k*] > *x*（蓝色区域）；
- en: if *k* = *r*, then *A*[*k*] = *x* (the yellow region).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果*k* = *r*，则*A*[*k*] = *x*（黄色区域）。
- en: We need to show that this loop invariant is true prior to the first iteration,
    that each iteration of the loop maintains the invariant, that the loop terminates,
    and that correctness follows from the invariant when the loop terminates.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要展示这个循环不变式在第一次迭代之前是正确的，每次循环迭代都保持不变式，循环终止，并且在循环终止时，正确性遵循不变式。
- en: '**Initialization:** Prior to the first iteration of the loop, we have *i* =
    *p* – 1 and *j* = *p*. Because no values lie between *p* and *i* and no values
    lie between *i* + 1 and *j* – 1, the first two conditions of the loop invariant
    are trivially satisfied. The assignment in line 1 satisfies the third condition.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '**初始化：** 在循环的第一次迭代之前，我们有*i* = *p* - 1和*j* = *p*。因为*p*和*i*之间没有值，*i* + 1和*j*
    - 1之间也没有值，循环不变式的前两个条件显然成立。第1行的赋值满足第三个条件。'
- en: '**Maintenance:** As [Figure 7.3](chapter007.xhtml#Fig_7-3) shows, we consider
    two cases, depending on the outcome of the test in line 4\. [Figure 7.3(a)](chapter007.xhtml#Fig_7-3)
    shows what happens when *A*[*j*] > *x*: the only action in the loop is to increment
    *j*. After *j* has been incremented, the second condition holds for *A*[*j* –
    1] and all other entries remain unchanged. [Figure 7.3(b)](chapter007.xhtml#Fig_7-3)
    shows what happens when *A*[*j*] ≤ *x*: the loop increments *i*, swaps *A*[*i*]
    and *A*[*j*], and then increments *j*. Because of the swap, we now have that *A*[*i*]
    ≤ *x*, and condition 1 is satisfied. Similarly, we also have that *A*[*j* – 1]
    > *x*, since the item that was swapped into *A*[*j* – 1] is, by the loop invariant,
    greater than *x*.'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**维护：** 如[图7.3](chapter007.xhtml#Fig_7-3)所示，我们考虑两种情况，取决于第4行测试的结果。[图7.3(a)](chapter007.xhtml#Fig_7-3)展示了当*A*[*j*]
    > *x*时会发生什么：循环中的唯一操作是增加*j*。增加*j*后，第二个条件对*A*[*j* - 1]成立，所有其他条目保持不变。[图7.3(b)](chapter007.xhtml#Fig_7-3)展示了当*A*[*j*]
    ≤ *x*时会发生什么：循环增加*i*，交换*A*[*i*]和*A*[*j*]，然后增加*j*。由于交换，现在有*A*[*i*] ≤ *x*，满足条件1。同样，我们也有*A*[*j*
    - 1] > *x*，因为根据循环不变式，交换到*A*[*j* - 1]的项大于*x*。'
- en: '**Termination:** Since the loop makes exactly *r* – *p* iterations, it terminates,
    whereupon *j* = *r*. At that point, the unexamined subarray *A*[*j* : *r* – 1]
    is empty, and every entry in the array belongs to one of the other three sets
    described by the invariant. Thus, the values in the array have been partitioned
    into three sets: those less than or equal to *x* (the low side), those greater
    than *x* (the high side), and a singleton set containing *x* (the pivot).'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**终止条件：** 由于循环恰好进行*r* - *p*次迭代，循环终止时，*j* = *r*。此时，未经检查的子数组*A*[*j* : *r* - 1]为空，数组中的每个条目都属于不变式描述的其他三个集合中的一个。因此，数组中的值被分成三组：小于或等于*x*的值（低侧）、大于*x*的值（高侧）和包含*x*的单元素集（枢轴）。'
- en: '![art](images/Art_P309.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P309.jpg)'
- en: '**Figure 7.1** The operation of PARTITION on a sample array. Array entry *A*[*r*]
    becomes the pivot element *x*. Tan array elements all belong to the low side of
    the partition, with values at most *x*. Blue elements belong to the high side,
    with values greater than *x*. White elements have not yet been put into either
    side of the partition, and the yellow element is the pivot *x*. **(a)** The initial
    array and variable settings. None of the elements have been placed into either
    side of the partition. **(b)** The value 2 is “swapped with itself” and put into
    the low side. **(c)–(d)** The values 8 and 7 are placed into to high side. **(e)**
    The values 1 and 8 are swapped, and the low side grows. **(f)** The values 3 and
    7 are swapped, and the low side grows. **(g)–(h)** The high side of the partition
    grows to include 5 and 6, and the loop terminates. **(i)** Line 7 swaps the pivot
    element so that it lies between the two sides of the partition, and line 8 returns
    the pivot’s new index.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.1** PARTITION在示例数组上的操作。数组条目*A*[*r*]变为枢轴元素*x*。棕色数组元素都属于分区的低侧，值最多为*x*。蓝色元素属于高侧，值大于*x*。白色元素尚未放入分区的任一侧，黄色元素是枢轴*x*。**(a)**
    初始数组和变量设置。没有元素被放入分区的任一侧。**(b)** 值为2被“与自身交换”并放入低侧。**(c)-(d)** 值8和7被放入高侧。**(e)**
    值1和8被交换，低侧增长。**(f)** 值3和7被交换，低侧增长。**(g)-(h)** 分区的高侧增长以包括5和6，并且循环终止。**(i)** 第7行交换枢轴元素，使其位于分区的两侧之间，第8行返回枢轴的新索引。'
- en: 'The final two lines of PARTITION finish up by swapping the pivot with the leftmost
    element greater than *x*, thereby moving the pivot into its correct place in the
    partitioned array, and then returning the pivot’s new index. The output of PARTITION
    now satisfies the specifications given for the divide step. In fact, it satisfies
    a slightly stronger condition: after line 3 of QUICKSORT, *A*[*q*] is strictly
    less than every element of *A*[*q* + 1 : *r*].'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 'PARTITION 的最后两行通过将枢纽与大于 *x* 的最左元素交换完成，从而将枢纽移动到分区数组的正确位置，然后返回枢纽的新索引。PARTITION
    的输出现在满足了分割步骤的规定。事实上，它满足了一个稍微更强的条件：在 QUICKSORT 的第3行之后，*A*[*q*] 严格小于 *A*[*q* + 1
    : *r*] 的每个元素。'
- en: '![art](images/Art_P310.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P310.jpg)'
- en: '**Figure 7.2** The four regions maintained by the procedure PARTITION on a
    subarray *A*[*p* : *r*]. The tan values in *A*[*p* : *i*] are all less than or
    equal to *x*, the blue values in *A*[*i* + 1 : *j* – 1] are all greater than *x*,
    the white values in *A*[*j* : *r* – 1] have unknown relationships to *x*, and
    *A*[*r*] = *x*.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.2** 过程 PARTITION 在子数组 *A*[*p* : *r*] 上维护的四个区域。*A*[*p* : *i*] 中的棕色值都小于或等于
    *x*，*A*[*i* + 1 : *j* – 1] 中的蓝色值都大于 *x*，*A*[*j* : *r* – 1] 中的白色值与 *x* 的关系未知，而
    *A*[*r*] = *x*。'
- en: '![art](images/Art_P311.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P311.jpg)'
- en: '**Figure 7.3** The two cases for one iteration of procedure PARTITION. **(a)**
    If *A*[*j*] > *x*, the only action is to increment *j*, which maintains the loop
    invariant. **(b)** If *A*[*j*] ≤ *x*, index *i* is incremented, *A*[*i*] and *A*[*j*]
    are swapped, and then *j* is incremented. Again, the loop invariant is maintained.'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.3** 过程 PARTITION 的一次迭代的两种情况。**(a)** 如果 *A*[*j*] > *x*，则唯一的操作是增加 *j*，这保持了循环不变性。**(b)**
    如果 *A*[*j*] ≤ *x*，则增加索引 *i*，交换 *A*[*i*] 和 *A*[*j*]，然后增加 *j*。同样，循环不变性得以保持。'
- en: 'Exercise 7.1-3 asks you to show that the running time of PARTITION on a subarray
    *A*[*p* : *r*] of *n* = *r* – *p* + 1 elements is Θ(*n*).'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '练习 7.1-3 要求您展示在由 *n* = *r* – *p* + 1 个元素组成的子数组 *A*[*p* : *r*] 上的 PARTITION
    的运行时间是 Θ(*n*)。'
- en: '**Exercises**'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***7.1-1***'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.1-1***'
- en: Using [Figure 7.1](chapter007.xhtml#Fig_7-1) as a model, illustrate the operation
    of PARTITION on the array *A* = 〈13, 19, 9, 5, 12, 8, 7, 4, 21, 2, 6, 11〉.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 [图 7.1](chapter007.xhtml#Fig_7-1) 作为模型，说明在数组 *A* = 〈13, 19, 9, 5, 12, 8,
    7, 4, 21, 2, 6, 11〉 上的 PARTITION 操作。
- en: '***7.1-2***'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.1-2***'
- en: 'What value of *q* does PARTITION return when all elements in the subarray *A*[*p*
    : *r*] have the same value? Modify PARTITION so that *q* = ⌊(*p* + *r*)/2⌋ when
    all elements in the subarray *A*[*p* : *r*] have the same value.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '当子数组 *A*[*p* : *r*] 中的所有元素具有相同值时，PARTITION 返回什么值？修改 PARTITION，使得当子数组 *A*[*p*
    : *r*] 中的所有元素具有相同值时，*q* = ⌊(*p* + *r*)/2⌋。'
- en: '***7.1-3***'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.1-3***'
- en: Give a brief argument that the running time of PARTITION on a subarray of size
    *n* is Θ(*n*).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 简要说明 PARTITION 在大小为 *n* 的子数组上的运行时间是 Θ(*n*)。
- en: '***7.1-4***'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.1-4***'
- en: Modify QUICKSORT to sort into monotonically decreasing order.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 修改 QUICKSORT 以按单调递减顺序排序。
- en: '[**7.2      Performance of quicksort**](toc.xhtml#Rh1-40)'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '[**7.2      快速排序的性能**](toc.xhtml#Rh1-40)'
- en: The running time of quicksort depends on how balanced each partitioning is,
    which in turn depends on which elements are used as pivots. If the two sides of
    a partition are about the same size—the partitioning is balanced—then the algorithm
    runs asymptotically as fast as merge sort. If the partitioning is unbalanced,
    however, it can run asymptotically as slowly as insertion sort. To allow you to
    gain some intuition before diving into a formal analysis, this section informally
    investigates how quicksort performs under the assumptions of balanced versus unbalanced
    partitioning.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序的运行时间取决于每个分区的平衡程度，而这又取决于哪些元素被用作枢轴。如果一个分区的两侧大小大致相同——分区是平衡的——那么算法的运行速度会随着合并排序一样快。然而，如果分区不平衡，它的运行速度可能会与插入排序一样慢。为了让您在深入进行正式分析之前获得一些直觉，本节非正式地探讨了在平衡与不平衡分区假设下快速排序的性能。
- en: But first, let’s briefly look at the maximum amount of memory that quicksort
    requires. Although quicksort sorts in place according to the definition on page
    158, the amount of memory it uses—aside from the array being sorted—is not constant.
    Since each recursive call requires a constant amount of space on the runtime stack,
    outside of the array being sorted, quicksort requires space proportional to the
    maximum depth of the recursion. As we’ll see now, that could be as bad as Θ(*n*)
    in the worst case.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，让我们简要地看一下快速排序需要的最大内存量。尽管快速排序根据第158页的定义就地排序，但它使用的内存量——除了被排序的数组之外——并不是恒定的。由于每个递归调用在运行时栈上需要恒定的空间，除了被排序的数组之外，快速排序需要的空间与递归的最大深度成正比。正如我们现在将看到的那样，在最坏情况下，这可能与
    Θ(*n*) 一样糟糕。
- en: '**Worst-case partitioning**'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**最坏情况的分区**'
- en: The worst-case behavior for quicksort occurs when the partitioning produces
    one subproblem with *n* – 1 elements and one with 0 elements. (See [Section 7.4.1](chapter007.xhtml#Sec_7.4.1).)
    Let us assume that this unbalanced partitioning arises in each recursive call.
    The partitioning costs Θ(*n*) time. Since the recursive call on an array of size
    0 just returns without doing anything, *T* (0) = Θ(1), and the recurrence for
    the running time is
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序的最坏情况发生在分区产生一个具有 *n* – 1 个元素和一个具有 0 个元素的子问题时。（参见[第7.4.1节](chapter007.xhtml#Sec_7.4.1)。）让我们假设在每次递归调用中都会出现这种不平衡的分区。分区的成本为
    Θ(*n*) 时间。由于对大小为 0 的数组的递归调用只是返回而不执行任何操作，*T* (0) = Θ(1)，因此运行时间的递归为
- en: '| *T* (*n*) | = | *T* (*n* – 1) + *T* (0) + Θ(*n*) |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| *T* (*n*) | = | *T* (*n* – 1) + *T* (0) + Θ(*n*) |'
- en: '|  | = | *T* (*n* – 1) + Θ(*n*). |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *T* (*n* – 1) + Θ(*n*). |'
- en: By summing the costs incurred at each level of the recursion, we obtain an arithmetic
    series (equation (A.3) on page 1141), which evaluates to Θ(*n*²). Indeed, the
    substitution method can be used to prove that the recurrence *T* (*n*) = *T* (*n*
    – 1) + Θ(*n*) has the solution *T* (*n*) = Θ(*n*²). (See Exercise 7.2-1.)
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对递归的每个级别产生的成本进行求和，我们得到一个等差数列（第1141页的方程（A.3）），其计算结果为 Θ(*n*²)。事实上，可以使用替换法证明递归
    *T* (*n*) = *T* (*n* – 1) + Θ(*n*) 的解为 *T* (*n*) = Θ(*n*²)。（参见练习 7.2-1。）
- en: Thus, if the partitioning is maximally unbalanced at every recursive level of
    the algorithm, the running time is Θ(*n*²). The worst-case running time of quicksort
    is therefore no better than that of insertion sort. Moreover, the Θ(*n*²) running
    time occurs when the input array is already completely sorted—a situation in which
    insertion sort runs in *O*(*n*) time.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果在算法的每个递归级别上分区是最大程度不平衡的，运行时间为Θ(*n*²)。因此，快速排序的最坏情况运行时间不比插入排序好。此外，当输入数组已完全排序时，Θ(*n*²)的运行时间发生，这种情况下插入排序的运行时间为*O*(*n*)。
- en: '**Best-case partitioning**'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '**最佳情况的分区**'
- en: In the most even possible split, PARTITION produces two subproblems, each of
    size no more than *n*/2, since one is of size ⌊(*n* – 1)/2⌋ ≤ *n*/2 and one of
    size ⌈(*n* – 1)/2⌉ – 1 ≤ *n*/2\. In this case, quicksort runs much faster. An
    upper bound on the running time can then be described by the recurrence
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在最均匀的分割中，PARTITION产生两个大小不超过*n*/2的子问题，因为一个大小为⌊(*n* – 1)/2⌋ ≤ *n*/2，另一个大小为⌈(*n*
    – 1)/2⌉ – 1 ≤ *n*/2。在这种情况下，快速排序运行速度更快。然后，运行时间的上界可以由递归描述为
- en: '*T* (*n*) = 2*T* (*n*/2) + Θ(*n*).'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '*T* (*n*) = 2*T* (*n*/2) + Θ(*n*).'
- en: By case 2 of the master theorem (Theorem 4.1 on page 102), this recurrence has
    the solution *T* (*n*) = Θ(*n* lg *n*). Thus, if the partitioning is equally balanced
    at every level of the recursion, an asymptotically faster algorithm results.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 根据主定理的情况2（第102页的定理4.1），此递归的解为*T* (*n*) = Θ(*n* lg *n*)。因此，如果在递归的每个级别上分区是平衡的，将得到一个渐近更快的算法。
- en: '**Balanced partitioning**'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '**平衡分区**'
- en: As the analyses in [Section 7.4](chapter007.xhtml#Sec_7.4) will show, the average-case
    running time of quicksort is much closer to the best case than to the worst case.
    By appreciating how the balance of the partitioning affects the recurrence describing
    the running time, we can gain an understanding of why.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第7.4节](chapter007.xhtml#Sec_7.4)中的分析将显示，快速排序的平均情况运行时间更接近最佳情况而不是最坏情况。通过理解分区平衡如何影响描述运行时间的递归，我们可以理解为什么。
- en: Suppose, for example, that the partitioning algorithm always produces a 9-to-1
    proportional split, which at first blush seems quite unbalanced. We then obtain
    the recurrence
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设分区算法总是产生9比1的比例分割，乍一看似乎非常不平衡。然后我们得到递归
- en: '*T* (*n*) = *T* (9*n*/10) + *T* (*n*/10) + Θ(*n*),'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '*T* (*n*) = *T* (9*n*/10) + *T* (*n*/10) + Θ(*n*),'
- en: on the running time of quicksort. [Figure 7.4](chapter007.xhtml#Fig_7-4) shows
    the recursion tree for this recurrence, where for simplicity the Θ(*n*) driving
    function has been replaced by *n*, which won’t affect the asymptotic solution
    of the recurrence (as Exercise 4.7-1 on page 118 justifies). Every level of the
    tree has cost *n*, until the recursion bottoms out in a base case at depth log[10] *n*
    = Θ(lg *n*), and then the levels have cost at most *n*. The recursion terminates
    at depth log[10/9] *n* = Θ(lg *n*). Thus, with a 9-to-1 proportional split at
    every level of recursion, which intuitively seems highly unbalanced, quicksort
    runs in *O*(*n* lg *n*) time—asymptotically the same as if the split were right
    down the middle. Indeed, even a 99-to-1 split yields an *O*(*n* lg *n*) running
    time. In fact, any split of *constant* proportionality yields a recursion tree
    of depth Θ(lg *n*), where the cost at each level is *O*(*n*). The running time
    is therefore *O*(*n* lg *n*) whenever the split has constant proportionality.
    The ratio of the split affects only the constant hidden in the *O*-notation.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 对快速排序的运行时间。[图7.4](chapter007.xhtml#Fig_7-4)显示了此递归的递归树，为简单起见，Θ(*n*)驱动函数已被*n*替换，这不会影响递归的渐近解（正如第118页上的练习4.7-1所证明的）。树的每个级别的成本为*n*，直到递归在深度log[10] *n*
    = Θ(lg *n*)处触底，然后每个级别的成本最多为*n*。递归在深度log[10/9] *n* = Θ(lg *n*)处终止。因此，每个递归级别都有9比1的比例分割，直观上看似乎非常不平衡，快速排序的运行时间为*O*(*n*
    lg *n*)—渐近地与分割正好在中间的情况相同。事实上，即使是99比1的分割也会产生*O*(*n* lg *n*)的运行时间。实际上，任何*常数*比例的分割都会产生深度Θ(lg
    *n*)的递归���，其中每个级别的成本为*O*(*n*)。因此，只要分割具有常数比例，运行时间就是*O*(*n* lg *n*)。分割的比例只影响*O*符号中的常数。
- en: '![art](images/Art_P312.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P312.jpg)'
- en: '**Figure 7.4** A recursion tree for QUICKSORT in which PARTITION always produces
    a 9-to-1 split, yielding a running time of *O*(*n* lg *n*). Nodes show subproblem
    sizes, with per-level costs on the right.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '**图7.4** QUICKSORT的递归树，其中PARTITION始终产生9比1的分割，导致运行时间为*O*(*n* lg *n*)。节点显示子问题大小，右侧显示每级成本。'
- en: '**Intuition for the average case**'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '**平均情况的直觉**'
- en: To develop a clear notion of the expected behavior of quicksort, we must assume
    something about how its inputs are distributed. Because quicksort determines the
    sorted order using only comparisons between input elements, its behavior depends
    on the relative ordering of the values in the array elements given as the input,
    not on the particular values in the array. As in the probabilistic analysis of
    the hiring problem in [Section 5.2](chapter005.xhtml#Sec_5.2), assume that all
    permutations of the input numbers are equally likely and that the elements are
    distinct.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 要对快速排序的预期行为有清晰的概念，我们必须假设其输入是如何分布的。因为快速排序仅使用输入元素之间的比较来确定排序顺序，其行为取决于作为输入给出的数组元素中值的相对顺序，而不取决于数组中的特定值。就像在[第5.2节](chapter005.xhtml#Sec_5.2)中对雇佣问题的概率分析一样，假设输入数字的所有排列是等可能的，并且元素是不同的。
- en: When quicksort runs on a random input array, the partitioning is highly unlikely
    to happen in the same way at every level, as our informal analysis has assumed.
    We expect that some of the splits will be reasonably well balanced and that some
    will be fairly unbalanced. For example, Exercise 7.2-6 asks you to show that about
    80% of the time PARTITION produces a split that is at least as balanced as 9 to
    1, and about 20% of the time it produces a split that is less balanced than 9
    to 1.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 当快速排序在随机输入数组上运行时，分区高度不太可能在每个级别以相同方式发生，正如我们的非正式分析所假设的那样。我们预期一些分割将相当平衡，而一些将相当不平衡。例如，练习7.2-6要求您展示PARTITION大约80%的时间产生至少与9比1一样平衡的分割，大约20%的时间产生比9比1更不平衡的分割。
- en: '![art](images/Art_P313.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P313.jpg)'
- en: '**Figure 7.5 (a)** Two levels of a recursion tree for quicksort. The partitioning
    at the root costs *n* and produces a “bad” split: two subarrays of sizes 0 and
    *n* – 1\. The partitioning of the subarray of size *n* – 1 costs *n* – 1 and produces
    a “good” split: subarrays of size (*n* – 1)/2 – 1 and (*n* – 1)/2\. **(b)** A
    single level of a recursion tree that is well balanced. In both parts, the partitioning
    cost for the subproblems shown with blue shading is Θ(*n*). Yet the subproblems
    remaining to be solved in (a), shown with tan shading, are no larger than the
    corresponding subproblems remaining to be solved in (b).'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '**图 7.5（a）** 快速排序递归树的两个层级。根节点的分区成本为 *n*，产生了一个“坏”分割：两个大小为 0 和 *n* – 1 的子数组。大小为
    *n* – 1 的子数组的分区成本为 *n* – 1，并产生了一个“好”分割：大小为 (*n* – 1)/2 – 1 和 (*n* – 1)/2 的子数组。**(b)**
    递归树的一个层级是平衡的。在两个部分中，用蓝色阴影显示的子问题的分区成本为 Θ(*n*)。然而，在（a）中待解决的子问题，用棕色阴影显示，不会比（b）中待解决的相应子问题更大。'
- en: 'In the average case, PARTITION produces a mix of “good” and “bad” splits. In
    a recursion tree for an average-case execution of PARTITION, the good and bad
    splits are distributed randomly throughout the tree. Suppose for the sake of intuition
    that the good and bad splits alternate levels in the tree, and that the good splits
    are best-case splits and the bad splits are worst-case splits. [Figure 7.5(a)](chapter007.xhtml#Fig_7-5)
    shows the splits at two consecutive levels in the recursion tree. At the root
    of the tree, the cost is *n* for partitioning, and the subarrays produced have
    sizes *n* – 1 and 0: the worst case. At the next level, the subarray of size *n*
    – 1 undergoes best-case partitioning into subarrays of size (*n* – 1)/2 – 1 and
    (*n* – 1)/2\. Let’s assume that the base-case cost is 1 for the subarray of size
    0.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在平均情况下，PARTITION 产生“好”和“坏”分割的混合。在 PARTITION 的平均情况执行的递归树中，好和坏分割随机分布在整个树中。为了直观起见，假设好和坏分割在树的层级中交替出现，并且好分割是最佳情况分割，坏分割是最坏情况分割。[图
    7.5（a）](chapter007.xhtml#Fig_7-5)展示了递归树中两个连续层级的分割。在树的根部，分区成本为 *n*，产生的子数组大小为 *n*
    – 1 和 0：最坏情况。在下一个层级，大小为 *n* – 1 的子数组经历最佳情况分割，分成大小为 (*n* – 1)/2 – 1 和 (*n* – 1)/2
    的子数组。让我们假设大小为 0 的子数组的基本情况成本为 1。
- en: 'The combination of the bad split followed by the good split produces three
    subarrays of sizes 0, (*n* – 1)/2 – 1, and (*n* – 1)/2 at a combined partitioning
    cost of Θ(*n*) + Θ(*n* – 1) = Θ(*n*). This situation is at most a constant factor
    worse than that in [Figure 7.5(b)](chapter007.xhtml#Fig_7-5), namely, where a
    single level of partitioning produces two subarrays of size (*n* – 1)/2, at a
    cost of Θ(*n*). Yet this latter situation is balanced! Intuitively, the Θ(*n*
    – 1) cost of the bad split in [Figure 7.5(a)](chapter007.xhtml#Fig_7-5) can be
    absorbed into the Θ(*n*) cost of the good split, and the resulting split is good.
    Thus, the running time of quicksort, when levels alternate between good and bad
    splits, is like the running time for good splits alone: still *O*(*n* lg *n*),
    but with a slightly larger constant hidden by the *O*-notation. We’ll analyze
    the expected running time of a randomized version of quicksort rigorously in [Section
    7.4.2](chapter007.xhtml#Sec_7.4.2).'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 坏分割后跟好分割的组合产生了三个大小为 0、(*n* – 1)/2 – 1 和 (*n* – 1)/2 的子数组，组合分区成本为 Θ(*n*) + Θ(*n*
    – 1) = Θ(*n*)。这种情况最多比[图 7.5（b）](chapter007.xhtml#Fig_7-5)中的情况差一个常数因子，即一个单层分区产生两个大小为
    (*n* – 1)/2 的子数组，成本为 Θ(*n*)。然而，后一种情况是平衡的！直观上，[图 7.5（a）](chapter007.xhtml#Fig_7-5)中坏分割的
    Θ(*n* – 1) 成本可以吸收到好分割的 Θ(*n*) 成本中，产生的分割是好的。因此，当层级在好坏分割之间交替时，快速排序的运行时间就像仅有好分割时的运行时间：仍然是
    *O*(*n* lg *n*)，但被 *O* 表示法隐藏的常数略大。我们将在[第 7.4.2 节](chapter007.xhtml#Sec_7.4.2)中严格分析随机版本快速排序的预期运行时间。
- en: '**Exercises**'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***7.2-1***'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.2-1***'
- en: Use the substitution method to prove that the recurrence *T* (*n*) = *T* (*n*
    – 1) + Θ(*n*) has the solution *T* (*n*) = Θ(*n*²), as claimed at the beginning
    of [Section 7.2](chapter007.xhtml#Sec_7.2).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 使用替换法证明递归 *T* (*n*) = *T* (*n* – 1) + Θ(*n*) 的解为 *T* (*n*) = Θ(*n*²)，正如在[第 7.2
    节](chapter007.xhtml#Sec_7.2)开头所述。
- en: '***7.2-2***'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.2-2***'
- en: What is the running time of QUICKSORT when all elements of array *A* have the
    same value?
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当数组 *A* 的所有元素具有相同值时，QUICKSORT 的运行时间是多少？
- en: '***7.2-3***'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.2-3***'
- en: Show that the running time of QUICKSORT is Θ(*n*²) when the array *A* contains
    distinct elements and is sorted in decreasing order.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 证明当数组 *A* 包含不同元素且按降序排序时，QUICKSORT 的运行时间为 Θ(*n*²)。
- en: '***7.2-4***'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.2-4***'
- en: Banks often record transactions on an account in order of the times of the transactions,
    but many people like to receive their bank statements with checks listed in order
    by check number. People usually write checks in order by check number, and merchants
    usually cash them with reasonable dispatch. The problem of converting time-of-transaction
    ordering to check-number ordering is therefore the problem of sorting almost-sorted
    input. Explain persuasively why the procedure INSERTION-SORT might tend to beat
    the procedure QUICKSORT on this problem.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 银行通常按交易时间记录账户上的交易，但许多人喜欢按支票号码顺序收到银行对账单。人们通常按支票号码顺序书写支票，商家通常会合理迅速地兑现它们。因此，将交易时间排序转换为支票号码排序的问题就是对几乎排序好的输入进行排序的问题。有说服力地解释为什么插入排序程序可能在这个问题上胜过快速排序程序。
- en: '***7.2-5***'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.2-5***'
- en: Suppose that the splits at every level of quicksort are in the constant proportion
    *α* to *β*, where *α* + *β* = 1 and 0 < *α* ≤ *β* < 1\. Show that the minimum
    depth of a leaf in the recursion tree is approximately log[1/*α*] *n* and that
    the maximum depth is approximately log[1/*β*] *n*. (Don’t worry about integer
    round-off.)
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 假设快速排序每个层级的分割比例恒定为 *α* 到 *β*，其中 *α* + *β* = 1 且 0 < *α* ≤ *β* < 1。证明递归树中叶子的最小深度约为
    log[1/*α*] *n*，最大深度约为 log[1/*β*] *n*。（不用担心整数四舍五入。）
- en: '***7.2-6***'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.2-6***'
- en: Consider an array with distinct elements and for which all permutations of the
    elements are equally likely. Argue that for any constant 0 < *α* ≤ 1/2, the probability
    is approximately 1 – 2*α* that PARTITION produces a split at least as balanced
    as 1 – *α* to *α*.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个具有不同元素且所有元素的排列都是等概率的数组。证明对于任意常数0 < *α* ≤ 1/2，PARTITION产生的分割至少与1 – *α*到*α*一样平衡的概率近似为1
    – 2*α*。
- en: '[**7.3      A randomized version of quicksort**](toc.xhtml#Rh1-41)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '[**7.3      快速排序的随机版本**](toc.xhtml#Rh1-41)'
- en: In exploring the average-case behavior of quicksort, we have assumed that all
    permutations of the input numbers are equally likely. This assumption does not
    always hold, however, as, for example, in the situation laid out in the premise
    for Exercise 7.2-4\. [Section 5.3](chapter005.xhtml#Sec_5.3) showed that judicious
    randomization can sometimes be added to an algorithm to obtain good expected performance
    over all inputs. For quicksort, randomization yields a fast and practical algorithm.
    Many software libraries provide a randomized version of quicksort as their algorithm
    of choice for sorting large data sets.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在探讨快速排序的平均情况行为时，我们假设输入数字的所有排列都是等概率的。然而，这个假设并不总是成立，例如，在练习7.2-4的前提中所述的情况。[第5.3节](chapter005.xhtml#Sec_5.3)表明，明智的随机化有时可以添加到算法中，以获得对所有输入的良好期望性能。对于快速排序，随机化产生了一个快速且实用的算法。许多软件库提供了快速排序的随机版本作为排序大型数据集的首选算法。
- en: 'In [Section 5.3](chapter005.xhtml#Sec_5.3), the RANDOMIZED-HIRE-ASSISTANT procedure
    explicitly permutes its input and then runs the deterministic HIRE-ASSISTANT procedure.
    We could do the same for quicksort as well, but a different randomization technique
    yields a simpler analysis. Instead of always using *A*[*r*] as the pivot, a randomized
    version randomly chooses the pivot from the subarray *A*[*p* : *r*], where each
    element in *A*[*p* : *r*] has an equal probability of being chosen. It then exchanges
    that element with *A*[*r*] before partitioning. Because the pivot is chosen randomly,
    we expect the split of the input array to be reasonably well balanced on average.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '在[第5.3节](chapter005.xhtml#Sec_5.3)中，RANDOMIZED-HIRE-ASSISTANT过程明确地对其输入进行排列，然后运行确定性的HIRE-ASSISTANT过程。我们也可以对快速排序做同样的事情，但是不同的随机化技术会产生更简单的分析。随机版本不总是使用*A*[*r*]作为枢轴，而是从子数组*A*[*p*
    : *r*]中随机选择枢轴，其中*A*[*p* : *r*]中的每个元素被选择的概率相等。然后在分区之前将该元素与*A*[*r*]交换。由于枢轴是随机选择的，我们期望输入数组的分割在平均情况下是相当平衡的。'
- en: The changes to PARTITION and QUICKSORT are small. The new partitioning procedure,
    RANDOMIZED-PARTITION, simply swaps before performing the partitioning. The new
    quicksort procedure, RANDOMIZED-QUICKSORT, calls RANDOMIZED-PARTITION instead
    of PARTITION. We’ll analyze this algorithm in the next section.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: PARTITION和QUICKSORT的更改很小。新的分区过程RANDOMIZED-PARTITION在执行分区之前简单地交换。新的快速排序过程RANDOMIZED-QUICKSORT调用RANDOMIZED-PARTITION而不是PARTITION。我们将在下一节分析这个算法。
- en: RANDOMIZED-PARTITION(*A*, *p*, *r*)
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: RANDOMIZED-PARTITION(*A*, *p*, *r*)
- en: '| 1 | *i* = RANDOM(*p*, *r*) |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| 1 | *i* = RANDOM(*p*, *r*) |'
- en: '| 2 | exchange *A*[*r*] with *A*[*i*] |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 交换*A*[*r*]和*A*[*i*] |'
- en: '| 3 | **return** PARTITION(*A*, *p*, *r*) |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **return** PARTITION(*A*, *p*, *r*) |'
- en: RANDOMIZED-QUICKSORT(*A*, *p*, *r*)
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: RANDOMIZED-QUICKSORT(*A*, *p*, *r*)
- en: '| 1 | **if** *p* < *r* |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **if** *p* < *r* |'
- en: '| 2 | *q* = RANDOMIZED-PARTITION(*A*, *p*, *r*) |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| 2 | *q* = RANDOMIZED-PARTITION(*A*, *p*, *r*) |'
- en: '| 3 | RANDOMIZED-QUICKSORT(*A*, *p*, *q* – 1) |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| 3 | RANDOMIZED-QUICKSORT(*A*, *p*, *q* – 1) |'
- en: '| 4 | RANDOMIZED-QUICKSORT(*A*, *q* + 1, *r*) |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| 4 | RANDOMIZED-QUICKSORT(*A*, *q* + 1, *r*) |'
- en: '**Exercises**'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***7.3-1***'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.3-1***'
- en: Why do we analyze the expected running time of a randomized algorithm and not
    its worst-case running time?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么我们分析随机算法的期望运行时间而不是最坏情况的运行时间？
- en: '***7.3-2***'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.3-2***'
- en: When RANDOMIZED-QUICKSORT runs, how many calls are made to the random-number
    generator RANDOM in the worst case? How about in the best case? Give your answer
    in terms of Θ-notation.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 在RANDOMIZED-QUICKSORT运行时，最坏情况下随机数生成器RANDOM会被调用多少次？最好情况呢？用Θ-符号表示你的答案。
- en: '[**7.4      Analysis of quicksort**](toc.xhtml#Rh1-42)'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '[**7.4      快速排序的分析**](toc.xhtml#Rh1-42)'
- en: '[Section 7.2](chapter007.xhtml#Sec_7.2) gave some intuition for the worst-case
    behavior of quicksort and for why we expect the algorithm to run quickly. This
    section analyzes the behavior of quicksort more rigorously. We begin with a worst-case
    analysis, which applies to either QUICKSORT or RANDOMIZED-QUICKSORT, and conclude
    with an analysis of the expected running time of RANDOMIZED-QUICKSORT.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7.2节](chapter007.xhtml#Sec_7.2)为快速排序的最坏情况行为和我们为什么期望算法运行快速提供了一些直觉。本节更加严格地分析快速排序的行为。我们从最坏情况分析开始，这适用于QUICKSORT或RANDOMIZED-QUICKSORT，最后分析RANDOMIZED-QUICKSORT的期望运行时间。'
- en: '**7.4.1    Worst-case analysis**'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**7.4.1    最坏情况分析**'
- en: We saw in [Section 7.2](chapter007.xhtml#Sec_7.2) that a worst-case split at
    every level of recursion in quicksort produces a Θ(*n*²) running time, which,
    intuitively, is the worst-case running time of the algorithm. We now prove this
    assertion.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在[第7.2节](chapter007.xhtml#Sec_7.2)中看到，在快速排序的每个递归层次上都产生最坏情况的分割会产生Θ(*n*²)的运行时间，直观上，这是算法的最坏情况运行时间。我们现在证明这个断言。
- en: We’ll use the substitution method (see [Section 4.3](chapter004.xhtml#Sec_4.3))
    to show that the running time of quicksort is *O*(*n*²). Let *T* (*n*) be the
    worst-case time for the procedure QUICKSORT on an input of size *n*. Because the
    procedure PARTITION produces two subproblems with total size *n* – 1, we obtain
    the recurrence
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用替换法（参见[第4.3节](chapter004.xhtml#Sec_4.3)）来证明快速排序的运行时间是*O*(*n*²)。设*T*(*n*)为过程QUICKSORT在大小为*n*的输入上的最坏情况时间。因为PARTITION过程产生两个总大小为*n*
    – 1的子问题，我们得到递归关系
- en: '![art](images/Art_P314.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P314.jpg)'
- en: We guess that *T* (*n*) ≤ *cn*² for some constant *c* > 0\. Substituting this
    guess into recurrence (7.1) yields
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 我们猜测*T*(*n*) ≤ *cn*²，其中常数*c* > 0。将这个猜测代入递归式(7.1)得到
- en: '| *T* (*n*) | ≤ | max {*cq*² + *c*(*n* – 1 – *q*)² : 0 ≤ *q* ≤ *n* – 1} + Θ(*n*)
    |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| *T* (*n*) | ≤ | max {*cq*² + *c*(*n* – 1 – *q*)² : 0 ≤ *q* ≤ *n* – 1} + Θ(*n*)
    |'
- en: '|  | = | *c* · max {*q*² + (*n* – 1 – *q*)² : 0 ≤ *q* ≤ *n* – 1} + Θ(*n*).
    |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '|  | = | *c* · max {*q*² + (*n* – 1 – *q*)² : 0 ≤ *q* ≤ *n* – 1} + Θ(*n*)。
    |'
- en: Let’s focus our attention on the maximization. For *q* = 0, 1, … , *n* – 1,
    we have
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把注意力集中在最大化上。对于 *q* = 0, 1, … , *n* – 1，我们有
- en: '| *q*² + (*n* – 1 – *q*)² | = | *q*² + (*n* – 1)² – 2*q*(*n* – 1) + *q*² |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| *q*² + (*n* – 1 – *q*)² | = | *q*² + (*n* – 1)² – 2*q*(*n* – 1) + *q*² |'
- en: '|  | = | (*n* – 1)² + 2*q*(*q* – (*n* – 1)) |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '|  | = | (*n* – 1)² + 2*q*(*q* – (*n* – 1)) |'
- en: '|  | ≤ | (*n* – 1)² |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | (*n* – 1)² |'
- en: because *q* ≤ *n* – 1 implies that 2*q*(*q* – (*n* – 1)) ≤ 0\. Thus every term
    in the maximization is bounded by (*n* – 1)².
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因为*q* ≤ *n* – 1意味着2*q*(*q* – (*n* – 1)) ≤ 0。因此，最大化中的每一项都受到(*n* – 1)²的限制。
- en: Continuing with our analysis of *T* (*n*), we obtain
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 继续我们对*T* (*n*)的分析，我们得到
- en: '| *T* (*n*) | ≤ | *c*(*n* – 1)² + Θ(*n*) |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| *T* (*n*) | ≤ | *c*(*n* – 1)² + Θ(*n*) |'
- en: '|  | ≤ | *cn*² – *c*(2*n* – 1) + Θ(*n*) |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | *cn*² – *c*(2*n* – 1) + Θ(*n*) |'
- en: '|  | ≤ | *cn*², |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '|  | ≤ | *cn*², |'
- en: 'by picking the constant *c* large enough that the *c*(2*n* – 1) term dominates
    the Θ(*n*) term. Thus *T* (*n*) = *O*(*n*²). [Section 7.2](chapter007.xhtml#Sec_7.2)
    showed a specific case where quicksort takes Ω(*n*²) time: when partitioning is
    maximally unbalanced. Thus, the worst-case running time of quicksort is Θ(*n*²).'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过选择足够大的常数*c*，使得*c*(2*n* – 1)项支配Θ(*n*)项。因此*T* (*n*) = *O*(*n*²)。[Section 7.2](chapter007.xhtml#Sec_7.2)展示了quicksort需要Ω(*n*²)时间的特定情况：当分区极度不平衡时。因此，quicksort的最坏情况运行时间为Θ(*n*²)。
- en: '**7.4.2    Expected running time**'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '**7.4.2    预期运行时间**'
- en: 'We have already seen the intuition behind why the expected running time of
    RANDOMIZED-QUICKSORT is *O*(*n* lg *n*): if, in each level of recursion, the split
    induced by RANDOMIZED-PARTITION puts any constant fraction of the elements on
    one side of the partition, then the recursion tree has depth Θ(lg *n*) and *O*(*n*)
    work is performed at each level. Even if we add a few new levels with the most
    unbalanced split possible between these levels, the total time remains *O*(*n*
    lg *n*). We can analyze the expected running time of RANDOMIZED-QUICKSORT precisely
    by first understanding how the partitioning procedure operates and then using
    this understanding to derive an *O*(*n* lg *n*) bound on the expected running
    time. This upper bound on the expected running time, combined with the Θ(*n* lg
    *n*) best-case bound we saw in [Section 7.2](chapter007.xhtml#Sec_7.2), yields
    a Θ(*n* lg *n*) expected running time. We assume throughout that the values of
    the elements being sorted are distinct.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到RANDOMIZED-QUICKSORT的预期运行时间为*O*(*n* lg *n*)的直觉：如果在每个递归级别中，RANDOMIZED-PARTITION引起的分割将任意常数部分的元素放在分区的一侧，那么递归树的深度为Θ(lg
    *n*)，并且每个级别执行*O*(*n*)的工作。即使我们在这些级别之间添加了一些最不平衡的分割，总时间仍然保持为*O*(*n* lg *n*)。我们可以通过首先了解分区过程的操作方式，然后利用这种理解来推导对预期运行时间的*O*(*n*
    lg *n*)上界来精确分析RANDOMIZED-QUICKSORT的预期运行时间��这对预期运行时间的上界，再结合我们在[Section 7.2](chapter007.xhtml#Sec_7.2)中看到的Θ(*n*
    lg *n*)最佳情况下的上界，得到Θ(*n* lg *n*)的预期运行时间。我们始终假设被排序元素的值是不同的。
- en: '**Running time and comparisons**'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**运行时间和比较**'
- en: The QUICKSORT and RANDOMIZED-QUICKSORT procedures differ only in how they select
    pivot elements. They are the same in all other respects. We can therefore analyze
    RANDOMIZED-QUICKSORT by considering the QUICKSORT and PARTITION procedures, but
    with the assumption that pivot elements are selected randomly from the subarray
    passed to RANDOMIZED-PARTITION. Let’s start by relating the asymptotic running
    time of QUICKSORT to the number of times elements are compared (all in line 4
    of PARTITION), understanding that this analysis also applies to RANDOMIZED-QUICKSORT.
    Note that we are counting the number of times that *array elements* are compared,
    not comparisons of indices.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: QUICKSORT和RANDOMIZED-QUICKSORT过程只在选择枢轴元素的方式上有所不同。在其他方面它们是相同的。因此，我们可以通过考虑QUICKSORT和PARTITION过程来分析RANDOMIZED-QUICKSORT，但假设枢轴元素是从传递给RANDOMIZED-PARTITION的子数组中随机选择的。让我们从将QUICKSORT的渐近运行时间与元素比较次数的关系开始分析（都在PARTITION的第4行中），理解这种分析也适用于RANDOMIZED-QUICKSORT。请注意，我们计算的是*数组元素*比较的次数，而不是索引的比较。
- en: '***Lemma 7.1***'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 7.1***'
- en: The running time of QUICKSORT on an *n*-element array is *O*(*n* + *X*), where
    *X* is the number of element comparisons performed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在*n*元素数组上QUICKSORT的运行时间为*O*(*n* + *X*)，其中*X*是执行的元素比较次数。
- en: '***Proof***   The running time of QUICKSORT is dominated by the time spent
    in the PARTITION procedure. Each time PARTITION is called, it selects a pivot
    element, which is never included in any future recursive calls to QUICKSORT and
    PARTITION. Thus, there can be at most *n* calls to PARTITION over the entire execution
    of the quicksort algorithm. Each time QUICKSORT calls PARTITION, it also recursively
    calls itself twice, so there are at most 2*n* calls to the QUICKSORT procedure
    itself.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   QUICKSORT的运行时间主要取决于PARTITION过程中花费的时间。每次调用PARTITION时，它选择一个枢轴元素，该元素永远不会包含在未来对QUICKSORT和PARTITION的递归调用中。因此，在整个quicksort算法的执行过程中最多可以有*n*次对PARTITION的调用。每次QUICKSORT调用PARTITION时，它还会递归调用自身两次，因此QUICKSORT过程本身最多有2*n*次调用。'
- en: One call to PARTITION takes *O*(1) time plus an amount of time that is proportional
    to the number of iterations of the **for** loop in lines 3–6\. Each iteration
    of this **for** loop performs one comparison in line 4, comparing the pivot element
    to another element of the array *A*. Therefore, the total time spent in the **for**
    loop across all executions is proportional to *X*. Since there are at most *n*
    calls to PARTITION and the time spent outside the **for** loop is *O*(1) for each
    call, the total time spent in PARTITION outside of the **for** loop is *O*(*n*).
    Thus the total time for quicksort is *O*(*n* + *X*).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对PARTITION的每次调用需要*O*(1)的时间，再加上与第3-6行的**for**循环迭代次数成比例的时间。这个**for**循环的每次迭代在第4行进行一次比较，将枢轴元素与数组*A*的另一个元素进行比较。因此，所有执行中**for**循环中花费的总时间与*X*成比例。由于最多有*n*次对PARTITION的调用，而**for**循环外的时间对于每次调用都是*O*(1)，因此在**for**循环外对PARTITION花费的总时间是*O*(*n*)。因此，quicksort的总时间为*O*(*n*
    + *X*)。
- en: ▪
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: Our goal for analyzing RANDOMIZED-QUICKSORT, therefore, is to compute the expected
    value E [*X*] of the random variable *X* denoting the total number of comparisons
    performed in all calls to PARTITION. To do so, we must understand when the quicksort
    algorithm compares two elements of the array and when it does not. For ease of
    analysis, let’s index the elements of the array *A* by their position in the sorted
    output, rather than their position in the input. That is, although the elements
    in *A* may start out in any order, we’ll refer to them by *z*[1], *z*[2], … ,
    *z[n]*, where *z*[1] < *z*[2] < ⋯ < *z[n]*, with strict inequality because we
    assume that all elements are distinct. We denote the set {*z[i]*, *z*[*i* + 1],
    … , *z[j]*} by *Z[ij]*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们分析RANDOMIZED-QUICKSORT的目标是计算随机变量*X*表示在所有调用PARTITION中执行的比较总数��期望值E[*X*]。为此，我们必须了解快速排序算法何时比较数组中的两个元素，何时不比较。为了便于分析，让我们按照它们在排序输出中的位置而不是它们在输入中的位置对数组*A*中的元素进行索引。也就是说，尽管*A*中的元素可能以任何顺序开始，我们将按*z*[1]，*z*[2]，…，*z[n]*来引用它们，其中*z*[1]
    < *z*[2] < ⋯ < *z[n]*，严格的不等式是因为我们假设所有元素都是不同的。我们用*Z[ij]*表示集合{*z[i]*，*z*[*i* + 1]，…，*z[j]*}。
- en: The next lemma characterizes when two elements are compared.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个引理描述了两个元素何时被比较。
- en: '***Lemma 7.2***'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 7.2***'
- en: During the execution of RANDOMIZED-QUICKSORT on an array of *n* distinct elements
    *z*[1] < *z*[2] < ⋯ < *z[n]*, an element *z[i]* is compared with an element *z[j]*,
    where *i* < *j*, if and only if one of them is chosen as a pivot before any other
    element in the set *Z[ij]*. Moreover, no two elements are ever compared twice.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在对由*n*个不同元素*z*[1] < *z*[2] < ⋯ < *z[n]*组成的数组执行RANDOMIZED-QUICKSORT期间，元素*z[i]*与元素*z[j]*进行比较，其中*i*
    < *j*，当且仅当它们中的一个在集合*Z[ij]*中的任何其他元素之前被选择为枢轴时。此外，没有两个元素会被比较两次。
- en: '***Proof***   Let’s look at the first time that an element *x* ∈ *Z[ij]* is
    chosen as a pivot during the execution of the algorithm. There are three cases
    to consider. If *x* is neither *z[i]* nor *z[j]*—that is, *z[i]* < *x* < *z[j]*—then
    *z[i]* and *z[j]* are not compared at any subsequent time, because they fall into
    different sides of the partition around *x*. If *x* = *z[i]*, then PARTITION compares
    *z[i]* with every other item in *Z[ij]*. Similarly, if *x* = *z[j]*, then PARTITION
    compares *z[j]* with every other item in *Z[ij]*. Thus, *z[i]* and *z[j]* are
    compared if and only if the first element to be chosen as a pivot from *Z[ij]*
    is either *z[i]* or *z[j]*. In the latter two cases, where one of *z[i]* and *z[j]*
    is chosen as a pivot, since the pivot is removed from future comparisons, it is
    never compared again with the other element.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 让我们看看算法执行过程中第一次选择元素*x* ∈ *Z[ij]*作为枢轴的情况。有三种情况需要考虑。如果*x*既不是*z[i]*也不是*z[j]*—也就是说，*z[i]*
    < *x* < *z[j]*—那么*z[i]*和*z[j]*在分区周围时不会在任何后续时间进行比较。如果*x* = *z[i]*，那么PARTITION将*z[i]*与*Z[ij]*中的每个其他项进行比较。类似地，如果*x*
    = *z[j]*，那么PARTITION将*z[j]*与*Z[ij]*中的每个其他项进行比较。因此，*z[i]*和*z[j]*仅在从*Z[ij]*中选择为枢轴的第一个元素是*z[i]*或*z[j]*时进行比较。在后两种情况中，其中*z[i]*和*z[j]*中的一个被选择为枢轴，由于枢轴被移除以避免未来的比较，它们永远不会再与另一个元素进行比较。'
- en: ▪
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: 'As an example of this lemma, consider an input to quicksort of the numbers
    1 through 10 in some arbitrary order. Suppose that the first pivot element is
    7\. Then the first call to PARTITION separates the numbers into two sets: {1,
    2, 3, 4, 5, 6} and {8, 9, 10}. In the process, the pivot element 7 is compared
    with all other elements, but no number from the first set (e.g., 2) is or ever
    will be compared with any number from the second set (e.g., 9). The values 7 and
    9 are compared because 7 is the first item from *Z*[7,9] to be chosen as a pivot.
    In contrast, 2 and 9 are never compared because the first pivot element chosen
    from *Z*[2,9] is 7.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 作为这个引理的一个例子，考虑以某种任意顺序的数字1到10作为快速排序的输入。假设第一个枢轴元素是7。然后，第一次调用PARTITION将数字分为两组：{1,
    2, 3, 4, 5, 6}和{8, 9, 10}。在这个过程中，枢轴元素7与所有其他元素进行比较，但第一组中的任何数字（例如2）都不会与第二组中的任何数字（例如9）进行比较。值7和9被比较是因为7是从*Z*[7,9]中选择为枢轴的第一个项目。相反，2和9永远不会被比较，因为从*Z*[2,9]中选择为枢轴的第一个元素是7。
- en: The next lemma gives the probability that two elements are compared.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个引理给出了两个元素被比较的概率。
- en: '***Lemma 7.3***'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: '***引理 7.3***'
- en: Consider an execution of the procedure RANDOMIZED-QUICKSORT on an array of *n*
    distinct elements *z*[1] < *z*[2] < ⋯ < *z[n]*. Given two arbitrary elements *z[i]*
    and *z[j]* where *i* < *j*, the probability that they are compared is 2/(*j* –
    *i* + 1).
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑在由*n*个不同元素*z*[1] < *z*[2] < ⋯ < *z[n]*组成的数组上执行RANDOMIZED-QUICKSORT过程。给定两个任意元素*z[i]*和*z[j]*，其中*i*
    < *j*，它们被比较的概率为2/(*j* – *i* + 1)。
- en: '***Proof***   Let’s look at the tree of recursive calls that RANDOMIZED-QUICKSORT
    makes, and consider the sets of elements provided as input to each call. Initially,
    the root set contains all the elements of *Z[ij]*, since the root set contains
    every element in *A*. The elements belonging to *Z[ij]* all stay together for
    each recursive call of RANDOMIZED-QUICKSORT until PARTITION chooses some element
    *x* ∈ *Z[ij]* as a pivot. From that point on, the pivot *x* appears in no subsequent
    input set. The first time that RANDOMIZED-SELECT chooses a pivot *x* ∈ *Z[ij]*
    from a set containing all the elements of *Z[ij]*, each element in *Z[ij]* is
    equally likely to be *x* because the pivot is chosen uniformly at random. Since
    |*Z[ij]*| = *j* – *i* + 1, the probability is 1/(*j* – *i* + 1) that any given
    element in *Z[ij]* is the first pivot chosen from *Z[ij]*. Thus, by Lemma 7.2,
    we have'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明*** 让我们看看RANDOMIZED-QUICKSORT所做的递归调用树，并考虑提供给每个调用的元素集。最初，根集包含*Z[ij]*的所有元素，因为根集包含*A*中的每个元素。属于*Z[ij]*的元素在RANDOMIZED-QUICKSORT的每个递归调用中保持在一起，直到PARTITION选择一些属于*Z[ij]*的元素*x*作为枢轴。从那时起，枢轴*x*不会出现在后续的输入集中。RANDOMIZED-SELECT第一次从包含*Z[ij]*所有元素的集合中选择枢轴*x*
    ∈ *Z[ij]*时，*Z[ij]*中的每个元素都有相同的可能性成为*x*，因为枢轴是均匀随机选择的。由于|*Z[ij]*| = *j* – *i* + 1，任何给定的*Z[ij]*中的元素是第一个从*Z[ij]*中选择的枢轴的概率为1/(*j*
    – *i* + 1)。因此，根据引理7.2，我们有'
- en: '| Pr {*z[i]* is compared with *z[j]*} | = | Pr {*z[i]* or *z[j]* is the first
    pivot chosen from *Z[ij]*} |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| Pr {*z[i]* 与 *z[j]* 进行比较} | = | Pr {*z[i]* 或 *z[j]* 是从 *Z[ij]* 中选择的第一个枢轴}
    |'
- en: '|  | = | Pr {*z[i]* is the first pivot chosen from *Z[ij]*} |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '|  | = | Pr {*z[i]* 是从 *Z[ij]* 中选择的第一个枢轴} |'
- en: '|  |  | + Pr {*z[j]* is the first pivot chosen from *Z[ij]*} |'
  id: totrans-151
  prefs: []
  type: TYPE_TB
  zh: '|  |  | + Pr {*z[j]* 是从 *Z[ij]* 中选择的第一个枢轴} |'
- en: '|  | = | ![art](images/Art_P315.jpg), |'
  id: totrans-152
  prefs: []
  type: TYPE_TB
  zh: '|  | = | ![art](images/Art_P315.jpg), |'
- en: where the second line follows from the first because the two events are mutually
    exclusive.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行是因为这两个事件是互斥的。
- en: ▪
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: We can now complete the analysis of randomized quicksort.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以完成随机快速排序的分析。
- en: '***Theorem 7.4***'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '***定理 7.4***'
- en: The expected running time of RANDOMIZED-QUICKSORT on an input of *n* distinct
    elements is *O*(*n* lg *n*).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: RANDOMIZED-QUICKSORT 在 *n* 个不同元素的输入上的期望运行时间为 *O*(*n* lg *n*)。
- en: '***Proof***   The analysis uses indicator random variables (see [Section 5.2](chapter005.xhtml#Sec_5.2)).
    Let the *n* distinct elements be *z*[1] < *z*[2] < ⋯ < *z[n]*, and for 1 ≤ *i*
    < *j* ≤ *n*, define the indicator random variable *X[ij]* = I {*z[i]* is compared
    with *z[j]*}. From Lemma 7.2, each pair is compared at most once, and so we can
    express *X* as follows:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '***证明***   该分析使用指示器随机变量（参见 [第 5.2 节](chapter005.xhtml#Sec_5.2)）。让 *n* 个不同元素为
    *z*[1] < *z*[2] < ⋯ < *z[n]*，对于 1 ≤ *i* < *j* ≤ *n*，定义指示器随机变量 *X[ij]* = I {*z[i]*
    与 *z[j]* 进行比较}。根据引理 7.2，每对最多只比较一次，因此我们可以表示 *X* 如下：'
- en: '![art](images/Art_P316.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P316.jpg)'
- en: By taking expectations of both sides and using linearity of expectation (equation
    (C.24) on page 1192) and Lemma 5.1 on page 130, we obtain
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 通过对两边取期望值，并使用期望的线性性（第 1192 页的方程式（C.24）和第 130 页的引理 5.1）以及引理 7.2，我们得到
- en: '![art](images/Art_P317.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P317.jpg)'
- en: 'We can evaluate this sum using a change of variables (*k* = *j* – *i*) and
    the bound on the harmonic series in equation (A.9) on page 1142:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过变量的变化（*k* = *j* – *i*）和对调和级数的界限（第 1142 页的方程式（A.9））来评估这个和：
- en: '![art](images/Art_P318.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_IMG
  zh: '![art](images/Art_P318.jpg)'
- en: This bound and Lemma 7.1 allow us to conclude that the expected running time
    of RANDOMIZED-QUICKSORT is *O*(*n* lg *n*) (assuming that the element values are
    distinct).
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这个界限和引理 7.1 使我们得出 RANDOMIZED-QUICKSORT 的期望运行时间为 *O*(*n* lg *n*)（假设元素值是不同的）。
- en: ▪
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: ▪
- en: '**Exercises**'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**练习**'
- en: '***7.4-1***'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.4-1***'
- en: Show that the recurrence
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 显示递归
- en: '*T* (*n*) = max {*T* (*q*) + *T* (*n* – *q* – 1) : 0 ≤ *q* ≤ *n* – 1} + Θ(*n*)'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '*T* (*n*) = max {*T* (*q*) + *T* (*n* – *q* – 1) : 0 ≤ *q* ≤ *n* – 1} + Θ(*n*)'
- en: has a lower bound of *T* (*n*) = Ω (*n*²).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 具有下界 *T* (*n*) = Ω (*n*²)。
- en: '***7.4-2***'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.4-2***'
- en: Show that quicksort’s best-case running time is Ω(*n* lg *n*).
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 显示快速排序���最佳情况运行时间为 Ω(*n* lg *n*)。
- en: '***7.4-3***'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.4-3***'
- en: Show that the expression *q*² + (*n* – *q* – 1)² achieves its maximum value
    over *q* = 0, 1, … , *n* – 1 when *q* = 0 or *q* = *n* – 1.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 当 *q* = 0 或 *q* = *n* – 1 时，证明表达式 *q*² + (*n* – *q* – 1)² 取得最大值。
- en: '***7.4-4***'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.4-4***'
- en: Show that RANDOMIZED-QUICKSORT’s expected running time is Ω(*n* lg *n*).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 显示 RANDOMIZED-QUICKSORT 的期望运行时间为 Ω(*n* lg *n*)。
- en: '***7.4-5***'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '***7.4-5***'
- en: Coarsening the recursion, as we did in Problem 2-1 for merge sort, is a common
    way to improve the running time of quicksort in practice. We modify the base case
    of the recursion so that if the array has fewer than *k* elements, the subarray
    is sorted by insertion sort, rather than by continued recursive calls to quicksort.
    Argue that the randomized version of this sorting algorithm runs in *O*(*nk* +
    *n* lg(*n*/*k*)) expected time. How should you pick *k*, both in theory and in
    practice?
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 粗化递归，就像我们在合并排序的问题 2-1 中所做的那样，是在实践中改善快速排序运行时间的常见方法。我们修改递归的基本情况，以便如果数组少于 *k* 个元素，则子数组通过插入排序而不是通过继续递归调用快速排序进行排序。论证这种排序算法的随机版本的期望运行时间为
    *O*(*nk* + *n* lg(*n*/*k*))。在理论和实践中应该如何选择 *k*？
- en: ★ ***7.4-6***
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: ★ ***7.4-6***
- en: 'Consider modifying the PARTITION procedure by randomly picking three elements
    from subarray *A*[*p* : *r*] and partitioning about their median (the middle value
    of the three elements). Approximate the probability of getting worse than an *α*-to-(1–*α*)
    split, as a function of *α* in the range 0 < *α* < 1/2.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '考虑通过从子数组 *A*[*p* : *r*] 中随机选择三个元素并围绕它们的中位数（三个元素的中间值）进行分区来修改 PARTITION 程序。估计在范围
    0 < *α* < 1/2 的 *α* 的情况下，获得比 *α*-to-(1–*α*) 分割更糟糕的概率。'
- en: '**Problems**'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '**问题**'
- en: '***7-1     Hoare partition correctness***'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '***7-1     Hoare 分区正确性***'
- en: The version of PARTITION given in this chapter is not the original partitioning
    algorithm. Here is the original partitioning algorithm, which is due to C. A.
    R. Hoare.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中给出的 PARTITION 版本不是原始的分区算法。这是原始的分区算法，归功于 C. A. R. Hoare。
- en: HOARE-PARTITION(*A*, *p*, *r*)
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: HOARE-PARTITION(*A*, *p*, *r*)
- en: '|   1 | *x* = *A*[*p*] |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
  zh: '|   1 | *x* = *A*[*p*] |'
- en: '|   2 | *i* = *p* – 1 |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
  zh: '|   2 | *i* = *p* – 1 |'
- en: '|   3 | *j* = *r* + 1 |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '|   3 | *j* = *r* + 1 |'
- en: '|   4 | **while** TRUE |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '|   4 | **当** TRUE **时** |'
- en: '|   5 | **repeat** |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '|   5 | **重复** |'
- en: '|   6 | *j* = *j* – 1 |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '|   6 | *j* = *j* – 1 |'
- en: '|   7 | **until** *A*[*j*] ≤ *x* |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '|   7 | **直到** *A*[*j*] ≤ *x* |'
- en: '|   8 | **repeat** |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '|   8 | **重复** |'
- en: '|   9 | *i* = *i* + 1 |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '|   9 | *i* = *i* + 1 |'
- en: '| 10 | **until** *A*[*i*] ≥ *x* |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| 10 | **直到** *A*[*i*] ≥ *x* |'
- en: '| 11 | **if** *i* < *j* |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 11 | **如果** *i* < *j* |'
- en: '| 12 | exchange *A*[*i*] with *A*[*j*] |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| 12 | 交换 *A*[*i*] 和 *A*[*j*] |'
- en: '| 13 | **else return** *j* |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| 13 | **否则返回** *j* |'
- en: '***a.*** Demonstrate the operation of HOARE-PARTITION on the array *A* = 〈13,
    19, 9, 5, 12, 8, 7, 4, 11, 2, 6, 21〉, showing the values of the array and the
    indices *i* and *j* after each iteration of the **while** loop in lines 4–13.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 在数组 *A* = 〈13, 19, 9, 5, 12, 8, 7, 4, 11, 2, 6, 21〉 上演示 HOARE-PARTITION
    的操作，显示每次迭代 lines 4–13 中 **while** 循环后数组和索引 *i* 和 *j* 的值。'
- en: '***b.*** Describe how the PARTITION procedure in [Section 7.1](chapter007.xhtml#Sec_7.1)
    differs from HOARE-PARTITION when all elements in *A*[*p* : *r*] are equal. Describe
    a practical advantage of HOARE-PARTITION over PARTITION for use in quicksort.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 描述当 *A*[*p* : *r*] 中的所有元素相等时，[第 7.1 节](chapter007.xhtml#Sec_7.1) 中的
    PARTITION 程序与 HOARE-PARTITION 有何不同。描述 HOARE-PARTITION 相对于 PARTITION 在快速排序中的实际优势。'
- en: 'The next three questions ask you to give a careful argument that the procedure
    HOARE-PARTITION is correct. Assuming that the subarray *A*[*p* : *r*] contains
    at least two elements, prove the following:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来的三个问题要求您仔细论证HOARE-PARTITION过程的正确性。假设子数组* A * [*p* : *r*]至少包含两个元素，证明以下内容：'
- en: '***c.*** The indices *i* and *j* are such that the procedure never accesses
    an element of *A* outside the subarray *A*[*p* : *r*].'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 索引*i*和*j*是这样的，使得该过程永远不会访问* A *子数组* A * [*p* : *r*]之外的元素。'
- en: '***d.*** When HOARE-PARTITION terminates, it returns a value *j* such that
    *p* ≤ *j* < *r*.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 当HOARE-PARTITION终止时，它返回一个值*j*，使得*p* ≤ *j* < *r*。'
- en: '***e.*** Every element of *A*[*p* : *j*] is less than or equal to every element
    of *A*[*j* + 1 : *r*] when HOARE-PARTITION terminates.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** 当HOARE-PARTITION终止时，*A* [*p* : *j*]的每个元素都小于或等于* A * [*j* + 1 : *r*]的每个元素。'
- en: 'The PARTITION procedure in [Section 7.1](chapter007.xhtml#Sec_7.1) separates
    the pivot value (originally in *A*[*r*]) from the two partitions it forms. The
    HOARE-PARTITION procedure, on the other hand, always places the pivot value (originally
    in *A*[*p*]) into one of the two partitions *A*[*p* : *j*] and *A*[*j* + 1 : *r*].
    Since *p* ≤ *j* < *r*, neither partition is empty.'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7.1节](chapter007.xhtml#Sec_7.1)中的PARTITION过程将枢轴值（最初在*A* [*r*]中）与其形成的两个分区分开。另一方面，HOARE-PARTITION过程总是将枢轴值（最初在*A*
    [*p*]中）放入两个分区*A* [*p* : *j*]和*A* [*j* + 1 : *r*]之一。由于*p* ≤ *j* < *r*，因此两个分区都不为空。'
- en: '***f.*** Rewrite the QUICKSORT procedure to use HOARE-PARTITION.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '***f.*** 重写QUICKSORT过程以使用HOARE-PARTITION。'
- en: '***7-2     Quicksort with equal element values***'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '***7-2     具有相等元素值的快速排序***'
- en: The analysis of the expected running time of randomized quicksort in [Section
    7.4.2](chapter007.xhtml#Sec_7.4.2) assumes that all element values are distinct.
    This problem examines what happens when they are not.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第7.4.2节](chapter007.xhtml#Sec_7.4.2)中对随机快速排序的预期运行时间的分析假设所有元素值都不同。这个问题研究它们不同时会发生什么。
- en: '***a.*** Suppose that all element values are equal. What is randomized quicksort’s
    running time in this case?'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 假设所有元素值都相等。在这种情况下，随机快速排序的运行时间是多少？'
- en: '***b.*** The PARTITION procedure returns an index *q* such that each element
    of *A*[*p* : *q* – 1] is less than or equal to *A*[*q*] and each element of *A*[*q*
    + 1 : *r*] is greater than *A*[*q*]. Modify the PARTITION procedure to produce
    a procedure PARTITION′ (*A*, *p*, *r*), which permutes the elements of *A*[*p*
    : *r*] and returns two indices *q* and *t*, where *p* ≤ *q* ≤ *t* ≤ *r*, such
    that'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** PARTITION过程返回一个索引*q*，使得*A* [*p* : *q* – 1]的每个元素都小于或等于*A* [*q*]，并且*A*
    [*q* + 1 : *r*]的每个元素都大于*A* [*q*]。修改PARTITION过程以生成一个过程PARTITION′（*A*，*p*，*r*），它重新排列*A*
    [*p* : *r*]的元素并返回两个索引*q*和*t*，其中*p* ≤ *q* ≤ *t* ≤ *r*，使得'
- en: 'all elements of *A*[*q* : *t*] are equal,'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A* [*q* : *t*]的所有元素都相等，'
- en: 'each element of *A*[*p* : *q* – 1] is less than *A*[*q*], and'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A* [*p* : *q* – 1]的每个元素都小于*A* [*q*]，且'
- en: 'each element of *A*[*t* + 1 : *r*] is greater than *A*[*q*].'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*A* [*t* + 1 : *r*]的每个元素都大于*A* [*q*]。'
- en: Like PARTITION, your PARTITION′ procedure should take Θ(*r* – *p*) time.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 像PARTITION一样，您的PARTITION′过程应该花费Θ(*r* – *p*)的时间。
- en: '***c.*** Modify the RANDOMIZED-PARTITION procedure to call PARTITION′, and
    name the new procedure RANDOMIZED-PARTITION′. Then modify the QUICKSORT procedure
    to produce a procedure QUICKSORT′ (*A*, *p*, *r*) that calls RANDOMIZED-PARTITION′
    and recurses only on partitions where elements are not known to be equal to each
    other.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 修改RANDOMIZED-PARTITION过程以调用PARTITION′，并命名新过程为RANDOMIZED-PARTITION′。然后修改QUICKSORT过程以生成一个调用RANDOMIZED-PARTITION′并仅在元素不相等的分区上递归的过程QUICKSORT′（*A*，*p*，*r*）。'
- en: '***d.*** Using QUICKSORT′, adjust the analysis in [Section 7.4.2](chapter007.xhtml#Sec_7.4.2)
    to avoid the assumption that all elements are distinct.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 使用QUICKSORT′，调整[第7.4.2节](chapter007.xhtml#Sec_7.4.2)中的分析，以避免所有元素都不同的假设。'
- en: '***7-3     Alternative quicksort analysis***'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '***7-3     替代快速排序分析***'
- en: An alternative analysis of the running time of randomized quicksort focuses
    on the expected running time of each individual recursive call to RANDOMIZED-QUICKSORT,
    rather than on the number of comparisons performed. As in the analysis of [Section
    7.4.2](chapter007.xhtml#Sec_7.4.2), assume that the values of the elements are
    distinct.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 随机快速排序运行时间的另一种分析侧重于对每个递归调用RANDOMIZED-QUICKSORT的预期运行时间，而不是执行的比较次数。与[第7.4.2节](chapter007.xhtml#Sec_7.4.2)的分析一样，假设元素的值是不同的。
- en: '***a.*** Argue that, given an array of size *n*, the probability that any particular
    element is chosen as the pivot is 1/*n*. Use this probability to define indicator
    random variables *X[i]* = I {*i*th smallest element is chosen as the pivot}. What
    is E [*X[i]*]?'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 论证，给定大小为*n*的数组，选择任意特定元素作为枢轴的概率为1/*n*。利用这个概率定义指示随机变量*X[i]* = I {*第i个最小元素被选为枢轴}。E
    [*X[i]*]是多少？'
- en: '***b.*** Let *T* (*n*) be a random variable denoting the running time of quicksort
    on an array of size *n*. Argue that'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 让*T* (*n*)是一个随机变量，表示大小为*n*的数组上快速排序的运行时间。论证'
- en: '![art](images/Art_P319.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P319.jpg)'
- en: '***c.*** Show how to rewrite equation (7.2) as'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 展示如何将方程（7.2）重写为'
- en: '![art](images/Art_P320.jpg)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P320.jpg)'
- en: '***d.*** Show that'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 展示'
- en: '![art](images/Art_P321.jpg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![艺术](images/Art_P321.jpg)'
- en: for *n* ≥ 2\. (*Hint:* Split the summation into two parts, one summation for
    *q* = 1, 2, … , ⌈*n*/2⌉ – 1 and one summation for *q* = ⌈*n*/2⌉ , … , *n* – 1.)
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 对于*n* ≥ 2。 (*提示:* 将求和分为两部分，一个求和为*q* = 1, 2, … , ⌈*n*/2⌉ – 1，另一个求和为*q* = ⌈*n*/2⌉，…
    , *n* – 1。)
- en: '***e.*** Using the bound from equation (7.4), show that the recurrence in equation
    (7.3) has the solution E [*T* (*n*)] = *O*(*n* lg *n*). (*Hint:* Show, by substitution,
    that E [*T* (*n*)] ≤ *an* lg *n* for sufficiently large *n* and for some positive
    constant *a*.)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '***e.*** 使用方程（7.4）中的界限，展示方程（7.3）中的递归具有解E [*T* (*n*)] = *O*(*n* lg *n*)。 (*提示:*
    通过替换，展示对于足够大的*n*和某个正常数*a*，E [*T* (*n*)] ≤ *an* lg *n*。)'
- en: '***7-4     Stooge sort***'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '***7-4     Stooge排序***'
- en: Professors Howard, Fine, and Howard have proposed a deceptively simple sorting
    algorithm, named stooge sort in their honor, appearing on the following page.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: Howard、Fine和Howard教授提出了一个看似简单的排序算法，以他们的名字命名为stooge sort，出现在接下来的页面上。
- en: '***a.*** Argue that the call STOOGE-SORT(*A*, 1, *n*) correctly sorts the array
    *A*[1 : *n*].'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 论证调用STOOGE-SORT(*A*, 1, *n*)是否正确对���组*A*[1 : *n*]进行排序。'
- en: '***b.*** Give a recurrence for the worst-case running time of STOOGE-SORT and
    a tight asymptotic (Θ-notation) bound on the worst-case running time.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 给出STOOGE-SORT最坏情况运行时间的递归和最坏情况运行时间的紧密渐近（Θ-notation）界限。'
- en: '***c.*** Compare the worst-case running time of STOOGE-SORT with that of insertion
    sort, merge sort, heapsort, and quicksort. Do the professors deserve tenure?'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 比较STOOGE-SORT的最坏情况运行时间与插入排序、归并排序、堆排序和快速排序的情况。这些教授应该获得终身教职吗？'
- en: STOOGE-SORT(*A*, *p*, *r*)
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: STOOGE-SORT(*A*, *p*, *r*)
- en: '| 1 | **if** *A*[*p*] > *A*[*r*] |  |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **如果** *A*[*p*] > *A*[*r*] |  |'
- en: '| 2 | exchange *A*[*p*] with *A*[*r*] |  |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
  zh: '| 2 | 交换*A*[*p*]和*A*[*r*] |  |'
- en: '| 3 | **if** *p* + 1 < *r* |  |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
  zh: '| 3 | **如果** *p* + 1 < *r* |  |'
- en: '| 4 | *k* = ⌊(*r* – *p* + 1)/3⌋ | **//** round down |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| 4 | *k* = ⌊(*r* – *p* + 1)/3⌋ | **//** 向下取整 |'
- en: '| 5 | STOOGE-SORT(*A*, *p*, *r* – *k*) | **//** first two-thirds |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| 5 | STOOGE-SORT(*A*, *p*, *r* – *k*) | **//** 前两个三分之一 |'
- en: '| 6 | STOOGE-SORT(*A*, *p* + *k*, *r*) | **//** last two-thirds |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| 6 | STOOGE-SORT(*A*, *p* + *k*, *r*) | **//** 后两个三分之一 |'
- en: '| 7 | STOOGE-SORT(*A*, *p*, *r* – *k*) | **//** first two-thirds again |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| 7 | STOOGE-SORT(*A*, *p*, *r* – *k*) | **//** 再次前两个三分之一 |'
- en: '***7-5 Stack depth for quicksort***'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '***7-5 快速排序的堆栈深度***'
- en: The QUICKSORT procedure of [Section 7.1](chapter007.xhtml#Sec_7.1) makes two
    recursive calls to itself. After QUICKSORT calls PARTITION, it recursively sorts
    the low side of the partition and then it recursively sorts the high side of the
    partition. The second recursive call in QUICKSORT is not really necessary, because
    the procedure can instead use an iterative control structure. This transformation
    technique, called ***tail-recursion elimination***, is provided automatically
    by good compilers. Applying tail-recursion elimination transforms QUICKSORT into
    the TRE-QUICKSORT procedure.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '[第7.1节](chapter007.xhtml#Sec_7.1)的QUICKSORT过程对自身进行两次递归调用。QUICKSORT在调用PARTITION后，递归对分区的低端进行排序，然后递归对分区的高端进行排序。QUICKSORT中的第二次递归调用实际上并不是必要的，因为该过程可以使用迭代控制结构。这种转换技术称为***尾递归消除***，好的编译器会自动提供。应用尾递归消除将QUICKSORT转换为TRE-QUICKSORT过程。'
- en: TRE-QUICKSORT(*A*, *p*, *r*)
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: TRE-QUICKSORT(*A*, *p*, *r*)
- en: '| 1 | **while** *p* < *r* |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| 1 | **当** *p* < *r* |'
- en: '| 2 | **//** Partition and then sort the low side. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| 2 | **//** 分区然后对低端进行排序。 |'
- en: '| 3 | *q* = PARTITION(*A*, *p*, *r*) |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| 3 | *q* = PARTITION(*A*, *p*, *r*) |'
- en: '| 4 | TRE-QUICKSORT(*A*, *p*, *q* – 1) |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
  zh: '| 4 | TRE-QUICKSORT(*A*, *p*, *q* – 1) |'
- en: '| 5 | *p* = *q* + 1 |'
  id: totrans-247
  prefs: []
  type: TYPE_TB
  zh: '| 5 | *p* = *q* + 1 |'
- en: '***a.*** Argue that TRE-QUICKSORT(*A*, 1, *n*) correctly sorts the array *A*[1
    : *n*].'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 论证TRE-QUICKSORT(*A*, 1, *n*)是否正确对数组*A*[1 : *n*]进行排序。'
- en: Compilers usually execute recursive procedures by using a ***stack*** that contains
    pertinent information, including the parameter values, for each recursive call.
    The information for the most recent call is at the top of the stack, and the information
    for the initial call is at the bottom. When a procedure is called, its information
    is ***pushed*** onto the stack, and when it terminates, its information is ***popped***.
    Since we assume that array parameters are represented by pointers, the information
    for each procedure call on the stack requires *O*(1) stack space. The ***stack
    depth*** is the maximum amount of stack space used at any time during a computation.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器通常通过包含相关信息的***堆栈***来执行递归过程，其中包括每个递归调用的参数值。最近一次调用的信息位于堆栈顶部，初始调用的信息位于底部。当调用一个过程时，它的信息被***推入***堆栈，当它终止时，它的信息被***弹出***。由于我们假设数组参数由指针表示，堆栈上每个过程调用的信息需要*O*(1)的堆栈空间。***堆栈深度***是在计算过程中任何时候使用的最大堆栈空间量。
- en: '***b.*** Describe a scenario in which TRE-QUICKSORT’s stack depth is Θ(*n*)
    on an *n*-element input array.'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 描述一个情景，在这个情景下，TRE-QUICKSORT在*n*元素输入数组上的堆栈深度为Θ(*n*)。'
- en: '***c.*** Modify TRE-QUICKSORT so that the worst-case stack depth is Θ(lg *n*).
    Maintain the *O*(*n* lg *n*) expected running time of the algorithm.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 修改TRE-QUICKSORT，使得最坏情况堆栈深度为Θ(lg *n*)。保持算法的*O*(*n* lg *n*)预期运行时间。'
- en: '***7-6     Median-of-3 partition***'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '***7-6     中值法分区***'
- en: 'One way to improve the RANDOMIZED-QUICKSORT procedure is to partition around
    a pivot that is chosen more carefully than by picking a random element from the
    subarray. A common approach is the ***median-of-3*** method: choose the pivot
    as the median (middle element) of a set of 3 elements randomly selected from the
    subarray. (See Exercise 7.4-6.) For this problem, assume that the *n* elements
    in the input subarray *A*[*p* : *r*] are distinct and that *n* ≥ 3\. Denote the
    sorted version of *A*[*p* : *r*] by *z*[1], *z*[2], … , *z[n]*. Using the median-of-3
    method to choose the pivot element *x*, define *p[i]* = Pr {*x* = *z[i]*}.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '改进随机化快速排序过程的一种方法是围绕一个比从子数组中随机选择一个元素更谨慎地选择的枢轴进行分区。一种常见的方法是***中值法***：从子数组中随机选择的3个元素中选择中值（中间元素）作为枢轴。（参见练习7.4-6。）对于这个问题，假设输入子数组*A*[*p*
    : *r*]中的*n*个元素是不同的，且*n* ≥ 3。用*z*[1]，*z*[2]，…，*z[n]*表示*A*[*p* : *r*]的排序版本。使用中值法选择枢轴元素*x*，定义*p[i]*
    = Pr {*x* = *z[i]*}。'
- en: '***a.*** Give an exact formula for *p[i]* as a function of *n* and *i* for
    *i* = 2, 3, … , *n* – 1\. (Observe that *p*[1] = *p[n]* = 0.)'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 给出*p[i]*的精确公式，作为*n*和*i*的函数，对于*i* = 2, 3, … , *n* – 1。 （观察到*p*[1] =
    *p[n]* = 0。）'
- en: '***b.*** By what amount does the median-of-3 method increase the likelihood
    of choosing the pivot to be *x* = *z*[⌊(*n* + 1)/2⌋], the median of *A*[*p* :
    *r*], compared with the ordinary implementation? Assume that *n* → ∞, and give
    the limiting ratio of these probabilities.'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 与普通实现相比，中值法增加了选择枢轴为*x* = *z*[⌊(*n* + 1)/2⌋]的可能性的数量。假设*n* → ∞，给出这些概率的极限比率。'
- en: '***c.*** Suppose that we define a “good” split to mean choosing the pivot as
    *x* = *z[i]*, where *n*/3 ≤ *i* ≤ 2*n*/3\. By what amount does the median-of-3
    method increase the likelihood of getting a good split compared with the ordinary
    implementation? (*Hint:* Approximate the sum by an integral.)'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: '***c.*** 假设我们定义“好”分割是选择枢轴为 *x* = *z[i]*，其中 *n*/3 ≤ *i* ≤ 2*n*/3\. 与普通实现相比，中值-3方法增加了多少可能获得好分割的可能性？（*提示：*通过积分近似求和。）'
- en: '***d.*** Argue that in the Ω(*n* lg *n*) running time of quicksort, the median-of-3
    method affects only the constant factor.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: '***d.*** 论证在快速排序的Ω(*n* lg *n*)运行时间中，中值-3方法仅影响常数因子。'
- en: '***7-7     Fuzzy sorting of intervals***'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '***7-7     区间的模糊排序***'
- en: 'Consider a sorting problem in which you do not know the numbers exactly. Instead,
    for each number, you know an interval on the real line to which it belongs. That
    is, you are given *n* closed intervals of the form [*a[i]*, *b[i]*], where *a[i]*
    ≤ *b[i]*. The goal is to ***fuzzy-sort*** these intervals: to produce a permutation
    〈*i*[1], *i*[2], … , *i[n]*〉 of the intervals such that for *j* = 1, 2, … , *n*,
    there exist ![art](images/Art_P322.jpg) satisfying *c*[1] ≤ *c*[2] ≤ ⋯ ≤ *c[n]*.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个排序问题，其中你不知道确切的数字。相反，对于每个数字，你知道它属于实数线上的一个区间。也就是说，给定形式为 [*a[i]*, *b[i]*] 的
    *n* 个闭区间，其中 *a[i]* ≤ *b[i]*。目标是对这些区间进行***模糊排序***：产生一个区间的排列 〈*i*[1], *i*[2], …
    , *i[n]*〉，使得对于 *j* = 1, 2, … , *n*，存在 ![art](images/Art_P322.jpg) 满足 *c*[1] ≤
    *c*[2] ≤ ⋯ ≤ *c[n]*。
- en: '***a.*** Design a randomized algorithm for fuzzy-sorting *n* intervals. Your
    algorithm should have the general structure of an algorithm that quicksorts the
    left endpoints (the *a[i]* values), but it should take advantage of overlapping
    intervals to improve the running time. (As the intervals overlap more and more,
    the problem of fuzzy-sorting the intervals becomes progressively easier. Your
    algorithm should take advantage of such overlapping, to the extent that it exists.)'
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: '***a.*** 设计一个随机化算法来对 *n* 个区间进行模糊排序。你的算法应该具有快速排序左端点（*a[i]* 值）的一般结构，但应利用重叠区间来提高运行时间。（随着区间的重叠越来越多，模糊排序区间的问题变得逐渐容易。你的算法应该充分利用这种重叠，只要存在的话。）'
- en: '***b.*** Argue that your algorithm runs in Θ(*n* lg *n*) expected time in general,
    but runs in Θ(*n*) expected time when all of the intervals overlap (i.e., when
    there exists a value *x* such that *x* ∈ [*a[i]*, *b[i]*] for all *i*). Your algorithm
    should not be checking for this case explicitly, but rather, its performance should
    naturally improve as the amount of overlap increases.'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '***b.*** 论证你的算法在一般情况下以Θ(*n* lg *n*)的期望时间运行，但当所有区间重叠时以Θ(*n*)的期望时间运行（即存在一个值 *x*，使得对所有
    *i* 都有 *x* ∈ [*a[i]*, *b[i]*]）。你的算法不应明确检查这种情况，而是随着重叠量的增加，其性能应自然提高。'
- en: '**Chapter notes**'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '**章节注释**'
- en: Quicksort was invented by Hoare [[219](bibliography001.xhtml#endnote_219)],
    and his version of PARTITION appears in Problem 7-1\. Bentley [[51](bibliography001.xhtml#endnote_51),
    p. 117] attributes the PARTITION procedure given in [Section 7.1](chapter007.xhtml#Sec_7.1)
    to N. Lomuto. The analysis in [Section 7.4](chapter007.xhtml#Sec_7.4) based on
    an analysis due to Motwani and Raghavan [[336](bibliography001.xhtml#endnote_336)].
    Sedgewick [[401](bibliography001.xhtml#endnote_401)] and Bentley [[51](bibliography001.xhtml#endnote_51)]
    provide good references on the details of implementation and how they matter.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 快速排序是由霍尔发明的[[219](bibliography001.xhtml#endnote_219)]，他的PARTITION版本出现在问题7-1中。本特利[[51](bibliography001.xhtml#endnote_51)，p.
    117]将在[第7.1节](chapter007.xhtml#Sec_7.1)中给出的PARTITION过程归因于N. Lomuto。[第7.4节](chapter007.xhtml#Sec_7.4)中的分析基于Motwani和Raghavan的分析[[336](bibliography001.xhtml#endnote_336)]。Sedgewick[[401](bibliography001.xhtml#endnote_401)]和Bentley[[51](bibliography001.xhtml#endnote_51)]提供了有关实现细节及其重要性的良好参考资料。
- en: McIlroy [[323](bibliography001.xhtml#endnote_323)] shows how to engineer a “killer
    adversary” that produces an array on which virtually any implementation of quicksort
    takes Θ(*n*²) time.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: McIlroy[[323](bibliography001.xhtml#endnote_323)]展示了如何设计一个“杀手对手”，使得几乎任何快速排序实现在一个数组上花费Θ(*n*²)的时间。
- en: '[¹](#footnote_ref_1) You can enforce the assumption that the values in an array
    *A* are distinct at the cost of Θ(*n*) additional space and only constant overhead
    in running time by converting each input value *A*[*i*] to an ordered pair (*A*[*i*],
    *i*) with (*A*[*i*], *i*) < (*A*[*j*], *j*) if *A*[*i*] < *A*[*j*] or if *A*[*i*]
    = *A*[*j*] and *i* < *j*. There are also more practical variants of quicksort
    that work well when elements are not distinct.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: '[¹](#footnote_ref_1) 你可以通过将数组 *A* 中的值假定为不同来增加Θ(*n*)的额外空间成本，并且在运行时间中只有恒定的开销，方法是将每个输入值
    *A*[*i*] 转换为一个有序对 (*A*[*i*], *i*)，其中 (*A*[*i*], *i*) < (*A*[*j*], *j*)，如果 *A*[*i*]
    < *A*[*j*] 或者如果 *A*[*i*] = *A*[*j*] 且 *i* < *j*。当元素不是不同的时候，也有更实用的快速排序变体。'
