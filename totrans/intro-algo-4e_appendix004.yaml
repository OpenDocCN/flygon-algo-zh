- answer: '-   **`D` 矩阵**'
  en: '**D 矩阵**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **D 矩阵**  输出：'
  type: TYPE_NORMAL
  zh: '**`D` 矩阵**'
- answer: '-   矩阵在许多应用中出现，包括但不限于科学计算。如果您之前见过矩阵，那么本附录中的大部分内容对您来说将是熟悉的，但其中一些内容可能是新的。第
    `D.1` 节涵盖了基本矩阵定义和运算，而第 `D.2` 节介绍了一些基本矩阵性质。'
  en: 矩阵在许多应用中出现，包括但不限于科学计算。如果您之前见过矩阵，那么本附录中的大部分内容对您来说将是熟悉的，但其中一些内容可能是新的。第 D.1 节涵盖了基本矩阵定义和运算，而第
    D.2 节介绍了一些基本矩阵性质。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   矩阵在许多应用中出现，包括但不限于科学计算。如果您之前见过矩阵，那么本附录中的大部分内容对您来说将是熟悉的，但其中一些内容可能是新的。第
    D.1 节涵盖了基本矩阵定义和运算，而第 D.2 节介绍了一些基本矩阵性质。  输出：'
  type: TYPE_NORMAL
  zh: 矩阵在许多应用中出现，包括但不限于科学计算。如果您之前见过矩阵，那么本附录中的大部分内容对您来说将是熟悉的，但其中一些内容可能是新的。第 `D.1` 节涵盖了基本矩阵定义和运算，而第
    `D.2` 节介绍了一些基本矩阵性质。
- answer: '-   **`D.1` 矩阵和矩阵运算**'
  en: '**D.1 矩阵和矩阵运算**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **D.1 矩阵和矩阵运算**  输出：'
  type: TYPE_NORMAL
  zh: '**`D.1` 矩阵和矩阵运算**'
- answer: '-   本节回顾了矩阵理论的一些基本概念和矩阵的一些基本性质。'
  en: 本节回顾了矩阵理论的一些基本概念和矩阵的一些基本性质。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   本节回顾了矩阵理论的一些基本概念和矩阵的一些基本性质。  输出：'
  type: TYPE_NORMAL
  zh: 本节回顾了矩阵理论的一些基本概念和矩阵的一些基本性质。
- answer: '-   **`矩阵和向量`**'
  en: '**矩阵和向量**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **矩阵和向量**  输出：'
  type: TYPE_NORMAL
  zh: '**`矩阵和向量`**'
- answer: '-   一个`矩阵`是一个数字的矩形数组。例如，'
  en: 一个***矩阵***是一个数字的矩形数组。例如，
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   一个***矩阵***是一个数字的矩形数组。例如，  输出：'
  type: TYPE_NORMAL
  zh: 一个`矩阵`是一个数字的矩形数组。例如，
- answer: '---

    -   ![艺术](img/Art_P1768.jpg)'
  en: '![艺术](img/Art_P1768.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1768.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1768.jpg)'
- answer: '-   是一个 2 × 3 矩阵`A` = (`a[ij]`)，其中对于`i` = 1, 2 和`j` = 1, 2, 3，矩阵中第`i`行第`j`列的元素用`a[ij]`表示。按照惯例，大写字母表示矩阵，相应的带下标的小写字母表示它们的元素。我们用`ℝ^(m×n)`表示所有实值条目的*m*
    × *n*矩阵的集合，并且一般来说，用`S^(m×n)`表示条目来自集合`S`的*m* × *n*矩阵的集合。  '
  en: 是一个 2 × 3 矩阵*A* = (*a[ij]*)，其中对于*i* = 1, 2 和*j* = 1, 2, 3，矩阵中第*i*行第*j*列的元素用*a[ij]*表示。按照惯例，大写字母表示矩阵，相应的带下标的小写字母表示它们的元素。我们用ℝ^(*m*×*n*)表示所有实值条目的*m*
    × *n*矩阵的集合，并且一般来说，用*S*^(*m*×*n*)表示条目来自集合*S*的*m* × *n*矩阵的集合。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   是一个 2 × 3 矩阵*A*
    = (*a[ij]*)，其中对于*i* = 1, 2 和*j* = 1, 2, 3，矩阵中第*i*行第*j*列的元素用*a[ij]*表示。按照惯例，大写字母表示矩阵，相应的带下标的小写字母表示它们的元素。我们用ℝ^(*m*×*n*)表示所有实值条目的*m*
    × *n*矩阵的集合，并且一般来说，用*S*^(*m*×*n*)表示条目来自集合*S*的*m* × *n*矩阵的集合。  输出：'
  type: TYPE_NORMAL
  zh: '是一个 2 × 3 矩阵`A` = (`a[ij]`)，其中对于`i` = 1, 2 和`j` = 1, 2, 3，矩阵中第`i`行第`j`列的元素用`a[ij]`表示。按照惯例，大写字母表示矩阵，相应的带下标的小写字母表示它们的元素。我们用`ℝ^(m×n)`表示所有实值条目的*m*
    × *n*矩阵的集合，并且一般来说，用`S^(m×n)`表示条目来自集合`S`的*m* × *n*矩阵的集合。  '
- answer: '-   矩阵`A`的***转置***是通过交换矩阵`A`的行和列得到的矩阵`A`^T。对于方程(D.1)中的矩阵`A`，'
  en: 矩阵*A*的***转置***是通过交换矩阵*A*的行和列得到的矩阵*A*^T。对于方程(D.1)中的矩阵*A*，
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   矩阵*A*的***转置***是通过交换矩阵*A*的行和列得到的矩阵*A*^T。对于方程(D.1)中的矩阵*A*，  输出：'
  type: TYPE_NORMAL
  zh: 矩阵`A`的***转置***是通过交换矩阵`A`的行和列得到的矩阵`A`^T。对于方程(D.1)中的矩阵`A`，
- answer: '-   `![艺术](img/Art_P1769.jpg)`'
  en: '![艺术](img/Art_P1769.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1769.jpg)  输出：'
  type: TYPE_IMG
  zh: '`![艺术](img/Art_P1769.jpg)`'
- answer: '---

    -   一个`向量` 是一个数字的一维数组。例如，'
  en: 一个***向量*** 是一个数字的一维数组。例如，
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   一个***向量***
    是一个数字的一维数组。例如，  输出：'
  type: TYPE_NORMAL
  zh: 一个`向量` 是一个数字的一维数组。例如，
- answer: '---

    -   ![艺术](img/Art_P1770.jpg)'
  en: '![艺术](img/Art_P1770.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1770.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1770.jpg)'
- answer: '-   是一个大小为 3 的向量。我们有时将长度为`n`的向量称为***n-向量***。按照惯例，小写字母表示向量，大小为`n`的向量`x`的第`i`个元素用`x[i]`表示，其中`i`
    = 1, 2, … , `n`。我们将向量的标准形式视为等同于`n × 1`矩阵的***列向量***，而相应的***行向量***通过取转置得到：'
  en: 是一个大小为 3 的向量。我们有时将长度为*n*的向量称为***n-向量***。按照惯例，小写字母表示向量，大小为*n*的向量*x*的第*i*个元素用*x[i]*表示，其中*i*
    = 1, 2, … , *n*。我们将向量的标准形式视为等同于*n* × 1 矩阵的***列向量***，而相应的***行向量***通过取转置得到：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   是一个大小为 3 的向量。我们有时将长度为*n*的向量称为***n-向量***。按照惯例，小写字母表示向量，大小为*n*的向量*x*的第*i*个元素用*x[i]*表示，其中*i*
    = 1, 2, … , *n*。我们将向量的标准形式视为等同于*n* × 1 矩阵的***列向量***，而相应的***行向量***通过取转置得到：  输出：'
  type: TYPE_NORMAL
  zh: 是一个大小为 3 的向量。我们有时将长度为`n`的向量称为***n-向量***。按照惯例，小写字母表示向量，大小为`n`的向量`x`的第`i`个元素用`x[i]`表示，其中`i`
    = 1, 2, … , `n`。我们将向量的标准形式视为等同于`n × 1`矩阵的***列向量***，而相应的***行向量***通过取转置得到：
- answer: '---

    -   `x^T = ( 2 3 5 )`.

    ---'
  en: '*x*^T = ( 2 3 5 ).'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *x*^T = ( 2
    3 5 ).  输出：'
  type: TYPE_NORMAL
  zh: '`x^T = ( 2 3 5 )`.'
- answer: '---

    -   ***单位向量*** `e[i]` 是其第`i`个元素为 1 且所有其他元素为 0 的向量。通常，上下文会明确单位向量的大小。

    ---'
  en: '***单位向量*** *e[i]* 是其第*i*个元素为 1 且所有其他元素为 0 的向量。通常，上下文会明确单位向量的大小。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***单位向量*** *e[i]*
    是其第*i*个元素为 1 且所有其他元素为 0 的向量。通常，上下文会明确单位向量的大小。  输出：'
  type: TYPE_NORMAL
  zh: '***单位向量*** `e[i]` 是其第`i`个元素为 1 且所有其他元素为 0 的向量。通常，上下文会明确单位向量的大小。'
- answer: '---

    -   一个`零矩阵` 是所有条目都为 0 的矩阵。这样的矩阵通常用 0 表示，因为通常可以从上下文中解决数字 0 和全为 0 的矩阵之间的歧义。如果意图是一个全为
    0 的矩阵，则还需要从上下文中推导出矩阵的大小。'
  en: 一个***零矩阵*** 是所有条目都为 0 的矩阵。这样的矩阵通常用 0 表示，因为通常可以从上下文中解决数字 0 和全为 0 的矩阵之间的歧义。如果意图是一个全为
    0 的矩阵，则还需要从上下文中推导出矩阵的大小。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   一个***零矩阵***
    是所有条目都为 0 的矩阵。这样的矩阵通常用 0 表示，因为通常可以从上下文中解决数字 0 和全为 0 的矩阵之间的歧义。如果意图是一个全为 0 的矩阵，则还需要从上下文中推导出矩阵的大小。  输出：'
  type: TYPE_NORMAL
  zh: 一个`零矩阵` 是所有条目都为 0 的矩阵。这样的矩阵通常用 0 表示，因为通常可以从上下文中解决数字 0 和全为 0 的矩阵之间的歧义。如果意图是一个全为
    0 的矩阵，则还需要从上下文中推导出矩阵的大小。
- answer: '-   **`方阵`**  '
  en: '**方阵**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **方阵**  输出：'
  type: TYPE_NORMAL
  zh: '**`方阵`**  '
- en: '***方阵*** *n* × *n* 矩阵经常出现。方阵的几个特殊情况特别重要：'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***方阵*** *n*
    × *n* 矩阵经常出现。方阵的几个特殊情况特别重要：  输出：'
  type: TYPE_NORMAL
- answer: '-   1\. 一个`对角矩阵` 当*i* ≠ *j*时`a[ij]` = 0。因为所有非对角线元素为 0，因此指定矩阵的简洁方式仅列出沿对角线的元素：'
  en: 1\. 一个***对角矩阵*** 当*i* ≠ *j*时*a[ij]* = 0。因为所有非对角线元素为 0，因此指定矩阵的简洁方式仅列出沿对角线的元素：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   1\. 一个***对角矩阵***
    当*i* ≠ *j*时*a[ij]* = 0。因为所有非对角线元素为 0，因此指定矩阵的简洁方式仅列出沿对角线的元素：  输出：'
  type: TYPE_NORMAL
  zh: 1\. 一个`对角矩阵` 当*i* ≠ *j*时`a[ij]` = 0。因为所有非对角线元素为 0，因此指定矩阵的简洁方式仅列出沿对角线的元素：
- answer: '---

    -   ![艺术](img/Art_P1771.jpg)'
  en: '![艺术](img/Art_P1771.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1771.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1771.jpg)'
- answer: '-   2\. `n × n` ***单位矩阵*** `I[n]` 是沿对角线为 1 的对角矩阵：'
  en: 2\. *n* × *n* ***单位矩阵*** *I[n]* 是沿对角线为 1 的对角矩阵：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   2\. *n* × *n* ***单位矩阵*** *I[n]*
    是沿对角线为 1 的对角矩阵：  输出：'
  type: TYPE_NORMAL
  zh: 2\. `n × n` ***单位矩阵*** `I[n]` 是沿对角线为 1 的对角矩阵：
- answer: '---

    -   ![艺术](img/Art_P1772.jpg)'
  en: '![艺术](img/Art_P1772.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1772.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1772.jpg)'
- answer: '---

    -   当`I`没有下标时，其大小由上下文决定。单位矩阵的第`i`列是单位向量`e[i]`。'
  en: 当*I*没有下标时，其大小由上下文决定。单位矩阵的第*i*列是单位向量*e[i]*。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   当*I*没有下标时，其大小由上下文决定。单位矩阵的第*i*列是单位向量*e[i]*。  输出：'
  type: TYPE_NORMAL
  zh: 当`I`没有下标时，其大小由上下文决定。单位矩阵的第`i`列是单位向量`e[i]`。
- answer: '-   3\. 一个`三对角矩阵` *T* 是当|*i* − *j* | > 1 时`t[ij]` = 0 的矩阵。非零条目仅出现在主对角线上，主对角线上方（`t[i,i+1]`对于*i*
    = 1, 2, … , *n* − 1），或主对角线下方（`t[i+1,i]`对于*i* = 1, 2, … , *n* − 1）：  '
  en: 3\. 一个***三对角矩阵*** *T* 是当|*i* − *j* | > 1 时*t[ij]* = 0 的矩阵。非零条目仅出现在主对角线上，主对角线上方（*t*[*i,i*+1]对于*i*
    = 1, 2, … , *n* − 1），或主对角线下方（*t*[*i*+1,*i*]对于*i* = 1, 2, … , *n* − 1）：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   3\. 一个***三对角矩阵*** *T*
    是当|*i* − *j* | > 1 时*t[ij]* = 0 的矩阵。非零条目仅出现在主对角线上，主对角线上方（*t*[*i,i*+1]对于*i* = 1,
    2, … , *n* − 1），或主对角线下方（*t*[*i*+1,*i*]对于*i* = 1, 2, … , *n* − 1）：  输出：'
  type: TYPE_NORMAL
  zh: '3\. 一个`三对角矩阵` *T* 是当|*i* − *j* | > 1 时`t[ij]` = 0 的矩阵。非零条目仅出现在主对角线上，主对角线上方（`t[i,i+1]`对于*i*
    = 1, 2, … , *n* − 1），或主对角线下方（`t[i+1,i]`对于*i* = 1, 2, … , *n* − 1）：  '
- answer: '---

    -   ![艺术](img/Art_P1773.jpg)'
  en: '![艺术](img/Art_P1773.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1773.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1773.jpg)'
- answer: '-   4\. 一个***上三角矩阵*** `U` 是当`i` > `j`时`u[ij]` = 0 的矩阵。对角线以下的所有条目为 0：'
  en: 4\. 一个***上三角矩阵*** *U* 是当*i* > *j*时*u[ij]* = 0 的矩阵。对角线以下的所有条目为 0：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   4\. 一个***上三角矩阵*** *U*
    是当*i* > *j*时*u[ij]* = 0 的矩阵。对角线以下的所有条目为 0：  输出：'
  type: TYPE_NORMAL
  zh: 4\. 一个***上三角矩阵*** `U` 是当`i` > `j`时`u[ij]` = 0 的矩阵。对角线以下的所有条目为 0：
- answer: '-   ![艺术](img/Art_P1774.jpg)'
  en: '![艺术](img/Art_P1774.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1774.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1774.jpg)'
- answer: '-   如果上三角矩阵沿对角线具有全部为 1 的元素，则称为***单位上三角矩阵***。'
  en: 如果上三角矩阵沿对角线具有全部为 1 的元素，则称为***单位上三角矩阵***。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   如果上三角矩阵沿对角线具有全部为
    1 的元素，则称为***单位上三角矩阵***。  输出：'
  type: TYPE_NORMAL
  zh: 如果上三角矩阵沿对角线具有全部为 1 的元素，则称为***单位上三角矩阵***。
- answer: '-   5\. 一个***下三角矩阵*** *`L`* 是当*i* < *j*时`l[ij]` = 0 的矩阵。对角线以上的所有条目为 0：  '
  en: 5\. 一个***下三角矩阵*** *L* 是当*i* < *j*时*l[ij]* = 0 的矩阵。对角线以上的所有条目为 0：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   5\. 一个***下三角矩阵*** *L*
    是当*i* < *j*时*l[ij]* = 0 的矩阵。对角线以上的所有条目为 0：  输出：'
  type: TYPE_NORMAL
  zh: '5\. 一个***下三角矩阵*** *`L`* 是当*i* < *j*时`l[ij]` = 0 的矩阵。对角线以上的所有条目为 0：  '
- answer: '---

    -   ![艺术](img/Art_P1775.jpg)'
  en: '![艺术](img/Art_P1775.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1775.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1775.jpg)'
- answer: '---

    -   一个下三角矩阵如果沿对角线具有全部为 1 的元素，则称为***单位下三角矩阵***。'
  en: 一个下三角矩阵如果沿对角线具有全部为 1 的元素，则称为***单位下三角矩阵***。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   一个下三角矩阵如果沿对角线具有全部为
    1 的元素，则称为***单位下三角矩阵***。  输出：'
  type: TYPE_NORMAL
  zh: 一个下三角矩阵如果沿对角线具有全部为 1 的元素，则称为***单位下三角矩阵***。
- answer: '-   6\. 一个***置换矩阵*** `P` 每行或每列恰好有一个 1，其他位置为 0。置换矩阵的一个示例是'
  en: 6\. 一个***置换矩阵*** *P* 每行或每列恰好有一个 1，其他位置为 0。置换矩阵的一个示例是
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   6\. 一个***置换矩阵*** *P*
    每行或每列恰好有一个 1，其他位置为 0。置换矩阵的一个示例是  输出：'
  type: TYPE_NORMAL
  zh: 6\. 一个***置换矩阵*** `P` 每行或每列恰好有一个 1，其他位置为 0。置换矩阵的一个示例是
- answer: '```

    -   ![艺术](img/Art_P1776.jpg)

    ```'
  en: '![艺术](img/Art_P1776.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1776.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1776.jpg)'
- answer: '-   这样的矩阵称为置换矩阵，因为将向量`x`乘以置换矩阵的效果是对`x`的元素进行置换（重新排列）。练习 D.1-4 探讨了置换矩阵的其他性质。'
  en: 这样的矩阵称为置换矩阵，因为将向量*x*乘以置换矩阵的效果是对*x*的元素进行置换（重新排列）。练习 D.1-4 探讨了置换矩阵的其他性质。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   这样的矩阵称为置换矩阵，因为将向量*x*乘以置换矩阵的效果是对*x*的元素进行置换（重新排列）。练习
    D.1-4 探讨了置换矩阵的其他性质。  输出：'
  type: TYPE_NORMAL
  zh: 这样的矩阵称为置换矩阵，因为将向量`x`乘以置换矩阵的效果是对`x`的元素进行置换（重新排列）。练习 D.1-4 探讨了置换矩阵的其他性质。
- answer: '-   7\. 一个***对称矩阵*** `A` 满足条件 `A = A^T`。例如，'
  en: 7\. 一个***对称矩阵*** *A* 满足条件 *A* = *A*^T。例如，
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   7\. 一个***对称矩阵*** *A*
    满足条件 *A* = *A*^T。例如，  输出：'
  type: TYPE_NORMAL
  zh: 7\. 一个***对称矩阵*** `A` 满足条件 `A = A^T`。例如，
- en: '![艺术](img/Art_P1777.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1777.jpg)  输出：'
  type: TYPE_IMG
- answer: '-   是一个对称矩阵。'
  en: 是一个对称矩阵。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   是一个对称矩阵。  输出：'
  type: TYPE_NORMAL
  zh: 是一个对称矩阵。
- en: '**基本矩阵运算**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **基本矩阵运算**  输出：'
  type: TYPE_NORMAL
- answer: '-   矩阵或向量的元素是来自数字系统的`标量数`，例如实数、复数或模素数。数字系统定义了如何对标量进行加法和乘法。这些定义扩展到包括矩阵的加法和乘法。'
  en: 矩阵或向量的元素是来自数字系统的***标量数***，例如实数、复数或模素数。数字系统定义了如何对标量进行加法和乘法。这些定义扩展到包括矩阵的加法和乘法。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   矩阵或向量的元素是来自数字系统的***标量数***，例如实数、复数或模素数。数字系统定义了如何对标量进行加法和乘法。这些定义扩展到包括矩阵的加法和乘法。  输出：'
  type: TYPE_NORMAL
  zh: 矩阵或向量的元素是来自数字系统的`标量数`，例如实数、复数或模素数。数字系统定义了如何对标量进行加法和乘法。这些定义扩展到包括矩阵的加法和乘法。
- answer: '---

    -   我们定义***矩阵加法***如下。如果`A = (a[ij])`和`B = (b[ij])`是`m × n`矩阵，那么它们的矩阵和`C = (c[ij])
    = A + B`是由下式定义的`m × n`矩阵'
  en: 我们定义***矩阵加法***如下。如果*A* = (*a[ij]*)和*B* = (*b[ij]*)是*m* × *n*矩阵，那么它们的矩阵和*C* =
    (*c[ij]*) = *A* + *B*是由下式定义的*m* × *n*矩阵
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   我们定义***矩阵加法***如下。如果*A*
    = (*a[ij]*)和*B* = (*b[ij]*)是*m* × *n*矩阵，那么它们的矩阵和*C* = (*c[ij]*) = *A* + *B*是由下式定义的*m*
    × *n*矩阵  输出：'
  type: TYPE_NORMAL
  zh: 我们定义***矩阵加法***如下。如果`A = (a[ij])`和`B = (b[ij])`是`m × n`矩阵，那么它们的矩阵和`C = (c[ij])
    = A + B`是由下式定义的`m × n`矩阵
- answer: '-   `c[ij]` = `a[ij]` + `b[ij]`'
  en: '*c[ij]* = *a[ij]* + *b[ij]*'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *c[ij]* = *a[ij]*
    + *b[ij]*  输出：'
  type: TYPE_NORMAL
  zh: '`c[ij]` = `a[ij]` + `b[ij]`'
- answer: '-   对于`i = 1, 2, … , m`和`j = 1, 2, … , n`。也就是说，矩阵加法是逐分量执行的。零矩阵是矩阵加法的单位元：'
  en: 对于*i* = 1, 2, … , *m*和*j* = 1, 2, … , *n*。也就是说，矩阵加法是逐分量执行的。零矩阵是矩阵加法的单位元：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于*i* = 1,
    2, … , *m*和*j* = 1, 2, … , *n*。也就是说，矩阵加法是逐分量执行的。零矩阵是矩阵加法的单位元：  输出：'
  type: TYPE_NORMAL
  zh: 对于`i = 1, 2, … , m`和`j = 1, 2, … , n`。也就是说，矩阵加法是逐分量执行的。零矩阵是矩阵加法的单位元：
- answer: '-   `A + 0 = A = 0 + A`.'
  en: '*A* + 0 = *A* = 0 + *A*.'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *A* + 0 = *A*
    = 0 + *A*.  输出：'
  type: TYPE_NORMAL
  zh: '`A + 0 = A = 0 + A`.'
- answer: '-   如果`λ`是一个标量数，`A` = (`a[ij]`)是一个矩阵，那么`λA` = (`λa[ij]`)是通过将其每个元素乘以`λ`获得的矩阵的***标量倍数***。作为一个特例，我们定义矩阵`A`
    = (`a[ij]`)的***负***为−1 · `A` = −`A`，因此−`A`的`ij`项为−`a[ij]`。因此，'
  en: 如果*λ*是一个标量数，*A* = (*a[ij]*)是一个矩阵，那么*λA* = (*λa[ij]*)是通过将其每个元素乘以*λ*获得的矩阵的***标量倍数***。作为一个特例，我们定义矩阵*A*
    = (*a[ij]*)的***负***为−1 · *A* = −*A*，因此−*A*的*ij*项为−*a[ij]*。因此，
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   如果*λ*是一个标量数，*A*
    = (*a[ij]*)是一个矩阵，那么*λA* = (*λa[ij]*)是通过将其每个元素乘以*λ*获得的矩阵的***标量倍数***。作为一个特例，我们定义矩阵*A*
    = (*a[ij]*)的***负***为−1 · *A* = −*A*，因此−*A*的*ij*项为−*a[ij]*。因此，  输出：'
  type: TYPE_NORMAL
  zh: 如果`λ`是一个标量数，`A` = (`a[ij]`)是一个矩阵，那么`λA` = (`λa[ij]`)是通过将其每个元素乘以`λ`获得的矩阵的***标量倍数***。作为一个特例，我们定义矩阵`A`
    = (`a[ij]`)的***负***为−1 · `A` = −`A`，因此−`A`的`ij`项为−`a[ij]`。因此，
- answer: '-   `A + (-A) = 0 = (-A) + A`.'
  en: '*A* + (−*A*) = 0 = (−*A*) + *A*.'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *A* + (−*A*)
    = 0 = (−*A*) + *A*.  输出：'
  type: TYPE_NORMAL
  zh: '`A + (-A) = 0 = (-A) + A`.'
- answer: '```

    -   矩阵的负定义了***矩阵减法***：`A - B = A + (-B)`。

    ```'
  en: 矩阵的负定义了***矩阵减法***：*A* − *B* = *A* + (−*B*)。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   矩阵的负定义了***矩阵减法***：*A*
    − *B* = *A* + (−*B*)。  输出：'
  type: TYPE_NORMAL
  zh: 矩阵的负定义了***矩阵减法***：`A - B = A + (-B)`。
- answer: '-   我们定义***矩阵乘法***如下。从两个矩阵`A`和`B`开始，这两个矩阵在列数等于`B`的行数的意义上是***兼容的***。（通常，包含矩阵乘积`AB`的表达式总是假定矩阵`A`和`B`是兼容的。）如果`A`
    = (`a[ik]`)是一个*p* × *q*矩阵，`B` = (`b[kj]`)是一个*q* × *r*矩阵，那么它们的矩阵乘积`C` = `AB`是一个*p*
    × *r*矩阵，其中  '
  en: 我们定义***矩阵乘法***如下。从两个矩阵*A*和*B*开始，这两个矩阵在列数等于*B*的行数的意义上是***兼容的***。（通常，包含矩阵乘积*AB*的表达式总是假定矩阵*A*和*B*是兼容的。）如果*A*
    = (*a[ik]*)是一个*p* × *q*矩阵，*B* = (*b[kj]*)是一个*q* × *r*矩阵，那么它们的矩阵乘积*C* = *AB*是一个*p*
    × *r*矩阵，其中
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   我们定义***矩阵乘法***如下。从两个矩阵*A*和*B*开始，这两个矩阵在列数等于*B*的行数的意义上是***兼容的***。（通常，包含矩阵乘积*AB*的表达式总是假定矩阵*A*和*B*是兼容的。）如果*A*
    = (*a[ik]*)是一个*p* × *q*矩阵，*B* = (*b[kj]*)是一个*q* × *r*矩阵，那么它们的矩阵乘积*C* = *AB*是一个*p*
    × *r*矩阵，其中  输出：'
  type: TYPE_NORMAL
  zh: '我们定义***矩阵乘法***如下。从两个矩阵`A`和`B`开始，这两个矩阵在列数等于`B`的行数的意义上是***兼容的***。（通常，包含矩阵乘积`AB`的表达式总是假定矩阵`A`和`B`是兼容的。）如果`A`
    = (`a[ik]`)是一个*p* × *q*矩阵，`B` = (`b[kj]`)是一个*q* × *r*矩阵，那么它们的矩阵乘积`C` = `AB`是一个*p*
    × *r*矩阵，其中  '
- answer: '---

    -   ![艺术](img/Art_P1778.jpg)'
  en: '![艺术](img/Art_P1778.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1778.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1778.jpg)'
- answer: '-   对于`i = 1, 2, … , m`和`j = 1, 2, … , p`。第 374 页的 RECTANGULAR-MATRIX-MULTIPLY
    过程根据方程(D.2)以直接的方式实现矩阵乘法，假设`C`初始化为 0，使用`pqr`次乘法和`p(q - 1)r`次加法，运行时间为Θ(`pqr`)。如果矩阵是`n×n`方阵，使得`n
    = p = q = r`，则伪代码简化为第 81 页的 MATRIX-MULTIPLY，其运行时间为Θ(`n³`)。(第 4.2 节描述了一个由 V. Strassen
    提出的渐进更快的Θ(`n^(lg7)`)时间算法。)  '
  en: 对于*i* = 1, 2, … , *m*和*j* = 1, 2, … , *p*。第 374 页的 RECTANGULAR-MATRIX-MULTIPLY
    过程根据方程(D.2)以直接的方式实现矩阵乘法，假设*C*初始化为 0，使用*pqr*次乘法和*p*(*q* − 1)*r*次加法，运行时间为Θ(*pqr*)。如果矩阵是*n*×*n*方阵，使得*n*
    = *p* = *q* = *r*，则伪代码简化为第 81 页的 MATRIX-MULTIPLY，其运行时间为Θ(*n*³)。(第 4.2 节描述了一个由
    V. Strassen 提出的渐进更快的Θ(*n*^(lg7))时间算法。)
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于*i* = 1,
    2, … , *m*和*j* = 1, 2, … , *p*。第 374 页的 RECTANGULAR-MATRIX-MULTIPLY 过程根据方程(D.2)以直接的方式实现矩阵乘法，假设*C*初始化为
    0，使用*pqr*次乘法和*p*(*q* − 1)*r*次加法，运行时间为Θ(*pqr*)。如果矩阵是*n*×*n*方阵，使得*n* = *p* = *q*
    = *r*，则伪代码简化为第 81 页的 MATRIX-MULTIPLY，其运行时间为Θ(*n*³)。(第 4.2 节描述了一个由 V. Strassen
    提出的渐进更快的Θ(*n*^(lg7))时间算法。)  输出：'
  type: TYPE_NORMAL
  zh: '对于`i = 1, 2, … , m`和`j = 1, 2, … , p`。第 374 页的 RECTANGULAR-MATRIX-MULTIPLY
    过程根据方程(D.2)以直接的方式实现矩阵乘法，假设`C`初始化为 0，使用`pqr`次乘法和`p(q - 1)r`次加法，运行时间为Θ(`pqr`)。如果矩阵是`n×n`方阵，使得`n
    = p = q = r`，则伪代码简化为第 81 页的 MATRIX-MULTIPLY，其运行时间为Θ(`n³`)。(第 4.2 节描述了一个由 V. Strassen
    提出的渐进更快的Θ(`n^(lg7)`)时间算法。)  '
- answer: '-   矩阵具有许多（但不是全部）类似于数字的代数性质。单位矩阵是矩阵乘法的单位元：'
  en: 矩阵具有许多（但不是全部）类似于数字的代数性质。单位矩阵是矩阵乘法的单位元：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   矩阵具有许多（但不是全部）类似于数字的代数性质。单位矩阵是矩阵乘法的单位元：  输出：'
  type: TYPE_NORMAL
  zh: 矩阵具有许多（但不是全部）类似于数字的代数性质。单位矩阵是矩阵乘法的单位元：
- answer: '-   `I[m]A = AI[n] = A`'
  en: '*I[m]A* = *AI[n]* = *A*'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *I[m]A* = *AI[n]*
    = *A*  输出：'
  type: TYPE_NORMAL
  zh: '`I[m]A = AI[n] = A`'
- answer: '```

    -   对于任意`m * n`矩阵`A`。乘以零矩阵得到零矩阵：

    ```'
  en: 对于任意*m* × *n*矩阵*A*。乘以零矩阵得到零矩阵：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于任意*m* × *n*矩阵*A*。乘以零矩阵得到零矩阵：  输出：'
  type: TYPE_NORMAL
  zh: 对于任意`m * n`矩阵`A`。乘以零矩阵得到零矩阵：
- answer: '-   `A * 0 = 0.`'
  en: '*A* · 0 = 0.'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *A* · 0 = 0.  输出：'
  type: TYPE_NORMAL
  zh: '`A * 0 = 0.`'
- answer: '-   矩阵乘法是结合的：'
  en: 矩阵乘法是结合的：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   矩阵乘法是结合的：  输出：'
  type: TYPE_NORMAL
  zh: 矩阵乘法是结合的：
- answer: '-   `A(BC) = (AB)C`'
  en: '*A*(*BC*) = (*AB*)*C*'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *A*(*BC*) =
    (*AB*)*C*  输出：'
  type: TYPE_NORMAL
  zh: '`A(BC) = (AB)C`'
- answer: '```

    -   对于兼容的矩阵`A`、`B`和`C`。矩阵乘法分配于加法：

    ```'
  en: 对于兼容的矩阵*A*、*B*和*C*。矩阵乘法分配于加法：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于兼容的矩阵*A*、*B*和*C*。矩阵乘法分配于加法：  输出：'
  type: TYPE_NORMAL
  zh: 对于兼容的矩阵`A`、`B`和`C`。矩阵乘法分配于加法：
- answer: '-   | `A(B + C)` | = | `AB + AC`, |'
  en: '| *A*(*B* + *C*) | = | *AB* + *AC*, |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *A*(*B* +
    *C*) | = | *AB* + *AC*, |  输出：'
  type: TYPE_TB
  zh: '| `A(B + C)` | = | `AB + AC`, |'
- answer: '-   | --- | --- | --- |'
  en: '| --- | --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | --- | ---
    | --- |  输出：'
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- answer: '-   | (`B` + `C`)*D* | = | `BD` + `CD`. |'
  en: '| (*B* + *C*)*D* | = | *BD* + *CD*. |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | (*B* + *C*)*D*
    | = | *BD* + *CD*. |  输出：'
  type: TYPE_TB
  zh: '| (`B` + `C`)*D* | = | `BD` + `CD`. |'
- answer: '-   对于`n` > 1，`n` × `n`矩阵的乘法不是交换的。例如，如果![艺术](img/Art_P1779.jpg)和![艺术](img/Art_P1780.jpg)，那么![艺术](img/Art_P1781.jpg)和![艺术](img/Art_P1782.jpg)。'
  en: 对于*n* > 1，*n* × *n*矩阵的乘法不是交换的。例如，如果![艺术](img/Art_P1779.jpg)和![艺术](img/Art_P1780.jpg)，那么![艺术](img/Art_P1781.jpg)和![艺术](img/Art_P1782.jpg)。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于*n* > 1，*n*
    × *n*矩阵的乘法不是交换的。例如，如果![艺术](img/Art_P1779.jpg)和![艺术](img/Art_P1780.jpg)，那么![艺术](img/Art_P1781.jpg)和![艺术](img/Art_P1782.jpg)。  输出：'
  type: TYPE_NORMAL
  zh: 对于`n` > 1，`n` × `n`矩阵的乘法不是交换的。例如，如果![艺术](img/Art_P1779.jpg)和![艺术](img/Art_P1780.jpg)，那么![艺术](img/Art_P1781.jpg)和![艺术](img/Art_P1782.jpg)。
- answer: '-   我们将矩阵-向量乘积或向量-向量乘积定义为如果向量等同于`n × 1` 矩阵（或者在行向量的情况下为 `1 × n` 矩阵）。因此，如果`A`
    是一个`m × n`矩阵，`x` 是一个`n`-向量，那么 `Ax` 就是一个`m`-向量。如果`x` 和 `y` 是`n`-向量，那么'
  en: 我们将矩阵-向量乘积或向量-向量乘积定义为如果向量等同于*n* × 1 矩阵（或者在行向量的情况下为 1 × *n*矩阵）。因此，如果*A*是一个*m*
    × *n*矩阵，*x*是一个*n*-向量，那么*Ax*就是一个*m*-向量。如果*x*和*y*是*n*-向量，那么
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   我们将矩阵-向量乘积或向量-向量乘积定义为如果向量等同于*n*
    × 1 矩阵（或者在行向量的情况下为 1 × *n*矩阵）。因此，如果*A*是一个*m* × *n*矩阵，*x*是一个*n*-向量，那么*Ax*就是一个*m*-向量。如果*x*和*y*是*n*-向量，那么  输出：'
  type: TYPE_NORMAL
  zh: 我们将矩阵-向量乘积或向量-向量乘积定义为如果向量等同于`n × 1` 矩阵（或者在行向量的情况下为 `1 × n` 矩阵）。因此，如果`A` 是一个`m
    × n`矩阵，`x` 是一个`n`-向量，那么 `Ax` 就是一个`m`-向量。如果`x` 和 `y` 是`n`-向量，那么
- answer: '---

    -   ![艺术](img/Art_P1783.jpg)'
  en: '![艺术](img/Art_P1783.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1783.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1783.jpg)'
- answer: '-   是一个标量数（实际上是一个 1 × 1 矩阵），称为`x`和`y`的***内积***。我们还使用记号〈`x`, `y`〉表示`x`^T`y`。内积运算符是可交换的：〈`x`,
    `y`〉 = 〈`y`, `x`〉。矩阵`xy`^T 是一个`n` × `n`矩阵`Z`，称为`x`和`y`的***外积***，其中`z[ij]` = `x[i]y[j]`。`n`维向量`x`的***(欧几里得)范数***
    ∥`x`∥的定义为'
  en: 是一个标量数（实际上是一个 1 × 1 矩阵），称为*x*和*y*的***内积***。我们还使用记号〈*x*, *y*〉表示*x*^T*y*。内积运算符是可交换的：〈*x*,
    *y*〉 = 〈*y*, *x*〉。矩阵*xy*^T 是一个*n* × *n*矩阵*Z*，称为*x*和*y*的***外积***，其中*z[ij]* = *x[i]y[j]*。*n*维向量*x*的***(欧几里得)范数***
    ∥*x*∥的定义为
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   是一个标量数（实际上是一个
    1 × 1 矩阵），称为*x*和*y*的***内积***。我们还使用记号〈*x*, *y*〉表示*x*^T*y*。内积运算符是可交换的：〈*x*, *y*〉
    = 〈*y*, *x*〉。矩阵*xy*^T 是一个*n* × *n*矩阵*Z*，称为*x*和*y*的***外积***，其中*z[ij]* = *x[i]y[j]*。*n*维向量*x*的***(欧几里得)范数***
    ∥*x*∥的定义为  输出：'
  type: TYPE_NORMAL
  zh: 是一个标量数（实际上是一个 1 × 1 矩阵），称为`x`和`y`的***内积***。我们还使用记号〈`x`, `y`〉表示`x`^T`y`。内积运算符是可交换的：〈`x`,
    `y`〉 = 〈`y`, `x`〉。矩阵`xy`^T 是一个`n` × `n`矩阵`Z`，称为`x`和`y`的***外积***，其中`z[ij]` = `x[i]y[j]`。`n`维向量`x`的***(欧几里得)范数***
    ∥`x`∥的定义为
- answer: '-   `![艺术](img/Art_P1784.jpg)`'
  en: '![艺术](img/Art_P1784.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1784.jpg)  输出：'
  type: TYPE_IMG
  zh: '`![艺术](img/Art_P1784.jpg)`'
- answer: '-   因此，`x`的范数是它在n维欧几里得空间中的长度。一个有用的事实，根据等式'
  en: 因此，*x*的范数是它在*n*维欧几里得空间中的长度。一个有用的事实，根据等式
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   因此，*x*的范数是它在*n*维欧几里得空间中的长度。一个有用的事实，根据等式  输出：'
  type: TYPE_NORMAL
  zh: 因此，`x`的范数是它在n维欧几里得空间中的长度。一个有用的事实，根据等式
- answer: '```

    -   ![艺术](img/Art_P1785.jpg)

    ```'
  en: '![艺术](img/Art_P1785.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1785.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1785.jpg)'
- answer: '-   对于任意实数`a`和`n`维向量`x`，'
  en: 对于任意实���*a*和*n*维向量*x*，
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于任意实���*a*和*n*维向量*x*，  输出：'
  type: TYPE_NORMAL
  zh: 对于任意实数`a`和`n`维向量`x`，
- answer: '```

    -   ![艺术](img/Art_P1786.jpg)

    ```'
  en: '![艺术](img/Art_P1786.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1786.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1786.jpg)'
- answer: '-   **`练习`**  '
  en: '**练习**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **练习**  输出：'
  type: TYPE_NORMAL
  zh: '**`练习`**  '
- answer: '-   `D.1-1`'
  en: '***D.1-1***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***D.1-1***  输出：'
  type: TYPE_NORMAL
  zh: '`D.1-1`'
- answer: '-   表明如果`A`和`B`是对称的`n × n`矩阵，则`A + B`和`A - B`也是对称的。'
  en: 表明如果*A*和*B*是对称的*n* × *n*矩阵，则*A* + *B*和*A* − *B*也是对称的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   表明如果*A*和*B*是对称的*n*
    × *n*矩阵，则*A* + *B*和*A* − *B*也是对称的。  输出：'
  type: TYPE_NORMAL
  zh: 表明如果`A`和`B`是对称的`n × n`矩阵，则`A + B`和`A - B`也是对称的。
- answer: '---

    -   ***D.1-2***'
  en: '***D.1-2***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***D.1-2***  输出：'
  type: TYPE_NORMAL
  zh: '***D.1-2***'
- answer: '-   证明(`AB`)^T = `B`^T`A`^T 以及`A`^T`A`始终是对称矩阵。  '
  en: 证明(*AB*)^T = *B*^T*A*^T 以及*A*^T*A*始终是对称矩阵。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   证明(*AB*)^T
    = *B*^T*A*^T 以及*A*^T*A*始终是对称矩阵。  输出：'
  type: TYPE_NORMAL
  zh: '证明(`AB`)^T = `B`^T`A`^T 以及`A`^T`A`始终是对称矩阵。  '
- answer: '---

    -   ***D.1-3***


    ---'
  en: '***D.1-3***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***D.1-3***  输出：'
  type: TYPE_NORMAL
  zh: '***D.1-3***'
- answer: '-   证明两个下三角矩阵的乘积仍为下三角矩阵。'
  en: 证明两个下三角矩阵的乘积仍为下三角矩阵。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   证明两个下三角矩阵的乘积仍为下三角矩阵。  输出：'
  type: TYPE_NORMAL
  zh: 证明两个下三角矩阵的乘积仍为下三角矩阵。
- answer: '---

    -   ***D.1-4***'
  en: '***D.1-4***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***D.1-4***  输出：'
  type: TYPE_NORMAL
  zh: '***D.1-4***'
- answer: '-   证明如果`P`是一个`n` × `n`置换矩阵，`A`是一个`n` × `n`矩阵，则矩阵乘积`PA`是`A`的行置换，矩阵乘积`AP`是`A`的列置换。证明两个置换矩阵的乘积是一个置换矩阵。'
  en: 证明如果*P*是一个*n* × *n*置换矩阵，*A*是一个*n* × *n*矩阵，则矩阵乘积*PA*是*A*的行置换，矩阵乘积*AP*是*A*的列置换。证明两个置换矩阵的乘积是一个置换矩阵。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   证明如果*P*是一个*n*
    × *n*置换矩阵，*A*是一个*n* × *n*矩阵，则矩阵乘积*PA*是*A*的行置换，矩阵乘积*AP*是*A*的列置换。证明两个置换矩阵的乘积是一个置换矩阵。  输出：'
  type: TYPE_NORMAL
  zh: 证明如果`P`是一个`n` × `n`置换矩阵，`A`是一个`n` × `n`矩阵，则矩阵乘积`PA`是`A`的行置换，矩阵乘积`AP`是`A`的列置换。证明两个置换矩阵的乘积是一个置换矩阵。
- answer: '---

    -   **D.2 基本矩阵属性**'
  en: '**D.2 基本矩阵属性**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **D.2 基本矩阵属性**  输出：'
  type: TYPE_NORMAL
  zh: '**D.2 基本矩阵属性**'
- answer: '-   现在我们定义一些关于矩阵的基本属性：逆、线性相关和无关、秩和行列式。我们还定义了正定矩阵类。'
  en: 现在我们定义一些关于矩阵的基本属性：逆、线性相关和无关、秩和行列式。我们还定义了正定矩阵类。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   现在我们定义一些关于矩阵的基本属性：逆、线性相关和无关、秩和行列式。我们还定义了正定矩阵类。  输出：'
  type: TYPE_NORMAL
  zh: 现在我们定义一些关于矩阵的基本属性：逆、线性相关和无关、秩和行列式。我们还定义了正定矩阵类。
- answer: '-   **矩阵的逆、秩和行列式**'
  en: '**矩阵的逆、秩和行列式**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **矩阵的逆、秩和行列式**  输出：'
  type: TYPE_NORMAL
  zh: '**矩阵的逆、秩和行列式**'
- answer: '-   `n` × `n`矩阵`A`的***逆***是一个`n` × `n`矩阵，记为`A^(−1)`（如果存在），满足`AA^(−1) =
    I[n] = A^(−1)A`。例如，'
  en: '*n* × *n*矩阵*A*的***逆***是一个*n* × *n*矩阵，记为*A*^(−1)（如果存在），满足*AA*^(−1) = *I[n]*
    = *A*^(−1)*A*。例如，'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *n* × *n*矩阵*A*的***逆***是一个*n*
    × *n*矩阵，记为*A*^(−1)（如果存在），满足*AA*^(−1) = *I[n]* = *A*^(−1)*A*。例如，  输出：'
  type: TYPE_NORMAL
  zh: '`n` × `n`矩阵`A`的***逆***是一个`n` × `n`矩阵，记为`A^(−1)`（如果存在），满足`AA^(−1) = I[n] = A^(−1)A`。例如，'
- answer: '-   `![艺术](img/Art_P1787.jpg)`'
  en: '![艺术](img/Art_P1787.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1787.jpg)  输出：'
  type: TYPE_IMG
  zh: '`![艺术](img/Art_P1787.jpg)`'
- answer: '---

    -   许多非零`n × n`矩阵没有逆。没有逆的矩阵称为***不可逆***或***奇异***。一个例子是'
  en: 许多非零*n* × *n*矩阵没有逆。没有逆的矩阵称为***不可逆***或***奇异***。一个例子是
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   许多非零*n* × *n*矩阵没有逆。没有逆的矩阵称为***不可逆***或***奇异***。一个例子是  输出：'
  type: TYPE_NORMAL
  zh: 许多非零`n × n`矩阵没有逆。没有逆的矩阵称为***不可逆***或***奇异***。一个例子是
- answer: '-   `![艺术](img/Art_P1788.jpg)`'
  en: '![艺术](img/Art_P1788.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1788.jpg)  输出：'
  type: TYPE_IMG
  zh: '`![艺术](img/Art_P1788.jpg)`'
- answer: '---

    -   如果一个矩阵有逆，那么它被称为`可逆`或`非奇异`。矩阵的逆，如果存在，是唯一的。（参见练习 D.2-1。）如果`A`和`B`是非奇异的*n* ×
    *n*矩阵，则  '
  en: 如果一个矩阵有逆，那么它被称为***可逆***或***非奇异***。矩阵的逆，如果存在，是唯一的。（参见练习 D.2-1。）如果*A*和*B*是非奇异的*n*
    × *n*矩阵，则
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   如果一个矩阵有逆，那么它被称为***可逆***或***非奇异***。矩阵的逆，如果存在，是唯一的。（参见练习
    D.2-1。）如果*A*和*B*是非奇异的*n* × *n*矩阵，则  输出：'
  type: TYPE_NORMAL
  zh: '如果一个矩阵有逆，那么它被称为`可逆`或`非奇异`。矩阵的逆，如果存在，是唯一的。（参见练习 D.2-1。）如果`A`和`B`是非奇异的*n* × *n*矩阵，则  '
- answer: '-   `BA`^(-1) = `A`^(-1)`B`^(-1)。  '
  en: (*BA*)^(−1) = *A*^(−1)*B*^(−1)。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   (*BA*)^(−1)
    = *A*^(−1)*B*^(−1)。  输出：'
  type: TYPE_NORMAL
  zh: '`BA`^(-1) = `A`^(-1)`B`^(-1)。  '
- answer: '-   逆运算与转置运算可交换：'
  en: 逆运算与转置运算可交换：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   逆运算与转置运算可交换：  输出：'
  type: TYPE_NORMAL
  zh: 逆运算与转置运算可交换：
- answer: '-   `(*A*^(-1))^T = (*A*^T)^(-1).`  '
  en: (*A*^(−1))^T = (*A*^T)^(−1).
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   (*A*^(−1))^T
    = (*A*^T)^(−1).  输出：'
  type: TYPE_NORMAL
  zh: '`(*A*^(-1))^T = (*A*^T)^(-1).`  '
- answer: '-   如果存在系数 `c[1]`, `c[2]`, … , `c[n]`，不全为 0，使得 `c[1]*x[1] + c[2]*x[2] +
    ⋯ + c[n]x[n] = 0`，那么向量 `x[1]`, `x[2]`, … , `x[n]` ***线性相关***。例如，行向量 `x[1] = (
    1 2 3 )`，`x[2] = ( 2 6 4 )`，和 `x[3] = ( 4 11 9 )` 是线性相关的，因为 `2*x[1]+3*x[2]−2*x[3]
    = 0`。如果向量不是线性相关，则它们是***线性无关***的。例如，单位矩阵的列是线性无关的。  '
  en: 如果存在系数 *c*[1], *c*[2], … , *c[n]*，不全为 0，使得 *c*[1]*x*[1] + *c*[2]*x*[2] + ⋯ +
    *c[n]x[n]* = 0，那么向量 *x*[1], *x*[2], … , *x[n]* ***线性相关***。例如，行向量 *x*[1] = ( 1
    2 3 )，*x*[2] = ( 2 6 4 )，和 *x*[3] = ( 4 11 9 ) 是线性相关的，因为 2*x*[1]+3*x*[2]−2*x*[3]
    = 0。如果向量不是线性相关，则它们是***线性无关***的。例如，单位矩阵的列是线性无关的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   如果存在系数 *c*[1],
    *c*[2], … , *c[n]*，不全为 0，使得 *c*[1]*x*[1] + *c*[2]*x*[2] + ⋯ + *c[n]x[n]* = 0，那么向量
    *x*[1], *x*[2], … , *x[n]* ***线性相关***。例如，行向量 *x*[1] = ( 1 2 3 )，*x*[2] = ( 2 6
    4 )，和 *x*[3] = ( 4 11 9 ) 是线性相关的，因为 2*x*[1]+3*x*[2]−2*x*[3] = 0。如果向量不是线性相关，则它们是***线性无关***的。例如，单位矩阵的列是线性无关的。  输出：'
  type: TYPE_NORMAL
  zh: '如果存在系数 `c[1]`, `c[2]`, … , `c[n]`，不全为 0，使得 `c[1]*x[1] + c[2]*x[2] + ⋯ + c[n]x[n]
    = 0`，那么向量 `x[1]`, `x[2]`, … , `x[n]` ***线性相关***。例如，行向量 `x[1] = ( 1 2 3 )`，`x[2]
    = ( 2 6 4 )`，和 `x[3] = ( 4 11 9 )` 是线性相关的，因为 `2*x[1]+3*x[2]−2*x[3] = 0`。如果向量不是线性相关，则它们是***线性无关***的。例如，单位矩阵的列是线性无关的。  '
- answer: '-   非零`m` × `n`矩阵`A`的***列秩***是`A`的线性无关列的最大集合的大小。类似地，`A`的***行秩***是`A`的线性无关行的最大集合的大小。任何矩阵`A`的一个基本性质是，它的行秩总是等于列秩，因此我们可以简单地称为`A`的***秩***。一个`m`
    × `n`矩阵的秩是一个介于 0 和 min {`m`, `n`}之间的整数（零矩阵的秩为 0，`n` × `n`单位矩阵的秩为`n`）。另一个等价但通常更有用的定义是，非零`m`×`n`矩阵`A`的秩是存在矩阵`B`和`C`，分别为`m`
    × `r`和`r` × `n`的最小数`r`，使得`A` = `BC`。一个`n` × `n`方阵如果秩为`n`，则具有***满秩***。一个`m` × `n`矩阵如果秩为`n`，则具有***满列秩***。以下定理给出了秩的一个基本性质。'
  en: 非零*m* × *n*矩阵*A*的***列秩***是*A*的线性无关列的最大集合的大小。类似地，*A*的***行秩***是*A*的线性无关行的最大集合的大小。任何矩阵*A*的一个基本性质是，它的行秩总是等于列秩，因此我们可以简单地称为*A*的***秩***。一个*m*
    × *n*矩阵的秩是一个介于 0 和 min {*m*, *n*}之间的整数（零矩阵的秩为 0，*n* × *n*单位矩阵的秩为*n*）。另一个等价但通常更有用的定义是，非零*m*×*n*矩阵*A*的秩是存在矩阵*B*和*C*，分别为*m*
    × *r*和*r* × *n*的最小数*r*，使得*A* = *BC*。一个*n* × *n*方阵如果秩为*n*，则具有***满秩***。一个*m* × *n*矩阵如果秩为*n*，则具有***满列秩***。以下定理给出了秩的一个基本性质。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   非零*m* × *n*矩阵*A*的***列秩***是*A*的线性无关列的最大集合的大小。类似地，*A*的***行秩***是*A*的线性无关行的最大集合的大小。任何矩阵*A*的一个基本性质是，它的行秩总是等于列秩，因此我们可以简单地称为*A*的***秩***。一个*m*
    × *n*矩阵的秩是一个介于 0 和 min {*m*, *n*}之间的整数（零矩阵的秩为 0，*n* × *n*单位矩阵的秩为*n*）。另一个等价但通常更有用的定义是，非零*m*×*n*矩阵*A*的秩是存在矩阵*B*和*C*，分别为*m*
    × *r*和*r* × *n*的最小数*r*，使得*A* = *BC*。一个*n* × *n*方阵如果秩为*n*，则具有***满秩***。一个*m* × *n*矩阵如果秩为*n*，则具有***满列秩***。以下定理给出了秩的一个基本性质。  输出：'
  type: TYPE_NORMAL
  zh: 非零`m` × `n`矩阵`A`的***列秩***是`A`的线性无关列的最大集合的大小。类似地，`A`的***行秩***是`A`的线性无关行的最大集合的大小。任何矩阵`A`的一个基本性质是，它的行秩总是等于列秩，因此我们可以简单地称为`A`的***秩***。一个`m`
    × `n`矩阵的秩是一个介于 0 和 min {`m`, `n`}之间的整数（零矩阵的秩为 0，`n` × `n`单位矩阵的秩为`n`）。另一个等价但通常更有用的定义是，非零`m`×`n`矩阵`A`的秩是存在矩阵`B`和`C`，分别为`m`
    × `r`和`r` × `n`的最小数`r`，使得`A` = `BC`。一个`n` × `n`方阵如果秩为`n`，则具有***满秩***。一个`m` × `n`矩阵如果秩为`n`，则具有***满列秩***。以下定理给出了秩的一个基本性质。
- answer: '-   ***`定理 D.1`***'
  en: '***定理 D.1***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***定理 D.1***  输出：'
  type: TYPE_NORMAL
  zh: '***`定理 D.1`***'
- answer: '-   一个方阵具有满秩当且仅当它是非奇异的。  '
  en: 一个方阵具有满秩当且仅当它是非奇异的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   一个方阵具有满秩当且仅当它是非奇异的。  输出：'
  type: TYPE_NORMAL
  zh: '一个方阵具有满秩当且仅当它是非奇异的。  '
- en: ▪
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ▪  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   对于矩阵`A`，零向量是一个非零向量`x`，使得`Ax` = 0。以下定理（其证明留作练习 D.2-7）及其推论将列秩和奇异性的概念与零向量联系起来。

    ---'
  en: 对于矩阵*A*，零向量是一个非零向量*x*，使得*Ax* = 0。以下定理（其证明留作练习 D.2-7）及其推论将列秩和奇异性的概念与零向量联系起来。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于矩阵*A*，零向量是一个非零向量*x*，使得*Ax*
    = 0。以下定理（其证明留作练习 D.2-7）及其推论将列秩和奇异性的概念与零向量联系起来。  输出：'
  type: TYPE_NORMAL
  zh: 对于矩阵`A`，零向量是一个非零向量`x`，使得`Ax` = 0。以下定理（其证明留作练习 D.2-7）及其推论将列秩和奇异性的概念与零向量联系起来。
- answer: '-   ***定理 `D.2`*** '
  en: '***定理 D.2***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***定理 D.2***  输出：'
  type: TYPE_NORMAL
  zh: '***定理 `D.2`*** '
- answer: '-   一个矩阵具有完整的列秩当且仅当它没有零向量。'
  en: 一个矩阵具有完整的列秩当且仅当它没有零向量。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   一个矩阵具有完整的列秩当且仅当它没有零向量。  输出：'
  type: TYPE_NORMAL
  zh: 一个矩阵具有完整的列秩当且仅当它没有零向量。
- en: ▪
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ▪  输出：'
  type: TYPE_NORMAL
- answer: '-   `推论 D.3`'
  en: '***推论 D.3***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***推论 D.3***  输出：'
  type: TYPE_NORMAL
  zh: '`推论 D.3`'
- answer: '-   方阵是奇异的当且仅当它有一个零向量。'
  en: 方阵是奇异的当且仅当它有一个零向量。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   方阵是奇异的当且仅当它有一个零向量。  输出：'
  type: TYPE_NORMAL
  zh: 方阵是奇异的当且仅当它有一个零向量。
- en: ▪
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ▪  输出：'
  type: TYPE_NORMAL
- answer: '-   对于`n` > 1 的`n`×`n`矩阵`A`，第`ij`个***子式***是通过删除`A`的第`i`行和第`j`列得到的(`n`−1)×(`n`−1)矩阵`A`[[`ij`]]。通过子式的递归定义，`n`×`n`矩阵`A`的***行列式***如下定义：'
  en: 对于*n* > 1 的*n*×*n*矩阵*A*，第*ij*个***子式***是通过删除*A*的第*i*行和第*j*列得到的(*n*−1)×(*n*−1)矩阵*A*[[*ij*]]。通过子式的递归定义，*n*×*n*矩阵*A*的***行列式***如下定义：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于*n* > 1 的*n*×*n*矩阵*A*，第*ij*个***子式***是通过删除*A*的第*i*行和第*j*列得到的(*n*−1)×(*n*−1)矩阵*A*[[*ij*]]。通过子式的递归定义，*n*×*n*矩阵*A*的***行列式***如下定义：  输出：'
  type: TYPE_NORMAL
  zh: 对于`n` > 1 的`n`×`n`矩阵`A`，第`ij`个***子式***是通过删除`A`的第`i`行和第`j`列得到的(`n`−1)×(`n`−1)矩阵`A`[[`ij`]]。通过子式的递归定义，`n`×`n`矩阵`A`的***行列式***如下定义：
- answer: '-   `![艺术](img/Art_P1789.jpg)`'
  en: '![艺术](img/Art_P1789.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1789.jpg)  输出：'
  type: TYPE_IMG
  zh: '`![艺术](img/Art_P1789.jpg)`'
- answer: '-   术语`(-1)^(i+j)` det(`A[[ij]]`)被称为元素`a[ij]`的***余子式***。'
  en: 术语(−1)^(*i*+*j*) det(*A*[[*ij*]])被称为元素*a[ij]*的***余子式***。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   术语(−1)^(*i*+*j*)
    det(*A*[[*ij*]])被称为元素*a[ij]*的***余子式***。  输出：'
  type: TYPE_NORMAL
  zh: 术语`(-1)^(i+j)` det(`A[[ij]]`)被称为元素`a[ij]`的***余子式***。
- answer: '-   以下定理的证明被省略，表达了行列式的基本性质。'
  en: 以下定理的证明被省略，表达了行列式的基本性质。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   以下定理的证明被省略，表达了行列式的基本性质。  输出：'
  type: TYPE_NORMAL
  zh: 以下定理的证明被省略，表达了行列式的基本性质。
- answer: '-   ***定理 D.4（行列式性质）***'
  en: '***定理 D.4（行列式性质）***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***定理 D.4（行列式性质）***  输出：'
  type: TYPE_NORMAL
  zh: '***定理 D.4（行列式性质）***'
- en: 方阵*A*的行列式具有以下性质：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   方阵*A*的行列式具有以下性质：  输出：'
  type: TYPE_NORMAL
- answer: '-   如果`A`的任意一行或任意一列为零，则 `det(A) = 0`。'
  en: 如果*A*的任意一行或任意一列为零，则 det(*A*) = 0。
  prefs:
  - PREF_UL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   如果*A*的任意一行或任意一列为零，则
    det(*A*) = 0。  输出：'
  type: TYPE_NORMAL
  zh: 如果`A`的任意一行或任意一列为零，则 `det(A) = 0`。
- answer: '-   如果`A`的任意一行（或任意一列）的元素都乘以`λ`，则`A`的行列式乘以`λ`。  '
  en: 如果*A*的任意一行（或任意一列）的元素都乘以*λ*，则*A*的行列式乘以*λ*。
  prefs:
  - PREF_UL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   如果*A*的任意一行（或任意一列）的元素都乘以*λ*，则*A*的行列式乘以*λ*。  输出：'
  type: TYPE_NORMAL
  zh: '如果`A`的任意一行（或任意一列）的元素都乘以`λ`，则`A`的行列式乘以`λ`。  '
- answer: '-   如果一行（或一列）的元素加到另一行（或另一列）的元素中，则`A`的行列式保持不变。'
  en: 如果一行（或一列）的元素加到另一行（或另一列）的元素中，则*A*的行列式保持不变。
  prefs:
  - PREF_UL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   如果一行（或一列）的元素加到另一行（或另一列）的元素中，则*A*的行列式保持不变。  输出：'
  type: TYPE_NORMAL
  zh: 如果一行（或一列）的元素加到另一行（或另一列）的元素中，则`A`的行列式保持不变。
- answer: '-   `A`的行列式等于`A^T`的行列式。'
  en: '*A*的行列式等于*A*^T 的行列式。'
  prefs:
  - PREF_UL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *A*的行列式等于*A*^T
    的行列式。  输出：'
  type: TYPE_NORMAL
  zh: '`A`的行列式等于`A^T`的行列式。'
- answer: '-   如果交换任意两行（或任意两列），则`A`的行列式乘以−1。'
  en: 如果交换任意两行（或任意两列），则*A*的行列式乘以−1。
  prefs:
  - PREF_UL
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   如果交换任意两行（或任意两列），则*A*的行列式乘以−1。  输出：'
  type: TYPE_NORMAL
  zh: 如果交换任意两行（或任意两列），则`A`的行列式乘以−1。
- answer: '-   此外，对于任何方阵`A`和`B`，我们有 `det(AB) = det(A) det(B)`。'
  en: 此外，对于任何方阵*A*和*B*，我们有 det(*AB*) = det(*A*) det(*B*)。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   此外，对于任何方阵*A*和*B*，我们有
    det(*AB*) = det(*A*) det(*B*)。  输出：'
  type: TYPE_NORMAL
  zh: 此外，对于任何方阵`A`和`B`，我们有 `det(AB) = det(A) det(B)`。
- answer: '---

    -   ▪ 输出：'
  en: ▪
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ▪  输出：'
  type: TYPE_NORMAL
  zh: ▪ 输出：
- answer: '-   ***`定理 D.5`***  '
  en: '***定理 D.5***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***定理 D.5***  输出：'
  type: TYPE_NORMAL
  zh: '***`定理 D.5`***  '
- answer: '-   一个`n` × `n`矩阵`A`是奇异当且仅当 det(`A`) = 0。'
  en: 一个*n* × *n*矩阵*A*是奇异���当且仅当 det(*A*) = 0。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   一个*n* × *n*矩阵*A*是奇异���当且仅当
    det(*A*) = 0。  输出：'
  type: TYPE_NORMAL
  zh: 一个`n` × `n`矩阵`A`是奇异当且仅当 det(`A`) = 0。
- en: ▪
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ▪  输出：'
  type: TYPE_NORMAL
- answer: '-   `正定矩阵`'
  en: '**正定矩阵**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **正定矩阵**  输出：'
  type: TYPE_NORMAL
  zh: '`正定矩阵`'
- answer: '-   正定矩阵在许多应用中起着重要作用。如果对于所有非零`n`维向量`x`，`x^TAx > 0`，则`n × n`矩阵`A`是***正定的***。例如，单位矩阵是正定的，因为如果`x
    = ( x[1] x[2] ⋯ x[n] )^T` 是一个非零向量，则  '
  en: 正定矩阵在许多应用中起着重要作用。如果对于所有非零*n*维向量*x*，*x*^T*Ax* > 0，则*n* × *n*矩阵*A*是***正定的***。例如，单位矩阵是正定的，因为如果*x*
    = ( *x*[1] *x*[2] ⋯ *x[n]*)^T 是一个非零向量，则
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   正定矩阵在许多应用中起着重要作用。如果对于所有非零*n*维向量*x*，*x*^T*Ax*
    > 0，则*n* × *n*矩阵*A*是***正定的***。例如，单位矩阵是正定的，因为如果*x* = ( *x*[1] *x*[2] ⋯ *x[n]*)^T
    是一个非零向量，则  输出：'
  type: TYPE_NORMAL
  zh: '正定矩阵在许多应用中起着重要作用。如果对于所有非零`n`维向量`x`，`x^TAx > 0`，则`n × n`矩阵`A`是***正定的***。例如，单位矩阵是正定的，因为如果`x
    = ( x[1] x[2] ⋯ x[n] )^T` 是一个非零向量，则  '
- answer: '-   `![艺术](img/Art_P1790.jpg)`  '
  en: '![艺术](img/Art_P1790.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1790.jpg)  输出：'
  type: TYPE_IMG
  zh: '`![艺术](img/Art_P1790.jpg)`  '
- answer: '-   在应用中出现的矩阵通常是正定的，这归因于以下定理。'
  en: 在应用中出现的矩阵通常是正定的，这归因于以下定理。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   在应用中出现的矩阵通常是正定的，这归因于以下定理。  输出：'
  type: TYPE_NORMAL
  zh: 在应用中出现的矩阵通常是正定的，这归因于以下定理。
- answer: '-   ***定理 D.6***'
  en: '***定理 D.6***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***定理 D.6***  输出：'
  type: TYPE_NORMAL
  zh: '***定理 D.6***'
- answer: '-   对于具有完整列秩的任何矩阵`A`，矩阵`A^T*A`是正定的。'
  en: 对于具有完整列秩的任何矩阵*A*，矩阵*A*^T*A*是正定的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于具有完整列秩的任何矩阵*A*，矩阵*A*^T*A*是正定的。  输出：'
  type: TYPE_NORMAL
  zh: 对于具有完整列秩的任何矩阵`A`，矩阵`A^T*A`是正定的。
- answer: '---

    -   ***证明***   我们必须证明对于任何非零向量`x`，`x^T(A^T*A)x > 0`。对于任何向量`x`，'
  en: '***证明***   我们必须证明对于任何非零向量*x*，*x*^T(*A*^T*A*)*x* > 0。对于任何向量*x*，'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***证明***   我们必须证明对于任何非零向量*x*，*x*^T(*A*^T*A*)*x*
    > 0。对于任何向量*x*，  输出：'
  type: TYPE_NORMAL
  zh: '***证明***   我们必须证明对于任何非零向量`x`，`x^T(A^T*A)x > 0`。对于任何向量`x`，'
- answer: '-   `| x^T(A^T*A)x |` = `| (Ax)^T(Ax) |` （根据习题 D.1-2） |'
  en: '| *x*^T(*A*^T*A*)*x* | = | (*Ax*)^T(*Ax*) | （根据习题 D.1-2） |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | *x*^T(*A*^T*A*)*x*
    | = | (*Ax*)^T(*Ax*) | （根据习题 D.1-2） |  输出：'
  type: TYPE_TB
  zh: '`| x^T(A^T*A)x |` = `| (Ax)^T(Ax) |` （根据习题 D.1-2） |'
- answer: "---\n-   | --- | --- | --- | --- |  \n---"
  en: '| --- | --- | --- | --- |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   | --- | ---
    | --- | --- |  输出：'
  type: TYPE_TB
  zh: '| --- | --- | --- | --- |  '
- answer: '---

    -   `|  | = | ∥Ax∥²。 |  |`'
  en: '|  | = | ∥*Ax*∥²。 |  |'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   |  | = | ∥*Ax*∥²。
    |  |  输出：'
  type: TYPE_TB
  zh: '`|  | = | ∥Ax∥²。 |  |`'
- answer: '-   ∥`Ax`∥²的值就是向量`Ax`的元素平方和。因此，∥`Ax`∥² ≥ 0。我们通过反证法证明∥`Ax`∥² > 0。假设∥`Ax`∥²
    = 0。那么，`Ax`的每个元素都是 0，即`Ax` = 0。由于`A`具有完整的列秩，定理 D.2 表明`x` = 0，这与`x`非零的要求相矛盾。因此，`A`^T`A`是正定的。'
  en: ∥*Ax*∥²的值就是向量*Ax*的元素平方和。因此，∥*Ax*∥² ≥ 0。我们通过反证法证明∥*Ax*∥² > 0。假设∥*Ax*∥² = 0。那么，*Ax*的每个元素都是
    0，即*Ax* = 0。由于*A*具有完整的列秩，定理 D.2 表明*x* = 0，这与*x*非零的要求相矛盾。因此，*A*^T*A*是正定的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ∥*Ax*∥²的值就是向量*Ax*的元素平方和。因此，∥*Ax*∥²
    ≥ 0。我们通过反证法证明∥*Ax*∥² > 0。假设∥*Ax*∥² = 0。那么，*Ax*的每个元素都是 0，即*Ax* = 0。由于*A*具有完整的列秩，定理
    D.2 表明*x* = 0，这与*x*非零的要求相矛盾。因此，*A*^T*A*是正定的。  输出：'
  type: TYPE_NORMAL
  zh: ∥`Ax`∥²的值就是向量`Ax`的元素平方和。因此，∥`Ax`∥² ≥ 0。我们通过反证法证明∥`Ax`∥² > 0。假设∥`Ax`∥² = 0。那么，`Ax`的每个元素都是
    0，即`Ax` = 0。由于`A`具有完整的列秩，定理 D.2 表明`x` = 0，这与`x`非零的要求相矛盾。因此，`A`^T`A`是正定的。
- en: ▪
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ▪  输出：'
  type: TYPE_NORMAL
- answer: '-   第 28.3 节探讨正定矩阵的其他性质。第 33.3 节使用类似的条件，称为半正定。如果对于所有非零*n*维向量`x`，`x^T Ax`
    ≥ 0，则*n* × *n*矩阵`A`是***半正定***的。'
  en: 第 28.3 节探讨正定矩阵的其他性质。第 33.3 节使用类似的条件，称为半正定。如果对于所有非零*n*维向量*x*，*x*^T*Ax* ≥ 0，则*n*
    × *n*矩阵*A*是***半正定***的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   第 28.3 节探讨正定矩阵的其他性质。第
    33.3 节使用类似的条件，称为半正定。如果对于所有非零*n*维向量*x*，*x*^T*Ax* ≥ 0，则*n* × *n*矩阵*A*是***半正定***的。  输出：'
  type: TYPE_NORMAL
  zh: 第 28.3 节探讨正定矩阵的其他性质。第 33.3 节使用类似的条件，称为半正定。如果对于所有非零*n*维向量`x`，`x^T Ax` ≥ 0，则*n*
    × *n*矩阵`A`是***半正定***的。
- answer: '-   **习题**'
  en: '**习题**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **习题**  输出：'
  type: TYPE_NORMAL
  zh: '**习题**'
- en: '***D.2-1***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***D.2-1***  输出：'
  type: TYPE_NORMAL
- answer: '-   证明矩阵的逆是唯一的，即，如果`B`和`C`是`A`的逆，则`B = C`。'
  en: 证明矩阵的逆是唯一的，即，如果*B*和*C*是*A*的逆，则*B* = *C*。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   证明矩阵的逆是唯一的，即，如果*B*和*C*是*A*的逆，则*B*
    = *C*。  输出：'
  type: TYPE_NORMAL
  zh: 证明矩阵的逆是唯一的，即，如果`B`和`C`是`A`的逆，则`B = C`。
- answer: '-   `D.2-2`'
  en: '***D.2-2***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***D.2-2***  输出：'
  type: TYPE_NORMAL
  zh: '`D.2-2`'
- answer: '-   证明下三角或上三角矩阵的行列式等于其对角线元素的乘积。证明下三角矩阵的逆（如果存在）也是下三角的。'
  en: 证明下三角或上三角矩阵的行列式等于其对角线元素的乘积。证明下三角矩阵的逆（如果存在）也是下三角的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   证明下三角或上三角矩阵的行列式等于其对角线元素的乘积。证明下三角矩阵的逆（如果存在）也是下三角的。  输出：'
  type: TYPE_NORMAL
  zh: 证明下三角或上三角矩阵的行列式等于其对角线元素的乘积。证明下三角矩阵的逆（如果存在）也是下三角的。
- en: '***D.2-3***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***D.2-3***  输出：'
  type: TYPE_NORMAL
- answer: '-   证明如果`P`是一个置换矩阵，则`P`是可逆的，其逆矩阵是`P^T`，并且`P^T`是一个置换矩阵。'
  en: 证明如果*P*是一个置换矩阵，则*P*是可逆的，其逆矩阵是*P*^T，并且*P*^T 是一个置换矩阵。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   证明如果*P*是一个置换矩阵，则*P*是可逆的，其逆矩阵是*P*^T，并且*P*^T
    是一个置换矩阵。  输出：'
  type: TYPE_NORMAL
  zh: 证明如果`P`是一个置换矩阵，则`P`是可逆的，其逆矩阵是`P^T`，并且`P^T`是一个置换矩阵。
- answer: '-   `D.2-4`'
  en: '***D.2-4***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***D.2-4***  输出：'
  type: TYPE_NORMAL
  zh: '`D.2-4`'
- answer: '-   设`A`和`B`是`n × n`矩阵，使得`AB = I`。证明如果从`A`中的第`j`行加到第`i`行得到`A''`，其中`i ≠
    j`，那么从`B`中的第`i`列减去第`j`列得到`A''`的逆`B''`。'
  en: 设*A*和*B*是*n* × *n*矩阵，使得*AB* = *I*。证明如果从*A*中的第*j*行加到第*i*行得到*A*'，其中*i* ≠ *j*，那么从*B*中的第*i*列减去第*j*列得到*A*'的逆*B*'。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   设*A*和*B*是*n*
    × *n*矩阵，使得*AB* = *I*。证明如果从*A*中的第*j*行加到第*i*行得到*A*''，其中*i* ≠ *j*，那么从*B*中的第*i*列减去第*j*列得到*A*''的逆*B*''。  输出：'
  type: TYPE_NORMAL
  zh: 设`A`和`B`是`n × n`矩阵，使得`AB = I`。证明如果从`A`中的第`j`行加到第`i`行得到`A'`，其中`i ≠ j`，那么从`B`中的第`i`列减去第`j`列得到`A'`的逆`B'`。
- answer: '---

    -   `D.2-5`'
  en: '***D.2-5***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***D.2-5***  输出：'
  type: TYPE_NORMAL
  zh: '`D.2-5`'
- answer: '-   设`A`是一个具有复数元素的非奇异`n` × `n`矩阵。证明当且仅当`A`的每个元素都是实数时，`A⁻¹`的每个元素都是实数。'
  en: 设*A*是一个具有复数元素的非奇异*n* × *n*矩阵。证明当且仅当*A*的每个元素都是实数时，*A*^(−1)的每个元素都是实数。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   设*A*是一个具有复数元素的非奇异*n*
    × *n*矩阵。证明当且仅当*A*的每个元素都是实数时，*A*^(−1)的每个元素都是实数。  输出：'
  type: TYPE_NORMAL
  zh: 设`A`是一个具有复数元素的非奇异`n` × `n`矩阵。证明当且仅当`A`的每个元素都是实数时，`A⁻¹`的每个元素都是实数。
- answer: '-   `D.2-6`'
  en: '***D.2-6***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***D.2-6***  输出：'
  type: TYPE_NORMAL
  zh: '`D.2-6`'
- answer: '-   证明如果`A`是一个非奇异、对称的`n` × `n`矩阵，那么`A`^(−1)也是对称的。证明如果`B`是一个任意的`m` × `n`矩阵，那么由乘积`BAB`^T
    给出的`m` × `m`矩阵是对称的。'
  en: 证明如果*A*是一个非奇异、对称的*n* × *n*矩阵，那么*A*^(−1)也是对称的。证明如果*B*是一个任意的*m* × *n*矩阵，那么由乘积*BAB*^T
    给出的*m* × *m*矩阵是对称的。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   证明如果*A*是一个非奇异、对称的*n*
    × *n*矩阵，那么*A*^(−1)也是对称的。证明如果*B*是一个任意的*m* × *n*矩阵，那么由乘积*BAB*^T 给出的*m* × *m*矩阵是对称的。  输出：'
  type: TYPE_NORMAL
  zh: 证明如果`A`是一个非奇异、对称的`n` × `n`矩阵，那么`A`^(−1)也是对称的。证明如果`B`是一个任意的`m` × `n`矩阵，那么由乘积`BAB`^T
    给出的`m` × `m`矩阵是对称的。
- answer: '---

    -   ***D.2-7***'
  en: '***D.2-7***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***D.2-7***  输出：'
  type: TYPE_NORMAL
  zh: '***D.2-7***'
- answer: '-   证明定理 D.2。即，证明矩阵`A`具有完整列秩当且仅当`Ax = 0` 意味着`x = 0`。(*提示:* 将一列对其他列的线性相关性表达为矩阵-向量方程。)'
  en: 证明定理 D.2。即，证明矩阵*A*具有完整列秩当且仅当*Ax* = 0 意味着*x* = 0。(*提示:* 将一列对其他列的线性相关性表达为矩阵-向量方程。)
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   证明定理 D.2。即，证明矩阵*A*具有完整列秩当且仅当*Ax*
    = 0 意味着*x* = 0。(*提示:* 将一列对其他列的线性相关性表达为矩阵-向量方程。)  输出：'
  type: TYPE_NORMAL
  zh: 证明定理 D.2。即，证明矩阵`A`具有完整列秩当且仅当`Ax = 0` 意味着`x = 0`。(*提示:* 将一列对其他列的线性相关性表达为矩阵-向量方程。)
- answer: '-   `D.2-8`  '
  en: '***D.2-8***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***D.2-8***  输出：'
  type: TYPE_NORMAL
  zh: '`D.2-8`  '
- answer: '-   证明对于任意两个兼容的矩阵`A`和`B`，'
  en: 证明对于任意两个兼容的矩阵*A*和*B*，
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   证明对于任意两个兼容的矩阵*A*和*B*，  输出：'
  type: TYPE_NORMAL
  zh: 证明对于任意两个兼容的矩阵`A`和`B`，
- answer: '-   rank(`AB`) ≤ min {rank(`A`), rank(`B`)},  '
  en: rank(*AB*) ≤ min {rank(*A*), rank(*B*)},
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   rank(*AB*)
    ≤ min {rank(*A*), rank(*B*)},  输出：'
  type: TYPE_NORMAL
  zh: 'rank(`AB`) ≤ min {rank(`A`), rank(`B`)},  '
- answer: '-   当且仅当`A`或`B`是非奇异方阵时，等式成立。（*提示:* 使用矩阵秩的另一定义。）'
  en: 当且仅当*A*或*B*是非奇异方阵时，等式成立。(*提示:* 使用矩阵秩的另一定义。)
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   当且仅当*A*或*B*是非奇异方阵时，等式成立。(*提示:*
    使用矩阵秩的另一定义。)  输出：'
  type: TYPE_NORMAL
  zh: 当且仅当`A`或`B`是非奇异方阵时，等式成立。（*提示:* 使用矩阵秩的另一定义。）
- answer: '---

    **问题**

    -   输出：'
  en: '**问题**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **问题**  输出：'
  type: TYPE_NORMAL
  zh: 输出：
- en: '***D-1 范德蒙矩阵***'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***D-1 范德蒙矩阵***  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   给定数字`x[0]`，`x[1]`，…，`x[n−1]`，证明***范德蒙矩阵***的行列式'
  en: 给定数字*x*[0]，*x*[1]，…，*x*[*n*−1]，证明***范德蒙矩阵***的行列式
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   给定数字*x*[0]，*x*[1]，…，*x*[*n*−1]，证明***范德蒙矩阵***的行列式  输出：'
  type: TYPE_NORMAL
  zh: 给定数字`x[0]`，`x[1]`，…，`x[n−1]`，证明***范德蒙矩阵***的行列式
- answer: '---

    -   ![艺术](img/Art_P1791.jpg)'
  en: '![艺术](img/Art_P1791.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1791.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1791.jpg)'
- en: 是
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   是  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   ![艺术](img/Art_P1792.jpg)'
  en: '![艺术](img/Art_P1792.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1792.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1792.jpg)'
- answer: '-   (*提示:* 将第`i`列乘以−`x[0]`并加到第`i` + 1 列，对于`i` = `n` − 1，`n` − 2，…，1，然后使用归纳法。)'
  en: (*提示:* 将第*i*列乘以−*x*[0]并加到第*i* + 1 列，对于*i* = *n* − 1，*n* − 2，…，1，然后使用归纳法。)
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   (*提示:* 将第*i*列乘以−*x*[0]并加到第*i*
    + 1 列，对于*i* = *n* − 1，*n* − 2，…，1，然后使用归纳法。)  输出：'
  type: TYPE_NORMAL
  zh: (*提示:* 将第`i`列乘以−`x[0]`并加到第`i` + 1 列，对于`i` = `n` − 1，`n` − 2，…，1，然后使用归纳法。)
- answer: '-   ***D-2 由 GF*(2)上的矩阵-向量乘法定义的排列**'
  en: '***D-2 由 GF*(2)上的矩阵-向量乘法定义的排列**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***D-2 由 GF*(2)上的矩阵-向量乘法定义的排列**  输出：'
  type: TYPE_NORMAL
  zh: '***D-2 由 GF*(2)上的矩阵-向量乘法定义的排列**'
- answer: '-   通过在`GF(2)`上进行矩阵乘法，将整数集`S[n]` = {0, 1, 2, … , 2*^n* − 1}的一类排列定义为二进制表示，对于每个整数`x`
    ∈ `S[n]`，我们将其二进制表示视为一个*n*位向量'
  en: 通过在*GF*(2)上进行矩阵乘法，将整数集*S[n]* = {0, 1, 2, … , 2*^n* − 1}的一类排列定义为二进制表示，对于每个整数*x*
    ∈ *S[n]*，我们将其二进制表示视为一个*n*位向量
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   通过在*GF*(2)上进行矩阵乘法，将整数集*S[n]*
    = {0, 1, 2, … , 2*^n* − 1}的一类排列定义为二进制表示，对于每个整数*x* ∈ *S[n]*，我们将其二进制表示视为一个*n*位向量  输出：'
  type: TYPE_NORMAL
  zh: 通过在`GF(2)`上进行矩阵乘法，将整数集`S[n]` = {0, 1, 2, … , 2*^n* − 1}的一类排列定义为二进制表示，对于每个整数`x`
    ∈ `S[n]`，我们将其二进制表示视为一个*n*位向量
- answer: '---

    -   ![艺术](img/Art_P1793.jpg)  '
  en: '![艺术](img/Art_P1793.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1793.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1793.jpg)  '
- answer: '---

    -   其中 ![艺术](img/Art_P1794.jpg)。如果`A`是每个条目为 0 或 1 的`n` × `n`矩阵，则我们可以定义一个排列，将`S[n]`中的每个值`x`映射到其二进制表示为矩阵-向量乘积`Ax`的数字。所有这些算术都在***GF*(2)**上执行：所有值都是
    0 或 1，除了一个例外，通常的加法和乘法规则适用。例外是 1 + 1 = 0。您可以将*GF*(2)上的算术视为与常规整数算术完全相同，只是您只使用最低有效位。

    ---'
  en: 其中 ![艺术](img/Art_P1794.jpg)。如果*A*是每个条目为 0 或 1 的*n* × *n*矩阵，则我们可以定义一个排列，将*S[n]*中的每个值*x*映射到其二进制表示为矩阵-向量乘积*Ax*的数字。所有这些算术都在***GF*(2)**上执行：所有值���是
    0 或 1，除了一个例外，通常的加法和乘法规则适用。例外是 1 + 1 = 0。您可以将*GF*(2)上的算术视为与常规整数算术完全相同，只是您只使用最低有效位。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   其中 ![艺术](img/Art_P1794.jpg)。如果*A*是每个条目为
    0 或 1 的*n* × *n*矩阵，则我们可以定义一个排列，将*S[n]*中的每个值*x*映射到其二进制表示为矩阵-向量乘积*Ax*的数字。所有这些算术都在***GF*(2)**上执行：所有值���是
    0 或 1，除了一个例外，通常的加法和乘法规则适用。例外是 1 + 1 = 0。您可以将*GF*(2)上的算术视为与常规整数算术完全相同，只是您只使用最低有效位。  输出：'
  type: TYPE_NORMAL
  zh: 其中 ![艺术](img/Art_P1794.jpg)。如果`A`是每个条目为 0 或 1 的`n` × `n`矩阵，则我们可以定义一个排列，将`S[n]`中的每个值`x`映射到其二进制表示为矩阵-向量乘积`Ax`的数字。所有这些算术都在***GF*(2)**上执行：所有值都是
    0 或 1，除了一个例外，通常的加法和乘法规则适用。例外是 1 + 1 = 0。您可以将*GF*(2)上的算术视为与常规整数算术完全相同，只是您只使用最低有效位。
- answer: '```

    -   例如，对于`S[2] = {0, 1, 2, 3}`，矩阵

    ```'
  en: 例如，对于*S*[2] = {0, 1, 2, 3}，矩阵
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   例如，对于*S*[2]
    = {0, 1, 2, 3}，矩阵  输出：'
  type: TYPE_NORMAL
  zh: 例如，对于`S[2] = {0, 1, 2, 3}`，矩阵
- answer: '---

    -   ![艺术](img/Art_P1795.jpg)'
  en: '![艺术](img/Art_P1795.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1795.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1795.jpg)'
- answer: '-   定义以下排列`π[A]`：`π[A](0 = 0`，`π[A](1 = 3`，`π[A](2 = 2`，`π[A](3 = 1`。要看到为什么`π[A](3
    = 1`，观察在`GF(2)`中进行操作，'
  en: 定义以下排列*π[A]*：*π[A]*(0) = 0，*π[A]*(1) = 3，*π[A]*(2) = 2，*π[A]*(3) = 1。要看到为什么*π[A]*(3)
    = 1，观察在*GF*(2)中进行操作，
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   定义以下排列*π[A]*：*π[A]*(0)
    = 0，*π[A]*(1) = 3，*π[A]*(2) = 2，*π[A]*(3) = 1。要看到为什么*π[A]*(3) = 1，观察在*GF*(2)中进行操作，  输出：'
  type: TYPE_NORMAL
  zh: 定义以下排列`π[A]`：`π[A](0 = 0`，`π[A](1 = 3`，`π[A](2 = 2`，`π[A](3 = 1`。要看到为什么`π[A](3
    = 1`，观察在`GF(2)`中进行操作，
- answer: '---

    -   ![艺术](img/Art_P1796.jpg)'
  en: '![艺术](img/Art_P1796.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1796.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1796.jpg)'
- answer: '-   这是 `1` 的二进制表示。'
  en: 这是 1 的二进制表示。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   这是 1 的二进制表示。  输出：'
  type: TYPE_NORMAL
  zh: 这是 `1` 的二进制表示。
- answer: '-   在接下来的问题中，我们将在`GF(2)`上进行操作，所有矩阵和向量的条目将为 0 或 1。将 0-1 矩阵（每个条目为 0 或 1 的矩阵）在`GF(2)`上的***秩***定义为与常规矩阵相同，但所有确定线性独立性的算术都在`GF(2)`上执行。我们通过以下方式定义*n*
    × *n* 0-1 矩阵`A`的***范围***：'
  en: 在接下来的问题中，我们将在*GF*(2)上进行操作，所有矩阵和向量的条目将为 0 或 1。将 0-1 矩阵（每个条目为 0 或 1 的矩阵）在*GF*(2)上的***秩***定义为与常规矩阵相同，但所有确定线性独立性的算术都在*GF*(2)上执行。我们通过以下方式定义*n*
    × *n* 0-1 矩阵*A*的***范围***：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   在接下来的问题中，我们将在*GF*(2)上进行操作，所有矩阵和向量的条目将为
    0 或 1。将 0-1 矩阵（每个条目为 0 或 1 的矩阵）在*GF*(2)上的***秩***定义为与常规矩阵相同，但所有确定线性独立性的算术都在*GF*(2)上执行。我们通过以下方式定义*n*
    × *n* 0-1 矩阵*A*的***范围***：  输出：'
  type: TYPE_NORMAL
  zh: 在接下来的问题中，我们将在`GF(2)`上进行操作，所有矩阵和向量的条目将为 0 或 1。将 0-1 矩阵（每个条目为 0 或 1 的矩阵）在`GF(2)`上的***秩***定义为与常规矩阵相同，但所有确定线性独立性的算术都在`GF(2)`上执行。我们通过以下方式定义*n*
    × *n* 0-1 矩阵`A`的***范围***：
- answer: '-   `R(A) = {y : y = Ax，对于某个x ∈ S[n]}`,  '
  en: '*R*(*A*) = {*y* : *y* = *Ax*，对于某个*x* ∈ *S[n]*},'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *R*(*A*) =
    {*y* : *y* = *Ax*，对于某个*x* ∈ *S[n]*},  输出：'
  type: TYPE_NORMAL
  zh: '`R(A) = {y : y = Ax，对于某个x ∈ S[n]}`,  '
- answer: '-   使得`R(A)`是通过将`S[n]`中的每个值`x`乘以`A`得到的数字集合。'
  en: 使得*R*(*A*)是通过将*S[n]*中的每个值*x*乘以*A*得到的数字集合。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   使得*R*(*A*)是通过将*S[n]*中的每个值*x*乘以*A*得到的数字集合。  输出：'
  type: TYPE_NORMAL
  zh: 使得`R(A)`是通过将`S[n]`中的每个值`x`乘以`A`得到的数字集合。
- answer: '-   ***a.*** 如果矩阵`A`的秩为`r`，证明|`R(A)`| = 2*^r*。得出结论，只有当`A`具有完整秩时，`A`才在`S[n]`上定义排列。'
  en: '***a.*** 如果矩阵*A*的秩为*r*，证明|*R*(*A*)| = 2*^r*。得出结论，只有当*A*具有完整秩时，*A*才在*S[n]*上定义排列。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***a.*** 如果矩阵*A*的秩为*r*，证明|*R*(*A*)|
    = 2*^r*。得出结论，只有当*A*具有完整秩时，*A*才在*S[n]*上定义排列。  输出：'
  type: TYPE_NORMAL
  zh: '***a.*** 如果矩阵`A`的秩为`r`，证明|`R(A)`| = 2*^r*。得出结论，只有当`A`具有完整秩时，`A`才在`S[n]`上定义排列。'
- answer: '---

    -   对于给定的`n` × `n`矩阵`A`和给定的值`y` ∈ `R(A)`，我们通过以下方式定义`y`的***原像***：'
  en: 对于给定的*n* × *n*矩阵*A*和给定的值*y* ∈ *R*(*A*)，我们通过以下方式定义*y*的***原像***：
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   对于给定的*n* ×
    *n*矩阵*A*和给定的值*y* ∈ *R*(*A*)，我们通过以下方式定义*y*的***原像***：  输出：'
  type: TYPE_NORMAL
  zh: 对于给定的`n` × `n`矩阵`A`和给定的值`y` ∈ `R(A)`，我们通过以下方式定义`y`的***原像***：
- answer: '-   *P* (`A, y`) = {`x : Ax = y`}'
  en: '*P* (*A*, *y*) = {*x* : *Ax* = *y*},'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   *P* (*A*, *y*)
    = {*x* : *Ax* = *y*},  输出：'
  type: TYPE_NORMAL
  zh: '*P* (`A, y`) = {`x : Ax = y`}'
- answer: '-   使得`P(A, y)`是通过`A`乘以`S[n]`中的每个值`x`得到`y`的值集合。'
  en: 使得*P*(*A*, *y*)是通过*A*乘以*S[n]*中的每个值*x*得到*y*的值集合。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   使得*P*(*A*,
    *y*)是通过*A*乘以*S[n]*中的每个值*x*得到*y*的值集合。  输出：'
  type: TYPE_NORMAL
  zh: 使得`P(A, y)`是通过`A`乘以`S[n]`中的每个值`x`得到`y`的值集合。
- answer: '-   ***b.*** 如果`r`是`n` × `n`矩阵`A`的秩，且`y` ∈ `R(A)`，证明|`P(A, y)`| = 2^(n−r)。  '
  en: '***b.*** 如果*r*是*n* × *n*矩阵*A*的秩，且*y* ∈ *R*(*A*)，证明|*P*(*A*, *y*)| = 2^(*n*−*r*)。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***b.*** 如果*r*是*n*
    × *n*矩阵*A*的秩，且*y* ∈ *R*(*A*)，证明|*P*(*A*, *y*)| = 2^(*n*−*r*)。  输出：'
  type: TYPE_NORMAL
  zh: '***b.*** 如果`r`是`n` × `n`矩阵`A`的秩，且`y` ∈ `R(A)`，证明|`P(A, y)`| = 2^(n−r)。  '
- answer: '-   令 0 ≤ `m` ≤ `n`，并假设我们将集合`S[n]`分成连续数字的块，第`i`块由 2^(`m`)个数字`i*2^m`, `i*2^m
    + 1`, `i*2^m +2`, … , (`i` +1)2`*m*` −1 组成。对于任意子集`S` ⊆ `S[n]`，定义`B(S, m)`为包含`S`中某个元素的大小为
    2`*m*`的块集合。例如，当`n` = 3，`m` = 1，且`S` = {1, 4, 5}时，`B(S, m)`包括块 0（因为 1 在第 0 块中）和块
    2（因为 4 和 5 都属于第 2 块）。'
  en: 令 0 ≤ *m* ≤ *n*，并假设我们将集合*S[n]*分成连续数字的块，第*i*块由 2^(*m*)个数字*i*2^(*m*), *i*2^(*m*)
    + 1, *i*2^(*m*) +2, … , (*i* +1)2*^m* −1 组成。对于任意子集*S* ⊆ *S[n]*，定义*B*(*S*, *m*)为包含*S*中某个元素的大小为
    2*^m*的块集合。例如，当*n* = 3，*m* = 1，且*S* = {1, 4, 5}时，*B*(*S*, *m*)包括块 0（因为 1 在第 0 块中）和块
    2（因为 4 和 5 都属于第 2 块）。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   令 0 ≤ *m* ≤
    *n*，并假设我们将集合*S[n]*分成连续数字的块，第*i*块由 2^(*m*)个数字*i*2^(*m*), *i*2^(*m*) + 1, *i*2^(*m*)
    +2, … , (*i* +1)2*^m* −1 组成。对于任意子集*S* ⊆ *S[n]*，定义*B*(*S*, *m*)为包含*S*中某个元素的大小为
    2*^m*的块集合。例如，当*n* = 3，*m* = 1，且*S* = {1, 4, 5}时，*B*(*S*, *m*)包括块 0（因为 1 在第 0 块中）和块
    2（因为 4 和 5 都属于第 2 块）。  输出：'
  type: TYPE_NORMAL
  zh: 令 0 ≤ `m` ≤ `n`，并假设我们将集合`S[n]`分成连续数字的块，第`i`块由 2^(`m`)个数字`i*2^m`, `i*2^m + 1`,
    `i*2^m +2`, … , (`i` +1)2`*m*` −1 组成。对于任意子集`S` ⊆ `S[n]`，定义`B(S, m)`为包含`S`中某个元素的大小为
    2`*m*`的块集合。例如，当`n` = 3，`m` = 1，且`S` = {1, 4, 5}时，`B(S, m)`包括块 0（因为 1 在第 0 块中）和块
    2（因为 4 和 5 都属于第 2 块）。
- answer: '-   ***c.*** 让`r`是`A`的左下角(*n* - *m*) × *m*子矩阵的秩，即由取底部*n* - *m*行和最左边*m*列形成的矩阵。让`S`是`S[n]`的任意大小为
    2*^m*的块，并且让`S''` = {*y* : *y* = *Ax*，对于某个*x* ∈ *S*}。证明|`B(S'', m)`| = 2*^r*，并且对于`B(S'',
    m)`中的每个块，恰好有 2^(*m*-*r*)个数字在`S`中映射到该块。'
  en: '***c.*** 让*r*是*A*的左下角(*n* − *m*) × *m*子矩阵的秩，即由取底部*n* − *m*行和最左边*m*列形成的矩阵。让*S*是*S[n]*的任意大小为
    2*^m*的块，并且让*S*′ = {*y* : *y* = *Ax*，对于某个*x* ∈ *S*}。证明|*B*(*S*′, *m*)| = 2*^r*，并且对于*B*(*S*′,
    *m*)中的每个块，恰好有 2^(*m*−*r*)个数字在*S*中映射到该块。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***c.*** 让*r*是*A*的左下角(*n*
    − *m*) × *m*子矩阵的秩，即由取底部*n* − *m*行和最左边*m*列形成的矩阵。让*S*是*S[n]*的任意大小为 2*^m*的块，并且让*S*′
    = {*y* : *y* = *Ax*，对于某个*x* ∈ *S*}。证明|*B*(*S*′, *m*)| = 2*^r*，并且对于*B*(*S*′, *m*)中的每个块，恰好有
    2^(*m*−*r*)个数字在*S*中映射到该块。  输出：'
  type: TYPE_NORMAL
  zh: '***c.*** 让`r`是`A`的左下角(*n* - *m*) × *m*子矩阵的秩，即由取底部*n* - *m*行和最左边*m*列形成的矩阵。让`S`是`S[n]`的任意大小为
    2*^m*的块，并且让`S''` = {*y* : *y* = *Ax*，对于某个*x* ∈ *S*}。证明|`B(S'', m)`| = 2*^r*，并且对于`B(S'',
    m)`中的每个块，恰好有 2^(*m*-*r*)个数字在`S`中映射到该块。'
- answer: '-   因为将零向量乘以任何矩阵都会得到零向量，由满秩`n × n` 0-1 矩阵在`GF(2)`上定义的`S[n]`的排列集合不能包含`S[n]`的所有排列。让我们通过在矩阵-向量乘法中包含一个加法项来扩展由矩阵-向量乘法定义的排列类，以便`x
    ∈ S[n]`映射到`Ax + c`，其中`c`是一个`n`-比特向量，加法在`GF(2)`上执行。例如，当'
  en: 因为将零向量乘以任何矩阵都会得到零向量，由满秩*n* × *n* 0-1 矩阵在*GF*(2)上定义的*S[n]*的排列集合不能包含*S[n]*的所有排列。让我们通过在矩阵-向量乘法中包含一个加法项来扩展由矩阵-向量乘法定义的排列类，以便*x*
    ∈ *S[n]*映射到*Ax* + *c*，其中*c*是一个*n*-比特向量，加法在*GF*(2)上执行。例如，当
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   因为将零向量乘以任何矩阵都会得到零向量，由满秩*n*
    × *n* 0-1 矩阵在*GF*(2)上定义的*S[n]*的排列集合不能包含*S[n]*的所有排列。让我们通过在矩阵-向量乘法中包含一个加法项来扩展由矩阵-向量乘法定义的排列类，以便*x*
    ∈ *S[n]*映射到*Ax* + *c*，其中*c*是一个*n*-比特向量，加法在*GF*(2)上执行。例如，当  输出：'
  type: TYPE_NORMAL
  zh: 因为将零向量乘以任何矩阵都会得到零向量，由满秩`n × n` 0-1 矩阵在`GF(2)`上定义的`S[n]`的排列集合不能包含`S[n]`的所有排列。让我们通过在矩阵-向量乘法中包含一个加法项来扩展由矩阵-向量乘法定义的排列类，以便`x
    ∈ S[n]`映射到`Ax + c`，其中`c`是一个`n`-比特向量，加法在`GF(2)`上执行。例如，当
- answer: '---

    -   ![艺术](img/Art_P1797.jpg)  '
  en: '![艺术](img/Art_P1797.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1797.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1797.jpg)  '
- en: 和
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   和  输出：'
  type: TYPE_NORMAL
- answer: '---

    -   ![艺术](img/Art_P1798.jpg)'
  en: '![艺术](img/Art_P1798.jpg)'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ![艺术](img/Art_P1798.jpg)  输出：'
  type: TYPE_IMG
  zh: '![艺术](img/Art_P1798.jpg)'
- answer: '-   我们得到以下排列`π[A,c]`：`π[A,c](0 = 2`，`π[A,c](1 = 1`，`π[A,c](2 = 0`，`π[A,c](3
    = 3`。我们称任何将`x ∈ S[n]`映射到`Ax + c`，对于某个具有满秩的`n × n` 0-1 矩阵`A` 和某个`n`-比特向量`c` 的排列为***线性排列***。'
  en: 我们得到以下排列*π[A,c]*：*π[A,c]*(0) = 2，*π[A,c]*(1) = 1，*π[A,c]*(2) = 0，*π[A,c]*(3)
    = 3。我们称任何将*x* ∈ *S[n]*映射到*Ax* + *c*，对于某个具有满秩的*n* × *n* 0-1 矩阵*A 和某个*n*-比特向量*c
    的排列为***线性排列***。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   我们得到以下排列*π[A,c]*：*π[A,c]*(0)
    = 2，*π[A,c]*(1) = 1，*π[A,c]*(2) = 0，*π[A,c]*(3) = 3。我们称任何将*x* ∈ *S[n]*映射到*Ax*
    + *c*，对于某个具有满秩的*n* × *n* 0-1 矩阵*A 和某个*n*-比特向量*c 的排列为***线性排列***。  输出：'
  type: TYPE_NORMAL
  zh: 我们得到以下排列`π[A,c]`：`π[A,c](0 = 2`，`π[A,c](1 = 1`，`π[A,c](2 = 0`，`π[A,c](3 = 3`。我们称任何将`x
    ∈ S[n]`映射到`Ax + c`，对于某个具有满秩的`n × n` 0-1 矩阵`A` 和某个`n`-比特向量`c` 的排列为***线性排列***。
- answer: '-   ***d.*** 使用计数论证明`S[n]`的线性排列数量远小于`S[n]`的排列数量。'
  en: '***d.*** 使用计数论证明*S[n]*的线性排列数量远小于*S[n]*的排列数量。'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***d.*** 使用计数论证明*S[n]*的线性排列数量远小于*S[n]*的排列数量。  输出：'
  type: TYPE_NORMAL
  zh: '***d.*** 使用计数论证明`S[n]`的线性排列数量远小于`S[n]`的排列数量。'
- answer: '-   ***e.*** 给出一个`n`的值和一个`S[n]`的排列的例子，该排列不能通过任何线性排列实现。（提示：对于给定的排列，考虑如何将矩阵乘以单位向量与矩阵的列相关联。）'
  en: '***e.*** 给出一个*n*的值和一个*S[n]*的排列的例子，该排列不能通过任何线性排列实现。（提示：对于给定的排列，考虑如何将矩阵乘以单位向量与矩阵的列相关联。）'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   ***e.*** 给出一个*n*的值和一个*S[n]*的排列的例子，该排列不能通过任何线性排列实现。（提示：对于给定的排列，考虑如何将矩阵乘以单位向量与矩阵的列相关联。）  输出：'
  type: TYPE_NORMAL
  zh: '***e.*** 给出一个`n`的值和一个`S[n]`的排列的例子，该排列不能通过任何线性排列实现。（提示：对于给定的排列，考虑如何将矩阵乘以单位向量与矩阵的列相关联。）'
- answer: '-   **附录注释**'
  en: '**附录注释**'
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   **附录注释**  输出：'
  type: TYPE_NORMAL
  zh: '**附录注释**'
- answer: '---

    -   线性代数教科书提供了关于矩阵的大量背景信息。Strang 的书籍\[422, 423\]特别好。'
  en: 线性代数教科书提供了关于矩阵的大量背景信息。Strang 的书籍[422, 423]特别好。
  prefs: []
  question: '假如你是个高级程序员和文档工程师，请将给定 Markdown 中的公式按照给定要求排版。  ## 要求  +   将公式使用内联代码符号（`...`）包围，其它文本原样输出
    +   如果公式中有斜体符号（*...*），将符号删除并保留公式其它部分 +   输入可能有多行，不要遗漏其中任何一行 +   输出的每一行前面需要有分隔符（-   ），不然我无法处理   ##
    示例  输入：  -   34.5.2 节定义了顶点覆盖问题并证明了其 NP 完全性。回想一下，对于无向图*G* = (*V*, *E*)，***顶点覆盖***是指一个子集*V*′
    ⊆ *V*，使得如果(*u*, *v*)是*G*的一条边，则*u* ∈ *V*′或*v* ∈ *V*′（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了*ρ*(*n*)的近似比率，我们称其为一个***ρ*(*n*)-近似算法***。近似比率和*ρ*(*n*)-近似算法的定义适用于最小化和最大化问题。对于最大化问题，0
    < *C* ≤ *C**，比率*C**/*C*给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，0 < *C** ≤ *C*，比率*C*/*C**给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为*C*/*C** ≤ 1 意味着*C**/*C*
    ≥ 1。因此，一个 1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。   输出：  -   34.5.2 节定义了顶点覆盖问题并证明了其
    NP 完全性。回想一下，对于无向图`G = (V, E)`，***顶点覆盖***是指一个子集`V′ ⊆ V`，使得如果`(u, v)`是`G`的一条边，则`u
    ∈ V′`或v ∈ V′`（或两者都在）。顶点覆盖的大小是其中顶点的数量。 -   如果一个算法实现了`ρ(n)`的近似比率，我们称其为一个**`ρ(n)`-近似算法**。近似比率和`ρ(n)`-近似算法的定义适用于最小化和最大化问题。对于最大化问题，`0
    < C ≤ C*`，比率`C*/C`给出了最优解的成本比近似解的成本大的因子。类似地，对于最小化问题，`0 < C* ≤ C`，比率`C/C*`给出了近似解的成本比最优解的成本大的因子。
    -   因为我们假设所有解都有正成本，所以这些比率总是明确定义的。近似算法的近似比例永远不会小于 1，因为`C/C* ≤ 1`意味着`C*/C ≥ 1`。因此，一个
    1-近似算法¹会产生一个最优解，而具有较大近似比率的近似算法可能返回比最优解差得多的解。  ## 需要排版的段落  输入：  -   线性代数教科书提供了关于矩阵的大量背景信息。Strang
    的书籍[422, 423]特别好。  输出：'
  type: TYPE_NORMAL
  zh: 线性代数教科书提供了关于矩阵的大量背景信息。Strang 的书籍\[422, 423\]特别好。
