- en: '[**31        Number-Theoretic Algorithms**](toc.xhtml#chap-31)'
  prefs: []
  type: TYPE_NORMAL
- en: Number theory was once viewed as a beautiful but largely useless subject in
    pure mathematics. Today number-theoretic algorithms are used widely, due in large
    part to the invention of cryptographic schemes based on large prime numbers. These
    schemes are feasible because we can find large primes quickly, and they are secure
    because we do not know how to factor the product of large primes (or solve related
    problems, such as computing discrete logarithms) efficiently. This chapter presents
    some of the number theory and related algorithms that underlie such applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start in [Section 31.1](chapter031.xhtml#Sec_31.1) by introducing basic
    concepts of number theory, such as divisibility, modular equivalence, and unique
    prime factorization. [Section 31.2](chapter031.xhtml#Sec_31.2) studies one of
    the world’s oldest algorithms: Euclid’s algorithm for computing the greatest common
    divisor of two integers, and [Section 31.3](chapter031.xhtml#Sec_31.3) reviews
    concepts of modular arithmetic. [Section 31.4](chapter031.xhtml#Sec_31.4) then
    explores the set of multiples of a given number *a*, modulo *n*, and shows how
    to find all solutions to the equation *ax* = *b* (mod *n*) by using Euclid’s algorithm.
    The Chinese remainder theorem is presented in [Section 31.5](chapter031.xhtml#Sec_31.5).
    [Section 31.6](chapter031.xhtml#Sec_31.6) considers powers of a given number *a*,
    modulo *n*, and presents a repeated-squaring algorithm for efficiently computing
    *a^b* mod *n*, given *a*, *b*, and *n*. This operation is at the heart of efficient
    primality testing and of much modern cryptography, such as the RSA public-key
    cryptosystem described in [Section 31.7](chapter031.xhtml#Sec_31.7). We wrap up
    in [Section 31.8](chapter031.xhtml#Sec_31.8), which examines a randomized primality
    test. This test finds large primes efficiently, an essential step in creating
    keys for the RSA cryptosystem.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Size of inputs and cost of arithmetic computations**'
  prefs: []
  type: TYPE_NORMAL
- en: Because we’ll be working with large integers, we need to adjust how to think
    about the size of an input and about the cost of elementary arithmetic operations.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, a “large input” typically means an input containing “large
    integers” rather than an input containing “many integers” (as for sorting). Thus,
    the size of an input depends on the *number of bits* required to represent that
    input, not just the number of integers in the input. An algorithm with integer
    inputs *a*[1], *a*[2], …, *a[k]* is a ***polynomial-time algorithm*** if it runs
    in time polynomial in 1g *a*[1], 1g *a*[2], …, 1g *a*[*k*], that is, polynomial
    in the lengths of its binary-encoded inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Most of this book considers the elementary arithmetic operations (multiplications,
    divisions, or computing remainders) as primitive operations that take one unit
    of time. Counting the number of such arithmetic operations that an algorithm performs
    provides a basis for making a reasonable estimate of the algorithm’s actual running
    time on a computer. Elementary operations can be time-consuming, however, when
    their inputs are large. It thus becomes appropriate to measure how many ***bit
    operations*** a number-theoretic algorithm requires. In this model, multiplying
    two *β*-bit integers by the ordinary method uses Θ(*β*²) bit operations. Similarly,
    dividing a *β*-bit integer by a shorter integer or taking the remainder of a *β*-bit
    integer when divided by a shorter integer requires Θ(*β*²) time by simple algorithms.
    (See Exercise 31.1-12.) Faster methods are known. For example, a simple divide-and-conquer
    method for multiplying two *β*-bit integers has a running time of Θ(*β*^(1g 3)),
    and *O*(*β* 1g *β* 1g 1g *β*) time is possible. For practical purposes, however,
    the Θ(*β*²) algorithm is often best, and we use this bound as a basis for our
    analyses. In this chapter, we’ll usually analyze algorithms in terms of both the
    number of arithmetic operations and the number of bit operations they require.
  prefs: []
  type: TYPE_NORMAL
- en: '[**31.1    Elementary number-theoretic notions**](toc.xhtml#Rh1-177)'
  prefs: []
  type: TYPE_NORMAL
- en: This section provides a brief review of notions from elementary number theory
    concerning the set ℤ = {…, –2, –1, 0, 1, 2, …} of integers and the set ℕ = {0,
    1, 2, …} of natural numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Divisibility and divisors**'
  prefs: []
  type: TYPE_NORMAL
- en: The notion of one integer being divisible by another is key to the theory of
    numbers. The notation *d* | *a* (read “*d* ***divides*** *a*”) means that *a*
    = *kd* for some integer *k*. Every integer divides 0\. If *a* > 0 and *d* | *a*,
    then |*d*| ≤ |*a*|. If *d* | *a*, then we also say that *a* is a ***multiple***
    of *d*. If *d* does not divide *a*, we write *d* ∤ *a*.
  prefs: []
  type: TYPE_NORMAL
- en: If *d* | *a* and *d* ≥ 0, then *d* is a ***divisor*** of *a*. Since *d* | *a*
    if and only if –*d* | *a*, without loss of generality, we define the divisors
    of *a* to be nonnegative, with the understanding that the negative of any divisor
    of *a* also divides *a*. A divisor of a nonzero integer *a* is at least 1 but
    not greater than |*a*|. For example, the divisors of 24 are 1, 2, 3, 4, 6, 8,
    12, and 24.
  prefs: []
  type: TYPE_NORMAL
- en: Every positive integer *a* is divisible by the ***trivial divisors*** 1 and
    *a*. The nontrivial divisors of *a* are the ***factors*** of *a*. For example,
    the factors of 20 are 2, 4, 5, and 10.
  prefs: []
  type: TYPE_NORMAL
- en: '**Prime and composite numbers**'
  prefs: []
  type: TYPE_NORMAL
- en: An integer *a* > 1 whose only divisors are the trivial divisors 1 and *a* is
    a ***prime number*** or, more simply, a ***prime***. Primes have many special
    properties and play a critical role in number theory. The first 20 primes, in
    order, are
  prefs: []
  type: TYPE_NORMAL
- en: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71.
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 31.1-2 asks you to prove that there are infinitely many primes. An
    integer *a* > 1 that is not prime is a ***composite number*** or, more simply,
    a ***composite***. For example, 39 is composite because 3 | 39\. We call the integer
    1 a ***unit***, and it is neither prime nor composite. Similarly, the integer
    0 and all negative integers are neither prime nor composite.
  prefs: []
  type: TYPE_NORMAL
- en: '**The division theorem, remainders, and modular equivalence**'
  prefs: []
  type: TYPE_NORMAL
- en: Given an integer *n*, we can partition the integers into those that are multiples
    of *n* and those that are not multiples of *n*. Much number theory is based upon
    refining this partition by classifying the integers that are not multiples of
    *n* according to their remainders when divided by *n*. The following theorem provides
    the basis for this refinement. We omit the proof (but see, for example, Niven
    and Zuckerman [[345](bibliography001.xhtml#endnote_345)]).
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.1 (Division theorem)***'
  prefs: []
  type: TYPE_NORMAL
- en: For any integer *a* and any positive integer *n*, there exist unique integers
    *q* and *r* such that 0 ≤ *r* < *n* and *a* = *qn* + *r*.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: The value *q* = ⌊*a*/*n*⌋ is the ***quotient*** of the division. The value *r*
    = *a* mod *n* is the ***remainder*** (or ***residue***) of the division, so that
    *n* | *a* if and only if *a* mod *n* = 0.
  prefs: []
  type: TYPE_NORMAL
- en: The integers partition into *n* equivalence classes according to their remainders
    modulo *n*. The ***equivalence class modulo n*** containing an integer *a* is
  prefs: []
  type: TYPE_NORMAL
- en: '[*a*][*n*] = {*a* + *kn* : *k* ∈ ℤ}.'
  prefs: []
  type: TYPE_NORMAL
- en: For example, [3][7] = {…, –11, –4, 3, 10, 17, …}, and [–4][7] and [10][7] also
    denote this set. With the notation defined on page 64, writing *a* ∈ [*b*][*n*]
    is the same as writing *a* = *b* (mod *n*). The set of all such equivalence classes
    is
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1131.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When you see the definition
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1132.jpg)'
  prefs: []
  type: TYPE_IMG
- en: you should read it as equivalent to equation (31.1) with the understanding that
    0 represents [0][*n*], 1 represents [1][*n*], and so on. Each class is represented
    by its smallest nonnegative element. You should keep the underlying equivalence
    classes in mind, however. For example, if we refer to –1 as a member of ℤ[*n*],
    we are really referring to [*n* – 1][*n*], since –1 = *n* – 1 (mod *n*).
  prefs: []
  type: TYPE_NORMAL
- en: '**Common divisors and greatest common divisors**'
  prefs: []
  type: TYPE_NORMAL
- en: If *d* is a divisor of *a* and *d* is also a divisor of *b*, then *d* is a ***common
    divisor*** of *a* and *b*. For example, the divisors of 30 are 1, 2, 3, 5, 6,
    10, 15, and 30, and so the common divisors of 24 and 30 are 1, 2, 3, and 6\. Any
    pair of integers has a common divisor of 1.
  prefs: []
  type: TYPE_NORMAL
- en: An important property of common divisors is that
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1133.jpg)'
  prefs: []
  type: TYPE_IMG
- en: More generally, for any integers *x* and *y*,
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1134.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Also, if *a* | *b*, then either |*a*| ≤ |*b*| or *b* = 0, which implies that
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1135.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The ***greatest common divisor*** of two integers *a* and *b* which are not
    both 0, denoted by gcd(*a*, *b*), is the largest of the common divisors of *a*
    and *b*. For example, gcd(24, 30) = 6, gcd(5, 7) = 1, and gcd(0, 9) = 9\. If *a*
    and *b* are both nonzero, then gcd(*a*, *b*) is an integer between 1 and min {|*a*|,
    |*b*|}. We define gcd(0, 0) to be 0, so that standard properties of the gcd function
    (such as equation (31.9) below) hold universally.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 31.1-9 asks you to prove the following elementary properties of the
    gcd function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1136.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The following theorem provides an alternative and useful way to characterize
    gcd(*a*, *b*).
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.2***'
  prefs: []
  type: TYPE_NORMAL
- en: 'If *a* and *b* are any integers, not both zero, then gcd(*a*, *b*) is the smallest
    positive element of the set {*ax* + *by* : *x*, *y* ∈ ℤ} of linear combinations
    of *a* and *b*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   Let *s* be the smallest positive such linear combination of *a*
    and *b*, and let *s* = *ax* + *by* for some *x*, *y* ∈ ℤ. Let *q* = ⌊*a*/*s*⌋.
    Equation (3.11) on page 64 then implies'
  prefs: []
  type: TYPE_NORMAL
- en: '| *a* mod *s* | = | *a* – *qs* |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | *a* – *q*(*ax* + *by*) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | *a* (1 – *qx*) + *b* (–*qy*), |'
  prefs: []
  type: TYPE_TB
- en: so that *a* mod *s* is a linear combination of *a* and *b* as well. Because
    *s* is the smallest *positive* such linear combination and 0 ≤ *a* mod *s* < *s*
    (inequality (3.12) on page 64), *a* mod *s* cannot be positive. Hence, *a* mod
    *s* = 0\. Therefore, we have that *s* | *a* and, by analogous reasoning, *s* |
    *b*. Thus, *s* is a common divisor of *a* and *b*, so that gcd(*a*, *b*) ≥ *s*.
    By definition, gcd(*a*, *b*) divides both *a* and *b*, and *s* is defined as a
    linear combination of *a* and *b*. Equation (31.4) therefore implies that gcd(*a*,
    *b*) | *s*. But gcd(*a*, *b*) | *s* and *s* > 0 imply that gcd(*a*, *b*) ≤ *s*.
    Combining gcd(*a*, *b*) ≥ *s* and gcd(*a*, *b*) ≤ *s* yields gcd(*a*, *b*) = *s*.
    We conclude that *s*, the smallest positive linear combination of *a* and *b*,
    is also their greatest common divisor.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: Theorem 31.2 engenders three useful corollaries.
  prefs: []
  type: TYPE_NORMAL
- en: '***Corollary 31.3***'
  prefs: []
  type: TYPE_NORMAL
- en: For any integers *a* and *b*, if *d* | *a* and *d* | *b*, then *d* | gcd(*a*,
    *b*).
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   This corollary follows from equation (31.4) and Theorem 31.2,
    because gcd(*a*, *b*) is a linear combination of *a* and *b*,'
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '***Corollary 31.4***'
  prefs: []
  type: TYPE_NORMAL
- en: For all integers *a* and *b* and any nonnegative integer *n*, we have
  prefs: []
  type: TYPE_NORMAL
- en: gcd(*an*, *bn*) = *n* gcd(*a*, *b*).
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   If *n* = 0, the corollary is trivial. If *n* > 0, then gcd(*an*,
    *bn*) is the smallest positive element of the set {*anx* + *bny* : *x*, *y* ∈
    ℤ}, which in turn is *n* times the smallest positive element of the set {*ax*
    + *by* : *x*, *y* ∈ ℤ}.'
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '***Corollary 31.5***'
  prefs: []
  type: TYPE_NORMAL
- en: For all positive integers *n*, *a*, and *b*, if *n* | *ab* and gcd(*a*, *n*)
    = 1, then *n* | *b*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   Exercise 31.1-5 asks you to provide the proof.'
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '**Relatively prime integers**'
  prefs: []
  type: TYPE_NORMAL
- en: Two integers *a* and *b* are ***relatively prime*** if their only common divisor
    is 1, that is, if gcd(*a*, *b*) = 1\. For example, 8 and 15 are relatively prime,
    since the divisors of 8 are 1, 2, 4, and 8, and the divisors of 15 are 1, 3, 5,
    and 15\. The following theorem states that if two integers are each relatively
    prime to an integer *p*, then their product is relatively prime to *p*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.6***'
  prefs: []
  type: TYPE_NORMAL
- en: For any integers *a*, *b*, and *p*, we have gcd(*ab*, *p*) = 1 if and only if
    gcd(*a*, *p*) = 1 and gcd(*b*, *p*) = 1 both hold.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   If gcd(*a*, *p*) = 1 and gcd(*b*, *p*) = 1, then it follows from
    Theorem 31.2 that there exist integers *x*, *y*, *x*′, and *y*′ such that'
  prefs: []
  type: TYPE_NORMAL
- en: '| *ax* + *py* | = | 1, |'
  prefs: []
  type: TYPE_TB
- en: '| *bx*′ + *py*′ | = | 1. |'
  prefs: []
  type: TYPE_TB
- en: Multiplying these equations and rearranging gives
  prefs: []
  type: TYPE_NORMAL
- en: '*ab*(*xx*′) + *p*(*ybx*′ + *y*′*ax* + *pyy*′) = 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Since 1 is thus a positive linear combination of *ab* and *p*, it is the smallest
    positive linear combination. Applying Theorem 31.2 implies gcd(*ab*, *p*) = 1,
    completing the proof in this direction.
  prefs: []
  type: TYPE_NORMAL
- en: Conversely, if gcd(*ab*, *p*) = 1, then Theorem 31.2 implies that there exist
    integers *x* and *y* such that
  prefs: []
  type: TYPE_NORMAL
- en: '*abx* + *py* = 1.'
  prefs: []
  type: TYPE_NORMAL
- en: Writing *abx* as *a*(*bx*) and applying Theorem 31.2 again proves that gcd(*a*,
    *p*) = 1\. Proving that gcd(*b*, *p*) = 1 is similar.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: Integers *n*[1], *n*[2], …, *n*[*k*] are ***pairwise relatively prime*** if
    gcd(*n*[*i*], *n*[*j*]) = 1 for 1 ≤ *i* < *j* ≤ *k*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unique prime factorization**'
  prefs: []
  type: TYPE_NORMAL
- en: An elementary but important fact about divisibility by primes is the following.
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.7***'
  prefs: []
  type: TYPE_NORMAL
- en: For all primes *p* and all integers *a* and *b*, if *p* | *ab*, then *p* | *a*
    or *p* | *b* (or both).
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   Assume for the purpose of contradiction that *p* | *ab*, but
    that *p* ∤ *a* and *p* ∤ *b*. Because *p* > 1 and *ab* = *kp* for some *k* ∈ ℤ,
    equation (31.10) gives that gcd(*ab*, *p*) = *p*. We also have that gcd(*a*, *p*)
    = 1 and gcd(*b*, *p*) = 1, since the only divisors of *p* are 1 and *p*, and we
    assumed that *p* divides neither *a* nor *b*. Theorem 31.6 then implies that gcd(*ab*,
    *p*) = 1, contradicting gcd(*ab*, *p*) = *p*. This contradiction completes the
    proof.'
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: A consequence of Theorem 31.7 is that any composite integer can be uniquely
    factored into a product of primes. Exercise 31.1-11 asks you to provide a proof.
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.8 (Unique prime factorization)***'
  prefs: []
  type: TYPE_NORMAL
- en: There is exactly one way to write any composite integer *a* as a product of
    the form
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1137.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where the *p*[*i*] are prime, *p*[1] < *p*[2] < … < *p*[*r*], and the *e*[*i*]
    are positive integers.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: As an example, the unique prime factorization of the number 6000 is 2⁴ · 3¹
    · 5³.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs: []
  type: TYPE_NORMAL
- en: '***31.1-1***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove that if *a* > *b* > 0 and *c* = *a* + *b*, then *c* mod *a* = *b*.
  prefs: []
  type: TYPE_NORMAL
- en: '***31.1-2***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove that there are infinitely many primes. (*Hint:* Show that none of the
    primes *p*[1], *p*[2], …, *p*[*k*] divide (*p*[1]*p*[2] ⋯ *p*[*k*]) + 1.)
  prefs: []
  type: TYPE_NORMAL
- en: '***31.1-3***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove that if *a* | *b* and *b* | *c*, then *a* | *c*.
  prefs: []
  type: TYPE_NORMAL
- en: '***31.1-4***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove that if *p* is prime and 0 < *k* < *p*, then gcd(*k*, *p*) = 1.
  prefs: []
  type: TYPE_NORMAL
- en: '***31.1-5***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove Corollary 31.5.
  prefs: []
  type: TYPE_NORMAL
- en: '***31.1-6***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove that if *p* is prime and 0 < *k* < *p*, then ![art](images/Art_P1138.jpg).
    Conclude that for all integers *a* and *b* and all primes *p*,
  prefs: []
  type: TYPE_NORMAL
- en: (*a* + *b*)^(*p*) = *a*^(*p*) + *b*^(*p*) (mod *p*).
  prefs: []
  type: TYPE_NORMAL
- en: '***31.1-7***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove that if *a* and *b* are any positive integers such that *a* | *b*, then
  prefs: []
  type: TYPE_NORMAL
- en: (*x* mod *b*) mod *a* = *x* mod *a*
  prefs: []
  type: TYPE_NORMAL
- en: for any *x*. Prove, under the same assumptions, that
  prefs: []
  type: TYPE_NORMAL
- en: '*x* = *y* (mod *b*) implies *x* = *y* (mod *a*)'
  prefs: []
  type: TYPE_NORMAL
- en: for any integers *x* and *y*.
  prefs: []
  type: TYPE_NORMAL
- en: '***31.1-8***'
  prefs: []
  type: TYPE_NORMAL
- en: For any integer *k* > 0, an integer *n* is a ***kth power*** if there exists
    an integer *a* such that *a*^(*k*) = *n*. Furthermore, *n* > 1 is a ***nontrivial
    power*** if it is a *k*th power for some integer *k* > 1\. Show how to determine
    whether a given *β*-bit integer *n* is a nontrivial power in time polynomial in
    *β*.
  prefs: []
  type: TYPE_NORMAL
- en: '***31.1-9***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove equations (31.6)–(31.10).
  prefs: []
  type: TYPE_NORMAL
- en: '***31.1-10***'
  prefs: []
  type: TYPE_NORMAL
- en: Show that the gcd operator is associative. That is, prove that for all integers
    *a*, *b*, and *c*, we have
  prefs: []
  type: TYPE_NORMAL
- en: gcd(*a*, gcd(*b*, *c*)) = gcd(gcd(*a*, *b*), *c*).
  prefs: []
  type: TYPE_NORMAL
- en: ★ ***31.1-11***
  prefs: []
  type: TYPE_NORMAL
- en: Prove Theorem 31.8.
  prefs: []
  type: TYPE_NORMAL
- en: '***31.1-12***'
  prefs: []
  type: TYPE_NORMAL
- en: Give efficient algorithms for the operations of dividing a *β*-bit integer by
    a shorter integer and of taking the remainder of a *β*-bit integer when divided
    by a shorter integer. Your algorithms should run in Θ(*β*²) time.
  prefs: []
  type: TYPE_NORMAL
- en: '***31.1-13***'
  prefs: []
  type: TYPE_NORMAL
- en: Give an efficient algorithm to convert a given *β*-bit (binary) integer to a
    decimal representation. Argue that if multiplication or division of integers whose
    length is at most *β* takes *M*(*β*) time, where *M*(*β*) = Ω(*β*), then you can
    convert binary to decimal in *O*(*M*(*β*) 1g *β*) time. (*Hint:* Use a divide-and-conquer
    approach, obtaining the top and bottom halves of the result with separate recursions.)
  prefs: []
  type: TYPE_NORMAL
- en: '***31.1-14***'
  prefs: []
  type: TYPE_NORMAL
- en: Professor Marshall sets up *n* lightbulbs in a row. The lightbulbs all have
    switches, so that if he presses a bulb, it toggles on if it was off and off if
    it was on. The lightbulbs all start off. For *i* = 1, 2, 3, …, *n*, the professor
    presses bulb *i*, 2*i*, 3*i*, …. After the last press, which lightbulbs are on?
    Prove your answer.
  prefs: []
  type: TYPE_NORMAL
- en: '[**31.2    Greatest common divisor**](toc.xhtml#Rh1-178)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we describe Euclid’s algorithm for efficiently computing the
    greatest common divisor of two integers. When we analyze the running time, we’ll
    see a surprising connection with the Fibonacci numbers, which yield a worst-case
    input for Euclid’s algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: We restrict ourselves in this section to nonnegative integers. This restriction
    is justified by equation (31.8), which states that gcd(*a*, *b*) = gcd(|*a*|,
    |*b*|).
  prefs: []
  type: TYPE_NORMAL
- en: In principle, for positive integers *a* and *b*, their prime factorizations
    suffice to compute gcd(*a*, *b*). Indeed, if
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1139.jpg)'
  prefs: []
  type: TYPE_IMG
- en: with 0 exponents being used to make the set of primes *p*[1], *p*[2], …, *p*[*r*]
    the same for both *a* and *b*, then, as Exercise 31.2-1 asks you to show,
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1140.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The best algorithms to date for factoring do not run in polynomial time. Thus,
    this approach to computing greatest common divisors seems unlikely to yield an
    efficient algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Euclid’s algorithm for computing greatest common divisors relies on the following
    theorem.
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.9 (GCD recursion theorem)***'
  prefs: []
  type: TYPE_NORMAL
- en: For any nonnegative integer *a* and any positive integer *b*,
  prefs: []
  type: TYPE_NORMAL
- en: gcd(*a*, *b*) = gcd(*b*, *a* mod *b*).
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   We will show that gcd(*a*, *b*) and gcd(*b*, *a* mod *b*) divide
    each other. Since they are both nonnegative, equation (31.5) then implies that
    they must be equal.'
  prefs: []
  type: TYPE_NORMAL
- en: We first show that gcd(*a*, *b*) | gcd(*b*, *a* mod *b*). If we let *d* = gcd(*a*,
    *b*), then *d* | *a* and *d* | *b*. By equation (3.11) on page 64, *a* mod *b*
    = *a* – *qb*, where *q* = ⌊*a*/*b*⌋. Since *a* mod *b* is thus a linear combination
    of *a* and *b*, equation (31.4) implies that *d* | (*a* mod *b*). Therefore, since
    *d* | *b* and *d* | (*a* mod *b*), Corollary 31.3 implies that *d* | gcd(*b*,
    *a* mod *b*), that is,
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1141.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Showing that gcd(*b*, *a* mod *b*) | gcd(*a*, *b*) is almost the same. If we
    now let *d* = gcd(*b*, *a* mod *b*), then *d* | *b* and *d* | (*a* mod *b*). Since
    *a* = *qb* + (*a* mod *b*), where *q* = ⌊*a*/*b*⌋, we have that *a* is a linear
    combination of *b* and (*a* mod *b*). By equation (31.4), we conclude that *d*
    | *a*. Since *d* | *b* and *d* | *a*, we have that *d* | gcd(*a*, *b*) by Corollary
    31.3, so that
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1142.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Using equation (31.5) to combine equations (31.14) and (31.15) completes the
    proof.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '**Euclid’s algorithm**'
  prefs: []
  type: TYPE_NORMAL
- en: Euclid’s *Elements* (circa 300 B.C.E.) describes the following gcd algorithm,
    although its origin might be even earlier. The recursive procedure EUCLID implements
    Euclid’s algorithm, based directly on Theorem 31.9\. The inputs *a* and *b* are
    arbitrary nonnegative integers.
  prefs: []
  type: TYPE_NORMAL
- en: EUCLID(*a*, *b*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | **if** *b* == 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | **return** *a* |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | **else return** EUCLID(*b*, *a* mod *b*) |'
  prefs: []
  type: TYPE_TB
- en: 'For example, here is how the procedure computes gcd(30, 21):'
  prefs: []
  type: TYPE_NORMAL
- en: '| EUCLID(30, 21) | = | EUCLID(21, 9) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | EUCLID(9, 3) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | EUCLID(3, 0) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | 3. |'
  prefs: []
  type: TYPE_TB
- en: This computation calls EUCLID recursively three times.
  prefs: []
  type: TYPE_NORMAL
- en: The correctness of EUCLID follows from Theorem 31.9 and the property that if
    the algorithm returns *a* in line 2, then *b* = 0, so that by equation (31.9),
    gcd(*a*, *b*) = gcd(*a*, 0) = *a*. The algorithm cannot recurse indefinitely,
    since the second argument strictly decreases in each recursive call and is always
    nonnegative. Therefore, EUCLID always terminates with the correct answer.
  prefs: []
  type: TYPE_NORMAL
- en: '**The running time of Euclid’s algorithm**'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s analyze the worst-case running time of EUCLID as a function of the size
    of *a* and *b*. The overall running time of EUCLID is proportional to the number
    of recursive calls it makes. The analysis assumes that *a* > *b* ≥ 0, that is,
    the first argument is greater than the second argument. Why? If *b* = *a* > 0,
    then *a* mod *b* = 0 and the procedure terminates after one recursive call. If
    *b* > *a* ≥ 0, then the procedure makes just one more recursive call than when
    *a* > *b*, because in this case EUCLID(*a*, *b*) immediately makes the recursive
    call EUCLID(*b*, *a*), and now the first argument is greater than the second.
  prefs: []
  type: TYPE_NORMAL
- en: Our analysis relies on the Fibonacci numbers *F*[*k*], defined by the recurrence
    equation (3.31) on page 69.
  prefs: []
  type: TYPE_NORMAL
- en: '***Lemma 31.10***'
  prefs: []
  type: TYPE_NORMAL
- en: If *a* > *b* ≥ 1 and the call EUCLID(*a*, *b*) performs *k* ≥ 1 recursive calls,
    then *a* ≥ *F*[*k*+2] and *b* ≥ *F*[*k*+1].
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   The proof proceeds by induction on *k*. For the base case of
    the induction, let *k* = 1\. Then, *b* ≥ 1 = *F*[2], and since *a* > *b*, we must
    have *a* ≥ 2 = *F*[3]. Since *b* > (*a* mod *b*), in each recursive call the first
    argument is strictly larger than the second. The assumption that *a* > *b* therefore
    holds for each recursive call.'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming inductively that the lemma holds if the procedure makes *k* – 1 recursive
    calls, we shall prove that the lemma holds for *k* recursive calls. Since *k*
    > 0, we have *b* > 0, and EUCLID(*a*, *b*) calls EUCLID(*b*, *a* mod *b*) recursively,
    which in turn makes *k* – 1 recursive calls. The inductive hypothesis then implies
    that *b* ≥ *F*[*k*+1] (thus proving part of the lemma), and *a* mod *b* ≥ *F*[*k*].
    We have
  prefs: []
  type: TYPE_NORMAL
- en: '| *b* + (*a* mod *b*) | = *b* + (*a* – *b* ⌊*a*/*b*⌋) | (by equation (3.11))
    |'
  prefs: []
  type: TYPE_TB
- en: '|  | ≤ *a*, |  |'
  prefs: []
  type: TYPE_TB
- en: since *a* > *b* > 0 implies ⌊*a*/*b*⌋ ≥ 1\. Thus,
  prefs: []
  type: TYPE_NORMAL
- en: '| *a* | ≥ | *b* + (*a* mod *b*) |'
  prefs: []
  type: TYPE_TB
- en: '|  | ≥ | *F*[*k*+1] + *F*[*k*] |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | *F*[*k*+2]. |'
  prefs: []
  type: TYPE_TB
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: The following theorem is an immediate corollary of this lemma.
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.11 (Lamé’s theorem)***'
  prefs: []
  type: TYPE_NORMAL
- en: For any integer *k* ≥ 1, if *a* > *b* ≥ 1 and *b* < *F*[*k*+1], then the call
    EUCLID(*a*, *b*) makes fewer than *k* recursive calls.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: To show that the upper bound of Theorem 31.11 is the best possible, we’ll show
    that the call EUCLID(*F*[*k*+1], *F*[*k*]) makes exactly *k* – 1 recursive calls
    when *k* ≥ 2\. We use induction on *k*. For the base case, *k* = 2, and the call
    EUCLID(*F*[3], *F*[2]) makes exactly one recursive call, to EUCLID(1, 0). (We
    have to start at *k* = 2, because when *k* = 1 we do not have *F*[2] > *F*[1].)
    For the inductive step, assume that EUCLID(*F*[*k*], *F*[*k*−1]) makes exactly
    *k* – 2 recursive calls. For *k* > 2, we have *F*[*k*] > *F*[*k*−1] > 0 and *F*[*k*+1]
    = *F*[*k*] + *F*[*k*−1], and so by Exercise 31.1-1, we have *F*[*k*+1] mod *F*[*k*]
    = *F*[*k*−1]. Because EUCLID(*a*, *b*) calls EUCLID(*b*, *a* mod *b*) when *b*
    > 0, the call EUCLID(*F*[*k*+1], *F*[*k*]) recurses one time more than the call
    EUCLID(*F*[*k*], *F*[*k*−1]), or exactly *k* – 1 times, which meets the upper
    bound given by Theorem 31.11.
  prefs: []
  type: TYPE_NORMAL
- en: Since *F*[*k*] is approximately ![art](images/Art_P1143.jpg), where *ϕ* is the
    golden ratio ![art](images/Art_P1144.jpg) defined by equation (3.32) on page 69,
    the number of recursive calls in EUCLID is *O*(1g *b*). (See Exercise 31.2-5 for
    a tighter bound.) Therefore, a call of EUCLID on two *β*-bit numbers performs
    *O*(*β*) arithmetic operations and *O*(*β*³) bit operations (assuming that multiplication
    and division of *β*-bit numbers take *O*(*β*²) bit operations). Problem 31-2 asks
    you to prove an *O*(*β*²) bound on the number of bit operations.
  prefs: []
  type: TYPE_NORMAL
- en: '**The extended form of Euclid’s algorithm**'
  prefs: []
  type: TYPE_NORMAL
- en: By rewriting Euclid’s algorithm, we can gain additional useful information.
    Specifically, let’s extend the algorithm to compute the integer coefficients *x*
    and *y* such that
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1145.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where either or both of *x* and *y* may be zero or negative. These coefficients
    will prove useful later for computing modular multiplicative inverses. The procedure
    EXTENDED-EUCLID takes as input a pair of nonnegative integers and returns a triple
    of the form (*d*, *x*, *y*) that satisfies equation (31.16). As an example, [Figure
    31.1](chapter031.xhtml#Fig_31-1) traces out the call EXTENDED-EUCLID(99, 78).
  prefs: []
  type: TYPE_NORMAL
- en: EXTENDED-EUCLID(*a*, *b*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | **if** *b* == 0 |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | **return** (*a*, 1, 0) |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | **else** (*d*′, *x*′, *y*′) = EXTENDED-EUCLID(*b*, *a* mod *b*) |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | (*d*, *x*, *y*) = (*d*′, *y*′, *x*′ – ⌊*a*/*b*⌋ *y*′) |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | **return** (*d*, *x*, *y*) |'
  prefs: []
  type: TYPE_TB
- en: The EXTENDED-EUCLID procedure is a variation of the EUCLID procedure. Line 1
    is equivalent to the test “*b* == 0” in line 1 of EUCLID. If *b* = 0, then EXTENDED-EUCLID
    returns not only *d* = *a* in line 2, but also the coefficients *x* = 1 and *y*
    = 0, so that *a* = *ax* + *by*. If *b* ≠ 0, EXTENDED-EUCLID first computes (*d*′,
    *x*′, *y*′) such that *d*′ = gcd(*b*, *a* mod *b*) and
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1146.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As in the EUCLID procedure, we have *d* = gcd(*a*, *b*) = *d*′ = gcd(*b*, *a*
    mod *b*). To obtain *x* and *y* such that *d* = *ax* + *by*, let’s rewrite equation
    (31.17), setting *d* = *d*′ and using equation (3.11):'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1147.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 31.1** How EXTENDED-EUCLID computes gcd(99, 78). Each line shows one
    level of the recursion: the values of the inputs *a* and *b*, the computed value
    ⌊*a*/*b*⌋, and the values *d*, *x*, and *y* returned. The triple (*d*, *x*, *y*)
    returned becomes the triple (*d*′, *x*′, *y*′) used at the next higher level of
    recursion. The call EXTENDED-EUCLID(99, 78) returns (3, –11, 14), so that gcd(99,
    78) = 3 = 99 · (–11) + 78 · 14.'
  prefs: []
  type: TYPE_NORMAL
- en: '| *d* | = | *bx*′ + (*a* – *b* ⌊*a*/*b*⌋)*y*′ |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | *ay*′ + *b*(*x*′ – ⌊*a*/*b*⌋ *y*′). |'
  prefs: []
  type: TYPE_TB
- en: Thus, choosing *x* = *y*′ and *y* = *x*′ – ⌊*a*/*b*⌋ *y*′ satisfies the equation
    *d* = *ax* + *by*, thereby proving the correctness of EXTENDED-EUCLID.
  prefs: []
  type: TYPE_NORMAL
- en: Since the number of recursive calls made in EUCLID is equal to the number of
    recursive calls made in EXTENDED-EUCLID, the running times of EUCLID and EXTENDED-EUCLID
    are the same, to within a constant factor. That is, for *a* > *b* > 0, the number
    of recursive calls is *O*(1g *b*).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs: []
  type: TYPE_NORMAL
- en: '***31.2-1***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove that equations (31.11) and (31.12) imply equation (31.13).
  prefs: []
  type: TYPE_NORMAL
- en: '***31.2-2***'
  prefs: []
  type: TYPE_NORMAL
- en: Compute the values (*d*, *x*, *y*) that the call EXTENDED-EUCLID(899, 493) returns.
  prefs: []
  type: TYPE_NORMAL
- en: '***31.2-3***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove that for all integers *a*, *k*, and *n*,
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1148.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Use equation (31.18) to show that *a* = 1 (mod *n*) implies gcd(*a*, *n*) =
    1.
  prefs: []
  type: TYPE_NORMAL
- en: '***31.2-4***'
  prefs: []
  type: TYPE_NORMAL
- en: Rewrite EUCLID in an iterative form that uses only a constant amount of memory
    (that is, stores only a constant number of integer values).
  prefs: []
  type: TYPE_NORMAL
- en: '***31.2-5***'
  prefs: []
  type: TYPE_NORMAL
- en: If *a* > *b* ≥ 0, show that the call EUCLID (*a*, *b*) makes at most 1 + log[*ϕ*] *b*
    recursive calls. Improve this bound to 1 + log[*ϕ*](*b*/gcd(*a*, *b)*).
  prefs: []
  type: TYPE_NORMAL
- en: '***31.2-6***'
  prefs: []
  type: TYPE_NORMAL
- en: What does EXTENDED-EUCLID(*F*[*k*+1], *F*[*k*]) return? Prove your answer correct.
  prefs: []
  type: TYPE_NORMAL
- en: '***31.2-7***'
  prefs: []
  type: TYPE_NORMAL
- en: Define the gcd function for more than two arguments by the recursive equation
    gcd(*a*[0], *a*[1], …, *a*[*n*]) = gcd(*a*[0], gcd(*a*[1], *a*[2], …, *a*[*n*])).
    Show that the gcd function returns the same answer independent of the order in
    which its arguments are specified. Also show how to find integers *x*[0], *x*[1],
    …, *x*[*n*] such that gcd(*a*[0], *a*[1], …, *a*[*n*]) = *a*[0]*x*[0] + *a*[1]*x*[1]
    + ⋯ + *a*[*n*]*x*[*n*]. Show that the number of divisions performed by your algorithm
    is *O*(*n* + 1g(max {*a*[0], *a*[1], …, *a*[*n*]})).
  prefs: []
  type: TYPE_NORMAL
- en: '***31.2-8***'
  prefs: []
  type: TYPE_NORMAL
- en: The ***least common multiple*** 1cm(*a*[1], *a*[2], …, *a*[*n*]) of integers
    *a*[1], *a*[2], …, *a*[*n*] is the smallest nonnegative integer that is a multiple
    of each *a*[*i*]. Show how to compute 1cm(*a*[1], *a*[2], …, *a*[*n*]) efficiently
    using the (two-argument) gcd operation as a subroutine.
  prefs: []
  type: TYPE_NORMAL
- en: '***31.2-9***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove that *n*[1], *n*[2], *n*[3], and *n*[4] are pairwise relatively prime
    if and only if
  prefs: []
  type: TYPE_NORMAL
- en: gcd(*n*[1]*n*[2], *n*[3]*n*[4]) = gcd(*n*[1]*n*[3], *n*[2]*n*[4]) = 1.
  prefs: []
  type: TYPE_NORMAL
- en: More generally, show that *n*[1], *n*[2], …, *n*[*k*] are pairwise relatively
    prime if and only if a set of ⌈1g *k*⌉ pairs of numbers derived from the *n*[*i*]
    are relatively prime.
  prefs: []
  type: TYPE_NORMAL
- en: '[**31.3    Modular arithmetic**](toc.xhtml#Rh1-179)'
  prefs: []
  type: TYPE_NORMAL
- en: Informally, you can think of modular arithmetic as arithmetic as usual over
    the integers, except that when working modulo *n*, then every result *x* is replaced
    by the element of {0, 1, …, *n* – 1} that is equivalent to *x*, modulo *n* (so
    that *x* is replaced by *x* mod *n*). This informal model suffices if you stick
    to the operations of addition, subtraction, and multiplication. A more formal
    model for modular arithmetic, which follows, is best described within the framework
    of group theory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Finite groups**'
  prefs: []
  type: TYPE_NORMAL
- en: 'A ***group*** (*S*, ⊕) is a set *S* together with a binary operation ⊕ defined
    on *S* for which the following properties hold:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Closure:** For all *a*, *b* ∈ *S*, we have *a* ⊕ *b* ∈ *S*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Identity:** There exists an element *e* ∈ *S*, called the ***identity***
    of the group, such that *e* ⊕ *a* = *a* ⊕ *e* = *a* for all *a* ∈ *S*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Associativity:** For all *a*, *b*, *c* ∈ *S*, we have (*a* ⊕ *b*) ⊕ *c* =
    *a* ⊕ (*b* ⊕ *c*).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Inverses:** For each *a* ∈ *S*, there exists a unique element *b* ∈ *S*,
    called the ***inverse*** of *a*, such that *a* ⊕ *b* = *b* ⊕ *a* = *e*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As an example, consider the familiar group (ℤ, +) of the integers ℤ under the
    operation of addition: 0 is the identity, and the inverse of *a* is –*a*. An ***abelian
    group*** (*S*, ⊕) satisfies the ***commutative law*** *a* ⊕ *b* = *b* ⊕ *a* for
    all *a*, *b* ∈ *S*. The ***size*** of group (*S*, ⊕) is |*S*|, and if |*S*| <
    ∞, then (*S*, ⊕) is a ***finite group***.'
  prefs: []
  type: TYPE_NORMAL
- en: '**The groups defined by modular addition and multiplication**'
  prefs: []
  type: TYPE_NORMAL
- en: We can form two finite abelian groups by using addition and multiplication modulo
    *n*, where *n* is a positive integer. These groups are based on the equivalence
    classes of the integers modulo *n*, defined in [Section 31.1](chapter031.xhtml#Sec_31.1).
  prefs: []
  type: TYPE_NORMAL
- en: To define a group on ℤ[*n*], we need suitable binary operations, which we obtain
    by redefining the ordinary operations of addition and multiplication. We can define
    addition and multiplication operations for ℤ[*n*], because the equivalence class
    of two integers uniquely determines the equivalence class of their sum or product.
    That is, if *a* = *a*′ (mod *n*) and *b* = *b*′ (mod *n*), then
  prefs: []
  type: TYPE_NORMAL
- en: '| *a* + *b* | = | *a*′ + *b*′ | (mod *n*), |'
  prefs: []
  type: TYPE_TB
- en: '| *ab* | = | *a*′*b*′ | (mod *n*). |'
  prefs: []
  type: TYPE_TB
- en: Thus, we define addition and multiplication modulo *n*, denoted +[*n*] and ·[*n*],
    by
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1149.jpg)'
  prefs: []
  type: TYPE_IMG
- en: (We can define subtraction similarly on ℤ[*n*] by [*a*][*n*] –[*n*] [*b*][*n*]
    = [*a* – *b*][*n*], but division is more complicated, as we’ll see.) These facts
    justify the common and convenient practice of using the smallest nonnegative element
    of each equivalence class as its representative when performing computations in
    ℤ[*n*]. We add, subtract, and multiply as usual on the representatives, but we
    replace each result *x* by the representative of its class, that is, by *x* mod
    *n*.
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1150.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 31.2** Two finite groups. Equivalence classes are denoted by their
    representative elements. **(a)** The group (ℤ[6], +[6]). **(b)** The group ![art](images/Art_P1151.jpg).'
  prefs: []
  type: TYPE_NORMAL
- en: Using this definition of addition modulo *n*, we define the ***additive group
    modulo n*** as (ℤ[*n*], +[*n*]). The size of the additive group modulo *n* is
    |ℤ[*n*]| = *n*. [Figure 31.2(a)](chapter031.xhtml#Fig_31-2) gives the operation
    table for the group (ℤ[6], +[6]).
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.12***'
  prefs: []
  type: TYPE_NORMAL
- en: The system (ℤ[*n*], +[*n*]) is a finite abelian group.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   Equation (31.19) shows that (ℤ[*n*], +[*n*]) is closed. Associativity
    and commutativity of +[*n*] follow from the associativity and commutativity of
    +:'
  prefs: []
  type: TYPE_NORMAL
- en: '| ([*a*][*n*] +[*n*] [*b*][*n*]) +[*n*] [*c*][*n*] | = | [*a* + *b*][*n*] +[*n*]
    [*c*][*n*] |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | [(*a* + *b*) + *c*][*n*] |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | [*a* + (*b* + *c*)][*n*] |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | [*a*][*n*] +[*n*] [*b* + *c*][*n*] |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | [*a*][*n*] +[*n*] ([*b*][*n*] +[*n*] [*c*][*n*]), |'
  prefs: []
  type: TYPE_TB
- en: '|   |'
  prefs: []
  type: TYPE_TB
- en: '| [*a*][*n*] +[*n*] [*b*][*n*] | = | [*a* + *b*][*n*] |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | [*b* + *a*][*n*] |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | [*b*][*n*] +[*n*] [*a*][*n*]. |'
  prefs: []
  type: TYPE_TB
- en: The identity element of (ℤ[*n*], +[*n*]) is 0 (that is, [0][*n*]). The (additive)
    inverse of an element *a* (that is, of [*a*][*n*]) is the element –*a* (that is,
    [–*a*][*n*] or [*n* – *a*][*n*]), since [*a*][*n*] +[*n*] [–*a*][*n*] = [*a* –
    *a*][*n*] = [0][*n*].
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the definition of multiplication modulo *n*, we define the ***multiplicative
    group modulo n*** as ![art](images/Art_P1152.jpg). The elements of this group
    are the set ![art](images/Art_P1153.jpg) of elements in ℤ[*n*] that are relatively
    prime to *n*, so that each one has a unique inverse, modulo *n*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1154.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'To see that ![art](images/Art_P1153.jpg) is well defined, note that for 0 ≤
    *a* < *n*, we have *a* = (*a* + *kn*) (mod *n*) for all integers *k*. By Exercise
    31.2-3, therefore, gcd(*a*, *n*) = 1 implies gcd(*a* + *kn*, *n*) = 1 for all
    integers *k*. Since [*a*][*n*] = {*a* + *kn* : *k* ∈ ℤ}, the set ![art](images/Art_P1153.jpg)
    is well defined. An example of such a group is'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1157.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where the group operation is multiplication modulo 15\. (We have denoted an
    element [*a*][15] as *a*, and thus, for example, we denote [7][15] as 7.) [Figure
    31.2(b)](chapter031.xhtml#Fig_31-2) shows the group ![art](images/Art_P1158.jpg).
    For example, 8 · 11 = 13 (mod 15), working in ![art](images/Art_P1159.jpg). The
    identity for this group is 1.
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.13***'
  prefs: []
  type: TYPE_NORMAL
- en: The system ![art](images/Art_P1160.jpg) is a finite abelian group.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   Theorem 31.6 implies that ![art](images/Art_P1152.jpg) is closed.
    Associativity and commutativity can be proved for ·[*n*] as they were for +[*n*]
    in the proof of Theorem 31.12\. The identity element is [1][*n*]. To show the
    existence of inverses, let *a* be an element of ![art](images/Art_P1153.jpg) and
    let (*d*, *x*, *y*) be returned by EXTENDED-EUCLID(*a*, *n*). Then we have *d*
    = 1, since ![art](images/Art_P1163.jpg), and'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1164.jpg)'
  prefs: []
  type: TYPE_IMG
- en: or equivalently,
  prefs: []
  type: TYPE_NORMAL
- en: '*ax* = 1 (mod *n*).'
  prefs: []
  type: TYPE_NORMAL
- en: Thus [*x*][*n*] is a multiplicative inverse of [*a*][*n*], modulo *n*. Furthermore,
    we claim that ![art](images/Art_P1165.jpg). To see why, equation (31.20) demonstrates
    that the smallest positive linear combination of *x* and *n* must be 1\. Therefore,
    Theorem 31.2 implies that gcd(*x*, *n*) = 1\. We defer the proof that inverses
    are uniquely defined until Corollary 31.26 in [Section 31.4](chapter031.xhtml#Sec_31.4).
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: As an example of computing multiplicative inverses, suppose that *a* = 5 and
    *n* = 11\. Then EXTENDED-EUCLID(*a*, *n*) returns (*d*, *x*, *y*) = (1, –2, 1),
    so that 1 = 5 · (–2) + 11 · 1\. Thus, [–2][11] (i.e., [9][11]) is the multiplicative
    inverse of [5][11].
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with the groups (ℤ[*n*], +[*n*]) and ![art](images/Art_P1160.jpg)
    in the remainder of this chapter, we follow the convenient practice of denoting
    equivalence classes by their representative elements and denoting the operations
    +[*n*] and ·[*n*] by the usual arithmetic notations + and · (or juxtaposition,
    so that *ab* = *a* · *b*) respectively. Furthermore, equivalences modulo *n* may
    also be interpreted as equations in ℤ[*n*]. For example, the following two statements
    are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '*ax* = *b* (mod *n*)'
  prefs: []
  type: TYPE_NORMAL
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '[*a*][*n*] ·[*n*] [*x*][*n*] = [*b*][*n*].'
  prefs: []
  type: TYPE_NORMAL
- en: As a further convenience, we sometimes refer to a group (*S*, ⊕) merely as *S*
    when the operation ⊕ is understood from context. We may thus refer to the groups
    (ℤ[*n*], +[*n*]) and ![art](images/Art_P1160.jpg) as just ℤ[*n*] and ![art](images/Art_P1153.jpg),
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: We denote the (multiplicative) inverse of an element *a* by (*a*^(−1) mod *n*).
    Division in ![art](images/Art_P1153.jpg) is defined by the equation *a*/*b* =
    *ab*^(−1) (mod *n*). For example, in ![art](images/Art_P1159.jpg) we have that
    7^(−1) = 13 (mod 15), since 7 · 13 = 91 = 1 (mod 15), so that 2/7 = 2 · 13 = 11
    (mod 15).
  prefs: []
  type: TYPE_NORMAL
- en: The size of ![art](images/Art_P1153.jpg) is denoted *ϕ*(*n*). This function,
    known as ***Euler’s phi function***, satisfies the equation
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1172.jpg)'
  prefs: []
  type: TYPE_IMG
- en: so that *p* runs over all the primes dividing *n* (including *n* itself, if
    *n* is prime). We won’t prove this formula here. Intuitively, begin with a list
    of the *n* remainders {0, 1, …, *n* – 1} and then, for each prime *p* that divides
    *n*, cross out every multiple of *p* in the list. For example, since the prime
    divisors of 45 are 3 and 5,
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1173.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If *p* is prime, then ![art](images/Art_P1174.jpg), and
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1175.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If *n* is composite, then *ϕ*(*n*) < *n* – 1, although it can be shown that
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1176.jpg)'
  prefs: []
  type: TYPE_IMG
- en: for *n* ≥ 3, where *γ* = 0.5772156649 … is ***Euler’s constant***. A somewhat
    simpler (but looser) lower bound for *n* > 5 is
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1177.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The lower bound (31.23) is essentially the best possible, since
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1178.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Subgroups**'
  prefs: []
  type: TYPE_NORMAL
- en: If (*S*, ⊕) is a group, *S*′ ⊆ *S*, and (*S*′, ⊕) is also a group, then (*S*′,
    ⊕) is a ***subgroup*** of (*S*, ⊕). For example, the even integers form a subgroup
    of the integers under the operation of addition. The following theorem, whose
    proof we leave as Exercise 31.3-3, provides a useful tool for recognizing subgroups.
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.14 (A nonempty closed subset of a finite group is a subgroup)***'
  prefs: []
  type: TYPE_NORMAL
- en: If (*S*, ⊕) is a finite group and *S*′ is any nonempty subset of *S* such that
    *a* ⊕ *b* ∈ *S*′ for all *a*, *b* ∈ *S*′, then (*S*′, ⊕) is a subgroup of (*S*,
    ⊕).
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: For example, the set {0, 2, 4, 6} forms a subgroup of ℤ[8], since it is nonempty
    and closed under the operation + (that is, it is closed under +[8]).
  prefs: []
  type: TYPE_NORMAL
- en: The following theorem, whose proof is omitted, provides an extremely useful
    constraint on the size of a subgroup.
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.15 (Lagrange’s theorem)***'
  prefs: []
  type: TYPE_NORMAL
- en: If (*S*, ⊕) is a finite group and (*S*′, ⊕) is a subgroup of (*S*, ⊕), then
    |*S*′| is a divisor of |*S*|.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: A subgroup *S*′ of a group *S* is a ***proper*** subgroup if *S*′ ≠ *S*. We’ll
    use the following corollary in the analysis in [Section 31.8](chapter031.xhtml#Sec_31.8)
    of the Miller-Rabin primality test procedure.
  prefs: []
  type: TYPE_NORMAL
- en: '***Corollary 31.16***'
  prefs: []
  type: TYPE_NORMAL
- en: If *S*′ is a proper subgroup of a finite group *S*, then |*S*′| ≤ |*S*|/2.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '**Subgroups generated by an element**'
  prefs: []
  type: TYPE_NORMAL
- en: 'Theorem 31.14 affords us a straightforward way to produce a subgroup of a finite
    group (*S*, ⊕): choose an element *a* and take all elements that can be generated
    from *a* using the group operation. Specifically, define *a*^((*k*)) for *k* ≥
    1 by'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1179.jpg)'
  prefs: []
  type: TYPE_IMG
- en: For example, taking *a* = 2 in the group ℤ[6] yields the sequence
  prefs: []
  type: TYPE_NORMAL
- en: '*a*^((1)), *a*^((2)), *a*^((3)), … = 2, 4, 0, 2, 4, 0, 2, 4, 0, ….'
  prefs: []
  type: TYPE_NORMAL
- en: We have *a*^((*k*)) = *ka* mod *n* in the group ℤ[*n*], and *a*^((*k*)) = *a*^(*k*)
    mod *n* in the group ![art](images/Art_P1153.jpg). We define the ***subgroup generated
    by a***, denoted 〈*a*〉 or (〈*a*〉, ⊕), by
  prefs: []
  type: TYPE_NORMAL
- en: '〈*a*〉 = {*a*^((*k*)) : *k* ≥ 1}.'
  prefs: []
  type: TYPE_NORMAL
- en: We say that *a* ***generates*** the subgroup 〈*a*〉 or that *a* is a ***generator***
    of 〈*a*〉. Since *S* is finite, 〈*a*〉 is a finite subset of *S*, possibly including
    all of *S*. Since the associativity of ⊕ implies
  prefs: []
  type: TYPE_NORMAL
- en: '*a*^((*i*)) ⊕ *a*^((*j*)) = *a*^((*i*+*j*)),'
  prefs: []
  type: TYPE_NORMAL
- en: 〈*a*〉 is closed and therefore, by Theorem 31.14, 〈*a*〉 is a subgroup of *S*.
    For example, in ℤ[6], we have
  prefs: []
  type: TYPE_NORMAL
- en: '| 〈0〉 | = | {0}, |'
  prefs: []
  type: TYPE_TB
- en: '| 〈1〉 | = | {0, 1, 2, 3, 4, 5}, |'
  prefs: []
  type: TYPE_TB
- en: '| 〈2〉 | = | {0, 2, 4}. |'
  prefs: []
  type: TYPE_TB
- en: Similarly, in ![art](images/Art_P1181.jpg), we have
  prefs: []
  type: TYPE_NORMAL
- en: '| 〈1〉 | = | {1}, |'
  prefs: []
  type: TYPE_TB
- en: '| 〈2〉 | = | {1, 2, 4}, |'
  prefs: []
  type: TYPE_TB
- en: '| 〈3〉 | = | {1, 2, 3, 4, 5, 6}. |'
  prefs: []
  type: TYPE_TB
- en: The ***order*** of *a* (in the group *S*), denoted ord(*a*), is defined as the
    smallest positive integer *t* such that *a*^((*t*)) = *e*. (Recall that *e* ∈
    *S* is the group identity.)
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.17***'
  prefs: []
  type: TYPE_NORMAL
- en: For any finite group (*S*, ⊕) and any *a* ∈ *S*, the order of *a* is equal to
    the size of the subgroup it generates, or ord(*a*) = |〈*a*〉|.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   Let *t* = ord(*a*). Since *a*^((*t*)) = *e* and *a*^((*t*+*k*))
    = *a*^((*t*)) ⊕ *a*^((*k*)) = *a*^((*k*)) for *k* ≥ 1, if *i* > *t*, then *a*^((*i*))
    = *a*^((*j*)) for some *j* < *i*. Therefore, as we generate elements by *a*, we
    see no new elements after *a*^((*t*)). Thus, 〈*a*〉 = {*a*^((1)), *a*^((2)), …,
    *a*^((*t*))}, and so |〈*a*〉| ≤ *t*. To show that |〈*a*〉| ≥ *t*, we show that each
    element of the sequence *a*^((1)), *a*^((2)), …, *a*^((*t*)) is distinct. Suppose
    for the purpose of contradiction that *a*^((*i*)) = *a*^((*j*)) for some *i* and
    *j* satisfying 1 ≤ *i* < *j* ≤ *t*. Then, *a*^((*i*+*k*)) = *a*^((*j*+*k*)) for
    *k* ≥ 0\. But this equation implies that *a*^((*i*+(*t*–*j*))) = *a*^((*j*+(*t*–*j*)))
    = *e*, a contradiction, since *i* + (*t* – *j*) < *t* but *t* is the least positive
    value such that *a*^((*t*)) = *e*. Therefore, each element of the sequence *a*^((1)),
    *a*^((2)), …, *a*^((*t*)) is distinct, and |〈*a*〉| ≥ *t*. We conclude that ord(*a*)
    = |〈*a*〉|.'
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '***Corollary 31.18***'
  prefs: []
  type: TYPE_NORMAL
- en: The sequence *a*^((1)), *a*^((2)), … is periodic with period *t* = ord(*a*),
    that is, *a*^((*i*)) = *a*^((*j*)) if and only if *i* = *j* (mod *t*).
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: Consistent with the above corollary, we define *a*^((0)) as *e* and *a*^((*i*))
    as *a*^((*i* mod *t*)), where *t* = ord(*a*), for all integers *i*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Corollary 31.19***'
  prefs: []
  type: TYPE_NORMAL
- en: If (*S*, ⊕) is a finite group with identity *e*, then for all *a* ∈ *S*,
  prefs: []
  type: TYPE_NORMAL
- en: '*a*^((|*S*|)) = *e*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   Lagrange’s theorem (Theorem 31.15) implies that ord(*a*) | |*S*|,
    and so |*S*| = 0 (mod *t*), where *t* = ord(*a*). Therefore, *a*^((|*S*|)) = *a*^((0))
    = *e*.'
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs: []
  type: TYPE_NORMAL
- en: '***31.3-1***'
  prefs: []
  type: TYPE_NORMAL
- en: Draw the group operation tables for the groups (ℤ[4], +[4]) and ![art](images/Art_P1182.jpg).
    Show that these groups are isomorphic by exhibiting a one-to-one correspondence
    *f* between ℤ[4] and ![art](images/Art_P1183.jpg) such that *a*+*b* = *c* (mod
    4) if and only if *f*(*a*)·*f*(*b*) = *f*(*c*) (mod 5).
  prefs: []
  type: TYPE_NORMAL
- en: '***31.3-2***'
  prefs: []
  type: TYPE_NORMAL
- en: List all subgroups of ℤ[9] and of ![art](images/Art_P1184.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: '***31.3-3***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove Theorem 31.14.
  prefs: []
  type: TYPE_NORMAL
- en: '***31.3-4***'
  prefs: []
  type: TYPE_NORMAL
- en: Show that if *p* is prime and *e* is a positive integer, then
  prefs: []
  type: TYPE_NORMAL
- en: '*ϕ*(*p*^(*e*)) = *p*^(*e*–1)(*p* – 1).'
  prefs: []
  type: TYPE_NORMAL
- en: '***31.3-5***'
  prefs: []
  type: TYPE_NORMAL
- en: Show that for any integer *n* > 1 and for any ![art](images/Art_P1185.jpg),
    the function ![art](images/Art_P1186.jpg) defined by *f*[*a*](*x*) = *ax* mod
    *n* is a permutation of ![art](images/Art_P1153.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: '[**31.4    Solving modular linear equations**](toc.xhtml#Rh1-180)'
  prefs: []
  type: TYPE_NORMAL
- en: We now consider the problem of finding solutions to the equation
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1188.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *a* > 0 and *n* > 0\. This problem has several applications. For example,
    we’ll use it in [Section 31.7](chapter031.xhtml#Sec_31.7) as part of the procedure
    to find keys in the RSA public-key cryptosystem. We assume that *a*, *b*, and
    *n* are given, and we wish to find all values of *x*, modulo *n*, that satisfy
    equation (31.26). The equation may have zero, one, or more than one such solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let 〈*a*〉 denote the subgroup of ℤ[*n*] generated by *a*. Since 〈*a*〉 = {*a*^((*x*))
    : *x* > 0} = {*ax* mod *n* : *x* > 0}, equation (31.26) has a solution if and
    only if [*b*] ∈ 〈*a*〉. Lagrange’s theorem (Theorem 31.15) tells us that |〈*a*〉|
    must be a divisor of *n*. The following theorem gives us a precise characterization
    of 〈*a*〉.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.20***'
  prefs: []
  type: TYPE_NORMAL
- en: For any positive integers *a* and *n*, if *d* = gcd(*a*, *n*), then we have
  prefs: []
  type: TYPE_NORMAL
- en: '| 〈*a*〉 | = | 〈*d*〉 |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | {0, *d*, 2*d*, …, ((*n*/*d*) – 1)*d*} |'
  prefs: []
  type: TYPE_TB
- en: in ℤ[*n*], and thus
  prefs: []
  type: TYPE_NORMAL
- en: '|〈*a*〉| = *n*/*d*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   We begin by showing that *d* ∈ 〈*a*〉. Recall that EXTENDED-EUCLID(*a*,
    *n*) returns a triple (*d*, *x*, *y*) such that *ax* + *ny* = *d*. Thus, *ax*
    = *d* (mod *n*), so that *d* ∈ 〈*a*〉. In other words, *d* is a multiple of *a*
    in ℤ[*n*].'
  prefs: []
  type: TYPE_NORMAL
- en: Since *d* ∈ 〈*a*〉, it follows that every multiple of *d* belongs to 〈*a*〉, because
    any multiple of a multiple of *a* is itself a multiple of *a*. Thus, 〈*a*〉 contains
    every element in {0, *d*, 2*d*, …, ((*n*/*d*) – 1)*d*}. That is, 〈*d*〉 ⊆ 〈*a*〉.
  prefs: []
  type: TYPE_NORMAL
- en: We now show that 〈*a*〉 ⊆ 〈*d*〉. If *m* ∈ 〈*a*〉, then *m* = *ax* mod *n* for
    some integer *x*, and so *m* = *ax* + *ny* for some integer *y*. Because *d* =
    gcd(*a*, *n*), we know that *d* | *a* and *d* | *n*, and so *d* | *m* by equation
    (31.4). Therefore, *m* ∈ 〈*d*〉.
  prefs: []
  type: TYPE_NORMAL
- en: Combining these results, we have that 〈*a*〉 = 〈*d*〉. To see that |〈*a*〉| = *n*/*d*,
    observe that there are exactly *n*/*d* multiples of *d* between 0 and *n* – 1,
    inclusive.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '***Corollary 31.21***'
  prefs: []
  type: TYPE_NORMAL
- en: The equation *ax* = *b* (mod *n*) is solvable for the unknown *x* if and only
    if *d* | *b*, where *d* = gcd(*a*, *n*).
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   The equation *ax* = *b* (mod *n*) is solvable if and only if
    [*b*] ∈ 〈*a*〉, which is the same as saying'
  prefs: []
  type: TYPE_NORMAL
- en: (*b* mod *n*) ∈ {0, *d*, 2*d*, …, ((*n*/*d*) – 1)*d*},
  prefs: []
  type: TYPE_NORMAL
- en: by Theorem 31.20\. If 0 ≤ *b* < *n*, then *b* ∈ 〈*a*〉 if and only if *d* | *b*,
    since the members of 〈*a*〉 are precisely the multiples of *d*. If *b* < 0 or *b*
    ≥ *n*, the corollary then follows from the observation that *d* | *b* if and only
    if *d* | (*b* mod *n*), since *b* and *b* mod *n* differ by a multiple of *n*,
    which is itself a multiple of *d*.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '***Corollary 31.22***'
  prefs: []
  type: TYPE_NORMAL
- en: The equation *ax* = *b* (mod *n*) either has *d* distinct solutions modulo *n*,
    where *d* = gcd(*a*, *n*), or it has no solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   If *ax* = *b* (mod *n*) has a solution, then *b* ∈ 〈*a*〉. By
    Theorem 31.17, ord(*a*) = |〈*a*〉|, and so Corollary 31.18 and Theorem 31.20 imply
    that the sequence *ai* mod *n*, for *i* = 0, 1, …, is periodic with period |〈*a*〉|
    = *n*/*d*. If *b* ∈ 〈*a*〉, then *b* appears exactly *d* times in the sequence
    *ai* mod *n*, for *i* = 0, 1, …, *n* – 1, since the length-(*n*/*d*) block of
    values 〈*a*〉 repeats exactly *d* times as *i* increases from 0 to *n*–1\. The
    indices *x* of the *d* positions for which *ax* mod *n* = *b* are the solutions
    of the equation *ax* = *b* (mod *n*).'
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.23***'
  prefs: []
  type: TYPE_NORMAL
- en: Let *d* = gcd(*a*, *n*), and suppose that *d* = *ax*′ + *ny*′ for some integers
    *x*′ and *y*′ (for example, as computed by EXTENDED-EUCLID). If *d* | *b*, then
    the equation *ax* = *b* (mod *n*) has as one of its solutions the value *x*[0],
    where
  prefs: []
  type: TYPE_NORMAL
- en: '*x*[0] = *x*′(*b*/*d*) mod *n*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   We have'
  prefs: []
  type: TYPE_NORMAL
- en: '| *ax*[0] | = *ax*′(*b*/*d*) | (mod *n*) |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | = *d*(*b*/*d*) | (mod *n*) | (because *ax*′ = *d* (mod *n*)) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = *b* | (mod *n*), |  |'
  prefs: []
  type: TYPE_TB
- en: and thus *x*[0] is a solution to *ax* = *b* (mod *n*).
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.24***'
  prefs: []
  type: TYPE_NORMAL
- en: Suppose that the equation *ax* = *b* (mod *n*) is solvable (that is, *d* | *b*,
    where *d* = gcd(*a*, *n*)) and that *x*[0] is any solution to this equation. Then,
    this equation has exactly *d* distinct solutions, modulo *n*, given by *x*[*i*]
    = *x*[0] + *i*(*n*/*d*) for *i* = 0, 1, …, *d* – 1.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   Because *n*/*d* > 0 and 0 ≤ *i*(*n*/*d*) < *n* for *i* = 0, 1,
    …, *d* – 1, the values *x*[0], *x*[1], …, *x*[*d*–1] are all distinct, modulo
    *n*. Since *x*[0] is a solution of *ax* = *b* (mod *n*), we have *ax*[0] mod *n*
    = *b* (mod *n*). Thus, for *i* = 0, 1, …, *d* – 1, we have'
  prefs: []
  type: TYPE_NORMAL
- en: '| *ax*[*i*] mod *n* | = | *a*(*x*[0] + *in*/*d*) mod *n* |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | (*ax*[0] + *ain*/*d*) mod *n* |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | *ax*[0] mod *n* (because *d* &#124; *a* implies that *ain*/*d* is
    a multiple of *n*) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | *b* (mod *n*), |'
  prefs: []
  type: TYPE_TB
- en: and hence *ax*[*i*] = *b* (mod *n*), making *x*[*i*] a solution, too. By Corollary
    31.22, the equation *ax* = *b* (mod *n*) has exactly *d* solutions, so that *x*[0],
    *x*[1], …, *x*[*d*–1] must be all of them.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: We have now developed the mathematics needed to solve the equation *ax* = *b*
    (mod *n*). The procedure MODULAR-LINEAR-EQUATION-SOLVER prints all solutions to
    this equation. The inputs *a* and *n* are arbitrary positive integers, and *b*
    is an arbitrary integer.
  prefs: []
  type: TYPE_NORMAL
- en: MODULAR-LINEAR-EQUATION-SOLVER(*a*, *b*, *n*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | (*d*, *x*′, *y*′) = EXTENDED-EUCLID(*a*, *n*) |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | **if** *d* &#124; *b* |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | *x*[0] = *x*′(*b*/*d*) mod *n* |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | **for** *i* = 0 **to** *d* – 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | print (*x*[0] + *i*(*n*/*d*)) mod *n* |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | **else** print “no solutions” |'
  prefs: []
  type: TYPE_TB
- en: As an example of the operation of MODULAR-LINEAR-EQUATION-SOLVER, consider the
    equation 14*x* = 30 (mod 100) (and thus *a* = 14, *b* = 30, and *n* = 100). Calling
    EXTENDED-EUCLID in line 1 gives (*d*, *x*′, *y*′) = (2, –7, 1). Since 2 | 30,
    lines 3–5 execute. Line 3 computes *x*[0] = (–7)(15) mod 100 = 95\. The **for**
    loop of lines 4–5 prints the two solutions, 95 and 45.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure MODULAR-LINEAR-EQUATION-SOLVER works as follows. The call to EXTENDED-EUCLID
    in line 1 returns a triple (*d*, *x*′, *y*′) such that *d* = gcd(*a*, *n*) and
    *d* = *ax*′ + *ny*′. Therefore, *x*′ is a solution to the equation *ax*′ = *d*
    (mod *n*). If *d* does not divide *b*, then the equation *ax* = *b* (mod *n*)
    has no solution, by Corollary 31.21\. Line 2 checks to see whether *d* | *b*,
    and if not, line 6 reports that there are no solutions. Otherwise, line 3 computes
    a solution *x*[0] to *ax* = *b* (mod *n*), as Theorem 31.23 suggests. Given one
    solution, Theorem 31.24 states that adding multiples of (*n*/*d*), modulo *n*,
    yields the other *d* – 1 solutions. The **for** loop of lines 4–5 prints out all
    *d* solutions, beginning with *x*[0] and spaced *n*/*d* apart, modulo *n*.
  prefs: []
  type: TYPE_NORMAL
- en: MODULAR-LINEAR-EQUATION-SOLVER performs *O*(1g *n* + gcd(*a*, *n*)) arithmetic
    operations, since EXTENDED-EUCLID performs *O*(1g *n*) arithmetic operations,
    and each iteration of the **for** loop of lines 4–5 performs a constant number
    of arithmetic operations.
  prefs: []
  type: TYPE_NORMAL
- en: The following corollaries of Theorem 31.24 give specializations of particular
    interest.
  prefs: []
  type: TYPE_NORMAL
- en: '***Corollary 31.25***'
  prefs: []
  type: TYPE_NORMAL
- en: For any *n* > 1, if gcd(*a*, *n*) = 1, then the equation *ax* = *b* (mod *n*)
    has a unique solution, modulo *n*.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: If *b* = 1, a common case of considerable interest, the *x* that solves the
    equation is a ***multiplicative inverse*** of *a*, modulo *n*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Corollary 31.26***'
  prefs: []
  type: TYPE_NORMAL
- en: For any *n* > 1, if gcd(*a*, *n*) = 1, then the equation *ax* = 1 (mod *n*)
    has a unique solution, modulo *n*. Otherwise, it has no solution.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: Thanks to Corollary 31.26, the notation *a*^(−1) mod *n* refers to *the* multiplicative
    inverse of *a*, modulo *n*, when *a* and *n* are relatively prime. If gcd(*a*,
    *n*) = 1, then the unique solution to the equation *ax* = 1 (mod *n*) is the integer
    *x* returned by EXTENDED-EUCLID, since the equation
  prefs: []
  type: TYPE_NORMAL
- en: gcd(*a*, *n*) = 1 = *ax* + *ny*
  prefs: []
  type: TYPE_NORMAL
- en: implies *ax* = 1 (mod *n*). Thus, EXTENDED-EUCLID can compute *a*^(−1) mod *n*
    efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs: []
  type: TYPE_NORMAL
- en: '***31.4-1***'
  prefs: []
  type: TYPE_NORMAL
- en: Find all solutions to the equation 35*x* = 10 (mod 50).
  prefs: []
  type: TYPE_NORMAL
- en: '***31.4-2***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove that the equation *ax* = *ay* (mod *n*) implies *x* = *y* (mod *n*) whenever
    gcd(*a*, *n*) = 1\. Show that the condition gcd(*a*, *n*) = 1 is necessary by
    supplying a counterexample with gcd(*a*, *n*) > 1.
  prefs: []
  type: TYPE_NORMAL
- en: '***31.4-3***'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following change to line 3 of the procedure MODULAR-LINEAR-EQUATION-SOLVER:'
  prefs: []
  type: TYPE_NORMAL
- en: '| 3 | *x*[0] = *x*′(*b*/*d*) mod (*n*/*d*) |'
  prefs: []
  type: TYPE_TB
- en: With this change, will the procedure still work? Explain why or why not.
  prefs: []
  type: TYPE_NORMAL
- en: ★ ***31.4-4***
  prefs: []
  type: TYPE_NORMAL
- en: Let *p* be prime and *f*(*x*) = (*f*[0] + *f*[1]*x* + ⋯ + *f*[*t*]*x*^(*t*))
    (mod *p*) be a polynomial of degree *t*, with coefficients *f*[*i*] drawn from
    ℤ[*p*]. We say that *a* ∈ ℤ[*p*] is a ***zero*** of *f* if *f*(*a*) = 0 (mod *p*).
    Prove that if *a* is a zero of *f*, then *f*(*x*) = (*x* – *a*)*g*(*x*) (mod *p*)
    for some polynomial *g*(*x*) of degree *t* – 1\. Prove by induction on *t* that
    if *p* is prime, then a polynomial *f*(*x*) of degree *t* can have at most *t*
    distinct zeros modulo *p*.
  prefs: []
  type: TYPE_NORMAL
- en: '[**31.5    The Chinese remainder theorem**](toc.xhtml#Rh1-181)'
  prefs: []
  type: TYPE_NORMAL
- en: Around 100 C.E., the Chinese mathematician Sun-Tsŭ solved the problem of finding
    those integers *x* that leave remainders 2, 3, and 2 when divided by 3, 5, and
    7 respectively. One such solution is *x* = 23, and all solutions are of the form
    23+105*k* for arbitrary integers *k*. The “Chinese remainder theorem” provides
    a correspondence between a system of equations modulo a set of pairwise relatively
    prime moduli (for example, 3, 5, and 7) and an equation modulo their product (for
    example, 105).
  prefs: []
  type: TYPE_NORMAL
- en: The Chinese remainder theorem has two major applications. Let the integer *n*
    be factored as *n* = *n*[1]*n*[2] ⋯ *n*[*k*], where the factors *n*[*i*] are pairwise
    relatively prime. First, the Chinese remainder theorem is a descriptive “structure
    theorem” that describes the structure of ℤ[*n*] as identical to that of the Cartesian
    product ![art](images/Art_P1189.jpg) with componentwise addition and multiplication
    modulo *n*[*i*] in the *i*th component. Second, this description helps in designing
    efficient algorithms, since working in each of the systems ![art](images/Art_P1190.jpg)
    can be more efficient (in terms of bit operations) than working modulo *n*.
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.27 (Chinese remainder theorem)***'
  prefs: []
  type: TYPE_NORMAL
- en: Let *n* = *n*[1]*n*[2] ⋯ *n*[*k*], where the *n*[*i*] are pairwise relatively
    prime. Consider the correspondence
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1191.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where ![art](images/Art_P1192.jpg), and
  prefs: []
  type: TYPE_NORMAL
- en: '*a*[*i*] = *a* mod *n*[*i*]'
  prefs: []
  type: TYPE_NORMAL
- en: for *i* = 1, 2, …, *k*. Then, mapping (31.27) is a one-to-one mapping (bijection)
    between ℤ[*n*] and the Cartesian product ![art](images/Art_P1193.jpg). Operations
    performed on the elements of ℤ[*n*] can be equivalently performed on the corresponding
    *k*-tuples by performing the operations independently in each coordinate position
    in the appropriate system. That is, if
  prefs: []
  type: TYPE_NORMAL
- en: '| *a* | ↔ | (*a*[1], *a*[2], …, *a*[*k*]), |'
  prefs: []
  type: TYPE_TB
- en: '| *b* | ↔ | (*b*[1], *b*[2], …, *b*[*k*]), |'
  prefs: []
  type: TYPE_TB
- en: then
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1194.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '***Proof***   Let’s see how to translate between the two representations. Going
    from *a* to (*a*[1], *a*[2], …, *a*[*k*]) requires only *k* “mod” operations.
    The reverse—computing *a* from inputs (*a*[1], *a*[2], …, *a*[*k*])—is only slightly
    more complicated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin by defining *m*[*i*] = *n*/*n*[*i*] for *i* = 1, 2, …, *k*. Thus,
    *m*[*i*] is the product of all of the *n*[*j*]’s other than *n*[*i*]: *m*[*i*]
    = *n*[1]*n*[2] ⋯ *n*[*i*−1]*n*[*i*+1] ⋯ *n*[*k*]. We next define'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1195.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'for *i* = 1, 2, …, *k*. Equation (31.31) is well defined: since *m*[*i*] and
    *n*[*i*] are relatively prime (by Theorem 31.6), Corollary 31.26 guarantees that
    ![art](images/Art_P1196.jpg) mod *n*[*i*] exists. Here is how to compute *a* as
    a function of the *a*[*i*] and *c*[*i*]:'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1197.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We now show that equation (31.32) ensures that *a* = *a*[*i*] (mod *n*[*i*])
    for *i* = 1, 2, …, *k*. If *j* ≠ *i*, then *m*[*j*] = 0 (mod *n*[*i*]), which
    implies that *c*[*j*] = *m*[*j*] = 0 (mod *n*[*i*]). Note also that *c*[*i*] =
    1 (mod *n*[*i*]), from equation (31.31). We thus have the appealing and useful
    correspondence
  prefs: []
  type: TYPE_NORMAL
- en: '*c*[*i*] ↔ (0, 0, …, 0, 1, 0, …, 0),'
  prefs: []
  type: TYPE_NORMAL
- en: a vector that has 0s everywhere except in the *i*th coordinate, where it has
    a 1\. The *c*[*i*] thus form a “basis” for the representation, in a certain sense.
    For each *i*, therefore, we have
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1198.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'which is what we wished to show: our method of computing *a* from the *a*[*i*]’s
    produces a result *a* that satisfies the constraints *a* = *a*[*i*] (mod *n*[*i*])
    for *i* = 1, 2, …, *k*. The correspondence is one-to-one, since we can transform
    in both directions. Finally, equations (31.28)–(31.30) follow directly from Exercise
    31.1-7, since *x* mod *n*[*i*] = (*x* mod *n*) mod *n*[*i*] for any *x* and *i*
    = 1, 2, …, *k*.'
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use the following corollaries later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: '***Corollary 31.28***'
  prefs: []
  type: TYPE_NORMAL
- en: If *n*[1], *n*[2], …, *n*[*k*] are pairwise relatively prime and *n* = *n*[1]*n*[2]
    ⋯ *n*[*k*], then for any integers *a*[1], *a*[2], …, *a*[*k*], the set of simultaneous
    equations
  prefs: []
  type: TYPE_NORMAL
- en: '| *x* = *a*[*i*] | (mod *n*[*i*]), |'
  prefs: []
  type: TYPE_TB
- en: for *i* = 1, 2, …, *k*, has a unique solution modulo *n* for the unknown *x*.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '***Corollary 31.29***'
  prefs: []
  type: TYPE_NORMAL
- en: If *n*[1], *n*[2], …, *n*[*k*] are pairwise relatively prime and *n* = *n*[1]*n*[2]
    ⋯ *n*[*k*], then for all integers *x* and *a*,
  prefs: []
  type: TYPE_NORMAL
- en: '*x* = *a* (mod *n*[*i*])'
  prefs: []
  type: TYPE_NORMAL
- en: for *i* = 1, 2, …, *k* if and only if
  prefs: []
  type: TYPE_NORMAL
- en: '*x* = *a* (mod *n*).'
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: As an example of the application of the Chinese remainder theorem, suppose that
    you are given the two equations
  prefs: []
  type: TYPE_NORMAL
- en: '| *a* = 2 | (mod 5), |'
  prefs: []
  type: TYPE_TB
- en: '| *a* = 3 | (mod 13), |'
  prefs: []
  type: TYPE_TB
- en: so that *a*[1] = 2, *n*[1] = *m*[2] = 5, *a*[2] = 3, and *n*[2] = *m*[1] = 13,
    and you wish to compute *a* mod 65, since *n* = *n*[1]*n*[2] = 65\. Because 13^(−1)
    = 2 (mod 5) and 5^(−1) = 8 (mod 13), you compute
  prefs: []
  type: TYPE_NORMAL
- en: '| *c*[1] | = 13 · (2 mod 5) = 26, |'
  prefs: []
  type: TYPE_TB
- en: '| *c*[2] | = 5 · (8 mod 13) = 40, |'
  prefs: []
  type: TYPE_TB
- en: and
  prefs: []
  type: TYPE_NORMAL
- en: '| *a* | = | 2 · 26 + 3 · 40 | (mod 65) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | 52 + 120 | (mod 65) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = | 42 | (mod 65). |'
  prefs: []
  type: TYPE_TB
- en: '![art](images/Art_P1199.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 31.3** An illustration of the Chinese remainder theorem for *n*[1]
    = 5 and *n*[2] = 13\. For this example, *c*[1] = 26 and *c*[2] = 40\. In row *i*,
    column *j* is shown the value of *a*, modulo 65, such that *a* mod 5 = *i* and
    *a* mod 13 = *j*. Note that row 0, column 0 contains a 0\. Similarly, row 4, column
    12 contains a 64 (equivalent to −1). Since *c*[1] = 26, moving down a row increases
    *a* by 26\. Similarly, *c*[2] = 40 means that moving right by a column increases
    *a* by 40\. Increasing *a* by 1 corresponds to moving diagonally downward and
    to the right, wrapping around from the bottom to the top and from the right to
    the left.'
  prefs: []
  type: TYPE_NORMAL
- en: See [Figure 31.3](chapter031.xhtml#Fig_31-3) for an illustration of the Chinese
    remainder theorem, modulo 65.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, you can work modulo *n* by working modulo *n* directly or by working in
    the transformed representation using separate modulo *n*[*i*] computations, as
    convenient. The computations are entirely equivalent.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs: []
  type: TYPE_NORMAL
- en: '***31.5-1***'
  prefs: []
  type: TYPE_NORMAL
- en: Find all solutions to the equations *x* = 4 (mod 5) and *x* = 5 (mod 11).
  prefs: []
  type: TYPE_NORMAL
- en: '***31.5-2***'
  prefs: []
  type: TYPE_NORMAL
- en: Find all integers *x* that leave remainders 1, 2, and 3 when divided by 9, 8,
    and 7, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '***31.5-3***'
  prefs: []
  type: TYPE_NORMAL
- en: Argue that, under the definitions of Theorem 31.27, if gcd(*a*, *n*) = 1, then
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1200.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '***31.5-4***'
  prefs: []
  type: TYPE_NORMAL
- en: Under the definitions of Theorem 31.27, prove that for any polynomial *f*, the
    number of roots of the equation *f*(*x*) = 0 (mod *n*) equals the product of the
    number of roots of each of the equations *f*(*x*) = 0 (mod *n*[1]), *f*(*x*) =
    0 (mod *n*[2]), …, *f*(*x*) = 0 (mod *n*[*k*]).
  prefs: []
  type: TYPE_NORMAL
- en: '[**31.6    Powers of an element**](toc.xhtml#Rh1-182)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Along with considering the multiples of a given element *a*, modulo *n*, we
    often consider the sequence of powers of *a*, modulo *n*, where ![art](images/Art_P1201.jpg):'
  prefs: []
  type: TYPE_NORMAL
- en: '*a*⁰, *a*¹, *a*², *a*³, …,'
  prefs: []
  type: TYPE_NORMAL
- en: modulo *n*. Indexing from 0, the 0th value in this sequence is *a*⁰ mod *n*
    = 1, and the *i*th value is *a*^(*i*) mod *n*. For example, the powers of 3 modulo
    7 are
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1201a.jpg)'
  prefs: []
  type: TYPE_IMG
- en: and the powers of 2 modulo 7 are
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1201b.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this section, let 〈*a*〉 denote the subgroup of ![art](images/Art_Zastn.jpg)
    generated by *a* through repeated multiplication, and let ord[*n*](*a*) (the “order
    of *a*, modulo *n*”) denote the order of *a* in ![art](images/Art_Zastn.jpg).
    For example, 〈2〉 = {1, 2, 4} in ![art](images/Art_P1202.jpg), and ord[7](2) =
    3\. Using the definition of the Euler phi function *ϕ*(*n*) as the size of ![art](images/Art_Zastn.jpg)
    (see [Section 31.3](chapter031.xhtml#Sec_31.3)), we now translate Corollary 31.19
    into the notation of ![art](images/Art_Zastn.jpg) to obtain Euler’s theorem and
    specialize it to ![art](images/Art_Zastp.jpg), where *p* is prime, to obtain Fermat’s
    theorem.
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.30 (Euler’s theorem)***'
  prefs: []
  type: TYPE_NORMAL
- en: For any integer *n* > 1,
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1203.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.31 (Fermat’s theorem)***'
  prefs: []
  type: TYPE_NORMAL
- en: If *p* is prime, then
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1204.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '***Proof***   By equation (31.22), *ϕ*(*p*) = *p* – 1 if *p* is prime.'
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: Fermat’s theorem applies to every element in ℤ[*p*] except 0, since ![art](images/Art_P1205.jpg).
    For all *a* ∈ ℤ[*p*], however, we have *a*^(*p*) = *a* (mod *p*) if *p* is prime.
  prefs: []
  type: TYPE_NORMAL
- en: If ![art](images/Art_P1206.jpg), then every element in ![art](images/Art_Zastn.jpg)
    is a power of *g*, modulo *n*, and *g* is a ***primitive root*** or a ***generator***
    of ![art](images/Art_Zastn.jpg). For example, 3 is a primitive root, modulo 7,
    but 2 is not a primitive root, modulo 7\. If ![art](images/Art_Zastn.jpg) possesses
    a primitive root, the group ![art](images/Art_Zastn.jpg) is ***cyclic***. We omit
    the proof of the following theorem, which is proven by Niven and Zuckerman [[345](bibliography001.xhtml#endnote_345)].
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.32***'
  prefs: []
  type: TYPE_NORMAL
- en: The values of *n* > 1 for which ![art](images/Art_Zastn.jpg) is cyclic are 2,
    4, *p*^(*e*), and 2*p*^(*e*), for all primes *p* > 2 and all positive integers
    *e*.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: If *g* is a primitive root of ![art](images/Art_Zastn.jpg) and *a* is any element
    of ![art](images/Art_Zastn.jpg), then there exists a *z* such that *g*^(*z*) =
    *a* (mod *n*). This *z* is a ***discrete logarithm*** or an ***index*** of *a*,
    modulo *n*, to the base *g*. We denote this value as ind[*n*,*g*](*a*).
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.33 (Discrete logarithm theorem)***'
  prefs: []
  type: TYPE_NORMAL
- en: If *g* is a primitive root of ![art](images/Art_Zastn.jpg), then the equation
    *g*^(*x*) = *g*^(*y*) (mod *n*) holds if and only if the equation *x* = *y* (mod
    *ϕ*(*n*)) holds.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   Suppose first that *x* = *y* (mod *ϕ*(*n*)). Then, we have *x*
    = *y* + *kϕ*(*n*) for some integer *k*, and thus'
  prefs: []
  type: TYPE_NORMAL
- en: '| *g*^(*x*) | = *g*^(*y*+*kϕ*(*n*)) | (mod *n*) |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | = *g*^(*y*) · (*g*^(*ϕ*(*n*)))^(*k*) | (mod *n*) |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | = *g*^(*y*) · 1^(*k*) | (mod *n*) | (by Euler’s theorem) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = *g*^(*y*) | (mod *n*). |  |'
  prefs: []
  type: TYPE_TB
- en: Conversely, suppose that *g*^(*x*) = *g*^(*y*) (mod *n*). Because the sequence
    of powers of *g* generates every element of 〈*g*〉 and |〈*g*〉| = *ϕ*(*n*), Corollary
    31.18 implies that the sequence of powers of *g* is periodic with period *ϕ*(*n*).
    Therefore, if *g*^(*x*) = *g*^(*y*) (mod *n*), we must have *x* = *y* (mod *ϕ*(*n*)).
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: Let’s now turn our attention to the square roots of 1, modulo a prime power.
    The following properties will be useful to justify the primality-testing algorithm
    in [Section 31.8](chapter031.xhtml#Sec_31.8).
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.34***'
  prefs: []
  type: TYPE_NORMAL
- en: If *p* is an odd prime and *e* ≥ 1, then the equation
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1207.jpg)'
  prefs: []
  type: TYPE_IMG
- en: has only two solutions, namely *x* = 1 and *x* = −1.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   By Exercise 31.6-2, equation (31.33) is equivalent to'
  prefs: []
  type: TYPE_NORMAL
- en: '*p*^(*e*) | (*x* − 1)(*x* + 1).'
  prefs: []
  type: TYPE_NORMAL
- en: Since *p* > 2, we can have *p* | (*x* − 1) or *p* | (*x* + 1), but not both.
    (Otherwise, by property (31.3), *p* would also divide their difference (*x* +
    1) – (*x* − 1) = 2.) If *p* ∤ (*x* – 1), then gcd(*p*^(*e*), *x* − 1) = 1, and
    by Corollary 31.5, we would have *p*^(*e*) | (*x* + 1). That is, *x* = −1 (mod
    *p*^(*e*)). Symmetrically, if *p* ∤ (*x* + 1), then gcd(*p*^(*e*), *x* + 1) =
    1, and Corollary 31.5 implies that *p*^(*e*) | (*x* − 1), so that *x* = 1 (mod
    *p*^(*e*)). Therefore, either *x* = −1 (mod *p*^(*e*)) or *x* = 1 (mod *p*^(*e*)).
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: 'A number *x* is a ***nontrivial square root of* 1, *modulo n***, if it satisfies
    the equation *x*² = 1 (mod *n*) but *x* is equivalent to neither of the two “trivial”
    square roots: 1 or −1, modulo *n*. For example, 6 is a nontrivial square root
    of 1, modulo 35\. We’ll use the following corollary to Theorem 31.34 in [Section
    31.8](chapter031.xhtml#Sec_31.8) to prove the Miller-Rabin primality-testing procedure
    correct.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Corollary 31.35***'
  prefs: []
  type: TYPE_NORMAL
- en: If there exists a nontrivial square root of 1, modulo *n*, then *n* is composite.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   By the contrapositive of Theorem 31.34, if there exists a nontrivial
    square root of 1, modulo *n*, then *n* cannot be an odd prime or a power of an
    odd prime. Nor can *n* be 2, because if *x*² = 1 (mod 2), then *x* = 1 (mod 2),
    and therefore, all square roots of 1, modulo 2, are trivial. Thus, *n* cannot
    be prime. Finally, we must have *n* > 1 for a nontrivial square root of 1 to exist.
    Therefore, *n* must be composite.'
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '**Raising to powers with repeated squaring**'
  prefs: []
  type: TYPE_NORMAL
- en: A frequently occurring operation in number-theoretic computations is raising
    one number to a power modulo another number, also known as ***modular exponentiation***.
    More precisely, we would like an efficient way to compute *a*^(*b*) mod *n*, where
    *a* and *b* are nonnegative integers and *n* is a positive integer. Modular exponentiation
    is an essential operation in many primality-testing routines and in the RSA public-key
    cryptosystem. The method of ***repeated squaring*** solves this problem efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeated squaring is based on the following formula to compute *a*^(*b*) for
    nonnegative integers *a* and *b*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1208.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The last case, where *b* is odd, reduces to the one of the first two cases,
    since if *b* is odd, then *b* − 1 is even. The recursive procedure MODULAR-EXPONENTIATION
    on the next page computes *a*^(*b*) mod *n* using equation (31.34), but performing
    all computations modulo *n*. The term “repeated squaring” comes from squaring
    the intermediate result *d* = *a*^(*b*/2) in line 5\. [Figure 31.4](chapter031.xhtml#Fig_31-4)
    shows the values of the parameter *b*, the local variable *d*, and the value returned
    at each level of the recursion for the call MODULAR-EXPONENTIATION(7,560,561),
    which returns the result 1.
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1209.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 31.4** The values of the parameter *b*, the local variable *d*, and
    the value returned for recursive calls of MODULAR-EXPONENTIATION with parameter
    values *a* = 7, *b* = 560, and *n* = 561\. The value returned by each recursive
    call is assigned directly to *d*. The result of the call with *a* = 7, *b* = 560,
    and *n* = 561 is 1.'
  prefs: []
  type: TYPE_NORMAL
- en: MODULAR-EXPONENTIATION(*a*, *b*, *n*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | **if** *b* == 0 |  |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | **return** 1 |  |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | **elseif** *b* mod 2 == 0 |  |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | *d* = MODULAR-EXPONENTIATION(*a*, *b*/2, *n*) | **//** *b* is even |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | **return** (*d* · *d*) mod *n* |  |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | **else** *d* = MODULAR-EXPONENTIATION(*a*, *b* − 1, *n*) | **//** *b*
    is odd |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | **return** (*a* · *d*) mod *n* |  |'
  prefs: []
  type: TYPE_TB
- en: The total number of recursive calls depends on the number of bits of *b* and
    the values of these bits. Assume that *b* > 0 and that the most significant bit
    of *b* is a 1\. Each 0 generates one recursive call (in line 4), and each 1 generates
    two recursive calls (one in line 6 followed by one in line 4 because if *b* is
    odd, then *b* − 1 is even). If the inputs *a*, *b*, and *n* are *β*-bit numbers,
    then there are between *β* and 2*β* − 1 recursive calls altogether, the total
    number of arithmetic operations required is *O*(*β*), and the total number of
    bit operations required is *O*(*β*³).
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs: []
  type: TYPE_NORMAL
- en: '***31.6-1***'
  prefs: []
  type: TYPE_NORMAL
- en: Draw a table showing the order of every element in ![art](images/Art_P1210.jpg).
    Pick the smallest primitive root *g* and compute a table giving ind[11,*g*](*x*)
    for all ![art](images/Art_P1211.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: '***31.6-2***'
  prefs: []
  type: TYPE_NORMAL
- en: Show that *x*² = 1 (mod *p*^(*e*)) is equivalent to *p*^(*e*) | (*x* − 1)(*x*
    + 1).
  prefs: []
  type: TYPE_NORMAL
- en: '***31.6-3***'
  prefs: []
  type: TYPE_NORMAL
- en: Rewrite the third case of MODULAR-EXPONENTIATION, where *b* is odd, so that
    if *b* has *β* bits and the most significant bit is 1, then there are always exactly
    *β* recursive calls.
  prefs: []
  type: TYPE_NORMAL
- en: '***31.6-4***'
  prefs: []
  type: TYPE_NORMAL
- en: Give a nonrecursive (i.e., iterative) version of MODULAR-EXPONENTIATION.
  prefs: []
  type: TYPE_NORMAL
- en: '***31.6-5***'
  prefs: []
  type: TYPE_NORMAL
- en: Assuming that you know *ϕ*(*n*), explain how to compute *a*^(−1) mod *n* for
    any ![art](images/Art_P1212.jpg) using the procedure MODULAR-EXPONENTIATION.
  prefs: []
  type: TYPE_NORMAL
- en: '[**31.7    The RSA public-key cryptosystem**](toc.xhtml#Rh1-183)'
  prefs: []
  type: TYPE_NORMAL
- en: With a public-key cryptosystem, you can ***encrypt*** messages sent between
    two communicating parties so that an eavesdropper who overhears the encrypted
    messages will not be able to decode, or ***decrypt***, them. A public-key cryptosystem
    also enables a party to append an unforgeable “digital signature” to the end of
    an electronic message. Such a signature is the electronic version of a handwritten
    signature on a paper document. It can be easily checked by anyone, forged by no
    one, yet loses its validity if any bit of the message is altered. It therefore
    provides authentication of both the identity of the signer and the contents of
    the signed message. It is the perfect tool for electronically signed business
    contracts, electronic checks, electronic purchase orders, and other electronic
    communications that parties wish to authenticate.
  prefs: []
  type: TYPE_NORMAL
- en: The RSA public-key cryptosystem relies on the dramatic difference between the
    ease of finding large prime numbers and the difficulty of factoring the product
    of two large prime numbers. [Section 31.8](chapter031.xhtml#Sec_31.8) describes
    an efficient procedure for finding large prime numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '**Public-key cryptosystems**'
  prefs: []
  type: TYPE_NORMAL
- en: In a public-key cryptosystem, each participant has both a ***public key*** and
    a ***secret key***. Each key is a piece of information. For example, in the RSA
    cryptosystem, each key consists of a pair of integers. The participants “Alice”
    and “Bob” are traditionally used in cryptography examples. We denote the public
    keys for Alice and Bob as *P*[*A*] and *P*[*B*], respectively, and likewise the
    secret keys are *S*[*A*] for Alice and *S*[*B*] for Bob.
  prefs: []
  type: TYPE_NORMAL
- en: Each participant creates his or her own public and secret keys. Secret keys
    are kept secret, but public keys can be revealed to anyone or even published.
    In fact, it is often convenient to assume that everyone’s public key is available
    in a public directory, so that any participant can easily obtain the public key
    of any other participant.
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1213.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 31.5** Encryption in a public key system. Bob encrypts the message
    *M* using Alice’s public key *P*[*A*] and transmits the resulting ciphertext *C*
    = *P*[*A*](*M*) over a communication channel to Alice. An eavesdropper who captures
    the transmitted ciphertext gains no information about *M*. Alice receives *C*
    and decrypts it using her secret key to obtain the original message *M* = *S*[*A*](*C*).'
  prefs: []
  type: TYPE_NORMAL
- en: The public and secret keys specify functions that can be applied to any message.
    Let D denote the set of permissible messages. For example, D might be the set
    of all finite-length bit sequences. The simplest, and original, formulation of
    public-key cryptography requires one-to-one functions from D to itself, based
    on the public and secret keys. We denote the function based on Alice’s public
    key *P*[*A*] by *P*[*A*]() and the function based on her secret key *S*[*A*] by
    *S*[*A*](). The functions *P*[*A*]() and *S*[*A*]() are thus permutations of D.
    We assume that the functions *P*[*A*]() and *S*[*A*]() are efficiently computable
    given the corresponding keys *P*[*A*] and *S*[*A*].
  prefs: []
  type: TYPE_NORMAL
- en: The public and secret keys for any participant are a “matched pair” in that
    they specify functions that are inverses of each other. That is,
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1214.jpg)'
  prefs: []
  type: TYPE_IMG
- en: for any message *M* ∈ D. Transforming *M* with the two keys *P*[*A*] and *S*[*A*]
    successively, in either order, yields back the original message *M*.
  prefs: []
  type: TYPE_NORMAL
- en: A public-key cryptosystem requires that Alice, and only Alice, be able to compute
    the function *S*[*A*]() in any practical amount of time. This assumption is crucial
    to keeping encrypted messages sent to Alice private and to knowing that Alice’s
    digital signatures are authentic. Alice must keep her key *S*[*A*] secret. If
    she does not, whoever else has access to *S*[*A*] can decrypt messages intended
    only for Alice and can also forge her digital signature. The assumption that only
    Alice can reasonably compute *S*[*A*]() must hold even though everyone knows *P*[*A*]
    and can compute *P*[*A*](), the inverse function to *S*[*A*](), efficiently. These
    requirements appear formidable, but we’ll see how to satisfy them.
  prefs: []
  type: TYPE_NORMAL
- en: In a public-key cryptosystem, encryption works as shown in [Figure 31.5](chapter031.xhtml#Fig_31-5).
    Suppose that Bob wishes to send Alice a message *M* encrypted so that it looks
    like
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1215.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '**Figure 31.6** Digital signatures in a public-key system. Alice signs the
    message *M*′ by appending her digital signature *σ* = *S*[*A*](*M*′) to it. She
    transmits the message/signature pair (*M*′, *σ*) to Bob, who verifies it by checking
    the equation *M*′ = *P*[*A*](*σ*). If the equation holds, he accepts (*M*′, *σ*)
    as a message that Alice has signed.'
  prefs: []
  type: TYPE_NORMAL
- en: unintelligible gibberish to an eavesdropper. The scenario for sending the message
    goes as follows.
  prefs: []
  type: TYPE_NORMAL
- en: Bob obtains Alice’s public key *P*[*A*], perhaps from a public directory or
    perhaps directly from Alice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bob computes the ***ciphertext*** *C* = *P*[*A*](*M*) corresponding to the message
    *M* and sends *C* to Alice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When Alice receives the ciphertext *C*, she applies her secret key *S*[*A*]
    to retrieve the original message: *S*[*A*](*C*) = *S*[*A*](*P*[*A*](*M*)) = *M*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because *S*[*A*]() and *P*[*A*]() are inverse functions, Alice can compute *M*
    from *C*. Because only Alice is able to compute *S*[*A*](), only Alice can compute
    *M* from *C*. Because Bob encrypts *M* using *P*[*A*](), only Alice can understand
    the transmitted message.
  prefs: []
  type: TYPE_NORMAL
- en: Digital signatures can be implemented within this formulation of a public-key
    cryptosystem. (There are other ways to construct digital signatures, but we won’t
    go into them here.) Suppose now that Alice wishes to send Bob a digitally signed
    response *M*′. [Figure 31.6](chapter031.xhtml#Fig_31-6) shows how the digital-signature
    scenario proceeds.
  prefs: []
  type: TYPE_NORMAL
- en: Alice computes her ***digital signature*** *σ* for the message *M*′ using her
    secret key *S*[*A*] and the equation *σ* = *S*[*A*](*M*′).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Alice sends the message/signature pair (*M*′, *σ*) to Bob.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When Bob receives (*M*′, *σ*), he can verify that it originated from Alice by
    using Alice’s public key to verify the equation *M*′ = *P*[*A*](*σ*). (Presumably,
    *M*′ contains Alice’s name, so that Bob knows whose public key to use.) If the
    equation holds, then Bob concludes that the message *M*′ was actually signed by
    Alice. If the equation fails to hold, Bob concludes either that the information
    he received was corrupted by transmission errors or that the pair (*M*′, *σ*)
    is an attempted forgery.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Because a digital signature provides both authentication of the signer’s identity
    and authentication of the contents of the signed message, it is analogous to a
    handwritten signature at the end of a written document.
  prefs: []
  type: TYPE_NORMAL
- en: A digital signature must be verifiable by anyone who has access to the signer’s
    public key. A signed message can be verified by one party and then passed on to
    other parties who can also verify the signature. For example, the message might
    be an electronic check from Alice to Bob. After Bob verifies Alice’s signature
    on the check, he can give the check to his bank, who can then also verify the
    signature and effect the appropriate funds transfer.
  prefs: []
  type: TYPE_NORMAL
- en: A signed message may or may not be encrypted. The message can be “in the clear”
    and not protected from disclosure. By composing the above protocols for encryption
    and for signatures, Alice can create a message to Bob that is both signed and
    encrypted. Alice first appends her digital signature to the message and then encrypts
    the resulting message/signature pair with Bob’s public key. Bob decrypts the received
    message with his secret key to obtain both the original message and its digital
    signature. Bob can then verify the signature using Alice’s public key. The corresponding
    combined process using paper-based systems would be to sign the paper document
    and then seal the document inside a paper envelope that is opened only by the
    intended recipient.
  prefs: []
  type: TYPE_NORMAL
- en: '**The RSA cryptosystem**'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the ***RSA public-key cryptosystem***, a participant creates a public key
    and a secret key with the following procedure:'
  prefs: []
  type: TYPE_NORMAL
- en: Select at random two large prime numbers *p* and *q* such that *p* ≠ *q*. The
    primes *p* and *q* might be, say, 1024 bits each.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute *n* = *pq*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a small odd integer *e* that is relatively prime to *ϕ*(*n*), which,
    by equation (31.21), equals (*p* – 1)(*q* – 1).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compute *d* as the multiplicative inverse of *e*, modulo *ϕ*(*n*). (Corollary
    31.26 guarantees that *d* exists and is uniquely defined. You can use the technique
    of [Section 31.4](chapter031.xhtml#Sec_31.4) to compute *d*, given *e* and *ϕ*(*n*).)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publish the pair *P* = (*e*, *n*) as the participant’s ***RSA public key***.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Keep secret the pair *S* = (*d*, *n*) as the participant’s ***RSA secret key***.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For this scheme, the domain D is the set ℤ[*n*]. To transform a message *M*
    associated with a public key *P* = (*e*, *n*), compute
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1216.jpg)'
  prefs: []
  type: TYPE_IMG
- en: To transform a ciphertext *C* associated with a secret key *S* = (*d*, *n*),
    compute
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1217.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These equations apply to both encryption and signatures. To create a signature,
    the signer’s secret key is applied to the message to be signed, rather than to
    a ciphertext. To verify a signature, the public key of the signer is applied to
    the signature rather than to a message to be encrypted.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the public-key and secret-key operations (31.37) and (31.38), you
    can use the procedure MODULAR-EXPONENTIATION described in [Section 31.6](chapter031.xhtml#Sec_31.6).
    To analyze the running time of these operations, assume that the public key (*e*,
    *n*) and secret key (*d*, *n*) satisfy 1g *e* = *O*(1), 1g *d* ≤ *β*, and 1g *n*
    ≤ *β*. Then, applying a public key requires *O*(1) modular multiplications and
    uses *O*(*β*²) bit operations. Applying a secret key requires *O*(*β*) modular
    multiplications, using *O*(*β*³) bit operations.
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.36 (Correctness of RSA)***'
  prefs: []
  type: TYPE_NORMAL
- en: The RSA equations (31.37) and (31.38) define inverse transformations of ℤ[*n*]
    satisfying equations (31.35) and (31.36).
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   From equations (31.37) and (31.38), we have that for any *M*
    ∈ ℤ[*n*],'
  prefs: []
  type: TYPE_NORMAL
- en: '*P*(*S*(*M*)) = *S*(*P*(*M*)) = *M*^(*ed*) (mod *n*).'
  prefs: []
  type: TYPE_NORMAL
- en: Since *e* and *d* are multiplicative inverses modulo *ϕ*(*n*) = (*p* – 1)(*q*
    – 1),
  prefs: []
  type: TYPE_NORMAL
- en: '*ed* = 1 + *k*(*p* – 1)(*q* – 1)'
  prefs: []
  type: TYPE_NORMAL
- en: for some integer *k*. But then, if *M* ≠ 0 (mod *p*), we have
  prefs: []
  type: TYPE_NORMAL
- en: '| *M*^(*ed*) | = *M*(*M*^(*p*–1))^(*k*(*q*–1)) | (mod *p*) |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | = *M*((*M* mod *p*)^(*p*–1))^(*k*(*q*–1)) | (mod *p*) |  |'
  prefs: []
  type: TYPE_TB
- en: '|  | = *M*(1)^(*k*(*q*–1)) | (mod *p*) | (by Theorem 31.31) |'
  prefs: []
  type: TYPE_TB
- en: '|  | = *M* | (mod *p*) |  |'
  prefs: []
  type: TYPE_TB
- en: Also, *M*^(*ed*) = *M* (mod *p*) if *M* = 0 (mod *p*). Thus,
  prefs: []
  type: TYPE_NORMAL
- en: '*M*^(*ed*) = *M* (mod *p*)'
  prefs: []
  type: TYPE_NORMAL
- en: for all *M*. Similarly,
  prefs: []
  type: TYPE_NORMAL
- en: '*M*^(*ed*) = *M* (mod *q*)'
  prefs: []
  type: TYPE_NORMAL
- en: for all *M*. Thus, by Corollary 31.29 to the Chinese remainder theorem,
  prefs: []
  type: TYPE_NORMAL
- en: '*M*^(*ed*) = *M* (mod *n*)'
  prefs: []
  type: TYPE_NORMAL
- en: for all *M*.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: The security of the RSA cryptosystem rests in large part on the difficulty of
    factoring large integers. If an adversary can factor the modulus *n* in a public
    key, then the adversary can derive the secret key from the public key, using the
    knowledge of the factors *p* and *q* in the same way that the creator of the public
    key used them. Therefore, if factoring large integers is easy, then breaking the
    RSA cryptosystem is easy. The converse statement, that if factoring large integers
    is hard, then breaking RSA is hard, is unproven. After two decades of research,
    however, no easier method has been found to break the RSA public-key cryptosystem
    than to factor the modulus *n*. And factoring large integers is surprisingly difficult.
    By randomly selecting and multiplying together two 1024-bit primes, you can create
    a public key that cannot be “broken” in any feasible amount of time with current
    technology. In the absence of a fundamental breakthrough in the design of number-theoretic
    algorithms, and when implemented with care following recommended standards, the
    RSA cryptosystem is capable of providing a high degree of security in applications.
  prefs: []
  type: TYPE_NORMAL
- en: In order to achieve security with the RSA cryptosystem, however, you should
    use integers that are quite long—more than 1000 bits—to resist possible advances
    in the art of factoring. In 2021, RSA moduli are commonly in the range of 2048
    to 4096 bits. To create moduli of such sizes, you must find large primes efficiently.
    [Section 31.8](chapter031.xhtml#Sec_31.8) addresses this problem.
  prefs: []
  type: TYPE_NORMAL
- en: For efficiency, RSA is often used in a “hybrid” or “key-management” mode with
    fast cryptosystems that are not public-key cryptosystems. With such a ***symmetric-key***
    system, the encryption and decryption keys are identical. If Alice wishes to send
    a long message *M* to Bob privately, she selects a random key *K* for the fast
    symmetric-key cryptosystem and encrypts *M* using *K*, obtaining ciphertext *C*,
    where *C* is as long as *M*, but *K* is quite short. Then she encrypts *K* using
    Bob’s public RSA key. Since *K* is short, computing *P*[*B*](*K*) is fast (much
    faster than computing *P*[*B*](*M*)). She then transmits (*C*, *P*[*B*](*K*))
    to Bob, who decrypts *P*[*B*](*K*) to obtain *K* and then uses *K* to decrypt
    *C*, obtaining *M*.
  prefs: []
  type: TYPE_NORMAL
- en: A similar hybrid approach creates digital signatures efficiently. This approach
    combines RSA with a public ***collision-resistant hash function*** *h*—a function
    that is easy to compute but for which it is computationally infeasible to find
    two messages *M* and *M*′ such that *h*(*M*) = *h*(*M*′). The value *h*(*M*) is
    a short (say, 256-bit) “fingerprint” of the message *M*. If Alice wishes to sign
    a message *M*, she first applies *h* to *M* to obtain the fingerprint *h*(*M*),
    which she then encrypts with her secret key. She sends (*M*, *S*[*A*](*h*(*M*)))
    to Bob as her signed version of *M*. Bob can verify the signature by computing
    *h*(*M*) and verifying that *P*[*A*] applied to *S*[*A*](*h*(*M*)) as received
    equals *h*(*M*). Because no one can create two messages with the same fingerprint,
    it is computationally infeasible to alter a signed message and preserve the validity
    of the signature.
  prefs: []
  type: TYPE_NORMAL
- en: One way to distribute public keys uses ***certificates***. For example, assume
    that there is a “trusted authority” *T* whose public key is known by everyone.
    Alice can obtain from *T* a signed message (her certificate) stating that “Alice’s
    public key is *P*[*A*].” This certificate is “self-authenticating” since everyone
    knows *P*[*T*]. Alice can include her certificate with her signed messages, so
    that the recipient has Alice’s public key immediately available in order to verify
    her signature. Because her key was signed by *T*, the recipient knows that Alice’s
    key is really Alice’s.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs: []
  type: TYPE_NORMAL
- en: '***31.7-1***'
  prefs: []
  type: TYPE_NORMAL
- en: Consider an RSA key set with *p* = 11, *q* = 29, *n* = 319, and *e* = 3\. What
    value of *d* should be used in the secret key? What is the encryption of the message
    *M* = 100?
  prefs: []
  type: TYPE_NORMAL
- en: '***31.7-2***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove that if Alice’s public exponent *e* is 3 and an adversary obtains Alice’s
    secret exponent *d*, where 0 < *d* < *ϕ*(*n*), then the adversary can factor Alice’s
    modulus *n* in time polynomial in the number of bits in *n*. (Although you are
    not asked to prove it, you might be interested to know that this result remains
    true even if the condition *e* = 3 is removed. See Miller [[327](bibliography001.xhtml#endnote_327)].)
  prefs: []
  type: TYPE_NORMAL
- en: ★ ***31.7-3***
  prefs: []
  type: TYPE_NORMAL
- en: Prove that RSA is multiplicative in the sense that
  prefs: []
  type: TYPE_NORMAL
- en: '*P*[*A*](*M*[1])*P*[*A*](*M*[2]) = *P*[*A*](*M*[1]*M*[2]) (mod *n*).'
  prefs: []
  type: TYPE_NORMAL
- en: Use this fact to prove that if an adversary had a procedure that could efficiently
    decrypt 1% of messages from ℤ[*n*] encrypted with *P*[*A*], then the adversary
    could employ a probabilistic algorithm to decrypt every message encrypted with
    *P*[*A*] with high probability.
  prefs: []
  type: TYPE_NORMAL
- en: '[★ **31.8    Primality testing**](toc.xhtml#Rh1-184)'
  prefs: []
  type: TYPE_NORMAL
- en: This section shows how to find large primes. We begin with a discussion of the
    density of primes, proceed to examine a plausible, but incomplete, approach to
    primality testing, and then present an effective randomized primality test due
    to Miller and Rabin.
  prefs: []
  type: TYPE_NORMAL
- en: '**The density of prime numbers**'
  prefs: []
  type: TYPE_NORMAL
- en: Many applications, such as cryptography, call for finding large “random” primes.
    Fortunately, large primes are not too rare, so that it is feasible to test random
    integers of the appropriate size until you find one that is prime. The ***prime
    distribution function*** *π*(*n*) specifies the number of primes that are less
    than or equal to *n*. For example, *π*(10) = 4, since there are 4 prime numbers
    less than or equal to 10, namely, 2, 3, 5, and 7\. The prime number theorem gives
    a useful approximation to *π*(*n*).
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.37 (Prime number theorem)***'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1218.jpg)'
  prefs: []
  type: TYPE_IMG
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: The approximation *n*/ln *n* gives reasonably accurate estimates of *π*(*n*)
    even for small *n*. For example, it is off by less than 6% at *n* = 10⁹, where
    *π*(*n*) = 50,847,534 and *n*/ln *n* ≈ 48,254,942\. (To a number theorist, 10⁹
    is a small number.)
  prefs: []
  type: TYPE_NORMAL
- en: The process of randomly selecting an integer *n* and determining whether it
    is prime is really just a Bernoulli trial (see [Section C.4](appendix003.xhtml#Sec_C.4)).
    By the prime number theorem, the probability of a success—that is, the probability
    that *n* is prime—is approximately 1/ln *n*. The geometric distribution says how
    many trials must occur to obtain a success, and by equation (C.36) on page 1197,
    the expected number of trials is approximately ln *n*. Thus, in order to find
    a prime that has the same length as *n* by testing integers chosen randomly near
    *n*, the expected number examined would be approximately ln *n*. For example,
    the expectation is that finding a 1024-bit prime would require testing approximately
    ln 2^(1024) ≈ 710 randomly chosen 1024-bit numbers for primality. (Of course,
    to cut this figure in half, choose only odd integers.)
  prefs: []
  type: TYPE_NORMAL
- en: The remainder of this section shows how to determine whether a large odd integer
    *n* is prime. For notational convenience, we assume that *n* has the prime factorization
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1219.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where *r* ≥ 1, *p*[1], *p*[2], …, *p*[*r*] are the prime factors of *n*, and
    *e*[1], *e*[2], …, *e*[*r*] are positive integers. The integer *n* is prime if
    and only if *r* = 1 and *e*[1] = 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'One simple approach to the problem of testing for primality is ***trial division***:
    try dividing *n* by each integer 2, 3, 5, 7, 9, …, ![art](images/Art_P1220.jpg),
    skipping even integers greater than 2\. We can conclude that *n* is prime if and
    only if none of the trial divisors divides *n*. Assuming that each trial division
    takes constant time, the worst-case running time is ![art](images/Art_P1221.jpg),
    which is exponential in the length of *n*. (Recall that if *n* is encoded in binary
    using *β* bits, then *β* = ⌈1g(*n* + 1)⌉, and so ![art](images/Art_P1222.jpg).)
    Thus, trial division works well only if *n* is very small or happens to have a
    small prime factor. When it works, trial division has the advantage that it not
    only determines whether *n* is prime or composite, it also determines one of *n*’s
    prime factors if *n* is composite.'
  prefs: []
  type: TYPE_NORMAL
- en: This section focuses on finding out whether a given number *n* is prime. If
    *n* is composite, we won’t worry about finding its prime factorization. Computing
    the prime factorization of a number is computationally expensive. You might be
    surprised that it turns out to be much easier to ascertain whether a given number
    is prime than it is to determine the prime factorization of the number if it is
    not prime.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pseudoprimality testing**'
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll start with a method for primality testing that “almost works” and, in
    fact, is good enough for many practical applications. Later on, we’ll refine this
    method to remove the small defect. Let ![art](images/Art_P1223.jpg) denote the
    nonzero elements of ℤ[*n*]:'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1224.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If *n* is prime, then ![art](images/Art_P1225.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: We say that *n* is a ***base-a pseudoprime*** if *n* is composite and
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1226.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Fermat’s theorem (Theorem 31.31 on page 932) implies that if *n* is prime, then
    *n* satisfies equation (31.39) for every *a* in ![art](images/Art_P1227.jpg).
    Thus, if there is any ![art](images/Art_P1228.jpg) such that *n* does *not* satisfy
    equation (31.39), then *n* is certainly composite. Surprisingly, the converse
    *almost* holds, so that this criterion forms an almost perfect test for primality.
    Instead of trying every value of ![art](images/Art_P1228.jpg), test to see whether
    *n* satisfies equation (31.39) for just *a* = 2\. If not, then declare *n* to
    be composite by returning COMPOSITE. Otherwise, return PRIME, guessing that *n*
    is prime (when, in fact, all we know is that *n* is either prime or a base-2 pseudoprime).
  prefs: []
  type: TYPE_NORMAL
- en: The procedure PSEUDOPRIME on the next page pretends in this manner to check
    whether *n* is prime. It uses the procedure MODULAR-EXPONENTIATION from [Section
    31.6](chapter031.xhtml#Sec_31.6). It assumes that the input *n* is an odd integer
    greater than 2\. This procedure can make errors, but only of one type. That is,
    if it says that *n* is composite, then it is always correct. If it says that *n*
    is prime, however, then it makes an error only if *n* is a base-2 pseudoprime.
  prefs: []
  type: TYPE_NORMAL
- en: How often does PSEUDOPRIME err? Surprisingly rarely. There are only 22 values
    of *n* less than 10,000 for which it errs, the first four of which are 341, 561,
    645,
  prefs: []
  type: TYPE_NORMAL
- en: PSEUDOPRIME(*n*)
  prefs: []
  type: TYPE_NORMAL
- en: '| 1 | **if** MODULAR-EXPONENTIATION(2, *n* – 1, *n*) ≠ 1 (mod *n*) |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | **return** COMPOSITE | **//** definitely |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | **else return** PRIME | **//** we hope! |'
  prefs: []
  type: TYPE_TB
- en: and 1105\. We won’t prove it, but the probability that this program makes an
    error on a randomly chosen *β*-bit number goes to 0 as *β* approaches ∞. Using
    more precise estimates due to Pomerance [[361](bibliography001.xhtml#endnote_361)]
    of the number of base-2 pseudoprimes of a given size, a randomly chosen 512-bit
    number that is called prime by PSEUDOPRIME has less than one chance in 10^(20)
    of being a base-2 pseudoprime, and a randomly chosen 1024-bit number that is called
    prime has less than one chance in 10^(41) of being a base-2 pseudoprime. Thus,
    if you are merely trying to find a large prime for some application, for all practical
    purposes you almost never go wrong by choosing large numbers at random until one
    of them causes PSEUDOPRIME to return PRIME. But when the numbers being tested
    for primality are not randomly chosen, you might need a better approach for testing
    primality. As we’ll see, a little more cleverness, and some randomization, will
    yield a primality-testing method that works well on all inputs.
  prefs: []
  type: TYPE_NORMAL
- en: Since PSEUDOPRIME checks equation (31.39) for only *a* = 2, you might think
    that you could eliminate all the errors by simply checking equation (31.39) for
    a second base number, say *a* = 3\. Better yet, you could check equation (31.39)
    for even more values of *a*. Unfortunately, even checking for several values of
    *a* does not eliminate all errors, because there exist composite integers *n*,
    known as ***Carmichael numbers***, that satisfy equation (31.39) for *all* ![art](images/Art_P1230.jpg).
    (The equation does fail when gcd(*a*, *n*) > 1—that is, when ![art](images/Art_P1231.jpg)—but
    demonstrating that *n* is composite by finding such an *a* can be difficult if
    *n* has only large prime factors.) The first three Carmichael numbers are 561,
    1105, and 1729\. Carmichael numbers are extremely rare. For example, only 255
    of them are less than 100,000,000\. Exercise 31.8-2 helps explain why they are
    so rare.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s see how to improve the primality test so that Carmichael numbers won’t
    fool it.
  prefs: []
  type: TYPE_NORMAL
- en: '**The Miller-Rabin randomized primality test**'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Miller-Rabin primality test overcomes the problems of the simple procedure
    PSEUDOPRIME with two modifications:'
  prefs: []
  type: TYPE_NORMAL
- en: It tries several randomly chosen base values *a* instead of just one base value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While computing each modular exponentiation, it looks for a nontrivial square
    root of 1, modulo *n*, during the final set of squarings. If it finds one, it
    stops and returns COMPOSITE. Corollary 31.35 from [Section 31.6](chapter031.xhtml#Sec_31.6)
    justifies detecting composites in this manner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The pseudocode for the Miller-Rabin primality test appears in the procedures
    MILLER-RABIN and WITNESS. The input *n* > 2 to MILLER-RABIN is the odd number
    to be tested for primality, and *s* is the number of randomly chosen base values
    from ![art](images/Art_P1232.jpg) to be tried. The code uses the random-number
    generator RANDOM described on page 129: RANDOM(2, *n* – 2) returns a randomly
    chosen integer *a* satisfying 2 ≤ *a* ≤ *n* – 2\. (This range of values avoids
    having *a* = ≥1 (mod *n*).) The call of the auxiliary procedure WITNESS(*a*, *n*)
    returns TRUE if and only if *a* is a “witness” to the compositeness of *n*—that
    is, if it is possible using *a* to prove (in a manner that we will see) that *n*
    is composite. The test WITNESS(*a*, *n*) is an extension of, but more effective
    than, the test in equation (31.39) that formed the basis for PSEUDOPRIME, using
    *a* = 2.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s first understand how WITNESS works, and then we’ll see how the Miller-Rabin
    primality test uses it. Let *n* – 1 = 2^(*t*)*u* where *t* ≥ 1 and *u* is odd.
    That is, the binary representation of *n* – 1 is the binary representation of
    the odd integer *u* followed by exactly *t* zeros. Therefore, ![art](images/Art_P1233.jpg),
    so that one way to compute *a*^(*n*−1) mod *n* is to first compute *a*^(*u*) mod
    *n* and then square the result *t* times successively.
  prefs: []
  type: TYPE_NORMAL
- en: '| MILLER-RABIN(*n*, *s*) | **//** *n* > 2 is odd |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | **for** *j* = 1 **to** *s* |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | *a* = RANDOM(2, *n* – 2) |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | **if** WITNESS(*a*, *n*) |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | **return** COMPOSITE | **//** definitely |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | **return** PRIME | **//** almost surely |'
  prefs: []
  type: TYPE_TB
- en: '| WITNESS(*a*, *n*) |'
  prefs: []
  type: TYPE_TB
- en: '| 1 | let *t* and *u* be such that *t* ≥ 1, *u* is odd, and *n* – 1 = 2^(*t*)*u*
    |'
  prefs: []
  type: TYPE_TB
- en: '| 2 | *x*[0] = MODULAR-EXPONENTIATION(*a*, *u*, *n*) |'
  prefs: []
  type: TYPE_TB
- en: '| 3 | **for** *i* = 1 **to** *t* |'
  prefs: []
  type: TYPE_TB
- en: '| 4 | ![art](images/Art_P1234.jpg) |'
  prefs: []
  type: TYPE_TB
- en: '| 5 | **if** *x*[*i*] == 1 and *x*[*i*–1] ≠ 1 and *x*[*i*–1] ≠ *n* – 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 6 | **return** TRUE | **//** found a nontrivial square root of 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 7 | **if** *x*[*t*] ≠ 1 |'
  prefs: []
  type: TYPE_TB
- en: '| 8 | **return** TRUE | **//** composite, as in PSEUDOPRIME |'
  prefs: []
  type: TYPE_TB
- en: '| 9 | **return** FALSE |'
  prefs: []
  type: TYPE_TB
- en: This pseudocode for WITNESS computes *a*^(*n*–1) mod *n* by first computing
    the value *x*[0] = *a*^(*u*) mod *n* in line 2 and then repeatedly squaring the
    result *t* times in the **for** loop of lines 3–6\. By induction on *i*, the sequence
    *x*[0], *x*[1], …, *x*[*t*] of values computed satisfies the equation ![art](images/Art_P1235.jpg)
    for *i* = 0, 1, …, *t*, so that in particular *x*[*t*] = *a*^(*n*–1) (mod *n*).
    After line 4 performs a squaring step, however, the loop will terminate early
    if lines 5–6 detect that a nontrivial square root of 1 has just been discovered.
    (We’ll explain these tests shortly.) If so, the procedure stops and returns TRUE.
    Lines 7–8 return TRUE if the value computed for *x*[*t*] = *a*^(*n*–1) (mod *n*)
    is not equal to 1, just as the PSEUDOPRIME procedure returns COMPOSITE in this
    case. Line 9 returns FALSE if lines 6 or 8 have not returned TRUE.
  prefs: []
  type: TYPE_NORMAL
- en: The following lemma proves the correctness of WITNESS.
  prefs: []
  type: TYPE_NORMAL
- en: '***Lemma 31.38***'
  prefs: []
  type: TYPE_NORMAL
- en: If WITNESS(*a*, *n*) returns TRUE, then a proof that *n* is composite can be
    constructed using *a* as a witness.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   If WITNESS returns TRUE from line 8, it’s because line 7 determined
    that *x*[*t*] = *a*^(*n*–1) mod *n* ≠ 1\. If *n* is prime, however, Fermat’s theorem
    (Theorem 31.31) says that *a*^(*n*–1) = 1 (mod *n*) for all ![art](images/Art_P1236.jpg).
    Since ![art](images/Art_P1237.jpg) if *n* is prime, Fermat’s theorem also says
    that *a*^(*n*–1) = 1 (mod *n*) for all ![art](images/Art_P1238.jpg). Therefore,
    *n* cannot be prime, and the equation *a*^(*n*–1) mod *n* ≠ 1 proves this fact.'
  prefs: []
  type: TYPE_NORMAL
- en: If WITNESS returns TRUE from line 6, then it has discovered that *x*[*i*–1]
    is a nontrivial square root of 1, modulo *n*, since we have that *x*[*i*–1] ≠
    ±1 (mod *n*) yet ![art](images/Art_P1239.jpg). Corollary 31.35 on page 934 states
    that only if *n* is composite can there exist a nontrivial square root of 1, modulo
    *n*, so that demonstrating that *x*[*i*–1] is a nontrivial square root of 1, modulo
    *n* proves that *n* is composite.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: Thus, if the call WITNESS(*a*, *n*) returns TRUE, then *n* is surely composite,
    and the witness *a*, along with the reason that the procedure returns TRUE (did
    it return from line 6 or from line 8?), provides a proof that *n* is composite.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s explore an alternative view of the behavior of WITNESS as a function
    of the sequence *X* = 〈*x*[0], *x*[1], …, *x*[*t*]〉. We’ll find this view useful
    later on, when we analyze the error rate of the Miller-Rabin primality test. Note
    that if *x*[*i*] = 1 for some 0 ≤ *i* < *t*, WITNESS might not compute the rest
    of the sequence. If it were to do so, however, each value *x*[*i*+1], *x*[*i*+2],
    …, *x*[*t*] would be 1, so we can consider these positions in the sequence *X*
    as being all 1s. There are four cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '*X* = 〈…, *d*〉, where *d* ≠ 1: the sequence *X* does not end in 1\. Return
    TRUE in line 8, since *a* is a witness to the compositeness of *n* (by Fermat’s
    Theorem).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*X* = 〈1, 1, …, 1〉: the sequence *X* is all 1s. Return FALSE, since *a* is
    not a witness to the compositeness of *n*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*X* = 〈…, –1, 1, …, 1〉: the sequence *X* ends in 1, and the last non-1 is equal
    to –1\. Return FALSE, since *a* is not a witness to the compositeness of *n*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*X* = 〈…, *d*, 1, …, 1〉, where *d* ≠ ±1: the sequence *X* ends in 1, but the
    last non-1 is not –1\. Return TRUE in line 6: *a* is a witness to the compositeness
    of *n*, since *d* is a nontrivial square root of 1.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let’s examine the Miller-Rabin primality test based on how it uses the
    WITNESS procedure. As before, assume that *n* is an odd integer greater than 2.
  prefs: []
  type: TYPE_NORMAL
- en: The procedure MILLER-RABIN is a probabilistic search for a proof that *n* is
    composite. The main loop (beginning on line 1) picks up to *s* random values of
    *a* from ![art](images/Art_P1240.jpg), except for 1 and *n* – 1 (line 2). If it
    picks a value of *a* that is a witness to the compositeness of *n*, then MILLER-RABIN
    returns COMPOSITE on line 4\. Such a result is always correct, by the correctness
    of WITNESS. If MILLER-RABIN finds no witness in *s* trials, then the procedure
    assumes that it found no witness because no witnesses exist, and therefore it
    assumes that *n* is prime. We’ll see that this result is likely to be correct
    if *s* is large enough, but there is still a tiny chance that the procedure could
    be unlucky in its choice of *s* random values of *a*, so that even though the
    procedure failed to find a witness, at least one witness exists.
  prefs: []
  type: TYPE_NORMAL
- en: To illustrate the operation of MILLER-RABIN, let *n* be the Carmichael number
    561, so that *n* – 1 = 560 = 2⁴ · 35, *t* = 4, and *u* = 35\. If the procedure
    chooses *a* = 7 as a base, the column for *b* = 35 in [Figure 31.4](chapter031.xhtml#Fig_31-4)
    ([Section 31.6](chapter031.xhtml#Sec_31.6)) shows that WITNESS computes *x*[0]
    = *a*^(35) = 241 (mod 561). Because of how the MODULAR-EXPONENTIATION procedure
    operates recursively on its parameter *b*, the first four columns in [Figure 31.4](chapter031.xhtml#Fig_31-4)
    represent the factor 2⁴ of 560—the rightmost four zeros in the binary representation
    of 560—reading these four zeros from right to left in the binary representation.
    Thus WITNESS computes the sequence *X* = 〈241, 298, 166, 67, 1〉. Then, in the
    last squaring step, WITNESS discovers that *a*^(280) is a nontrivial square root
    of 1 since *a*^(280) = 67 (mod *n*) and (*a*^(280))² = *a*^(560) = 1 (mod *n*).
    Therefore, *a* = 7 is a witness to the compositeness of *n*, WITNESS(7, *n*) returns
    TRUE, and MILLER-RABIN returns COMPOSITE.
  prefs: []
  type: TYPE_NORMAL
- en: If *n* is a *β*-bit number, MILLER-RABIN requires *O*(*sβ*) arithmetic operations
    and *O*(*sβ*³) bit operations, since it requires asymptotically no more work than
    *s* modular exponentiations.
  prefs: []
  type: TYPE_NORMAL
- en: '**Error rate of the Miller-Rabin primality test**'
  prefs: []
  type: TYPE_NORMAL
- en: 'If MILLER-RABIN returns PRIME, then there is a very slim chance that it has
    made an error. Unlike PSEUDOPRIME, however, the chance of error does not depend
    on *n*: there are no bad inputs for this procedure. Rather, it depends on the
    size of *s* and the “luck of the draw” in choosing base values *a*. Moreover,
    since each test is more stringent than a simple check of equation (31.39), we
    can expect on general principles that the error rate should be small for randomly
    chosen integers *n*. The following theorem presents a more precise argument.'
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.39***'
  prefs: []
  type: TYPE_NORMAL
- en: If *n* is an odd composite number, then the number of witnesses to the compositeness
    of *n* is at least (*n* – 1)/2.
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   The proof shows that the number of nonwitnesses is at most (*n*
    – 1)/2, which implies the theorem.'
  prefs: []
  type: TYPE_NORMAL
- en: We start by claiming that any nonwitness must be a member of ![art](images/Art_Zastn.jpg).
    Why? Consider any nonwitness *a*. It must satisfy *a*^(*n*–1) = 1 (mod *n*) or,
    equivalently, *a* · *a*^(*n*−2) = 1 (mod *n*). Thus the equation *ax* = 1 (mod
    *n*) has a solution, namely *a*^(*n*−2). By Corollary 31.21 on page 924, gcd(*a*,
    *n*) | 1, which in turn implies that gcd(*a*, *n*) = 1\. Therefore, *a* is a member
    of ![art](images/Art_Zastn.jpg), and all nonwitnesses belong to ![art](images/Art_Zastn.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: To complete the proof, we show that not only are all nonwitnesses contained
    in ![art](images/Art_Zastn.jpg), they are all contained in a proper subgroup *B*
    of ![art](images/Art_Zastn.jpg) (recall that *B* is a *proper* subgroup of ![art](images/Art_Zastn.jpg)
    when *B* is subgroup of ![art](images/Art_Zastn.jpg) but *B* is not equal to ![art](images/Art_Zastn.jpg)).
    By Corollary 31.16 on page 921, we then have ![art](images/Art_P1241.jpg). Since
    ![art](images/Art_P1242.jpg), we obtain |*B*| ≤ (*n* – 1)/2\. Therefore, if all
    nonwitnesses are contained in a proper subgroup of ![art](images/Art_Zastn.jpg),
    then the number of nonwitnesses is at most (*n* – 1)/2, so that the number of
    witnesses must be at least (*n* – 1)/2.
  prefs: []
  type: TYPE_NORMAL
- en: To find a proper subgroup *B* of ![art](images/Art_Zastn.jpg) containing all
    of the nonwitnesses, we consider two cases.
  prefs: []
  type: TYPE_NORMAL
- en: '*Case 1:* There exists an ![art](images/Art_P1243.jpg) such that'
  prefs: []
  type: TYPE_NORMAL
- en: '*x*^(*n*–1) ≠ 1 (mod *n*).'
  prefs: []
  type: TYPE_NORMAL
- en: In other words, *n* is not a Carmichael number. Since, as noted earlier, Carmichael
    numbers are extremely rare, case 1 is the more typical case (e.g., when *n* has
    been chosen randomly and is being tested for primality).
  prefs: []
  type: TYPE_NORMAL
- en: Let ![art](images/Art_P1244.jpg). The set *B* must be nonempty, since 1 ∈ *B*.
    The set *B* is closed under multiplication modulo *n*, and so *B* is a subgroup
    of ![art](images/Art_Zastn.jpg) by Theorem 31.14\. Every nonwitness belongs to
    *B*, since a nonwitness *a* satisfies *a*^(*n*–1) = 1 (mod *n*). Since ![art](images/Art_P1245.jpg),
    we have that *B* is a proper subgroup of ![art](images/Art_Zastn.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: '*Case 2:* For all ![art](images/Art_P1246.jpg),'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1247.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In other words, *n* is a Carmichael number. This case is extremely rare in practice.
    Unlike a pseudoprimality test, however, the Miller-Rabin test can efficiently
    determine that Carmichael numbers are composite, as we’re about to see.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, *n* cannot be a prime power. To see why, suppose to the contrary
    that *n* = *p*^(*e*), where *p* is a prime and *e* > 1\. We derive a contradiction
    as follows. Since we assume that *n* is odd, *p* must also be odd. Theorem 31.32
    on page 933 implies that ![art](images/Art_Zastn.jpg) is a cyclic group: it contains
    a generator *g* such that ![art](images/Art_P1248.jpg). (The formula for *ϕ*(*n*)
    comes from equation (31.21) on page 920.) By equation (31.40), we have *g*^(*n*–1)
    = 1 (mod *n*). Then the discrete logarithm theorem (Theorem 31.33 on page 933,
    taking *y* = 0) implies that *n* – 1 = 0 (mod *ϕ* (*n*)), or'
  prefs: []
  type: TYPE_NORMAL
- en: (*p* – 1)*p*^(*e*−1) | *p*^(*e*) – 1.
  prefs: []
  type: TYPE_NORMAL
- en: This statement is a contradiction for *e* > 1, since (*p* – 1)*p*^(*e*−1) is
    divisible by the prime *p*, but *p*^(*e*) – 1 is not. Thus *n* is not a prime
    power.
  prefs: []
  type: TYPE_NORMAL
- en: Since the odd composite number *n* is not a prime power, we decompose it into
    a product *n*[1]*n*[2], where *n*[1] and *n*[2] are odd numbers greater than 1
    that are relatively prime to each other. (There may be several ways to decompose
    *n*, and it does not matter which one we choose. For example, if ![art](images/Art_P1249.jpg),
    then we can choose ![art](images/Art_P1250.jpg) and ![art](images/Art_P1251.jpg).)
  prefs: []
  type: TYPE_NORMAL
- en: Recall that *t* and *u* are such that *n* – 1 = 2^(*t*)*u*, where *t* ≥ 1 and
    *u* is odd, and that for an input *a*, the procedure WITNESS computes the sequence
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1252.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where all computations are performed modulo *n*.
  prefs: []
  type: TYPE_NORMAL
- en: Let us call a pair (*v*, *j*) of integers ***acceptable*** if ![art](images/Art_P1253.jpg),
    and
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1254.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Acceptable pairs certainly exist, since *u* is odd. Choose *v* = *n* – 1 and
    *j* = 0, and let *u* = 2*k* + 1, so that ![art](images/Art_P1255.jpg). Taking
    this number modulo *n* gives (*n* – 1)^(2*k*+1) = (*n* – 1)^(2*k*) · (*n* – 1)
    = (–1)^(2*k*) · –1 = −1 (mod *n*). Thus, (*n* – 1, 0) is an acceptable pair. Now
    pick the largest possible *j* such that there exists an acceptable pair (*v*,
    *j*), and fix *v* so that (*v*, *j*) is an acceptable pair. Let
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1256.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since *B* is closed under multiplication modulo *n*, it is a subgroup of ![art](images/Art_Zastn.jpg).
    By Theorem 31.15 on page 921, therefore, |*B*| divides ![art](images/Art_P1257.jpg).
    Every nonwitness must be a member of *B*, since the sequence *X* produced by a
    nonwitness must either be all 1s or else contain a –1 no later than the *j*th
    position, by the maximality of *j*. (If (*a*, *j*′) is acceptable, where *a* is
    a nonwitness, we must have *j*′ ≤ *j* by how we chose *j*.)
  prefs: []
  type: TYPE_NORMAL
- en: We now use the existence of *v* to demonstrate that there exists a ![art](images/Art_P1258.jpg),
    and hence that *B* is a proper subgroup of ![art](images/Art_Zastn.jpg). Since
    ![art](images/Art_P1259.jpg), we also have ![art](images/Art_P1260.jpg) by Corollary
    31.29 to the Chinese remainder theorem. By Corollary 31.28, there exists a *w*
    simultaneously satisfying the equations
  prefs: []
  type: TYPE_NORMAL
- en: '| *w* | = *v* (mod *n*[1]), |'
  prefs: []
  type: TYPE_TB
- en: '| *w* | = 1 (mod *n*[2]). |'
  prefs: []
  type: TYPE_TB
- en: Therefore,
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1261.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Corollary 31.29 gives that ![art](images/Art_P1262.jpg) implies ![art](images/Art_P1263.jpg)
    and also that ![art](images/Art_P1264.jpg) implies ![art](images/Art_P1265.jpg).
    Hence, we conclude that ![art](images/Art_P1266.jpg), and so *w* ∉ *B*.
  prefs: []
  type: TYPE_NORMAL
- en: It remains to show that ![art](images/Art_P1267.jpg). We start by working separately
    modulo *n*[1] and modulo *n*[2]. Working modulo *n*[1], since ![art](images/Art_P1268.jpg),
    we have that gcd(*v*, *n*) = 1\. Also, we have gcd(*v*, *n*[1]) = 1, since if
    *v* does not have any common divisors with *n*, then it certainly does not have
    any common divisors with *n*[1]. Since *w* = *v* (mod *n*[1]), we see that gcd(*w*,
    *n*[1]) = 1\. Working modulo *n*[2], we have *w* = 1 (mod *n*[2]) implies gcd(*w*,
    *n*[2]) = 1 by Exercise 31.2-3\. Since gcd(*w*, *n*[1]) = 1 and gcd(*w*, *n*[2])
    = 1, Theorem 31.6 on page 908 yields gcd(*w*, *n*[1]*n*[2]) = gcd(*w*, *n*) =
    1\. That is, ![art](images/Art_P1269.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we have ![art](images/Art_P1270.jpg), and we can conclude in case
    2 that *B*, which includes all nonwitnesses, is a proper subgroup of ![art](images/Art_Zastn.jpg)
    and therefore has size at most (*n* – 1)/2.
  prefs: []
  type: TYPE_NORMAL
- en: In either case, the number of witnesses to the compositeness of *n* is at least
    (*n* – 1)/2.
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: '***Theorem 31.40***'
  prefs: []
  type: TYPE_NORMAL
- en: For any odd integer *n* > 2 and positive integer *s*, the probability that MILLER-RABIN(*n*,
    *s*) errs is at most 2^(–*s*).
  prefs: []
  type: TYPE_NORMAL
- en: '***Proof***   By Theorem 31.39, if *n* is composite, then each execution of
    the **for** loop of lines 1–4 of MILLER-RABIN has a probability of at least 1/2
    of discovering a witness to the compositeness of *n*. MILLER-RABIN makes an error
    only if it is so unlucky as to miss discovering a witness to the compositeness
    of *n* on each of the *s* iterations of the main loop. The probability of such
    a sequence of misses is at most 2^(–*s*).'
  prefs: []
  type: TYPE_NORMAL
- en: ▪
  prefs: []
  type: TYPE_NORMAL
- en: If *n* is prime, MILLER-RABIN always reports PRIME, and if *n* is composite,
    the chance that MILLER-RABIN reports PRIME is at most 2^(−*s*).
  prefs: []
  type: TYPE_NORMAL
- en: When applying MILLER-RABIN to a large randomly chosen integer *n*, however,
    we need to consider as well the prior probability that *n* is prime, in order
    to correctly interpret MILLER-RABIN’s result. Suppose that we fix a bit length
    *β* and choose at random an integer *n* of length *β* bits to be tested for primality,
    so that *β* ≈ 1g *n* ≈ 1.443 ln *n*. Let *A* denote the event that *n* is prime.
    By the prime number theorem (Theorem 31.37), the probability that *n* is prime
    is approximately
  prefs: []
  type: TYPE_NORMAL
- en: '| Pr {*A*} | ≈ | 1/ln *n* |'
  prefs: []
  type: TYPE_TB
- en: '|  | ≈ | 1.443/*β*. |'
  prefs: []
  type: TYPE_TB
- en: Now let *B* denote the event that MILLER-RABIN returns PRIME. We have that ![art](images/Art_P1271.jpg)
    (or equivalently, that Pr{*B* | *A*} = 1) and ![art](images/Art_P1272.jpg) (or
    equivalently, that ![art](images/Art_P1273.jpg)).
  prefs: []
  type: TYPE_NORMAL
- en: But what is Pr{*A* | *B*}, the probability that *n* is prime, given that MILLER-RABIN
    has returned PRIME? By the alternate form of Bayes’s theorem (equation (C.20)
    on page 1189) and approximating ![art](images/Art_P1274.jpg), we have
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1275.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This probability does not exceed 1/2 until *s* exceeds 1g(ln *n* – 1). Intuitively,
    that many initial trials are needed just for the confidence derived from failing
    to find a witness to the compositeness of *n* to overcome the prior bias in favor
    of *n* being composite. For a number with *β* = 1024 bits, this initial testing
    requires about
  prefs: []
  type: TYPE_NORMAL
- en: '| lg(ln *n* – 1) | ≈ | lg(*β*/1.443) |'
  prefs: []
  type: TYPE_TB
- en: '|  | ≈ | 9 |'
  prefs: []
  type: TYPE_TB
- en: trials. In any case, choosing *s* = 50 should suffice for almost any imaginable
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, the situation is much better. If you are trying to find large primes
    by applying MILLER-RABIN to large randomly chosen odd integers, then choosing
    a small value of *s* (say 3) is unlikely to lead to erroneous results, though
    we won’t prove it here. The reason is that for a randomly chosen odd composite
    integer *n*, the expected number of nonwitnesses to the compositeness of *n* is
    likely to be considerably smaller than (*n* – 1)/2.
  prefs: []
  type: TYPE_NORMAL
- en: If the integer *n* is not chosen randomly, however, the best that can be proven
    is that the number of nonwitnesses is at most (*n* – 1)/4, using an improved version
    of Theorem 31.39\. Furthermore, there do exist integers *n* for which the number
    of nonwitnesses is (*n* – 1)/4.
  prefs: []
  type: TYPE_NORMAL
- en: '**Exercises**'
  prefs: []
  type: TYPE_NORMAL
- en: '***31.8-1***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove that if an odd integer *n* > 1 is not a prime or a prime power, then there
    exists a nontrivial square root of 1, modulo *n*.
  prefs: []
  type: TYPE_NORMAL
- en: ★ ***31.8-2***
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to strengthen Euler’s theorem (Theorem 31.30) slightly to the
    form
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1276.jpg)'
  prefs: []
  type: TYPE_IMG
- en: where ![art](images/Art_P1277.jpg) and λ(*n*) is defined by
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1278.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Prove that *λ*(*n*) | *ϕ*(*n*). A composite number *n* is a Carmichael number
    if *λ*(*n*) | *n* – 1\. The smallest Carmichael number is 561 = 3 · 11 · 17, for
    which *λ*(*n*) = 1cm(2, 10, 16) = 80, which divides 560\. Prove that Carmichael
    numbers must be both “square-free” (not divisible by the square of any prime)
    and the product of at least three primes. (For this reason, they are not common.)
  prefs: []
  type: TYPE_NORMAL
- en: '***31.8-3***'
  prefs: []
  type: TYPE_NORMAL
- en: Prove that if *x* is a nontrivial square root of 1, modulo *n*, then gcd(*x*
    − 1, *n*) and gcd(*x* + 1, *n*) are both nontrivial divisors of *n*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Problems**'
  prefs: []
  type: TYPE_NORMAL
- en: '***31-1     Binary gcd algorithm***'
  prefs: []
  type: TYPE_NORMAL
- en: Most computers can perform the operations of subtraction, testing the parity
    (odd or even) of a binary integer, and halving more quickly than computing remainders.
    This problem investigates the ***binary gcd algorithm***, which avoids the remainder
    computations used in Euclid’s algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** Prove that if *a* and *b* are both even, then gcd(*a*, *b*) = 2 ·
    gcd(*a*/2, *b*/2).'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** Prove that if *a* is odd and *b* is even, then gcd(*a*, *b*) = gcd(*a*,
    *b*/2).'
  prefs: []
  type: TYPE_NORMAL
- en: '***c.*** Prove that if *a* and *b* are both odd, then gcd(*a*, *b*) = gcd((*a*
    – *b*)/2, *b*).'
  prefs: []
  type: TYPE_NORMAL
- en: '***d.*** Design an efficient binary gcd algorithm for input integers *a* and
    *b*, where *a* ≥ *b*, that runs in *O*(1g *a*) time. Assume that each subtraction,
    parity test, and halving takes unit time.'
  prefs: []
  type: TYPE_NORMAL
- en: '***31-2     Analysis of bit operations in Euclid’s algorithm***'
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** Consider the ordinary “paper and pencil” algorithm for long division:
    dividing *a* by *b*, which yields a quotient *q* and remainder *r*. Show that
    this method requires *O*((1 + 1g *q*)1g *b*) bit operations.'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** Define *μ*(*a*, *b*) = (1 + 1g *a*)(1 + 1g *b*). Show that the number
    of bit operations performed by EUCLID in reducing the problem of computing gcd(*a*,
    *b*) to that of computing gcd(*b*, *a* mod *b*) is at most *c*(*μ*(*a*, *b*) –
    *μ*(*b*, *a* mod *b*)) for some sufficiently large constant *c* > 0.'
  prefs: []
  type: TYPE_NORMAL
- en: '***c.*** Show that EUCLID(*a*, *b*) requires *O*(*μ*(*a*, *b*)) bit operations
    in general and *O*(*β*²) bit operations when applied to two *β*-bit inputs.'
  prefs: []
  type: TYPE_NORMAL
- en: '***31-3     Three algorithms for Fibonacci numbers***'
  prefs: []
  type: TYPE_NORMAL
- en: This problem compares the efficiency of three methods for computing the *n*th
    Fibonacci number *F*[*n*], given *n*. Assume that the cost of adding, subtracting,
    or multiplying two numbers is *O*(1), independent of the size of the numbers.
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** Show that the running time of the straightforward recursive method
    for computing *F*[*n*] based on recurrence (3.31) on page 69 is exponential in
    *n*. (See, for example, the FIB procedure on page 751.)'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** Show how to compute *F*[*n*] in *O*(*n*) time using memoization.'
  prefs: []
  type: TYPE_NORMAL
- en: '***c.*** Show how to compute *F*[*n*] in *O*(1g *n*) time using only integer
    addition and multiplication. (*Hint:* Consider the matrix ![art](images/Art_P1279.jpg)
    and its powers.)'
  prefs: []
  type: TYPE_NORMAL
- en: '***d.*** Assume now that adding two *β*-bit numbers takes Θ(*β*) time and that
    multiplying two *β*-bit numbers takes Θ(*β*²) time. What is the running time of
    these three methods under this more reasonable cost measure for the elementary
    arithmetic operations?'
  prefs: []
  type: TYPE_NORMAL
- en: '***31-4     Quadratic residues***'
  prefs: []
  type: TYPE_NORMAL
- en: Let *p* be an odd prime. A number ![art](images/Art_P1280.jpg) is a ***quadratic
    residue*** modulo *p*, if the equation *x*² = *a* (mod *p*) has a solution for
    the unknown *x*.
  prefs: []
  type: TYPE_NORMAL
- en: '***a.*** Show that there are exactly (*p* – 1)/2 quadratic residues, modulo
    *p*.'
  prefs: []
  type: TYPE_NORMAL
- en: '***b.*** If *p* is prime, we define the ***Legendre symbol*** ![art](images/Art_P1281.jpg),
    for ![art](images/Art_P1282.jpg), to be 1 if *a* is a quadratic residue, modulo
    *p*, and –1 otherwise. Prove that if ![art](images/Art_P1283.jpg), then'
  prefs: []
  type: TYPE_NORMAL
- en: '![art](images/Art_P1284.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Give an efficient algorithm that determines whether a given number *a* is a
    quadratic residue, modulo *p*. Analyze the efficiency of your algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: '***c.*** Prove that if *p* is a prime of the form 4*k* + 3 and *a* is a quadratic
    residue in ![art](images/Art_P1285.jpg), then *a*^(*k*+1) mod *p* is a square
    root of *a*, modulo *p*. How much time is required to find the square root of
    a quadratic residue *a*, modulo *p*?'
  prefs: []
  type: TYPE_NORMAL
- en: '***d.*** Describe an efficient randomized algorithm for finding a nonquadratic
    residue, modulo an arbitrary prime *p*, that is, a member of ![art](images/Art_Zastp.jpg)
    that is not a quadratic residue. How many arithmetic operations does your algorithm
    require on average?'
  prefs: []
  type: TYPE_NORMAL
- en: '**Chapter notes**'
  prefs: []
  type: TYPE_NORMAL
- en: Knuth [[260](bibliography001.xhtml#endnote_260)] contains a good discussion
    of algorithms for finding the greatest common divisor, as well as other basic
    number-theoretic algorithms. Dixon [[121](bibliography001.xhtml#endnote_121)]
    gives an overview of factorization and primality testing. Bach [[33](bibliography001.xhtml#endnote_33)],
    Riesel [[378](bibliography001.xhtml#endnote_378)], and Bach and Shallit [[34](bibliography001.xhtml#endnote_34)]
    provide overviews of the basics of computational number theory; Shoup [[411](bibliography001.xhtml#endnote_411)]
    provides a more recent survey. The conference proceedings edited by Pomerance
    [[362](bibliography001.xhtml#endnote_362)] contains several excellent survey articles.
  prefs: []
  type: TYPE_NORMAL
- en: Knuth [[260](bibliography001.xhtml#endnote_260)] discusses the origin of Euclid’s
    algorithm. It appears in Book 7, Propositions 1 and 2, of the Greek mathematician
    Euclid’s *Elements*, which was written around 300 B.C.E. Euclid’s description
    may have been derived from an algorithm due to Eudoxus around 375 B.C.E. Euclid’s
    algorithm may hold the honor of being the oldest nontrivial algorithm, rivaled
    only by an algorithm for multiplication known to the ancient Egyptians. Shallit
    [[407](bibliography001.xhtml#endnote_407)] chronicles the history of the analysis
    of Euclid’s algorithm.
  prefs: []
  type: TYPE_NORMAL
- en: Knuth attributes a special case of the Chinese remainder theorem (Theorem 31.27)
    to the Chinese mathematician Sun-Tsŭ, who lived sometime between 200 B.C.E. and
    200 C.E.—the date is quite uncertain. The same special case was given by the Greek
    mathematician Nichomachus around 100 C.E. It was generalized by Qin Jiushao in
    1247\. The Chinese remainder theorem was finally stated and proved in its full
    generality by L. Euler in 1734.
  prefs: []
  type: TYPE_NORMAL
- en: The randomized primality-testing algorithm presented here is due to Miller [[327](bibliography001.xhtml#endnote_327)]
    and Rabin [[373](bibliography001.xhtml#endnote_373)] and is the fastest randomized
    primality-testing algorithm known, to within constant factors. The proof of Theorem
    31.40 is a slight adaptation of one suggested by Bach [[32](bibliography001.xhtml#endnote_32)].
    A proof of a stronger result for MILLER-RABIN was given by Monier [[332](bibliography001.xhtml#endnote_332),
    [333](bibliography001.xhtml#endnote_333)]. For many years primality-testing was
    the classic example of a problem where randomization appeared to be necessary
    to obtain an efficient (polynomial-time) algorithm. In 2002, however, Agrawal,
    Kayal, and Saxena [[4](bibliography001.xhtml#endnote_4)] surprised everyone with
    their deterministic polynomial-time primality-testing algorithm. Until then, the
    fastest deterministic primality testing algorithm known, due to Cohen and Lenstra
    [[97](bibliography001.xhtml#endnote_97)], ran in (1g *n*)^(*O*(1g1g1g *n*)) time
    on input *n*, which is just slightly superpolynomial. Nonetheless, for practical
    purposes, randomized primality-testing algorithms remain more efficient and are
    generally preferred.
  prefs: []
  type: TYPE_NORMAL
- en: Beauchemin, Brassard, Crépeau, Goutier, and Pomerance [[40](bibliography001.xhtml#endnote_40)]
    nicely discuss the problem of finding large “random” primes.
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a public-key cryptosystem is due to Diffie and Hellman [[115](bibliography001.xhtml#endnote_115)].
    The RSA cryptosystem was proposed in 1977 by Rivest, Shamir, and Adleman [[380](bibliography001.xhtml#endnote_380)].
    Since then, the field of cryptography has blossomed. Our understanding of the
    RSA cryptosystem has deepened, and modern implementations use significant refinements
    of the basic techniques presented here. In addition, many new techniques have
    been developed for proving cryptosystems to be secure. For example, Goldwasser
    and Micali [[190](bibliography001.xhtml#endnote_190)] show that randomization
    can be an effective tool in the design of secure public-key encryption schemes.
    For signature schemes, Goldwasser, Micali, and Rivest [[191](bibliography001.xhtml#endnote_191)]
    present a digital-signature scheme for which every conceivable type of forgery
    is provably as difficult as factoring. Katz and Lindell [[253](bibliography001.xhtml#endnote_253)]
    provide an overview of modern cryptography.
  prefs: []
  type: TYPE_NORMAL
- en: The best algorithms for factoring large numbers have a running time that grows
    roughly exponentially with the cube root of the length of the number *n* to be
    factored. The general number-field sieve factoring algorithm (as developed by
    Buhler, Lenstra, and Pomerance [[77](bibliography001.xhtml#endnote_77)] as an
    extension of the ideas in the number-field sieve factoring algorithm by Pollard
    [[360](bibliography001.xhtml#endnote_360)] and Lenstra et al. [[295](bibliography001.xhtml#endnote_295)]
    and refined by Coppersmith [[102](bibliography001.xhtml#endnote_102)] and others)
    is perhaps the most efficient such algorithm in general for large inputs. Although
    it is difficult to give a rigorous analysis of this algorithm, under reasonable
    assumptions we can derive a running-time estimate of *L*(1/3, *n*)^(1.902+*o*(1)),
    where ![art](images/Art_P1286.jpg).
  prefs: []
  type: TYPE_NORMAL
- en: The elliptic-curve method due to Lenstra [[296](bibliography001.xhtml#endnote_296)]
    may be more effective for some inputs than the number-field sieve method, since
    it can find a small prime factor *p* quite quickly. With this method, the time
    to find *p* is estimated to be ![art](images/Art_P1287.jpg).
  prefs: []
  type: TYPE_NORMAL
